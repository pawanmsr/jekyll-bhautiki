import{H as e}from"./index-C7lpuH7l.esm.min.js";import"./morphTargetsVertexDeclaration-NWBzmmRm.esm.min.js";import"./bonesVertex-CA4NTDlA.esm.min.js";import"./bakedVertexAnimation-D0Lo47M5.esm.min.js";const t="iblVoxelGridVertexShader",r="#include <bakedVertexAnimationDeclaration>\n#include <bonesDeclaration>(attribute matricesIndices : vec4f;,,attribute matricesWeights : vec4f;,,attribute matricesIndicesExtra : vec4f;,,attribute matricesWeightsExtra : vec4f;,)\n#include <helperFunctions>\n#include <instancesDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#ifdef VERTEX_PULLING_USE_INDEX_BUFFER\nvar<storage,read> indices : array<u32>;\n#endif\nvar<storage,read> position : array<f32>;\n#if NUM_BONE_INFLUENCERS>0\nvar<storage,read> matricesIndices : array<u32>;var<storage,read> matricesWeights : array<f32>;uniform vp_matricesIndices_info: vec3f;uniform vp_matricesWeights_info: vec3f;\n#if NUM_BONE_INFLUENCERS>4\nvar<storage,read> matricesIndicesExtra : array<u32>;var<storage,read> matricesWeightsExtra : array<f32>;uniform vp_matricesIndicesExtra_info: vec3f;uniform vp_matricesWeightsExtra_info: vec3f;\n#endif\n#endif\nuniform world : mat4x4f;uniform invWorldScale: mat4x4f;varying vNormalizedPosition : vec3f;flat varying f_swizzle: i32;uniform vp_position_info: vec3f; \nfn convertToFloat(word: u32,byteInWord: u32,dataType: u32)->f32 {switch (dataType) {case 5120u: { \nlet shift=byteInWord*8u;let value=(word>>shift) & 0xFFu;return f32(i32(value<<24u)>>24u)/127.0; }\ncase 5121u: { \nlet shift=byteInWord*8u;let value=(word>>shift) & 0xFFu;return f32(value)/255.0;}\ncase 5122u: { \nlet shift=(byteInWord & 0xFFFFFFFEu)*8u; \nlet value=(word>>shift) & 0xFFFFu;return f32(i32(value<<16u)>>16u);}\ncase 5123u: { \nlet shift=(byteInWord & 0xFFFFFFFEu)*8u; \nlet value=(word>>shift) & 0xFFFFu;return f32(value);}\ncase 5126u: { \nreturn bitcast<f32>(word);}\ndefault: {return 0.0;}}}\nfn readPositionValue(byteOffset: u32,dataType: u32)->f32 {let wordOffset=byteOffset/4u;let byteInWord=byteOffset % 4u;let word: u32=bitcast<u32>(position[wordOffset]);return convertToFloat(word,byteInWord,dataType);}\nfn readVertexPosition(info: vec3f,vertexIndex: u32)->vec3f {let baseOffset=u32(info.x);let stride=u32(info.y);let dataType=u32(info.z);let offset=baseOffset+vertexIndex*stride;let componentSize=select(select(2u,1u,dataType==5120u || dataType==5121u),4u,dataType==5126u);return vec3f(\nreadPositionValue(offset,dataType),\nreadPositionValue(offset+componentSize,dataType),\nreadPositionValue(offset+componentSize*2u,dataType)\n);}\n#if NUM_BONE_INFLUENCERS>0\nfn readMatrixIndexValue(byteOffset: u32,dataType: u32)->f32 {let wordOffset=byteOffset/4u;let byteInWord=byteOffset % 4u;let word: u32=matricesIndices[wordOffset];return convertToFloat(word,byteInWord,dataType);}\nfn readMatrixIndices(info: vec3f,vertexIndex : u32)->vec4f {let baseOffset=u32(info.x);let stride=u32(info.y);let dataType=u32(info.z);let offset=baseOffset+vertexIndex*stride;let componentSize=select(select(2u,1u,dataType==5120u || dataType==5121u),4u,dataType==5126u);return vec4f(\nreadMatrixIndexValue(offset,dataType),\nreadMatrixIndexValue(offset+componentSize,dataType),\nreadMatrixIndexValue(offset+componentSize*2u,dataType),\nreadMatrixIndexValue(offset+componentSize*3u,dataType)\n);}\nfn readMatrixWeightValue(byteOffset: u32,dataType: u32)->f32 {let wordOffset=byteOffset/4u;let byteInWord=byteOffset % 4u;let word: u32=bitcast<u32>(matricesWeights[wordOffset]);return convertToFloat(word,byteInWord,dataType);}\nfn readMatrixWeights(info: vec3f,vertexIndex : u32)->vec4f {let baseOffset=u32(info.x);let stride=u32(info.y);let dataType=u32(info.z);let offset=baseOffset+vertexIndex*stride;let componentSize=select(select(2u,1u,dataType==5120u || dataType==5121u),4u,dataType==5126u);return vec4f(\nreadMatrixWeightValue(offset,dataType),\nreadMatrixWeightValue(offset+componentSize,dataType),\nreadMatrixWeightValue(offset+componentSize*2u,dataType),\nreadMatrixWeightValue(offset+componentSize*3u,dataType)\n);}\n#if NUM_BONE_INFLUENCERS>4\nfn readMatrixIndexExtraValue(byteOffset: u32,dataType: u32)->f32 {let wordOffset=byteOffset/4u;let byteInWord=byteOffset % 4u;let word : u32=matricesIndicesExtra[wordOffset];return convertToFloat(word,byteInWord,dataType);}\nfn readMatrixIndicesExtra(info: vec3f,vertexIndex : u32)->vec4f {let baseOffset=u32(info.x);let stride=u32(info.y);let dataType=u32(info.z);let offset=baseOffset+vertexIndex*stride;let componentSize=select(select(2u,1u,dataType==5120u || dataType==5121u),4u,dataType==5126u);return vec4f(\nreadMatrixIndexExtraValue(offset,dataType),\nreadMatrixIndexExtraValue(offset+componentSize,dataType),\nreadMatrixIndexExtraValue(offset+componentSize*2u,dataType),\nreadMatrixIndexExtraValue(offset+componentSize*3u,dataType)\n);}\nfn readMatrixWeightExtraValue(byteOffset: u32,dataType: u32)->f32 {let wordOffset=byteOffset/4u;let byteInWord=byteOffset % 4u;let word: u32=bitcast<u32>(matricesWeightsExtra[wordOffset]);return convertToFloat(word,byteInWord,dataType);}\nfn readMatrixWeightsExtra(info : vec3f,vertexIndex : u32)->vec4f {let baseOffset=u32(info.x);let stride=u32(info.y);let dataType=u32(info.z);let offset=baseOffset+vertexIndex*stride;let componentSize=select(select(2u,1u,dataType==5120u || dataType==5121u),4u,dataType==5126u);return vec4f(\nreadMatrixWeightExtraValue(offset,dataType),\nreadMatrixWeightExtraValue(offset+componentSize,dataType),\nreadMatrixWeightExtraValue(offset+componentSize*2u,dataType),\nreadMatrixWeightExtraValue(offset+componentSize*3u,dataType)\n);}\n#endif\n#endif\nfn readVertexIndex(index : u32)->u32 {\n#ifndef VERTEX_PULLING_USE_INDEX_BUFFER\nreturn index;\n#else\n#ifdef VERTEX_PULLING_INDEX_BUFFER_32BITS\nreturn indices[index];\n#else\nlet u32_index=index/2u;let bit_offset=(index & 1u)*16u;return (indices[u32_index]>>bit_offset) & 0xFFFFu;\n#endif\n#endif\n}\nfn calculateTriangleNormal(v0\n: vec3<f32>,v1\n: vec3<f32>,v2\n: vec3<f32>)\n->vec3<f32> {let edge1=v1-v0;let edge2=v2-v0;let triangleNormal=cross(edge1,edge2);let normalizedTriangleNormal=normalize(triangleNormal);return normalizedTriangleNormal;}\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#include <morphTargetsVertexGlobal>\nvar triPositions: array<vec3f,3>;var thisTriIndex : u32=input.vertexIndex; \nfor (var i: u32=0u; i<3u; i=i+1u) {var provokingVertNum : u32=input.vertexIndex/3*3;let vertIdx=readVertexIndex(provokingVertNum+i);if (provokingVertNum+i==input.vertexIndex) {thisTriIndex=i;}\nvar positionUpdated=readVertexPosition(uniforms.vp_position_info,vertIdx);\n#include <instancesVertex>\nlet inputPosition: vec3f=positionUpdated;\n#include <morphTargetsVertex>(vertexInputs.position\\),inputPosition),vertexInputs.vertexIndex,vertIdx)[0..maxSimultaneousMorphTargets]\n#if NUM_BONE_INFLUENCERS>0\nlet matrixIndex=readMatrixIndices(uniforms.vp_matricesIndices_info,vertIdx);let matrixWeight=readMatrixWeights(uniforms.vp_matricesWeights_info,vertIdx);\n#if NUM_BONE_INFLUENCERS>4\nlet matrixIndexExtra=readMatrixIndicesExtra(uniforms.vp_matricesIndicesExtra_info,vertIdx);let matrixWeightExtra=readMatrixWeightsExtra(uniforms.vp_matricesWeightsExtra_info,vertIdx);\n#endif\n#endif\n#include<bonesVertex>(vertexInputs.matricesIndices,matrixIndex,vertexInputs.matricesWeights,matrixWeight,vertexInputs.matricesIndicesExtra,matrixIndexExtra,vertexInputs.matricesWeightsExtra,matrixWeightExtra)\n#include<bakedVertexAnimation>(vertexInputs.matricesIndices,matrixIndex,vertexInputs.matricesWeights,matrixWeight,vertexInputs.matricesIndicesExtra,matrixIndexExtra,vertexInputs.matricesWeightsExtra,matrixWeightExtra)\ntriPositions[i]=(finalWorld*vec4(positionUpdated,1.0)).xyz;}\nvar N : vec3<f32>=calculateTriangleNormal(triPositions[0],triPositions[1],triPositions[2]);let worldPos=triPositions[thisTriIndex];vertexOutputs.position=uniforms.invWorldScale*vec4(worldPos,1.0);N=abs(N);if (N.x>N.y && N.x>N.z) {vertexOutputs.f_swizzle=0;vertexOutputs.position=vec4f(vertexOutputs.position.yzx,1.0);} else if (N.y>N.z) {vertexOutputs.f_swizzle=1;vertexOutputs.position=vec4f(vertexOutputs.position.zxy,1.0);} else {vertexOutputs.f_swizzle=2;vertexOutputs.position=vec4f(vertexOutputs.position.xyz,1.0);}\nvertexOutputs.vNormalizedPosition=vertexOutputs.position.xyz*0.5+0.5;vertexOutputs.position.z =\nvertexOutputs.vNormalizedPosition.z; }\n";e.ShadersStoreWGSL[t]||(e.ShadersStoreWGSL[t]=r);const n={name:t,shader:r};export{n as iblVoxelGridVertexShaderWGSL};
//# sourceMappingURL=iblVoxelGrid.vertex-_aQ9qltN.esm.min.js.map
