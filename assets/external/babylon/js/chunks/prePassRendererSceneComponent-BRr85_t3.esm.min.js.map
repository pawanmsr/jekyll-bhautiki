{"version":3,"file":"prePassRendererSceneComponent-BRr85_t3.esm.min.js","sources":["../../../../../dev/core/dist/PostProcesses/thinImageProcessingPostProcess.js","../../../../../dev/core/dist/PostProcesses/imageProcessingPostProcess.js","../../../../../dev/core/dist/Materials/Textures/prePassRenderTarget.js","../../../../../dev/core/dist/Rendering/prePassRenderer.js","../../../../../dev/core/dist/Rendering/prePassRendererSceneComponent.js"],"sourcesContent":["import { EffectWrapper } from \"../Materials/effectRenderer\";\nimport { Engine } from \"../Engines/engine\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { ImageProcessingConfiguration } from \"../Materials/imageProcessingConfiguration\";\n/**\n * Post process used to apply image processing to a scene\n */\nexport class ThinImageProcessingPostProcess extends EffectWrapper {\n    _gatherImports(useWebGPU, list) {\n        if (useWebGPU) {\n            this._webGPUReady = true;\n            list.push(import(\"../ShadersWGSL/imageProcessing.fragment\"));\n        }\n        else {\n            list.push(import(\"../Shaders/imageProcessing.fragment\"));\n        }\n    }\n    /**\n     * Gets the image processing configuration used either in this material.\n     */\n    get imageProcessingConfiguration() {\n        return this._imageProcessingConfiguration;\n    }\n    /**\n     * Sets the Default image processing configuration used either in the this material.\n     *\n     * If sets to null, the scene one is in use.\n     */\n    set imageProcessingConfiguration(value) {\n        // We are almost sure it is applied by post process as\n        // We are in the post process :-)\n        value.applyByPostProcess = true;\n        this._attachImageProcessingConfiguration(value);\n    }\n    /**\n     * Attaches a new image processing configuration to the PBR Material.\n     * @param configuration\n     * @param doNotBuild\n     */\n    _attachImageProcessingConfiguration(configuration, doNotBuild = false) {\n        if (configuration === this._imageProcessingConfiguration) {\n            return;\n        }\n        // Detaches observer.\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n        // Pick the scene configuration if needed.\n        if (!configuration) {\n            let scene = this.options.scene;\n            if (!scene) {\n                const engine = this.options.engine;\n                if (engine && engine.scenes) {\n                    const scenes = engine.scenes;\n                    scene = scenes[scenes.length - 1];\n                }\n                else {\n                    scene = EngineStore.LastCreatedScene;\n                }\n            }\n            if (scene) {\n                this._imageProcessingConfiguration = scene.imageProcessingConfiguration;\n            }\n            else {\n                this._imageProcessingConfiguration = new ImageProcessingConfiguration();\n            }\n        }\n        else {\n            this._imageProcessingConfiguration = configuration;\n        }\n        // Attaches observer.\n        if (this._imageProcessingConfiguration) {\n            this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {\n                this._updateParameters();\n            });\n        }\n        // Ensure the effect will be rebuilt.\n        if (!doNotBuild) {\n            this._updateParameters();\n        }\n    }\n    /**\n     * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .\n     */\n    get colorCurves() {\n        return this.imageProcessingConfiguration.colorCurves;\n    }\n    /**\n     * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .\n     */\n    set colorCurves(value) {\n        this.imageProcessingConfiguration.colorCurves = value;\n    }\n    /**\n     * Gets whether the color curves effect is enabled.\n     */\n    get colorCurvesEnabled() {\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\n    }\n    /**\n     * Sets whether the color curves effect is enabled.\n     */\n    set colorCurvesEnabled(value) {\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\n    }\n    /**\n     * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\n     */\n    get colorGradingTexture() {\n        return this.imageProcessingConfiguration.colorGradingTexture;\n    }\n    /**\n     * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\n     */\n    set colorGradingTexture(value) {\n        this.imageProcessingConfiguration.colorGradingTexture = value;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    get colorGradingEnabled() {\n        return this.imageProcessingConfiguration.colorGradingEnabled;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    set colorGradingEnabled(value) {\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\n    }\n    /**\n     * Gets exposure used in the effect.\n     */\n    get exposure() {\n        return this.imageProcessingConfiguration.exposure;\n    }\n    /**\n     * Sets exposure used in the effect.\n     */\n    set exposure(value) {\n        this.imageProcessingConfiguration.exposure = value;\n    }\n    /**\n     * Gets whether tonemapping is enabled or not.\n     */\n    get toneMappingEnabled() {\n        return this._imageProcessingConfiguration.toneMappingEnabled;\n    }\n    /**\n     * Sets whether tonemapping is enabled or not\n     */\n    set toneMappingEnabled(value) {\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\n    }\n    /**\n     * Gets the type of tone mapping effect.\n     */\n    get toneMappingType() {\n        return this._imageProcessingConfiguration.toneMappingType;\n    }\n    /**\n     * Sets the type of tone mapping effect.\n     */\n    set toneMappingType(value) {\n        this._imageProcessingConfiguration.toneMappingType = value;\n    }\n    /**\n     * Gets contrast used in the effect.\n     */\n    get contrast() {\n        return this.imageProcessingConfiguration.contrast;\n    }\n    /**\n     * Sets contrast used in the effect.\n     */\n    set contrast(value) {\n        this.imageProcessingConfiguration.contrast = value;\n    }\n    /**\n     * Gets Vignette stretch size.\n     */\n    get vignetteStretch() {\n        return this.imageProcessingConfiguration.vignetteStretch;\n    }\n    /**\n     * Sets Vignette stretch size.\n     */\n    set vignetteStretch(value) {\n        this.imageProcessingConfiguration.vignetteStretch = value;\n    }\n    /**\n     * Gets Vignette center X Offset.\n     * @deprecated use vignetteCenterX instead\n     */\n    get vignetteCentreX() {\n        return this.imageProcessingConfiguration.vignetteCenterX;\n    }\n    /**\n     * Sets Vignette center X Offset.\n     * @deprecated use vignetteCenterX instead\n     */\n    set vignetteCentreX(value) {\n        this.imageProcessingConfiguration.vignetteCenterX = value;\n    }\n    /**\n     * Gets Vignette center Y Offset.\n     * @deprecated use vignetteCenterY instead\n     */\n    get vignetteCentreY() {\n        return this.imageProcessingConfiguration.vignetteCenterY;\n    }\n    /**\n     * Sets Vignette center Y Offset.\n     * @deprecated use vignetteCenterY instead\n     */\n    set vignetteCentreY(value) {\n        this.imageProcessingConfiguration.vignetteCenterY = value;\n    }\n    /**\n     * Vignette center Y Offset.\n     */\n    get vignetteCenterY() {\n        return this.imageProcessingConfiguration.vignetteCenterY;\n    }\n    set vignetteCenterY(value) {\n        this.imageProcessingConfiguration.vignetteCenterY = value;\n    }\n    /**\n     * Vignette center X Offset.\n     */\n    get vignetteCenterX() {\n        return this.imageProcessingConfiguration.vignetteCenterX;\n    }\n    set vignetteCenterX(value) {\n        this.imageProcessingConfiguration.vignetteCenterX = value;\n    }\n    /**\n     * Gets Vignette weight or intensity of the vignette effect.\n     */\n    get vignetteWeight() {\n        return this.imageProcessingConfiguration.vignetteWeight;\n    }\n    /**\n     * Sets Vignette weight or intensity of the vignette effect.\n     */\n    set vignetteWeight(value) {\n        this.imageProcessingConfiguration.vignetteWeight = value;\n    }\n    /**\n     * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n     * if vignetteEnabled is set to true.\n     */\n    get vignetteColor() {\n        return this.imageProcessingConfiguration.vignetteColor;\n    }\n    /**\n     * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n     * if vignetteEnabled is set to true.\n     */\n    set vignetteColor(value) {\n        this.imageProcessingConfiguration.vignetteColor = value;\n    }\n    /**\n     * Gets Camera field of view used by the Vignette effect.\n     */\n    get vignetteCameraFov() {\n        return this.imageProcessingConfiguration.vignetteCameraFov;\n    }\n    /**\n     * Sets Camera field of view used by the Vignette effect.\n     */\n    set vignetteCameraFov(value) {\n        this.imageProcessingConfiguration.vignetteCameraFov = value;\n    }\n    /**\n     * Gets the vignette blend mode allowing different kind of effect.\n     */\n    get vignetteBlendMode() {\n        return this.imageProcessingConfiguration.vignetteBlendMode;\n    }\n    /**\n     * Sets the vignette blend mode allowing different kind of effect.\n     */\n    set vignetteBlendMode(value) {\n        this.imageProcessingConfiguration.vignetteBlendMode = value;\n    }\n    /**\n     * Gets whether the vignette effect is enabled.\n     */\n    get vignetteEnabled() {\n        return this.imageProcessingConfiguration.vignetteEnabled;\n    }\n    /**\n     * Sets whether the vignette effect is enabled.\n     */\n    set vignetteEnabled(value) {\n        this.imageProcessingConfiguration.vignetteEnabled = value;\n    }\n    /**\n     * Gets intensity of the dithering effect.\n     */\n    get ditheringIntensity() {\n        return this.imageProcessingConfiguration.ditheringIntensity;\n    }\n    /**\n     * Sets intensity of the dithering effect.\n     */\n    set ditheringIntensity(value) {\n        this.imageProcessingConfiguration.ditheringIntensity = value;\n    }\n    /**\n     * Gets whether the dithering effect is enabled.\n     */\n    get ditheringEnabled() {\n        return this.imageProcessingConfiguration.ditheringEnabled;\n    }\n    /**\n     * Sets whether the dithering effect is enabled.\n     */\n    set ditheringEnabled(value) {\n        this.imageProcessingConfiguration.ditheringEnabled = value;\n    }\n    /**\n     * Gets whether the input of the processing is in Gamma or Linear Space.\n     */\n    get fromLinearSpace() {\n        return this._fromLinearSpace;\n    }\n    /**\n     * Sets whether the input of the processing is in Gamma or Linear Space.\n     */\n    set fromLinearSpace(value) {\n        if (this._fromLinearSpace === value) {\n            return;\n        }\n        this._fromLinearSpace = value;\n        this._updateParameters();\n    }\n    /**\n     * * Gets the width of the output texture used to store the result of the post process.\n     */\n    get outputTextureWidth() {\n        return this.imageProcessingConfiguration.outputTextureWidth;\n    }\n    /**\n     * * Sets the width of the output texture used to store the result of the post process.\n     */\n    set outputTextureWidth(value) {\n        this.imageProcessingConfiguration.outputTextureWidth = value;\n    }\n    /**\n     * * Gets the height of the output texture used to store the result of the post process.\n     */\n    get outputTextureHeight() {\n        return this.imageProcessingConfiguration.outputTextureHeight;\n    }\n    /**\n     * * Sets the height of the output texture used to store the result of the post process.\n     */\n    set outputTextureHeight(value) {\n        this.imageProcessingConfiguration.outputTextureHeight = value;\n    }\n    /**\n     * Constructs a new image processing post process\n     * @param name Name of the effect\n     * @param engine Engine to use to render the effect. If not provided, the last created engine will be used\n     * @param options Options to configure the effect\n     */\n    constructor(name, engine = null, options) {\n        super({\n            ...options,\n            name,\n            engine: engine || Engine.LastCreatedEngine,\n            useShaderStore: true,\n            useAsPostProcess: true,\n            fragmentShader: ThinImageProcessingPostProcess.FragmentUrl,\n        });\n        this._fromLinearSpace = true;\n        /**\n         * Defines cache preventing GC.\n         */\n        this._defines = {\n            IMAGEPROCESSING: false,\n            VIGNETTE: false,\n            VIGNETTEBLENDMODEMULTIPLY: false,\n            VIGNETTEBLENDMODEOPAQUE: false,\n            TONEMAPPING: 0,\n            CONTRAST: false,\n            COLORCURVES: false,\n            COLORGRADING: false,\n            COLORGRADING3D: false,\n            FROMLINEARSPACE: false,\n            SAMPLER3DGREENDEPTH: false,\n            SAMPLER3DBGRMAP: false,\n            DITHER: false,\n            IMAGEPROCESSINGPOSTPROCESS: false,\n            EXPOSURE: false,\n            SKIPFINALCOLORCLAMP: false,\n        };\n        const imageProcessingConfiguration = options?.imageProcessingConfiguration;\n        // Setup the configuration as forced by the constructor. This would then not force the\n        // scene materials output in linear space and let untouched the default forward pass.\n        if (imageProcessingConfiguration) {\n            imageProcessingConfiguration.applyByPostProcess = true;\n            this._attachImageProcessingConfiguration(imageProcessingConfiguration, true);\n            // This will cause the shader to be compiled\n            this._updateParameters();\n        }\n        // Setup the default processing configuration to the scene.\n        else {\n            this._attachImageProcessingConfiguration(null, true);\n            this.imageProcessingConfiguration.applyByPostProcess = true;\n        }\n    }\n    /**\n     * @internal\n     */\n    _updateParameters() {\n        this._defines.FROMLINEARSPACE = this._fromLinearSpace;\n        this.imageProcessingConfiguration.prepareDefines(this._defines, true);\n        let defines = \"\";\n        for (const prop in this._defines) {\n            const value = this._defines[prop];\n            const type = typeof value;\n            switch (type) {\n                case \"number\":\n                case \"string\":\n                    defines += `#define ${prop} ${value};\\n`;\n                    break;\n                default:\n                    if (value) {\n                        defines += `#define ${prop};\\n`;\n                    }\n                    break;\n            }\n        }\n        const samplers = [\"textureSampler\"];\n        const uniforms = [\"scale\"];\n        if (ImageProcessingConfiguration) {\n            ImageProcessingConfiguration.PrepareSamplers(samplers, this._defines);\n            ImageProcessingConfiguration.PrepareUniforms(uniforms, this._defines);\n        }\n        this.updateEffect(defines, uniforms, samplers);\n    }\n    bind(noDefaultBindings = false) {\n        super.bind(noDefaultBindings);\n        this.imageProcessingConfiguration.bind(this.effect, this.overrideAspectRatio);\n    }\n    dispose() {\n        super.dispose();\n        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {\n            this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);\n        }\n        if (this._imageProcessingConfiguration) {\n            this.imageProcessingConfiguration.applyByPostProcess = false;\n        }\n    }\n}\n/**\n * The fragment shader url\n */\nThinImageProcessingPostProcess.FragmentUrl = \"imageProcessing\";\n//# sourceMappingURL=thinImageProcessingPostProcess.js.map","import { __decorate } from \"tslib\";\nimport { serialize } from \"../Misc/decorators\";\nimport { PostProcess } from \"./postProcess\";\nimport { Constants } from \"../Engines/constants\";\nimport { ThinImageProcessingPostProcess } from \"./thinImageProcessingPostProcess\";\n/**\n * ImageProcessingPostProcess\n * @see https://doc.babylonjs.com/features/featuresDeepDive/postProcesses/usePostProcesses#imageprocessing\n */\nexport class ImageProcessingPostProcess extends PostProcess {\n    get _imageProcessingConfiguration() {\n        return this._effectWrapper.imageProcessingConfiguration;\n    }\n    /**\n     * Gets the image processing configuration used either in this material.\n     */\n    get imageProcessingConfiguration() {\n        return this._effectWrapper.imageProcessingConfiguration;\n    }\n    /**\n     * Sets the Default image processing configuration used either in the this material.\n     *\n     * If sets to null, the scene one is in use.\n     */\n    set imageProcessingConfiguration(value) {\n        this._effectWrapper.imageProcessingConfiguration = value;\n    }\n    /**\n     * If the post process is supported.\n     */\n    get isSupported() {\n        const effect = this.getEffect();\n        return !effect || effect.isSupported;\n    }\n    /**\n     * Gets Color curves setup used in the effect if colorCurvesEnabled is set to true .\n     */\n    get colorCurves() {\n        return this.imageProcessingConfiguration.colorCurves;\n    }\n    /**\n     * Sets Color curves setup used in the effect if colorCurvesEnabled is set to true .\n     */\n    set colorCurves(value) {\n        this.imageProcessingConfiguration.colorCurves = value;\n    }\n    /**\n     * Gets whether the color curves effect is enabled.\n     */\n    get colorCurvesEnabled() {\n        return this.imageProcessingConfiguration.colorCurvesEnabled;\n    }\n    /**\n     * Sets whether the color curves effect is enabled.\n     */\n    set colorCurvesEnabled(value) {\n        this.imageProcessingConfiguration.colorCurvesEnabled = value;\n    }\n    /**\n     * Gets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\n     */\n    get colorGradingTexture() {\n        return this.imageProcessingConfiguration.colorGradingTexture;\n    }\n    /**\n     * Sets Color grading LUT texture used in the effect if colorGradingEnabled is set to true.\n     */\n    set colorGradingTexture(value) {\n        this.imageProcessingConfiguration.colorGradingTexture = value;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    get colorGradingEnabled() {\n        return this.imageProcessingConfiguration.colorGradingEnabled;\n    }\n    /**\n     * Gets whether the color grading effect is enabled.\n     */\n    set colorGradingEnabled(value) {\n        this.imageProcessingConfiguration.colorGradingEnabled = value;\n    }\n    /**\n     * Gets exposure used in the effect.\n     */\n    get exposure() {\n        return this.imageProcessingConfiguration.exposure;\n    }\n    /**\n     * Sets exposure used in the effect.\n     */\n    set exposure(value) {\n        this.imageProcessingConfiguration.exposure = value;\n    }\n    /**\n     * Gets whether tonemapping is enabled or not.\n     */\n    get toneMappingEnabled() {\n        return this._imageProcessingConfiguration.toneMappingEnabled;\n    }\n    /**\n     * Sets whether tonemapping is enabled or not\n     */\n    set toneMappingEnabled(value) {\n        this._imageProcessingConfiguration.toneMappingEnabled = value;\n    }\n    /**\n     * Gets the type of tone mapping effect.\n     */\n    get toneMappingType() {\n        return this._imageProcessingConfiguration.toneMappingType;\n    }\n    /**\n     * Sets the type of tone mapping effect.\n     */\n    set toneMappingType(value) {\n        this._imageProcessingConfiguration.toneMappingType = value;\n    }\n    /**\n     * Gets contrast used in the effect.\n     */\n    get contrast() {\n        return this.imageProcessingConfiguration.contrast;\n    }\n    /**\n     * Sets contrast used in the effect.\n     */\n    set contrast(value) {\n        this.imageProcessingConfiguration.contrast = value;\n    }\n    /**\n     * Gets Vignette stretch size.\n     */\n    get vignetteStretch() {\n        return this.imageProcessingConfiguration.vignetteStretch;\n    }\n    /**\n     * Sets Vignette stretch size.\n     */\n    set vignetteStretch(value) {\n        this.imageProcessingConfiguration.vignetteStretch = value;\n    }\n    /**\n     * Gets Vignette center X Offset.\n     * @deprecated use vignetteCenterX instead\n     */\n    get vignetteCentreX() {\n        return this.imageProcessingConfiguration.vignetteCenterX;\n    }\n    /**\n     * Sets Vignette center X Offset.\n     * @deprecated use vignetteCenterX instead\n     */\n    set vignetteCentreX(value) {\n        this.imageProcessingConfiguration.vignetteCenterX = value;\n    }\n    /**\n     * Gets Vignette center Y Offset.\n     * @deprecated use vignetteCenterY instead\n     */\n    get vignetteCentreY() {\n        return this.imageProcessingConfiguration.vignetteCenterY;\n    }\n    /**\n     * Sets Vignette center Y Offset.\n     * @deprecated use vignetteCenterY instead\n     */\n    set vignetteCentreY(value) {\n        this.imageProcessingConfiguration.vignetteCenterY = value;\n    }\n    /**\n     * Vignette center Y Offset.\n     */\n    get vignetteCenterY() {\n        return this.imageProcessingConfiguration.vignetteCenterY;\n    }\n    set vignetteCenterY(value) {\n        this.imageProcessingConfiguration.vignetteCenterY = value;\n    }\n    /**\n     * Vignette center X Offset.\n     */\n    get vignetteCenterX() {\n        return this.imageProcessingConfiguration.vignetteCenterX;\n    }\n    set vignetteCenterX(value) {\n        this.imageProcessingConfiguration.vignetteCenterX = value;\n    }\n    /**\n     * Gets Vignette weight or intensity of the vignette effect.\n     */\n    get vignetteWeight() {\n        return this.imageProcessingConfiguration.vignetteWeight;\n    }\n    /**\n     * Sets Vignette weight or intensity of the vignette effect.\n     */\n    set vignetteWeight(value) {\n        this.imageProcessingConfiguration.vignetteWeight = value;\n    }\n    /**\n     * Gets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n     * if vignetteEnabled is set to true.\n     */\n    get vignetteColor() {\n        return this.imageProcessingConfiguration.vignetteColor;\n    }\n    /**\n     * Sets Color of the vignette applied on the screen through the chosen blend mode (vignetteBlendMode)\n     * if vignetteEnabled is set to true.\n     */\n    set vignetteColor(value) {\n        this.imageProcessingConfiguration.vignetteColor = value;\n    }\n    /**\n     * Gets Camera field of view used by the Vignette effect.\n     */\n    get vignetteCameraFov() {\n        return this.imageProcessingConfiguration.vignetteCameraFov;\n    }\n    /**\n     * Sets Camera field of view used by the Vignette effect.\n     */\n    set vignetteCameraFov(value) {\n        this.imageProcessingConfiguration.vignetteCameraFov = value;\n    }\n    /**\n     * Gets the vignette blend mode allowing different kind of effect.\n     */\n    get vignetteBlendMode() {\n        return this.imageProcessingConfiguration.vignetteBlendMode;\n    }\n    /**\n     * Sets the vignette blend mode allowing different kind of effect.\n     */\n    set vignetteBlendMode(value) {\n        this.imageProcessingConfiguration.vignetteBlendMode = value;\n    }\n    /**\n     * Gets whether the vignette effect is enabled.\n     */\n    get vignetteEnabled() {\n        return this.imageProcessingConfiguration.vignetteEnabled;\n    }\n    /**\n     * Sets whether the vignette effect is enabled.\n     */\n    set vignetteEnabled(value) {\n        this.imageProcessingConfiguration.vignetteEnabled = value;\n    }\n    /**\n     * Gets intensity of the dithering effect.\n     */\n    get ditheringIntensity() {\n        return this.imageProcessingConfiguration.ditheringIntensity;\n    }\n    /**\n     * Sets intensity of the dithering effect.\n     */\n    set ditheringIntensity(value) {\n        this.imageProcessingConfiguration.ditheringIntensity = value;\n    }\n    /**\n     * Gets whether the dithering effect is enabled.\n     */\n    get ditheringEnabled() {\n        return this.imageProcessingConfiguration.ditheringEnabled;\n    }\n    /**\n     * Sets whether the dithering effect is enabled.\n     */\n    set ditheringEnabled(value) {\n        this.imageProcessingConfiguration.ditheringEnabled = value;\n    }\n    /**\n     * Gets whether the input of the processing is in Gamma or Linear Space.\n     */\n    get fromLinearSpace() {\n        return this._effectWrapper.fromLinearSpace;\n    }\n    /**\n     * Sets whether the input of the processing is in Gamma or Linear Space.\n     */\n    set fromLinearSpace(value) {\n        this._effectWrapper.fromLinearSpace = value;\n    }\n    constructor(name, options, camera = null, samplingMode, engine, reusable, textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE, imageProcessingConfiguration) {\n        const localOptions = {\n            size: typeof options === \"number\" ? options : undefined,\n            camera,\n            samplingMode,\n            engine,\n            reusable,\n            textureType,\n            imageProcessingConfiguration,\n            scene: camera?.getScene(),\n            ...options,\n            blockCompilation: true,\n        };\n        super(name, ThinImageProcessingPostProcess.FragmentUrl, {\n            effectWrapper: typeof options === \"number\" || !options.effectWrapper ? new ThinImageProcessingPostProcess(name, engine, localOptions) : undefined,\n            ...localOptions,\n        });\n        this.onApply = () => {\n            this._effectWrapper.overrideAspectRatio = this.aspectRatio;\n        };\n    }\n    /**\n     *  \"ImageProcessingPostProcess\"\n     * @returns \"ImageProcessingPostProcess\"\n     */\n    getClassName() {\n        return \"ImageProcessingPostProcess\";\n    }\n    /**\n     * @internal\n     */\n    _updateParameters() {\n        this._effectWrapper._updateParameters();\n    }\n    dispose(camera) {\n        super.dispose(camera);\n        if (this._imageProcessingConfiguration) {\n            this.imageProcessingConfiguration.applyByPostProcess = false;\n        }\n    }\n}\n__decorate([\n    serialize()\n], ImageProcessingPostProcess.prototype, \"fromLinearSpace\", null);\n//# sourceMappingURL=imageProcessingPostProcess.js.map","import { MultiRenderTarget } from \"./multiRenderTarget\";\nimport { ImageProcessingPostProcess } from \"../../PostProcesses/imageProcessingPostProcess\";\n/**\n * A multi render target designed to render the prepass.\n * Prepass is a scene component used to render information in multiple textures\n * alongside with the scene materials rendering.\n * Note : This is an internal class, and you should NOT need to instanciate this.\n * Only the `PrePassRenderer` should instanciate this class.\n * It is more likely that you need a regular `MultiRenderTarget`\n * @internal\n */\nexport class PrePassRenderTarget extends MultiRenderTarget {\n    constructor(name, renderTargetTexture, size, count, scene, options) {\n        super(name, size, count, scene, options);\n        /**\n         * @internal\n         */\n        this._beforeCompositionPostProcesses = [];\n        /**\n         * @internal\n         */\n        this._internalTextureDirty = false;\n        /**\n         * Is this render target enabled for prepass rendering\n         */\n        this.enabled = false;\n        /**\n         * Render target associated with this prePassRenderTarget\n         * If this is `null`, it means this prePassRenderTarget is associated with the scene\n         */\n        this.renderTargetTexture = null;\n        this.renderTargetTexture = renderTargetTexture;\n    }\n    /**\n     * Creates a composition effect for this RT\n     * @internal\n     */\n    _createCompositionEffect() {\n        this.imageProcessingPostProcess = new ImageProcessingPostProcess(\"prePassComposition\", 1, null, undefined, this._engine);\n        this.imageProcessingPostProcess._updateParameters();\n    }\n    /**\n     * Checks that the size of this RT is still adapted to the desired render size.\n     * @internal\n     */\n    _checkSize() {\n        const requiredWidth = this._engine.getRenderWidth(true);\n        const requiredHeight = this._engine.getRenderHeight(true);\n        const width = this.getRenderWidth();\n        const height = this.getRenderHeight();\n        if (width !== requiredWidth || height !== requiredHeight) {\n            this.resize({ width: requiredWidth, height: requiredHeight });\n            this._internalTextureDirty = true;\n        }\n    }\n    /**\n     * Changes the number of render targets in this MRT\n     * Be careful as it will recreate all the data in the new texture.\n     * @param count new texture count\n     * @param options Specifies texture types and sampling modes for new textures\n     * @param textureNames Specifies the names of the textures (optional)\n     */\n    updateCount(count, options, textureNames) {\n        super.updateCount(count, options, textureNames);\n        this._internalTextureDirty = true;\n    }\n    /**\n     * Resets the post processes chains applied to this RT.\n     * @internal\n     */\n    _resetPostProcessChain() {\n        this._beforeCompositionPostProcesses.length = 0;\n    }\n    /**\n     * Diposes this render target\n     */\n    dispose() {\n        const scene = this._scene;\n        super.dispose();\n        if (scene && scene.prePassRenderer) {\n            const index = scene.prePassRenderer.renderTargets.indexOf(this);\n            if (index !== -1) {\n                scene.prePassRenderer.renderTargets.splice(index, 1);\n            }\n        }\n        if (this.imageProcessingPostProcess) {\n            this.imageProcessingPostProcess.dispose();\n        }\n        if (this.renderTargetTexture) {\n            this.renderTargetTexture._prePassRenderTarget = null;\n        }\n        if (this._outputPostProcess) {\n            this._outputPostProcess.autoClear = true;\n            this._outputPostProcess.restoreDefaultInputTexture();\n        }\n    }\n}\n//# sourceMappingURL=prePassRenderTarget.js.map","import { PrePassRenderTarget } from \"../Materials/Textures/prePassRenderTarget\";\nimport { Constants } from \"../Engines/constants\";\nimport { _WarnImport } from \"../Misc/devTools\";\nimport { Color4 } from \"../Maths/math.color\";\nimport { Material } from \"../Materials/material\";\nimport { GeometryBufferRenderer } from \"../Rendering/geometryBufferRenderer\";\nimport \"../Engines/Extensions/engine.multiRender\";\n/**\n * Renders a pre pass of the scene\n * This means every mesh in the scene will be rendered to a render target texture\n * And then this texture will be composited to the rendering canvas with post processes\n * It is necessary for effects like subsurface scattering or deferred shading\n */\nexport class PrePassRenderer {\n    /**\n     * Indicates if the prepass renderer is generating normals in world space or camera space (default: camera space)\n     */\n    get generateNormalsInWorldSpace() {\n        return this._generateNormalsInWorldSpace;\n    }\n    set generateNormalsInWorldSpace(value) {\n        if (this._generateNormalsInWorldSpace === value) {\n            return;\n        }\n        this._generateNormalsInWorldSpace = value;\n        this._markAllMaterialsAsPrePassDirty();\n    }\n    /**\n     * Returns the index of a texture in the multi render target texture array.\n     * @param type Texture type\n     * @returns The index\n     */\n    getIndex(type) {\n        return this._textureIndices[type];\n    }\n    /**\n     * How many samples are used for MSAA of the scene render target\n     */\n    get samples() {\n        return this.defaultRT.samples;\n    }\n    set samples(n) {\n        this.defaultRT.samples = n;\n    }\n    /**\n     * If set to true (default: false), the depth texture will be cleared with the depth value corresponding to the far plane (1 in normal mode, 0 in reverse depth buffer mode)\n     * If set to false, the depth texture is always cleared with 0.\n     */\n    get useSpecificClearForDepthTexture() {\n        return this._useSpecificClearForDepthTexture;\n    }\n    set useSpecificClearForDepthTexture(value) {\n        if (this._useSpecificClearForDepthTexture === value) {\n            return;\n        }\n        this._useSpecificClearForDepthTexture = value;\n        this._isDirty = true;\n    }\n    /**\n     * @returns the prepass render target for the rendering pass.\n     * If we are currently rendering a render target, it returns the PrePassRenderTarget\n     * associated with that render target. Otherwise, it returns the scene default PrePassRenderTarget\n     */\n    getRenderTarget() {\n        return this._currentTarget;\n    }\n    /**\n     * @internal\n     * Managed by the scene component\n     * @param prePassRenderTarget\n     */\n    _setRenderTarget(prePassRenderTarget) {\n        if (prePassRenderTarget) {\n            this._currentTarget = prePassRenderTarget;\n        }\n        else {\n            this._currentTarget = this.defaultRT;\n            this._engine.currentRenderPassId = this._scene.activeCamera?.renderPassId ?? this._currentTarget.renderPassId;\n        }\n    }\n    /**\n     * Returns true if the currently rendered prePassRenderTarget is the one\n     * associated with the scene.\n     */\n    get currentRTisSceneRT() {\n        return this._currentTarget === this.defaultRT;\n    }\n    _refreshGeometryBufferRendererLink() {\n        if (!this.doNotUseGeometryRendererFallback) {\n            this._geometryBuffer = this._scene.enableGeometryBufferRenderer();\n            if (!this._geometryBuffer) {\n                // Not supported\n                this.doNotUseGeometryRendererFallback = true;\n                return;\n            }\n            this._geometryBuffer._linkPrePassRenderer(this);\n        }\n        else {\n            if (this._geometryBuffer) {\n                this._geometryBuffer._unlinkPrePassRenderer();\n            }\n            this._geometryBuffer = null;\n            this._scene.disableGeometryBufferRenderer();\n        }\n    }\n    /**\n     * Indicates if the prepass is enabled\n     */\n    get enabled() {\n        return this._enabled;\n    }\n    /**\n     * Instantiates a prepass renderer\n     * @param scene The scene\n     */\n    constructor(scene) {\n        /**\n         * To save performance, we can excluded skinned meshes from the prepass\n         */\n        this.excludedSkinnedMesh = [];\n        /**\n         * Force material to be excluded from the prepass\n         * Can be useful when `useGeometryBufferFallback` is set to `true`\n         * and you don't want a material to show in the effect.\n         */\n        this.excludedMaterials = [];\n        /**\n         * Number of textures in the multi render target texture where the scene is directly rendered\n         */\n        this.mrtCount = 0;\n        this._mrtTypes = [];\n        this._mrtFormats = [];\n        this._mrtLayout = [];\n        this._mrtNames = [];\n        this._textureIndices = [];\n        this._generateNormalsInWorldSpace = false;\n        this._useSpecificClearForDepthTexture = false;\n        this._isDirty = true;\n        /**\n         * Configuration for prepass effects\n         */\n        this._effectConfigurations = [];\n        /**\n         * Prevents the PrePassRenderer from using the GeometryBufferRenderer as a fallback\n         */\n        this.doNotUseGeometryRendererFallback = true;\n        /**\n         * All the render targets generated by prepass\n         */\n        this.renderTargets = [];\n        this._clearColor = new Color4(0, 0, 0, 0);\n        this._clearDepthColor = new Color4(0, 0, 0, 1); //  // sets an invalid value by default - depth in the depth texture is view.z, so 0 is not possible because view.z can't be less than camera.minZ\n        this._enabled = false;\n        this._needsCompositionForThisPass = false;\n        /**\n         * Set to true to disable gamma transform in PrePass.\n         * Can be useful in case you already proceed to gamma transform on a material level\n         * and your post processes don't need to be in linear color space.\n         */\n        this.disableGammaTransform = false;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        let type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n        if (this._engine._caps.textureFloat && this._engine._caps.textureFloatLinearFiltering) {\n            type = Constants.TEXTURETYPE_FLOAT;\n        }\n        else if (this._engine._caps.textureHalfFloat && this._engine._caps.textureHalfFloatLinearFiltering) {\n            type = Constants.TEXTURETYPE_HALF_FLOAT;\n        }\n        for (let i = 0; i < PrePassRenderer.TextureFormats.length; ++i) {\n            const format = PrePassRenderer.TextureFormats[i].format;\n            if (PrePassRenderer.TextureFormats[i].type === Constants.TEXTURETYPE_FLOAT) {\n                PrePassRenderer.TextureFormats[i].type = type;\n                if (type === Constants.TEXTURETYPE_FLOAT &&\n                    (format === Constants.TEXTUREFORMAT_R || format === Constants.TEXTUREFORMAT_RG || format === Constants.TEXTUREFORMAT_RGBA) &&\n                    !this._engine._caps.supportFloatTexturesResolve) {\n                    // We don't know in advance if the texture will be used as a resolve target, so we revert to half_float if the extension to resolve full float textures is not supported\n                    PrePassRenderer.TextureFormats[i].type = Constants.TEXTURETYPE_HALF_FLOAT;\n                }\n            }\n        }\n        PrePassRenderer._SceneComponentInitialization(this._scene);\n        this.defaultRT = this._createRenderTarget(\"sceneprePassRT\", null);\n        this._currentTarget = this.defaultRT;\n    }\n    /**\n     * Creates a new PrePassRenderTarget\n     * This should be the only way to instantiate a `PrePassRenderTarget`\n     * @param name Name of the `PrePassRenderTarget`\n     * @param renderTargetTexture RenderTarget the `PrePassRenderTarget` will be attached to.\n     * Can be `null` if the created `PrePassRenderTarget` is attached to the scene (default framebuffer).\n     * @internal\n     */\n    _createRenderTarget(name, renderTargetTexture) {\n        const rt = new PrePassRenderTarget(name, renderTargetTexture, { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, 0, this._scene, {\n            generateMipMaps: false,\n            generateStencilBuffer: this._engine.isStencilEnable,\n            defaultType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            types: [],\n            drawOnlyOnFirstAttachmentByDefault: true,\n        });\n        this.renderTargets.push(rt);\n        if (this._enabled) {\n            // The pre-pass renderer is already enabled, so make sure we create the render target with the correct number of textures\n            this._update();\n        }\n        return rt;\n    }\n    /**\n     * Indicates if rendering a prepass is supported\n     */\n    get isSupported() {\n        return this._scene.getEngine().getCaps().drawBuffersExtension;\n    }\n    /**\n     * Sets the proper output textures to draw in the engine.\n     * @param effect The effect that is drawn. It can be or not be compatible with drawing to several output textures.\n     * @param subMesh Submesh on which the effect is applied\n     */\n    bindAttachmentsForEffect(effect, subMesh) {\n        const material = subMesh.getMaterial();\n        const isPrePassCapable = material && material.isPrePassCapable;\n        const excluded = material && this.excludedMaterials.indexOf(material) !== -1;\n        if (this.enabled && this._currentTarget.enabled) {\n            if (effect._multiTarget && isPrePassCapable && !excluded) {\n                this._engine.bindAttachments(this._multiRenderAttachments);\n            }\n            else {\n                if (this._engine._currentRenderTarget) {\n                    this._engine.bindAttachments(this._defaultAttachments);\n                }\n                else {\n                    this._engine.restoreSingleAttachment();\n                }\n                if (this._geometryBuffer && this.currentRTisSceneRT && !excluded) {\n                    this._geometryBuffer.renderList.push(subMesh.getRenderingMesh());\n                }\n            }\n        }\n    }\n    _reinitializeAttachments() {\n        const multiRenderLayout = [];\n        const clearLayout = [false];\n        const clearDepthLayout = [false];\n        const defaultLayout = [true];\n        for (let i = 0; i < this.mrtCount; i++) {\n            multiRenderLayout.push(true);\n            if (i > 0) {\n                if (this._useSpecificClearForDepthTexture && this._mrtLayout[i] === Constants.PREPASS_DEPTH_TEXTURE_TYPE) {\n                    clearLayout.push(false);\n                    clearDepthLayout.push(true);\n                }\n                else {\n                    clearLayout.push(true);\n                    clearDepthLayout.push(false);\n                }\n                defaultLayout.push(false);\n            }\n        }\n        this._multiRenderAttachments = this._engine.buildTextureLayout(multiRenderLayout);\n        this._clearAttachments = this._engine.buildTextureLayout(clearLayout);\n        this._clearDepthAttachments = this._engine.buildTextureLayout(clearDepthLayout);\n        this._defaultAttachments = this._engine.buildTextureLayout(defaultLayout);\n    }\n    _resetLayout() {\n        for (let i = 0; i < PrePassRenderer.TextureFormats.length; i++) {\n            this._textureIndices[PrePassRenderer.TextureFormats[i].purpose] = -1;\n        }\n        this._textureIndices[Constants.PREPASS_COLOR_TEXTURE_TYPE] = 0;\n        this._mrtLayout = [Constants.PREPASS_COLOR_TEXTURE_TYPE];\n        this._mrtTypes = [PrePassRenderer.TextureFormats[Constants.PREPASS_COLOR_TEXTURE_TYPE].type];\n        this._mrtFormats = [PrePassRenderer.TextureFormats[Constants.PREPASS_COLOR_TEXTURE_TYPE].format];\n        this._mrtNames = [PrePassRenderer.TextureFormats[Constants.PREPASS_COLOR_TEXTURE_TYPE].name];\n        this.mrtCount = 1;\n    }\n    _updateGeometryBufferLayout() {\n        this._refreshGeometryBufferRendererLink();\n        if (this._geometryBuffer) {\n            this._geometryBuffer._resetLayout();\n            const texturesActivated = [];\n            for (let i = 0; i < this._mrtLayout.length; i++) {\n                texturesActivated.push(false);\n            }\n            this._geometryBuffer._linkInternalTexture(this.defaultRT.getInternalTexture());\n            const matches = [\n                {\n                    prePassConstant: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\n                    geometryBufferConstant: GeometryBufferRenderer.DEPTH_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\n                    geometryBufferConstant: GeometryBufferRenderer.NORMAL_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: Constants.PREPASS_POSITION_TEXTURE_TYPE,\n                    geometryBufferConstant: GeometryBufferRenderer.POSITION_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\n                    geometryBufferConstant: GeometryBufferRenderer.REFLECTIVITY_TEXTURE_TYPE,\n                },\n                {\n                    prePassConstant: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\n                    geometryBufferConstant: GeometryBufferRenderer.VELOCITY_TEXTURE_TYPE,\n                },\n            ];\n            // replace textures in the geometryBuffer RT\n            for (let i = 0; i < matches.length; i++) {\n                const index = this._mrtLayout.indexOf(matches[i].prePassConstant);\n                if (index !== -1) {\n                    this._geometryBuffer._forceTextureType(matches[i].geometryBufferConstant, index);\n                    texturesActivated[index] = true;\n                }\n            }\n            this._geometryBuffer._setAttachments(this._engine.buildTextureLayout(texturesActivated));\n        }\n    }\n    /**\n     * Restores attachments for single texture draw.\n     */\n    restoreAttachments() {\n        if (this.enabled && this._currentTarget.enabled && this._defaultAttachments) {\n            if (this._engine._currentRenderTarget) {\n                this._engine.bindAttachments(this._defaultAttachments);\n            }\n            else {\n                this._engine.restoreSingleAttachment();\n            }\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _beforeDraw(camera, faceIndex, layer) {\n        // const previousEnabled = this._enabled && this._currentTarget.enabled;\n        if (this._isDirty) {\n            this._update();\n        }\n        if (!this._enabled || !this._currentTarget.enabled) {\n            return;\n        }\n        if (this._geometryBuffer) {\n            this._geometryBuffer.renderList = [];\n        }\n        this._setupOutputForThisPass(this._currentTarget, camera);\n    }\n    _prepareFrame(prePassRenderTarget, faceIndex, layer) {\n        if (prePassRenderTarget.renderTargetTexture) {\n            prePassRenderTarget.renderTargetTexture._prepareFrame(this._scene, faceIndex, layer, prePassRenderTarget.renderTargetTexture.useCameraPostProcesses);\n        }\n        else if (this._postProcessesSourceForThisPass.length) {\n            this._scene.postProcessManager._prepareFrame();\n        }\n        else {\n            this._engine.restoreDefaultFramebuffer();\n        }\n    }\n    /**\n     * Sets an intermediary texture between prepass and postprocesses. This texture\n     * will be used as input for post processes\n     * @param rt The render target texture to use\n     * @returns true if there are postprocesses that will use this texture,\n     * false if there is no postprocesses - and the function has no effect\n     */\n    setCustomOutput(rt) {\n        const firstPP = this._postProcessesSourceForThisPass[0];\n        if (!firstPP) {\n            return false;\n        }\n        firstPP.inputTexture = rt.renderTarget;\n        return true;\n    }\n    _renderPostProcesses(prePassRenderTarget, faceIndex) {\n        const firstPP = this._postProcessesSourceForThisPass[0];\n        const outputTexture = firstPP ? firstPP.inputTexture : prePassRenderTarget.renderTargetTexture ? prePassRenderTarget.renderTargetTexture.renderTarget : null;\n        // Build post process chain for this prepass post draw\n        let postProcessChain = this._currentTarget._beforeCompositionPostProcesses;\n        if (this._needsCompositionForThisPass) {\n            postProcessChain = postProcessChain.concat([this._currentTarget.imageProcessingPostProcess]);\n        }\n        // Activates and renders the chain\n        if (postProcessChain.length) {\n            this._scene.postProcessManager._prepareFrame(this._currentTarget.renderTarget?.texture, postProcessChain);\n            this._scene.postProcessManager.directRender(postProcessChain, outputTexture, false, faceIndex);\n        }\n    }\n    /**\n     * @internal\n     */\n    _afterDraw(faceIndex, layer) {\n        if (this._enabled && this._currentTarget.enabled) {\n            this._prepareFrame(this._currentTarget, faceIndex, layer);\n            this._renderPostProcesses(this._currentTarget, faceIndex);\n        }\n    }\n    /**\n     * Clears the current prepass render target (in the sense of settings pixels to the scene clear color value)\n     * @internal\n     */\n    _clear() {\n        if (this._isDirty) {\n            this._update();\n        }\n        if (this._enabled && this._currentTarget.enabled) {\n            this._bindFrameBuffer();\n            // Clearing other attachment with 0 on all other attachments\n            this._engine.bindAttachments(this._clearAttachments);\n            this._engine.clear(this._clearColor, true, false, false);\n            if (this._useSpecificClearForDepthTexture) {\n                this._engine.bindAttachments(this._clearDepthAttachments);\n                this._engine.clear(this._clearDepthColor, true, false, false);\n            }\n            // Regular clear color with the scene clear color of the 1st attachment\n            this._engine.bindAttachments(this._defaultAttachments);\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _bindFrameBuffer() {\n        if (this._enabled && this._currentTarget.enabled) {\n            this._currentTarget._checkSize();\n            const internalTexture = this._currentTarget.renderTarget;\n            if (internalTexture) {\n                this._engine.bindFramebuffer(internalTexture);\n            }\n        }\n    }\n    _setEnabled(enabled) {\n        this._enabled = enabled;\n    }\n    _setRenderTargetEnabled(prePassRenderTarget, enabled) {\n        prePassRenderTarget.enabled = enabled;\n        if (!enabled) {\n            this._unlinkInternalTexture(prePassRenderTarget);\n        }\n    }\n    /**\n     * Adds an effect configuration to the prepass render target.\n     * If an effect has already been added, it won't add it twice and will return the configuration\n     * already present.\n     * @param cfg the effect configuration\n     * @returns the effect configuration now used by the prepass\n     */\n    addEffectConfiguration(cfg) {\n        // Do not add twice\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].name === cfg.name) {\n                return this._effectConfigurations[i];\n            }\n        }\n        this._effectConfigurations.push(cfg);\n        if (cfg.clearColor) {\n            this._clearColor.copyFrom(cfg.clearColor);\n        }\n        return cfg;\n    }\n    /**\n     * Retrieves an effect configuration by name\n     * @param name the name of the effect configuration\n     * @returns the effect configuration, or null if not present\n     */\n    getEffectConfiguration(name) {\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].name === name) {\n                return this._effectConfigurations[i];\n            }\n        }\n        return null;\n    }\n    _enable() {\n        const previousMrtCount = this.mrtCount;\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].enabled) {\n                this._enableTextures(this._effectConfigurations[i].texturesRequired);\n            }\n        }\n        for (let i = 0; i < this.renderTargets.length; i++) {\n            if (this.mrtCount !== previousMrtCount || this.renderTargets[i].count !== this.mrtCount) {\n                this.renderTargets[i].updateCount(this.mrtCount, { types: this._mrtTypes, formats: this._mrtFormats }, this._mrtNames.concat(\"prePass_DepthBuffer\"));\n            }\n            this.renderTargets[i]._resetPostProcessChain();\n            for (let j = 0; j < this._effectConfigurations.length; j++) {\n                if (this._effectConfigurations[j].enabled) {\n                    // TODO : subsurface scattering has 1 scene-wide effect configuration\n                    // solution : do not stock postProcess on effectConfiguration, but in the prepassRenderTarget (hashmap configuration => postProcess)\n                    // And call createPostProcess whenever the post process does not exist in the RT\n                    if (!this._effectConfigurations[j].postProcess && this._effectConfigurations[j].createPostProcess) {\n                        this._effectConfigurations[j].createPostProcess();\n                    }\n                    if (this._effectConfigurations[j].postProcess) {\n                        this.renderTargets[i]._beforeCompositionPostProcesses.push(this._effectConfigurations[j].postProcess);\n                    }\n                }\n            }\n        }\n        this._reinitializeAttachments();\n        this._setEnabled(true);\n        this._updateGeometryBufferLayout();\n    }\n    _disable() {\n        this._setEnabled(false);\n        for (let i = 0; i < this.renderTargets.length; i++) {\n            this._setRenderTargetEnabled(this.renderTargets[i], false);\n        }\n        this._resetLayout();\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            this._effectConfigurations[i].enabled = false;\n        }\n    }\n    _getPostProcessesSource(prePassRenderTarget, camera) {\n        if (camera) {\n            return camera._postProcesses;\n        }\n        else if (prePassRenderTarget.renderTargetTexture) {\n            if (prePassRenderTarget.renderTargetTexture.useCameraPostProcesses) {\n                const camera = prePassRenderTarget.renderTargetTexture.activeCamera ? prePassRenderTarget.renderTargetTexture.activeCamera : this._scene.activeCamera;\n                return camera ? camera._postProcesses : [];\n            }\n            else if (prePassRenderTarget.renderTargetTexture.postProcesses) {\n                return prePassRenderTarget.renderTargetTexture.postProcesses;\n            }\n            else {\n                return [];\n            }\n        }\n        else {\n            return this._scene.activeCamera ? this._scene.activeCamera._postProcesses : [];\n        }\n    }\n    _setupOutputForThisPass(prePassRenderTarget, camera) {\n        // Order is : draw ===> prePassRenderTarget._postProcesses ==> ipp ==> camera._postProcesses\n        const secondaryCamera = camera && this._scene.activeCameras && !!this._scene.activeCameras.length && this._scene.activeCameras.indexOf(camera) !== 0;\n        this._postProcessesSourceForThisPass = this._getPostProcessesSource(prePassRenderTarget, camera);\n        this._postProcessesSourceForThisPass = this._postProcessesSourceForThisPass.filter((pp) => {\n            return pp != null;\n        });\n        this._scene.autoClear = true;\n        const cameraHasImageProcessing = this._hasImageProcessing(this._postProcessesSourceForThisPass);\n        this._needsCompositionForThisPass = !cameraHasImageProcessing && !this.disableGammaTransform && this._needsImageProcessing() && !secondaryCamera;\n        const firstCameraPP = this._getFirstPostProcess(this._postProcessesSourceForThisPass);\n        const firstPrePassPP = prePassRenderTarget._beforeCompositionPostProcesses && prePassRenderTarget._beforeCompositionPostProcesses[0];\n        let firstPP = null;\n        // Setting the scene-wide post process configuration\n        this._scene.imageProcessingConfiguration.applyByPostProcess = this._needsCompositionForThisPass || cameraHasImageProcessing;\n        // Create composition effect if needed\n        if (this._needsCompositionForThisPass && !prePassRenderTarget.imageProcessingPostProcess) {\n            prePassRenderTarget._createCompositionEffect();\n        }\n        // Setting the prePassRenderTarget as input texture of the first PP\n        if (firstPrePassPP) {\n            firstPP = firstPrePassPP;\n        }\n        else if (this._needsCompositionForThisPass) {\n            firstPP = prePassRenderTarget.imageProcessingPostProcess;\n        }\n        else if (firstCameraPP) {\n            firstPP = firstCameraPP;\n        }\n        this._bindFrameBuffer();\n        this._linkInternalTexture(prePassRenderTarget, firstPP);\n    }\n    _linkInternalTexture(prePassRenderTarget, postProcess) {\n        if (postProcess) {\n            postProcess.autoClear = false;\n            postProcess.inputTexture = prePassRenderTarget.renderTarget;\n        }\n        if (prePassRenderTarget._outputPostProcess !== postProcess) {\n            if (prePassRenderTarget._outputPostProcess) {\n                this._unlinkInternalTexture(prePassRenderTarget);\n            }\n            prePassRenderTarget._outputPostProcess = postProcess;\n        }\n        if (prePassRenderTarget._internalTextureDirty) {\n            this._updateGeometryBufferLayout();\n            prePassRenderTarget._internalTextureDirty = false;\n        }\n    }\n    /**\n     * @internal\n     */\n    _unlinkInternalTexture(prePassRenderTarget) {\n        if (prePassRenderTarget._outputPostProcess) {\n            prePassRenderTarget._outputPostProcess.autoClear = true;\n            prePassRenderTarget._outputPostProcess.restoreDefaultInputTexture();\n            prePassRenderTarget._outputPostProcess = null;\n        }\n    }\n    _needsImageProcessing() {\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].enabled && this._effectConfigurations[i].needsImageProcessing) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _hasImageProcessing(postProcesses) {\n        let isIPPAlreadyPresent = false;\n        if (postProcesses) {\n            for (let i = 0; i < postProcesses.length; i++) {\n                if (postProcesses[i]?.getClassName() === \"ImageProcessingPostProcess\") {\n                    isIPPAlreadyPresent = true;\n                    break;\n                }\n            }\n        }\n        return isIPPAlreadyPresent;\n    }\n    /**\n     * Internal, gets the first post proces.\n     * @param postProcesses\n     * @returns the first post process to be run on this camera.\n     */\n    _getFirstPostProcess(postProcesses) {\n        for (let ppIndex = 0; ppIndex < postProcesses.length; ppIndex++) {\n            if (postProcesses[ppIndex] !== null) {\n                return postProcesses[ppIndex];\n            }\n        }\n        return null;\n    }\n    /**\n     * Marks the prepass renderer as dirty, triggering a check if the prepass is necessary for the next rendering.\n     */\n    markAsDirty() {\n        this._isDirty = true;\n    }\n    /**\n     * Enables a texture on the MultiRenderTarget for prepass\n     * @param types\n     */\n    _enableTextures(types) {\n        // For velocity : enable storage of previous matrices for instances\n        this._scene.needsPreviousWorldMatrices = false;\n        for (let i = 0; i < types.length; i++) {\n            const type = types[i];\n            if (this._textureIndices[type] === -1) {\n                this._textureIndices[type] = this._mrtLayout.length;\n                this._mrtLayout.push(type);\n                this._mrtTypes.push(PrePassRenderer.TextureFormats[type].type);\n                this._mrtFormats.push(PrePassRenderer.TextureFormats[type].format);\n                this._mrtNames.push(PrePassRenderer.TextureFormats[type].name);\n                this.mrtCount++;\n            }\n            if (type === Constants.PREPASS_VELOCITY_TEXTURE_TYPE || type === Constants.PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE) {\n                this._scene.needsPreviousWorldMatrices = true;\n            }\n        }\n    }\n    /**\n     * Makes sure that the prepass renderer is up to date if it has been dirtified.\n     */\n    update() {\n        if (this._isDirty) {\n            this._update();\n        }\n    }\n    _update() {\n        this._disable();\n        let enablePrePass = false;\n        this._scene.imageProcessingConfiguration.applyByPostProcess = false;\n        if (this._scene._depthPeelingRenderer && this._scene.useOrderIndependentTransparency) {\n            this._scene._depthPeelingRenderer.setPrePassRenderer(this);\n            enablePrePass = true;\n        }\n        for (let i = 0; i < this._scene.materials.length; i++) {\n            if (this._scene.materials[i].setPrePassRenderer(this)) {\n                enablePrePass = true;\n            }\n        }\n        if (enablePrePass) {\n            this._setRenderTargetEnabled(this.defaultRT, true);\n        }\n        let postProcesses;\n        for (let i = 0; i < this.renderTargets.length; i++) {\n            if (this.renderTargets[i].renderTargetTexture) {\n                postProcesses = this._getPostProcessesSource(this.renderTargets[i]);\n            }\n            else {\n                // When there are multiple active cameras, we have to choose one. We assume it's the first one and not scene.activeCamera, because in a number of cases,\n                // _update() will be called from an async method, meaning the active camera will be the last one in the list of active cameras,\n                // which is generally not the right camera to use for the prepass setup.\n                const camera = this._scene.activeCameras && this._scene.activeCameras.length > 0 ? this._scene.activeCameras[0] : this._scene.activeCamera;\n                if (!camera) {\n                    continue;\n                }\n                postProcesses = camera._postProcesses;\n            }\n            if (!postProcesses) {\n                continue;\n            }\n            postProcesses = postProcesses.filter((pp) => {\n                return pp != null;\n            });\n            if (postProcesses) {\n                for (let j = 0; j < postProcesses.length; j++) {\n                    if (postProcesses[j].setPrePassRenderer(this)) {\n                        this._setRenderTargetEnabled(this.renderTargets[i], true);\n                        enablePrePass = true;\n                    }\n                }\n                if (this._hasImageProcessing(postProcesses)) {\n                    this._scene.imageProcessingConfiguration.applyByPostProcess = true;\n                }\n            }\n        }\n        this._markAllMaterialsAsPrePassDirty();\n        this._isDirty = false;\n        if (enablePrePass) {\n            this._enable();\n        }\n    }\n    _markAllMaterialsAsPrePassDirty() {\n        const materials = this._scene.materials;\n        for (let i = 0; i < materials.length; i++) {\n            materials[i].markAsDirty(Material.PrePassDirtyFlag);\n        }\n    }\n    /**\n     * Disposes the prepass renderer.\n     */\n    dispose() {\n        for (let i = this.renderTargets.length - 1; i >= 0; i--) {\n            this.renderTargets[i].dispose();\n        }\n        for (let i = 0; i < this._effectConfigurations.length; i++) {\n            if (this._effectConfigurations[i].dispose) {\n                this._effectConfigurations[i].dispose();\n            }\n        }\n    }\n}\n/**\n * @internal\n */\nPrePassRenderer._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"PrePassRendererSceneComponent\");\n};\n/**\n * Describes the types and formats of the textures used by the pre-pass renderer\n */\nPrePassRenderer.TextureFormats = [\n    {\n        purpose: Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_HALF_FLOAT,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_Irradiance\",\n    },\n    {\n        purpose: Constants.PREPASS_POSITION_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_HALF_FLOAT,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_Position\",\n    },\n    {\n        purpose: Constants.PREPASS_VELOCITY_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_Velocity\",\n    },\n    {\n        purpose: Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_Reflectivity\",\n    },\n    {\n        purpose: Constants.PREPASS_COLOR_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_HALF_FLOAT,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_Color\",\n    },\n    {\n        purpose: Constants.PREPASS_DEPTH_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_FLOAT,\n        format: Constants.TEXTUREFORMAT_R,\n        name: \"prePass_Depth\",\n    },\n    {\n        purpose: Constants.PREPASS_NORMAL_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_HALF_FLOAT,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_Normal\",\n    },\n    {\n        purpose: Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_Albedo\",\n    },\n    {\n        purpose: Constants.PREPASS_WORLD_NORMAL_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_WorldNormal\",\n    },\n    {\n        purpose: Constants.PREPASS_LOCAL_POSITION_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_HALF_FLOAT,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_LocalPosition\",\n    },\n    {\n        purpose: Constants.PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_FLOAT,\n        format: Constants.TEXTUREFORMAT_R,\n        name: \"prePass_ScreenDepth\",\n    },\n    {\n        purpose: Constants.PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE,\n        type: Constants.TEXTURETYPE_HALF_FLOAT,\n        format: Constants.TEXTUREFORMAT_RGBA,\n        name: \"prePass_VelocityLinear\",\n    },\n];\n//# sourceMappingURL=prePassRenderer.js.map","import { Scene } from \"../scene\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { PrePassRenderer } from \"./prePassRenderer\";\nimport { Logger } from \"../Misc/logger\";\nObject.defineProperty(Scene.prototype, \"prePassRenderer\", {\n    get: function () {\n        return this._prePassRenderer;\n    },\n    set: function (value) {\n        if (value && value.isSupported) {\n            this._prePassRenderer = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.enablePrePassRenderer = function () {\n    if (this._prePassRenderer) {\n        return this._prePassRenderer;\n    }\n    this._prePassRenderer = new PrePassRenderer(this);\n    if (!this._prePassRenderer.isSupported) {\n        this._prePassRenderer = null;\n        Logger.Error(\"PrePassRenderer needs WebGL 2 support.\\n\" + \"Maybe you tried to use the following features that need the PrePassRenderer :\\n\" + \" + Subsurface Scattering\");\n    }\n    return this._prePassRenderer;\n};\nScene.prototype.disablePrePassRenderer = function () {\n    if (!this._prePassRenderer) {\n        return;\n    }\n    this._prePassRenderer.dispose();\n    this._prePassRenderer = null;\n};\n/**\n * Defines the Geometry Buffer scene component responsible to manage a G-Buffer useful\n * in several rendering techniques.\n */\nexport class PrePassRendererSceneComponent {\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_PREPASSRENDERER;\n        this.scene = scene;\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._beforeCameraDrawStage.registerStep(SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS, this, this._beforeCameraDraw);\n        this.scene._afterCameraDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterCameraDraw);\n        this.scene._beforeRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS, this, this._beforeRenderTargetDraw);\n        this.scene._afterRenderTargetDrawStage.registerStep(SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS, this, this._afterRenderTargetDraw);\n        this.scene._beforeClearStage.registerStep(SceneComponentConstants.STEP_BEFORECLEAR_PREPASS, this, this._beforeClearStage);\n        this.scene._beforeRenderTargetClearStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS, this, this._beforeRenderTargetClearStage);\n        this.scene._beforeRenderingMeshStage.registerStep(SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS, this, this._beforeRenderingMeshStage);\n        this.scene._afterRenderingMeshStage.registerStep(SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS, this, this._afterRenderingMeshStage);\n    }\n    _beforeRenderTargetDraw(renderTarget, faceIndex, layer) {\n        if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n            this.scene.prePassRenderer._beforeDraw(undefined, faceIndex, layer);\n        }\n    }\n    _afterRenderTargetDraw(renderTarget, faceIndex, layer) {\n        if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n            this.scene.prePassRenderer._afterDraw(faceIndex, layer);\n        }\n    }\n    _beforeRenderTargetClearStage(renderTarget) {\n        if (this.scene.prePassRenderer && !renderTarget.noPrePassRenderer) {\n            if (!renderTarget._prePassRenderTarget) {\n                renderTarget._prePassRenderTarget = this.scene.prePassRenderer._createRenderTarget(renderTarget.name + \"_prePassRTT\", renderTarget);\n            }\n            this.scene.prePassRenderer._setRenderTarget(renderTarget._prePassRenderTarget);\n            this.scene.prePassRenderer._clear();\n        }\n    }\n    _beforeCameraDraw(camera) {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._setRenderTarget(null);\n            this.scene.prePassRenderer._beforeDraw(camera);\n        }\n    }\n    _afterCameraDraw() {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._afterDraw();\n        }\n    }\n    _beforeClearStage() {\n        if (this.scene.prePassRenderer) {\n            this.scene.prePassRenderer._setRenderTarget(null);\n            this.scene.prePassRenderer._clear();\n        }\n    }\n    _beforeRenderingMeshStage(mesh, subMesh, batch, effect) {\n        if (!effect) {\n            return;\n        }\n        // Render to MRT\n        const scene = mesh.getScene();\n        if (scene.prePassRenderer) {\n            scene.prePassRenderer.bindAttachmentsForEffect(effect, subMesh);\n        }\n    }\n    _afterRenderingMeshStage(mesh) {\n        const scene = mesh.getScene();\n        if (scene.prePassRenderer) {\n            scene.prePassRenderer.restoreAttachments();\n        }\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do for this component\n    }\n    /**\n     * Disposes the component and the associated resources\n     */\n    dispose() {\n        this.scene.disablePrePassRenderer();\n    }\n}\nPrePassRenderer._SceneComponentInitialization = (scene) => {\n    // Register the G Buffer component to the scene.\n    let component = scene._getComponent(SceneComponentConstants.NAME_PREPASSRENDERER);\n    if (!component) {\n        component = new PrePassRendererSceneComponent(scene);\n        scene._addComponent(component);\n    }\n};\n//# sourceMappingURL=prePassRendererSceneComponent.js.map"],"names":["ThinImageProcessingPostProcess","EffectWrapper","_gatherImports","useWebGPU","list","this","_webGPUReady","push","import","imageProcessingConfiguration","_imageProcessingConfiguration","value","applyByPostProcess","_attachImageProcessingConfiguration","configuration","doNotBuild","_imageProcessingObserver","onUpdateParameters","remove","scene","options","engine","scenes","length","EngineStore","LastCreatedScene","ImageProcessingConfiguration","add","_updateParameters","colorCurves","colorCurvesEnabled","colorGradingTexture","colorGradingEnabled","exposure","toneMappingEnabled","toneMappingType","contrast","vignetteStretch","vignetteCentreX","vignetteCenterX","vignetteCentreY","vignetteCenterY","vignetteWeight","vignetteColor","vignetteCameraFov","vignetteBlendMode","vignetteEnabled","ditheringIntensity","ditheringEnabled","fromLinearSpace","_fromLinearSpace","outputTextureWidth","outputTextureHeight","constructor","name","super","Engine","LastCreatedEngine","useShaderStore","useAsPostProcess","fragmentShader","FragmentUrl","_defines","IMAGEPROCESSING","VIGNETTE","VIGNETTEBLENDMODEMULTIPLY","VIGNETTEBLENDMODEOPAQUE","TONEMAPPING","CONTRAST","COLORCURVES","COLORGRADING","COLORGRADING3D","FROMLINEARSPACE","SAMPLER3DGREENDEPTH","SAMPLER3DBGRMAP","DITHER","IMAGEPROCESSINGPOSTPROCESS","EXPOSURE","SKIPFINALCOLORCLAMP","prepareDefines","defines","prop","samplers","uniforms","PrepareSamplers","PrepareUniforms","updateEffect","bind","noDefaultBindings","effect","overrideAspectRatio","dispose","ImageProcessingPostProcess","PostProcess","_effectWrapper","isSupported","getEffect","camera","samplingMode","reusable","textureType","Constants","TEXTURETYPE_UNSIGNED_BYTE","localOptions","size","undefined","getScene","blockCompilation","effectWrapper","onApply","aspectRatio","getClassName","__decorate","serialize","prototype","PrePassRenderTarget","MultiRenderTarget","renderTargetTexture","count","_beforeCompositionPostProcesses","_internalTextureDirty","enabled","_createCompositionEffect","imageProcessingPostProcess","_engine","_checkSize","requiredWidth","getRenderWidth","requiredHeight","getRenderHeight","width","height","resize","updateCount","textureNames","_resetPostProcessChain","_scene","prePassRenderer","index","renderTargets","indexOf","splice","_prePassRenderTarget","_outputPostProcess","autoClear","restoreDefaultInputTexture","PrePassRenderer","generateNormalsInWorldSpace","_generateNormalsInWorldSpace","_markAllMaterialsAsPrePassDirty","getIndex","type","_textureIndices","samples","defaultRT","n","useSpecificClearForDepthTexture","_useSpecificClearForDepthTexture","_isDirty","getRenderTarget","_currentTarget","_setRenderTarget","prePassRenderTarget","currentRenderPassId","activeCamera","renderPassId","currentRTisSceneRT","_refreshGeometryBufferRendererLink","doNotUseGeometryRendererFallback","_geometryBuffer","_unlinkPrePassRenderer","disableGeometryBufferRenderer","enableGeometryBufferRenderer","_linkPrePassRenderer","_enabled","excludedSkinnedMesh","excludedMaterials","mrtCount","_mrtTypes","_mrtFormats","_mrtLayout","_mrtNames","_effectConfigurations","_clearColor","Color4","_clearDepthColor","_needsCompositionForThisPass","disableGammaTransform","getEngine","_caps","textureFloat","textureFloatLinearFiltering","TEXTURETYPE_FLOAT","textureHalfFloat","textureHalfFloatLinearFiltering","TEXTURETYPE_HALF_FLOAT","i","TextureFormats","format","TEXTUREFORMAT_R","TEXTUREFORMAT_RG","TEXTUREFORMAT_RGBA","supportFloatTexturesResolve","_SceneComponentInitialization","_createRenderTarget","rt","generateMipMaps","generateStencilBuffer","isStencilEnable","defaultType","types","drawOnlyOnFirstAttachmentByDefault","_update","getCaps","drawBuffersExtension","bindAttachmentsForEffect","subMesh","material","getMaterial","isPrePassCapable","excluded","_multiTarget","bindAttachments","_multiRenderAttachments","_currentRenderTarget","_defaultAttachments","restoreSingleAttachment","renderList","getRenderingMesh","_reinitializeAttachments","multiRenderLayout","clearLayout","clearDepthLayout","defaultLayout","PREPASS_DEPTH_TEXTURE_TYPE","buildTextureLayout","_clearAttachments","_clearDepthAttachments","_resetLayout","purpose","PREPASS_COLOR_TEXTURE_TYPE","_updateGeometryBufferLayout","texturesActivated","_linkInternalTexture","getInternalTexture","matches","prePassConstant","geometryBufferConstant","GeometryBufferRenderer","DEPTH_TEXTURE_TYPE","PREPASS_NORMAL_TEXTURE_TYPE","NORMAL_TEXTURE_TYPE","PREPASS_POSITION_TEXTURE_TYPE","POSITION_TEXTURE_TYPE","PREPASS_REFLECTIVITY_TEXTURE_TYPE","REFLECTIVITY_TEXTURE_TYPE","PREPASS_VELOCITY_TEXTURE_TYPE","VELOCITY_TEXTURE_TYPE","_forceTextureType","_setAttachments","restoreAttachments","_beforeDraw","faceIndex","layer","_setupOutputForThisPass","_prepareFrame","useCameraPostProcesses","_postProcessesSourceForThisPass","postProcessManager","restoreDefaultFramebuffer","setCustomOutput","firstPP","inputTexture","renderTarget","_renderPostProcesses","outputTexture","postProcessChain","concat","texture","directRender","_afterDraw","_clear","_bindFrameBuffer","clear","internalTexture","bindFramebuffer","_setEnabled","_setRenderTargetEnabled","_unlinkInternalTexture","addEffectConfiguration","cfg","clearColor","copyFrom","getEffectConfiguration","_enable","previousMrtCount","_enableTextures","texturesRequired","formats","j","postProcess","createPostProcess","_disable","_getPostProcessesSource","_postProcesses","postProcesses","secondaryCamera","activeCameras","filter","pp","cameraHasImageProcessing","_hasImageProcessing","_needsImageProcessing","firstCameraPP","_getFirstPostProcess","firstPrePassPP","needsImageProcessing","isIPPAlreadyPresent","ppIndex","markAsDirty","needsPreviousWorldMatrices","PREPASS_VELOCITY_LINEAR_TEXTURE_TYPE","update","enablePrePass","_depthPeelingRenderer","useOrderIndependentTransparency","setPrePassRenderer","materials","Material","PrePassDirtyFlag","_","_WarnImport","PREPASS_IRRADIANCE_TEXTURE_TYPE","PREPASS_ALBEDO_SQRT_TEXTURE_TYPE","PREPASS_WORLD_NORMAL_TEXTURE_TYPE","PREPASS_LOCAL_POSITION_TEXTURE_TYPE","PREPASS_SCREENSPACE_DEPTH_TEXTURE_TYPE","Object","defineProperty","Scene","get","_prePassRenderer","set","enumerable","configurable","enablePrePassRenderer","Logger","Error","disablePrePassRenderer","PrePassRendererSceneComponent","SceneComponentConstants","NAME_PREPASSRENDERER","register","_beforeCameraDrawStage","registerStep","STEP_BEFORECAMERADRAW_PREPASS","_beforeCameraDraw","_afterCameraDrawStage","STEP_AFTERCAMERADRAW_PREPASS","_afterCameraDraw","_beforeRenderTargetDrawStage","STEP_BEFORERENDERTARGETDRAW_PREPASS","_beforeRenderTargetDraw","_afterRenderTargetDrawStage","_afterRenderTargetDraw","_beforeClearStage","STEP_BEFORECLEAR_PREPASS","_beforeRenderTargetClearStage","STEP_BEFORERENDERTARGETCLEAR_PREPASS","_beforeRenderingMeshStage","STEP_BEFORERENDERINGMESH_PREPASS","_afterRenderingMeshStage","STEP_AFTERRENDERINGMESH_PREPASS","noPrePassRenderer","mesh","batch","rebuild","component","_getComponent","_addComponent"],"mappings":"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"}