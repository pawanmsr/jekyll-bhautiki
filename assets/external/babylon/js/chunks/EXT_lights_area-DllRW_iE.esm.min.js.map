{"version":3,"file":"EXT_lights_area-DllRW_iE.esm.min.js","sources":["../../../../../dev/core/dist/Lights/areaLight.js","../../../../../dev/core/dist/Lights/LTC/ltcTextureTool.js","../../../../../dev/core/dist/Lights/rectAreaLight.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/EXT_lights_area.js"],"sourcesContent":["import { RawTexture } from \"core/Materials/Textures/rawTexture\";\nimport { Texture } from \"core/Materials/Textures/texture\";\nimport { Constants } from \"core/Engines/constants\";\nimport { Light } from \"core/Lights/light\";\nimport { DecodeLTCTextureDataAsync } from \"core/Lights/LTC/ltcTextureTool\";\nimport { Logger } from \"core/Misc/logger\";\nfunction CreateSceneLTCTextures(scene) {\n    const useDelayedTextureLoading = scene.useDelayedTextureLoading;\n    scene.useDelayedTextureLoading = false;\n    const previousState = scene._blockEntityCollection;\n    scene._blockEntityCollection = false;\n    scene._ltcTextures = {\n        LTC1: RawTexture.CreateRGBATexture(null, 64, 64, scene.getEngine(), false, false, Constants.TEXTURE_LINEAR_LINEAR, Constants.TEXTURETYPE_HALF_FLOAT, 0, false, true),\n        LTC2: RawTexture.CreateRGBATexture(null, 64, 64, scene.getEngine(), false, false, Constants.TEXTURE_LINEAR_LINEAR, Constants.TEXTURETYPE_HALF_FLOAT, 0, false, true),\n    };\n    scene._blockEntityCollection = previousState;\n    scene._ltcTextures.LTC1.wrapU = Texture.CLAMP_ADDRESSMODE;\n    scene._ltcTextures.LTC1.wrapV = Texture.CLAMP_ADDRESSMODE;\n    scene._ltcTextures.LTC2.wrapU = Texture.CLAMP_ADDRESSMODE;\n    scene._ltcTextures.LTC2.wrapV = Texture.CLAMP_ADDRESSMODE;\n    scene.useDelayedTextureLoading = useDelayedTextureLoading;\n    DecodeLTCTextureDataAsync()\n        // eslint-disable-next-line github/no-then\n        .then((textureData) => {\n        if (scene._ltcTextures) {\n            const ltc1 = scene._ltcTextures?.LTC1;\n            ltc1.update(textureData[0]);\n            const ltc2 = scene._ltcTextures?.LTC2;\n            ltc2.update(textureData[1]);\n            scene.onDisposeObservable.addOnce(() => {\n                scene._ltcTextures?.LTC1.dispose();\n                scene._ltcTextures?.LTC2.dispose();\n            });\n        }\n    })\n        // eslint-disable-next-line github/no-then\n        .catch((error) => {\n        Logger.Error(`Area Light fail to get LTC textures data. Error: ${error}`);\n    });\n}\n/**\n * Abstract Area Light class that servers as parent for all Area Lights implementations.\n * The light is emitted from the area in the -Z direction.\n */\nexport class AreaLight extends Light {\n    /**\n     * Creates a area light object.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param position The position of the area light.\n     * @param scene The scene the light belongs to\n     * @param dontAddToScene True to not add the light to the scene\n     */\n    constructor(name, position, scene, dontAddToScene) {\n        super(name, scene, dontAddToScene);\n        this.position = position;\n        if (!this._scene._ltcTextures) {\n            CreateSceneLTCTextures(this._scene);\n        }\n    }\n    transferTexturesToEffect(effect, lightIndex) {\n        if (this._scene._ltcTextures) {\n            effect.setTexture(\"areaLightsLTC1Sampler\", this._scene._ltcTextures.LTC1);\n            effect.setTexture(\"areaLightsLTC2Sampler\", this._scene._ltcTextures.LTC2);\n        }\n        return this;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"AREALIGHT\" + lightIndex] = true;\n        defines[\"AREALIGHTUSED\"] = true;\n    }\n    _isReady() {\n        if (this._scene._ltcTextures) {\n            return this._scene._ltcTextures.LTC1.isReady() && this._scene._ltcTextures.LTC2.isReady();\n        }\n        return false;\n    }\n}\n//# sourceMappingURL=areaLight.js.map","import { Tools } from \"core/Misc/tools\";\n/**\n * Loads LTC texture data from Babylon.js CDN.\n * @returns Promise with data for LTC1 and LTC2 textures for area lights.\n */\nexport async function DecodeLTCTextureDataAsync() {\n    const ltc1 = new Uint16Array(64 * 64 * 4);\n    const ltc2 = new Uint16Array(64 * 64 * 4);\n    const file = await Tools.LoadFileAsync(Tools.GetAssetUrl(\"https://assets.babylonjs.com/core/areaLights/areaLightsLTC.bin\"));\n    const ltcEncoded = new Uint16Array(file);\n    const pixelCount = ltcEncoded.length / 8;\n    for (let pixelIndex = 0; pixelIndex < pixelCount; pixelIndex++) {\n        ltc1[pixelIndex * 4] = ltcEncoded[pixelIndex * 8];\n        ltc1[pixelIndex * 4 + 1] = ltcEncoded[pixelIndex * 8 + 1];\n        ltc1[pixelIndex * 4 + 2] = ltcEncoded[pixelIndex * 8 + 2];\n        ltc1[pixelIndex * 4 + 3] = ltcEncoded[pixelIndex * 8 + 3];\n        ltc2[pixelIndex * 4] = ltcEncoded[pixelIndex * 8 + 4];\n        ltc2[pixelIndex * 4 + 1] = ltcEncoded[pixelIndex * 8 + 5];\n        ltc2[pixelIndex * 4 + 2] = ltcEncoded[pixelIndex * 8 + 6];\n        ltc2[pixelIndex * 4 + 3] = ltcEncoded[pixelIndex * 8 + 7];\n    }\n    return [ltc1, ltc2];\n}\n//# sourceMappingURL=ltcTextureTool.js.map","import { __decorate } from \"tslib\";\nimport { Vector3 } from \"core/Maths/math.vector\";\nimport { Node } from \"core/node\";\nimport { Light } from \"core/Lights/light\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { serialize } from \"core/Misc/decorators\";\nimport { AreaLight } from \"core/Lights/areaLight\";\nimport { Constants } from \"core/Engines/constants\";\nNode.AddNodeConstructor(\"Light_Type_4\", (name, scene) => {\n    return () => new RectAreaLight(name, Vector3.Zero(), 1, 1, scene);\n});\n/**\n * A rectangular area light defined by an unique point in world space, a width and a height.\n * The light is emitted from the rectangular area in the -Z direction.\n */\nexport class RectAreaLight extends AreaLight {\n    /**\n     * Gets Rect Area Light emission texture. (Note: This texture needs pre-processing! Use AreaLightTextureTools to pre-process the texture).\n     */\n    get emissionTexture() {\n        return this._emissionTextureTexture;\n    }\n    /**\n     * Sets Rect Area Light emission texture. (Note: This texture needs pre-processing! Use AreaLightTextureTools to pre-process the texture).\n     */\n    set emissionTexture(value) {\n        if (this._emissionTextureTexture === value) {\n            return;\n        }\n        this._emissionTextureTexture = value;\n        if (this._emissionTextureTexture) {\n            this._emissionTextureTexture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n            this._emissionTextureTexture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n        }\n        if (this._emissionTextureTexture && RectAreaLight._IsTexture(this._emissionTextureTexture)) {\n            this._emissionTextureTexture.onLoadObservable.addOnce(() => {\n                this._markMeshesAsLightDirty();\n            });\n        }\n    }\n    /**\n     * Rect Area Light width.\n     */\n    get width() {\n        return this._width.x;\n    }\n    /**\n     * Rect Area Light width.\n     */\n    set width(value) {\n        this._width.x = value;\n    }\n    /**\n     * Rect Area Light height.\n     */\n    get height() {\n        return this._height.y;\n    }\n    /**\n     * Rect Area Light height.\n     */\n    set height(value) {\n        this._height.y = value;\n    }\n    /**\n     * Creates a rectangular area light object.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The friendly name of the light\n     * @param position The position of the area light.\n     * @param width The width of the area light.\n     * @param height The height of the area light.\n     * @param scene The scene the light belongs to\n     * @param dontAddToScene True to not add the light to the scene\n     */\n    constructor(name, position, width, height, scene, dontAddToScene) {\n        super(name, position, scene, dontAddToScene);\n        this._emissionTextureTexture = null;\n        this._width = new Vector3(width, 0, 0);\n        this._height = new Vector3(0, height, 0);\n        this._pointTransformedPosition = Vector3.Zero();\n        this._pointTransformedWidth = Vector3.Zero();\n        this._pointTransformedHeight = Vector3.Zero();\n    }\n    /**\n     * Returns the string \"RectAreaLight\"\n     * @returns the class name\n     */\n    getClassName() {\n        return \"RectAreaLight\";\n    }\n    /**\n     * Returns the integer 4.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    getTypeID() {\n        return Light.LIGHTTYPEID_RECT_AREALIGHT;\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightWidth\", 4);\n        this._uniformBuffer.addUniform(\"vLightHeight\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    _computeTransformedInformation() {\n        if (this.parent && this.parent.getWorldMatrix) {\n            Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this._pointTransformedPosition);\n            Vector3.TransformNormalToRef(this._width, this.parent.getWorldMatrix(), this._pointTransformedWidth);\n            Vector3.TransformNormalToRef(this._height, this.parent.getWorldMatrix(), this._pointTransformedHeight);\n            return true;\n        }\n        return false;\n    }\n    static _IsTexture(texture) {\n        return texture.onLoadObservable !== undefined;\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the PointLight transformed position (or position, if none) and passed name (string).\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The point light\n     */\n    transferToEffect(effect, lightIndex) {\n        const offset = this._scene.floatingOriginOffset;\n        if (this._computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this._pointTransformedPosition.x - offset.x, this._pointTransformedPosition.y - offset.y, this._pointTransformedPosition.z - offset.z, 0, lightIndex);\n            this._uniformBuffer.updateFloat4(\"vLightWidth\", this._pointTransformedWidth.x / 2, this._pointTransformedWidth.y / 2, this._pointTransformedWidth.z / 2, 0, lightIndex);\n            this._uniformBuffer.updateFloat4(\"vLightHeight\", this._pointTransformedHeight.x / 2, this._pointTransformedHeight.y / 2, this._pointTransformedHeight.z / 2, 0, lightIndex);\n        }\n        else {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, 0, lightIndex);\n            this._uniformBuffer.updateFloat4(\"vLightWidth\", this._width.x / 2, this._width.y / 2, this._width.z / 2, 0.0, lightIndex);\n            this._uniformBuffer.updateFloat4(\"vLightHeight\", this._height.x / 2, this._height.y / 2, this._height.z / 2, 0.0, lightIndex);\n        }\n        return this;\n    }\n    transferTexturesToEffect(effect, lightIndex) {\n        super.transferTexturesToEffect(effect, lightIndex);\n        if (this._emissionTextureTexture && this._emissionTextureTexture.isReady()) {\n            effect.setTexture(\"rectAreaLightEmissionTexture\" + lightIndex, this._emissionTextureTexture);\n        }\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        const offset = this._scene.floatingOriginOffset;\n        if (this._computeTransformedInformation()) {\n            effect.setFloat3(lightDataUniformName, this._pointTransformedPosition.x - offset.x, this._pointTransformedPosition.y - offset.y, this._pointTransformedPosition.z - offset.z);\n        }\n        else {\n            effect.setFloat3(lightDataUniformName, this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z);\n        }\n        return this;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        super.prepareLightSpecificDefines(defines, lightIndex);\n        defines[\"RECTAREALIGHTEMISSIONTEXTURE\" + lightIndex] = this._emissionTextureTexture && this._emissionTextureTexture.isReady() ? true : false;\n    }\n}\n__decorate([\n    serialize()\n], RectAreaLight.prototype, \"width\", null);\n__decorate([\n    serialize()\n], RectAreaLight.prototype, \"height\", null);\n// Register Class Name\nRegisterClass(\"BABYLON.RectAreaLight\", RectAreaLight);\n//# sourceMappingURL=rectAreaLight.js.map","import { Vector3, Quaternion } from \"core/Maths/math.vector\";\nimport { Color3 } from \"core/Maths/math.color\";\nimport { Light } from \"core/Lights/light\";\nimport { RectAreaLight } from \"core/Lights/rectAreaLight\";\nimport { TransformNode as BabylonTransformNode } from \"core/Meshes/transformNode\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nconst NAME = \"EXT_lights_area\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_lights_area/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class EXT_lights_area {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        delete this._lights;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._lights = extension.lights;\n            ArrayItem.Assign(this._lights);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {\n            this._loader._allMaterialsDirtyRequired = true;\n            return await this._loader.loadNodeAsync(context, node, (babylonMesh) => {\n                let babylonLight;\n                const light = ArrayItem.Get(extensionContext, this._lights, extension.light);\n                const name = light.name || babylonMesh.name;\n                this._loader.babylonScene._blockEntityCollection = !!this._loader._assetContainer;\n                const size = light.size !== undefined ? light.size : 1.0;\n                switch (light.type) {\n                    case \"rect\" /* EXTLightsArea_LightType.RECT */: {\n                        const width = light.rect?.aspect !== undefined ? light.rect.aspect * size : size;\n                        const height = size;\n                        const babylonRectAreaLight = new RectAreaLight(name, Vector3.Zero(), width, height, this._loader.babylonScene);\n                        babylonLight = babylonRectAreaLight;\n                        break;\n                    }\n                    case \"disk\" /* EXTLightsArea_LightType.DISK */: {\n                        // For disk lights, we'll use a rectangle light with the same area to approximate the disk light\n                        // In the future, this could be extended to support actual disk area lights\n                        const newSize = Math.sqrt(size * size * 0.25 * Math.PI); // Area of the disk\n                        const babylonRectAreaLight = new RectAreaLight(name, Vector3.Zero(), newSize, newSize, this._loader.babylonScene);\n                        babylonLight = babylonRectAreaLight;\n                        break;\n                    }\n                    default: {\n                        this._loader.babylonScene._blockEntityCollection = false;\n                        throw new Error(`${extensionContext}: Invalid area light type (${light.type})`);\n                    }\n                }\n                babylonLight._parentContainer = this._loader._assetContainer;\n                this._loader.babylonScene._blockEntityCollection = false;\n                light._babylonLight = babylonLight;\n                babylonLight.falloffType = Light.FALLOFF_GLTF;\n                babylonLight.diffuse = light.color ? Color3.FromArray(light.color) : Color3.White();\n                babylonLight.intensity = light.intensity == undefined ? 1 : light.intensity;\n                // glTF EXT_lights_area specifies lights face down -Z, but Babylon.js area lights face down +Z\n                // Create a parent transform node with 180-degree rotation around Y axis to flip the direction\n                const lightParentNode = new BabylonTransformNode(`${name}_orientation`, this._loader.babylonScene);\n                lightParentNode.rotationQuaternion = Quaternion.RotationAxis(Vector3.Up(), Math.PI);\n                lightParentNode.parent = babylonMesh;\n                babylonLight.parent = lightParentNode;\n                this._loader._babylonLights.push(babylonLight);\n                GLTFLoader.AddPointerMetadata(babylonLight, extensionContext);\n                assign(babylonMesh);\n            });\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new EXT_lights_area(loader));\n//# sourceMappingURL=EXT_lights_area.js.map"],"names":["CreateSceneLTCTextures","scene","useDelayedTextureLoading","previousState","_blockEntityCollection","_ltcTextures","LTC1","RawTexture","CreateRGBATexture","getEngine","Constants","TEXTURE_LINEAR_LINEAR","TEXTURETYPE_HALF_FLOAT","LTC2","wrapU","Texture","CLAMP_ADDRESSMODE","wrapV","async","ltc1","Uint16Array","ltc2","file","Tools","LoadFileAsync","GetAssetUrl","ltcEncoded","pixelCount","length","pixelIndex","DecodeLTCTextureDataAsync","then","textureData","update","onDisposeObservable","addOnce","dispose","catch","error","Logger","Error","AreaLight","Light","constructor","name","position","dontAddToScene","super","this","_scene","transferTexturesToEffect","effect","lightIndex","setTexture","prepareLightSpecificDefines","defines","_isReady","isReady","Node","AddNodeConstructor","RectAreaLight","Vector3","Zero","emissionTexture","_emissionTextureTexture","value","TEXTURE_CLAMP_ADDRESSMODE","_IsTexture","onLoadObservable","_markMeshesAsLightDirty","width","_width","x","height","_height","y","_pointTransformedPosition","_pointTransformedWidth","_pointTransformedHeight","getClassName","getTypeID","LIGHTTYPEID_RECT_AREALIGHT","_buildUniformLayout","_uniformBuffer","addUniform","create","_computeTransformedInformation","parent","getWorldMatrix","TransformCoordinatesToRef","TransformNormalToRef","texture","undefined","transferToEffect","offset","floatingOriginOffset","updateFloat4","z","transferToNodeMaterialEffect","lightDataUniformName","setFloat3","__decorate","serialize","prototype","RegisterClass","NAME","EXT_lights_area","loader","_loader","enabled","isExtensionUsed","_lights","onLoading","extensions","gltf","extension","lights","ArrayItem","Assign","loadNodeAsync","context","node","assign","GLTFLoader","LoadExtensionAsync","extensionContext","_allMaterialsDirtyRequired","babylonMesh","babylonLight","light","Get","babylonScene","_assetContainer","size","type","rect","aspect","newSize","Math","sqrt","PI","_parentContainer","_babylonLight","falloffType","FALLOFF_GLTF","diffuse","color","Color3","FromArray","White","intensity","lightParentNode","BabylonTransformNode","rotationQuaternion","Quaternion","RotationAxis","Up","_babylonLights","push","AddPointerMetadata","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}