{"version":3,"file":"MSFT_audio_emitter-QiYvbJNH.esm.min.js","sources":["../../../../../dev/core/dist/Animations/animationEvent.js","../../../../../dev/core/dist/Audio/sound.js","../../../../../dev/core/dist/Audio/weightedsound.js","../../../../../dev/core/dist/Audio/soundTrack.js","../../../../../dev/core/dist/Audio/audioSceneComponent.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/MSFT_audio_emitter.js"],"sourcesContent":["/**\n * Composed of a frame, and an action function\n */\nexport class AnimationEvent {\n    /**\n     * Initializes the animation event\n     * @param frame The frame for which the event is triggered\n     * @param action The event to perform when triggered\n     * @param onlyOnce Specifies if the event should be triggered only once\n     */\n    constructor(\n    /** The frame for which the event is triggered **/\n    frame, \n    /** The event to perform when triggered **/\n    action, \n    /** Specifies if the event should be triggered only once**/\n    onlyOnce) {\n        this.frame = frame;\n        this.action = action;\n        this.onlyOnce = onlyOnce;\n        /**\n         * Specifies if the animation event is done\n         */\n        this.isDone = false;\n    }\n    /** @internal */\n    _clone() {\n        return new AnimationEvent(this.frame, this.action, this.onlyOnce);\n    }\n}\n//# sourceMappingURL=animationEvent.js.map","import { _HasSpatialAudioOptions, _SpatialAudioDefaults } from \"../AudioV2/abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _WebAudioSoundSource } from \"../AudioV2/webAudio/webAudioSoundSource\";\nimport { _WebAudioStaticSound } from \"../AudioV2/webAudio/webAudioStaticSound\";\nimport { _WebAudioStreamingSound } from \"../AudioV2/webAudio/webAudioStreamingSound\";\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Vector3 } from \"../Maths/math.vector\";\nimport { _WarnImport } from \"../Misc/devTools\";\nimport { Logger } from \"../Misc/logger\";\nimport { Observable } from \"../Misc/observable\";\nimport { _RetryWithInterval } from \"../Misc/timingTools\";\nimport { RegisterClass } from \"../Misc/typeStore\";\nconst TmpRampOptions = {\n    duration: 0,\n    shape: \"linear\" /* AudioParameterRampShape.Linear */,\n};\nconst TmpPlayOptions = {\n    duration: 0,\n    startOffset: 0,\n    waitTime: 0,\n};\nconst TmpStopOptions = {\n    waitTime: 0,\n};\nfunction D2r(degrees) {\n    return (degrees * Math.PI) / 180;\n}\nfunction R2d(radians) {\n    return (radians * 180) / Math.PI;\n}\n/**\n * Defines a sound that can be played in the application.\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\n * @see https://doc.babylonjs.com/legacy/audio\n */\nexport class Sound {\n    /**\n     * The name of the sound in the scene.\n     */\n    get name() {\n        return this._soundV2.name;\n    }\n    set name(value) {\n        this._soundV2.name = value;\n    }\n    /**\n     * Does the sound autoplay once loaded.\n     */\n    get autoplay() {\n        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._optionsV2.autoplay;\n    }\n    set autoplay(value) {\n        this._optionsV2.autoplay = value;\n    }\n    /**\n     * Does the sound loop after it finishes playing once.\n     */\n    get loop() {\n        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._soundV2.loop;\n    }\n    set loop(value) {\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\n            return;\n        }\n        if (this._soundV2) {\n            this._soundV2.loop = value;\n        }\n    }\n    /**\n     * Is this sound currently played.\n     */\n    get isPlaying() {\n        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._soundV2?.state === 3 /* SoundState.Started */ || (!this.isReady() && this._optionsV2.autoplay);\n    }\n    /**\n     * Is this sound currently paused.\n     */\n    get isPaused() {\n        return this._soundV2 instanceof _WebAudioSoundSource ? false : this._soundV2.state === 5 /* SoundState.Paused */;\n    }\n    /**\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\n     */\n    get maxDistance() {\n        return this._optionsV2.spatialMaxDistance || 100;\n    }\n    set maxDistance(value) {\n        this._optionsV2.spatialMaxDistance = value;\n        if (this.useCustomAttenuation) {\n            return;\n        }\n        if (this._soundV2) {\n            this._initSpatial();\n            this._soundV2.spatial.maxDistance = value;\n        }\n    }\n    /**\n     * Define the distance attenuation model the sound will follow.\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\n     */\n    get distanceModel() {\n        return this._optionsV2.spatialDistanceModel || \"linear\";\n    }\n    set distanceModel(value) {\n        this._optionsV2.spatialDistanceModel = value;\n        if (this._soundV2) {\n            this._initSpatial();\n            this._soundV2.spatial.distanceModel = value;\n        }\n    }\n    /**\n     * Gets the current time for the sound.\n     */\n    get currentTime() {\n        return this._soundV2 instanceof _WebAudioSoundSource ? this._soundV2.engine.currentTime : this._soundV2.currentTime;\n    }\n    /**\n     * Does this sound enables spatial sound.\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\n     */\n    get spatialSound() {\n        return this._soundV2?._isSpatial ?? false;\n    }\n    /**\n     * Does this sound enables spatial sound.\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\n     */\n    set spatialSound(newValue) {\n        if (this._soundV2) {\n            if (newValue) {\n                this._initSpatial();\n            }\n            else {\n                this._soundV2._isSpatial = false;\n            }\n        }\n    }\n    get _onReady() {\n        if (!this._onReadyObservable) {\n            this._onReadyObservable = new Observable();\n        }\n        return this._onReadyObservable;\n    }\n    /**\n     * Create a sound and attach it to a scene\n     * @param name Name of your sound\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\n     * @param scene defines the scene the sound belongs to\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\n     */\n    constructor(name, urlOrArrayBuffer, scene, readyToPlayCallback = null, options) {\n        /**\n         * Does the sound use a custom attenuation curve to simulate the falloff\n         * happening when the source gets further away from the camera.\n         * @see https://doc.babylonjs.com/legacy/audio#creating-your-own-custom-attenuation-function\n         */\n        this.useCustomAttenuation = false;\n        /**\n         * The sound track id this sound belongs to.\n         */\n        this.soundTrackId = -1;\n        /**\n         * Define the reference distance the sound should be heard perfectly.\n         * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\n         */\n        this.refDistance = 1;\n        /**\n         * Define the roll off factor of spatial sounds.\n         * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\n         */\n        this.rolloffFactor = 1;\n        /**\n         * Gets or sets an object used to store user defined information for the sound.\n         */\n        this.metadata = null;\n        /**\n         * Observable event when the current playing sound finishes.\n         */\n        this.onEndedObservable = new Observable();\n        this._localDirection = new Vector3(1, 0, 0);\n        this._volume = 1;\n        this._isReadyToPlay = false;\n        this._isDirectional = false;\n        this._isOutputConnected = false;\n        this._url = null;\n        this._onReadyObservable = null;\n        this._onReadyToPlay = () => {\n            this._scene.mainSoundTrack.addSound(this);\n            this._isReadyToPlay = true;\n            this._readyToPlayCallback();\n            if (this._onReadyObservable) {\n                this._onReadyObservable.notifyObservers();\n            }\n            if (this._optionsV2.autoplay) {\n                this.play();\n            }\n        };\n        this._onended = () => {\n            if (this.onended) {\n                this.onended();\n            }\n            this.onEndedObservable.notifyObservers(this);\n        };\n        scene = scene || EngineStore.LastCreatedScene;\n        if (!scene) {\n            return;\n        }\n        this._scene = scene;\n        Sound._SceneComponentInitialization(scene);\n        this._readyToPlayCallback = readyToPlayCallback || (() => { });\n        // Default custom attenuation function is a linear attenuation\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        this._customAttenuationFunction = (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) => {\n            if (currentDistance < maxDistance) {\n                return currentVolume * (1 - currentDistance / maxDistance);\n            }\n            else {\n                return 0;\n            }\n        };\n        options = options || {};\n        const optionsV2 = {\n            analyzerEnabled: false,\n            autoplay: false, // `false` for now, but will be set to given option later\n            duration: options.length || 0,\n            loop: options.loop || false,\n            loopEnd: 0,\n            loopStart: 0,\n            outBus: null,\n            outBusAutoDefault: false,\n            playbackRate: options.playbackRate || 1,\n            pitch: 0,\n            skipCodecCheck: options.skipCodecCheck || false,\n            spatialDistanceModel: options.distanceModel,\n            spatialEnabled: options.spatialSound,\n            spatialMaxDistance: options.maxDistance,\n            spatialMinDistance: options.refDistance,\n            spatialRolloffFactor: options.rolloffFactor,\n            stereoEnabled: false,\n            startOffset: options.offset || 0,\n            volume: options.volume ?? 1,\n        };\n        this._volume = options.volume ?? 1;\n        if (_HasSpatialAudioOptions(optionsV2)) {\n            optionsV2.spatialAutoUpdate = false;\n            optionsV2.spatialConeInnerAngle = _SpatialAudioDefaults.coneInnerAngle;\n            optionsV2.spatialConeOuterAngle = _SpatialAudioDefaults.coneOuterAngle;\n            optionsV2.spatialConeOuterVolume = _SpatialAudioDefaults.coneOuterVolume;\n            optionsV2.spatialMinUpdateTime = 0;\n            optionsV2.spatialOrientation = _SpatialAudioDefaults.orientation.clone();\n            optionsV2.spatialPanningModel = (this._scene.headphone ? \"HRTF\" : \"equalpower\");\n            optionsV2.spatialPosition = _SpatialAudioDefaults.position.clone();\n            optionsV2.spatialRotation = _SpatialAudioDefaults.rotation.clone();\n            optionsV2.spatialRotationQuaternion = _SpatialAudioDefaults.rotationQuaternion.clone();\n            if (optionsV2.spatialMaxDistance === undefined) {\n                optionsV2.spatialMaxDistance = 100;\n            }\n        }\n        this._optionsV2 = { ...optionsV2 };\n        this._optionsV2.autoplay = options.autoplay || false;\n        this.useCustomAttenuation = options.useCustomAttenuation ?? false;\n        if (this.useCustomAttenuation) {\n            optionsV2.spatialMaxDistance = Number.MAX_VALUE;\n            optionsV2.volume = 0;\n        }\n        let streaming = options?.streaming || false;\n        const audioEngine = AbstractEngine.audioEngine;\n        if (!audioEngine) {\n            return;\n        }\n        const audioEngineV2 = AbstractEngine.audioEngine._v2;\n        const createSoundV2 = () => {\n            if (streaming) {\n                const streamingOptionsV2 = {\n                    preloadCount: 0,\n                    ...optionsV2,\n                };\n                const sound = new _WebAudioStreamingSound(name, audioEngineV2, streamingOptionsV2);\n                // eslint-disable-next-line github/no-then\n                void sound._initAsync(urlOrArrayBuffer, optionsV2).then(() => {\n                    // eslint-disable-next-line github/no-then\n                    void sound.preloadInstancesAsync(1).then(this._onReadyToPlay);\n                });\n                return sound;\n            }\n            else {\n                const sound = new _WebAudioStaticSound(name, audioEngineV2, optionsV2);\n                // eslint-disable-next-line github/no-then\n                void sound._initAsync(urlOrArrayBuffer, optionsV2).then(this._onReadyToPlay);\n                return sound;\n            }\n        };\n        // If no parameter is passed then the setAudioBuffer should be called to prepare the sound.\n        if (!urlOrArrayBuffer) {\n            // Create the sound but don't call _initAsync on it, yet. Call it later when `setAudioBuffer` is called.\n            this._soundV2 = new _WebAudioStaticSound(name, audioEngineV2, optionsV2);\n        }\n        else if (typeof urlOrArrayBuffer === \"string\") {\n            this._url = urlOrArrayBuffer;\n            this._soundV2 = createSoundV2();\n        }\n        else if (urlOrArrayBuffer instanceof ArrayBuffer) {\n            streaming = false;\n            this._soundV2 = createSoundV2();\n        }\n        else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\n            streaming = true;\n            this._soundV2 = createSoundV2();\n        }\n        else if (urlOrArrayBuffer instanceof MediaStream) {\n            const node = new MediaStreamAudioSourceNode(audioEngineV2._audioContext, { mediaStream: urlOrArrayBuffer });\n            this._soundV2 = new _WebAudioSoundSource(name, node, audioEngineV2, optionsV2);\n            // eslint-disable-next-line github/no-then\n            void this._soundV2._initAsync(optionsV2).then(this._onReadyToPlay);\n        }\n        else if (urlOrArrayBuffer instanceof AudioBuffer) {\n            streaming = false;\n            this._soundV2 = createSoundV2();\n        }\n        else if (Array.isArray(urlOrArrayBuffer)) {\n            this._soundV2 = createSoundV2();\n        }\n        if (!this._soundV2) {\n            Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\n            return;\n        }\n        if (!(this._soundV2 instanceof _WebAudioSoundSource)) {\n            this._soundV2.onEndedObservable.add(this._onended);\n        }\n    }\n    /**\n     * Release the sound and its associated resources\n     */\n    dispose() {\n        if (this.isPlaying) {\n            this.stop();\n        }\n        this._isReadyToPlay = false;\n        if (this.soundTrackId === -1) {\n            this._scene.mainSoundTrack.removeSound(this);\n        }\n        else if (this._scene.soundTracks) {\n            this._scene.soundTracks[this.soundTrackId].removeSound(this);\n        }\n        if (this._connectedTransformNode && this._registerFunc) {\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n            this._connectedTransformNode = null;\n        }\n        this._soundV2.dispose();\n    }\n    /**\n     * Gets if the sounds is ready to be played or not.\n     * @returns true if ready, otherwise false\n     */\n    isReady() {\n        return this._isReadyToPlay;\n    }\n    /**\n     * Get the current class name.\n     * @returns current class name\n     */\n    getClassName() {\n        return \"Sound\";\n    }\n    /**\n     * Sets the data of the sound from an audiobuffer\n     * @param audioBuffer The audioBuffer containing the data\n     */\n    setAudioBuffer(audioBuffer) {\n        if (this._isReadyToPlay) {\n            return;\n        }\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n            this._soundV2._initAsync(audioBuffer, this._optionsV2).then(this._onReadyToPlay);\n        }\n    }\n    /**\n     * Updates the current sounds options such as maxdistance, loop...\n     * @param options A JSON object containing values named as the object properties\n     */\n    updateOptions(options) {\n        if (options) {\n            this.loop = options.loop ?? this.loop;\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\n            this.refDistance = options.refDistance ?? this.refDistance;\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\n            if (options.playbackRate !== undefined) {\n                this.setPlaybackRate(options.playbackRate);\n            }\n            if (options.spatialSound !== undefined) {\n                this.spatialSound = options.spatialSound;\n            }\n            if (options.volume !== undefined) {\n                this.setVolume(options.volume);\n            }\n            if (this._soundV2 instanceof _WebAudioStaticSound) {\n                let updated = false;\n                if (options.offset !== undefined) {\n                    this._optionsV2.startOffset = options.offset;\n                    updated = true;\n                }\n                if (options.length !== undefined) {\n                    this._soundV2.duration = options.length;\n                    updated = true;\n                }\n                if (updated && this.isPaused) {\n                    this.stop();\n                }\n            }\n            this._updateSpatialParameters();\n        }\n    }\n    _updateSpatialParameters() {\n        if (!this.spatialSound) {\n            return;\n        }\n        const spatial = this._soundV2.spatial;\n        if (this.useCustomAttenuation) {\n            // Disable WebAudio attenuation.\n            spatial.distanceModel = \"linear\";\n            spatial.minDistance = 1;\n            spatial.maxDistance = Number.MAX_VALUE;\n            spatial.rolloffFactor = 1;\n            spatial.panningModel = \"equalpower\";\n        }\n        else {\n            spatial.distanceModel = this.distanceModel;\n            spatial.minDistance = this.refDistance;\n            spatial.maxDistance = this.maxDistance;\n            spatial.rolloffFactor = this.rolloffFactor;\n            spatial.panningModel = this._optionsV2.spatialPanningModel || \"equalpower\";\n        }\n    }\n    /**\n     * Switch the panning model to HRTF:\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\n     */\n    switchPanningModelToHRTF() {\n        if (this.spatialSound) {\n            this._initSpatial();\n            this._soundV2.spatial.panningModel = \"HRTF\";\n        }\n    }\n    /**\n     * Switch the panning model to Equal Power:\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\n     */\n    switchPanningModelToEqualPower() {\n        if (this.spatialSound) {\n            this._initSpatial();\n            this._soundV2.spatial.panningModel = \"equalpower\";\n        }\n    }\n    /**\n     * Connect this sound to a sound track audio node like gain...\n     * @param soundTrackAudioNode the sound track audio node to connect to\n     */\n    connectToSoundTrackAudioNode(soundTrackAudioNode) {\n        const outputNode = this._soundV2._outNode;\n        if (outputNode) {\n            if (this._isOutputConnected) {\n                outputNode.disconnect();\n            }\n            outputNode.connect(soundTrackAudioNode);\n            this._isOutputConnected = true;\n        }\n    }\n    /**\n     * Transform this sound into a directional source\n     * @param coneInnerAngle Size of the inner cone in degree\n     * @param coneOuterAngle Size of the outer cone in degree\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\n     */\n    setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {\n        if (coneOuterAngle < coneInnerAngle) {\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\n            return;\n        }\n        this._optionsV2.spatialConeInnerAngle = D2r(coneInnerAngle);\n        this._optionsV2.spatialConeOuterAngle = D2r(coneOuterAngle);\n        this._optionsV2.spatialConeOuterVolume = coneOuterGain;\n        this._initSpatial();\n        this._soundV2.spatial.coneInnerAngle = this._optionsV2.spatialConeInnerAngle;\n        this._soundV2.spatial.coneOuterAngle = this._optionsV2.spatialConeOuterAngle;\n        this._soundV2.spatial.coneOuterVolume = coneOuterGain;\n        this._isDirectional = true;\n        if (this.isPlaying && this.loop) {\n            this.stop();\n            this.play(0, this._optionsV2.startOffset, this._optionsV2.duration);\n        }\n    }\n    /**\n     * Gets or sets the inner angle for the directional cone.\n     */\n    get directionalConeInnerAngle() {\n        return R2d(typeof this._optionsV2.spatialConeInnerAngle === \"number\" ? this._optionsV2.spatialConeInnerAngle : _SpatialAudioDefaults.coneInnerAngle);\n    }\n    /**\n     * Gets or sets the inner angle for the directional cone.\n     */\n    set directionalConeInnerAngle(value) {\n        value = D2r(value);\n        if (value != this._optionsV2.spatialConeInnerAngle) {\n            if (this.directionalConeOuterAngle < value) {\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._optionsV2.spatialConeInnerAngle = value;\n            if (this.spatialSound) {\n                this._initSpatial();\n                this._soundV2.spatial.coneInnerAngle = value;\n            }\n        }\n    }\n    /**\n     * Gets or sets the outer angle for the directional cone.\n     */\n    get directionalConeOuterAngle() {\n        return R2d(typeof this._optionsV2.spatialConeOuterAngle === \"number\" ? this._optionsV2.spatialConeOuterAngle : _SpatialAudioDefaults.coneOuterAngle);\n    }\n    /**\n     * Gets or sets the outer angle for the directional cone.\n     */\n    set directionalConeOuterAngle(value) {\n        value = D2r(value);\n        if (value != this._optionsV2.spatialConeOuterAngle) {\n            if (value < this.directionalConeInnerAngle) {\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._optionsV2.spatialConeOuterAngle = value;\n            if (this.spatialSound) {\n                this._initSpatial();\n                this._soundV2.spatial.coneOuterAngle = value;\n            }\n        }\n    }\n    /**\n     * Sets the position of the emitter if spatial sound is enabled\n     * @param newPosition Defines the new position\n     */\n    setPosition(newPosition) {\n        if (this._optionsV2.spatialPosition && newPosition.equals(this._optionsV2.spatialPosition)) {\n            return;\n        }\n        if (!this._optionsV2.spatialPosition) {\n            this._optionsV2.spatialPosition = Vector3.Zero();\n        }\n        this._optionsV2.spatialPosition.copyFrom(newPosition);\n        if (this.spatialSound && !isNaN(newPosition.x) && !isNaN(newPosition.y) && !isNaN(newPosition.z)) {\n            this._initSpatial();\n            this._soundV2.spatial.position = newPosition;\n        }\n    }\n    /**\n     * Sets the local direction of the emitter if spatial sound is enabled\n     * @param newLocalDirection Defines the new local direction\n     */\n    setLocalDirectionToMesh(newLocalDirection) {\n        this._localDirection = newLocalDirection;\n        if (this._connectedTransformNode && this.isPlaying) {\n            this._updateDirection();\n        }\n    }\n    _updateDirection() {\n        if (!this._connectedTransformNode || !this.spatialSound) {\n            return;\n        }\n        const mat = this._connectedTransformNode.getWorldMatrix();\n        const direction = Vector3.TransformNormal(this._localDirection, mat);\n        direction.normalize();\n        this._initSpatial();\n        this._soundV2.spatial.orientation = direction;\n    }\n    _initSpatial() {\n        this._soundV2._isSpatial = true;\n        if (this._optionsV2.spatialDistanceModel === undefined) {\n            this._optionsV2.spatialDistanceModel = \"linear\";\n            this._soundV2.spatial.distanceModel = \"linear\";\n        }\n        if (this._optionsV2.spatialMaxDistance === undefined) {\n            this._optionsV2.spatialMaxDistance = 100;\n            this._soundV2.spatial.maxDistance = 100;\n        }\n    }\n    /** @internal */\n    updateDistanceFromListener() {\n        if (this._soundV2._outNode && this._connectedTransformNode && this.useCustomAttenuation && this._scene.activeCamera) {\n            const distance = this._scene.audioListenerPositionProvider\n                ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length()\n                : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\n            this._soundV2.volume = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\n        }\n    }\n    /**\n     * Sets a new custom attenuation function for the sound.\n     * @param callback Defines the function used for the attenuation\n     * @see https://doc.babylonjs.com/legacy/audio#creating-your-own-custom-attenuation-function\n     */\n    setAttenuationFunction(callback) {\n        this._customAttenuationFunction = callback;\n    }\n    /**\n     * Play the sound\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\n     * @param offset (optional) Start the sound at a specific time in seconds\n     * @param length (optional) Sound duration (in seconds)\n     */\n    play(time, offset, length) {\n        const audioEngine = AbstractEngine.audioEngine;\n        audioEngine?.unlock();\n        // WebAudio sound sources have no `play` function because they are always playing.\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\n            return;\n        }\n        if (this._isReadyToPlay && this._scene.audioEnabled) {\n            // The sound can only resume from pause when the `time`, `offset` and `length` args are not set.\n            if (this._soundV2.state === 5 /* SoundState.Paused */ && (time !== undefined || offset !== undefined || length !== undefined)) {\n                this._soundV2.stop();\n            }\n            try {\n                TmpPlayOptions.duration = length || 0;\n                TmpPlayOptions.startOffset = offset !== undefined ? offset || this._optionsV2.startOffset : this._optionsV2.startOffset;\n                TmpPlayOptions.waitTime = time || 0;\n                TmpPlayOptions.loop = undefined;\n                TmpPlayOptions.loopStart = undefined;\n                TmpPlayOptions.loopEnd = undefined;\n                TmpPlayOptions.volume = undefined;\n                if (audioEngine?.unlocked) {\n                    this._soundV2.play(TmpPlayOptions);\n                }\n                else {\n                    // Wait a bit for FF as context seems late to be ready.\n                    setTimeout(() => {\n                        this._soundV2.play(TmpPlayOptions);\n                    }, 500);\n                }\n            }\n            catch (ex) {\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\n            }\n        }\n    }\n    /**\n     * Stop the sound\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\n     */\n    stop(time) {\n        if (!this._soundV2) {\n            return;\n        }\n        // WebAudio sound sources have no `stop` function because they are always playing.\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\n            return;\n        }\n        TmpStopOptions.waitTime = time || 0;\n        this._soundV2.stop(TmpStopOptions);\n    }\n    /**\n     * Put the sound in pause\n     */\n    pause() {\n        if (!this._soundV2) {\n            return;\n        }\n        // WebAudio sound sources have no `pause` function because they are always playing.\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\n            return;\n        }\n        this._soundV2.pause();\n    }\n    /**\n     * Sets a dedicated volume for this sounds\n     * @param newVolume Define the new volume of the sound\n     * @param time Define time for gradual change to new volume\n     */\n    setVolume(newVolume, time) {\n        if (!this.isReady()) {\n            this._onReady.addOnce(() => {\n                this.setVolume(newVolume, time);\n            });\n            return;\n        }\n        TmpRampOptions.duration = time || 0;\n        this._soundV2.setVolume(newVolume, TmpRampOptions);\n        this._volume = newVolume;\n    }\n    /**\n     * Set the sound play back rate\n     * @param newPlaybackRate Define the playback rate the sound should be played at\n     */\n    setPlaybackRate(newPlaybackRate) {\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\n            this._soundV2.playbackRate = newPlaybackRate;\n        }\n    }\n    /**\n     * Gets the sound play back rate.\n     * @returns the  play back rate of the sound\n     */\n    getPlaybackRate() {\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\n            return this._soundV2.playbackRate;\n        }\n        return 1;\n    }\n    /**\n     * Gets the volume of the sound.\n     * @returns the volume of the sound\n     */\n    getVolume() {\n        return this._volume;\n    }\n    /**\n     * Attach the sound to a dedicated mesh\n     * @param transformNode The transform node to connect the sound with\n     * @see https://doc.babylonjs.com/legacy/audio#attaching-a-sound-to-a-mesh\n     */\n    attachToMesh(transformNode) {\n        if (this._connectedTransformNode && this._registerFunc) {\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n            this._registerFunc = null;\n        }\n        this._connectedTransformNode = transformNode;\n        if (!this.spatialSound) {\n            this.spatialSound = true;\n            if (this.isPlaying && this.loop) {\n                this.stop();\n                this.play(0, this._optionsV2.startOffset, this._optionsV2.duration);\n            }\n        }\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\n        this._registerFunc = (transformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\n    }\n    /**\n     * Detach the sound from the previously attached mesh\n     * @see https://doc.babylonjs.com/legacy/audio#attaching-a-sound-to-a-mesh\n     */\n    detachFromMesh() {\n        if (this._connectedTransformNode && this._registerFunc) {\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\n            this._registerFunc = null;\n            this._connectedTransformNode = null;\n        }\n    }\n    _onRegisterAfterWorldMatrixUpdate(node) {\n        if (!node.getBoundingInfo) {\n            this.setPosition(node.absolutePosition);\n        }\n        else {\n            const mesh = node;\n            const boundingInfo = mesh.getBoundingInfo();\n            this.setPosition(boundingInfo.boundingSphere.centerWorld);\n        }\n        if (this._isDirectional && this.isPlaying) {\n            this._updateDirection();\n        }\n    }\n    /**\n     * Clone the current sound in the scene.\n     * @returns the new sound clone\n     */\n    clone() {\n        if (!(this._soundV2 instanceof _WebAudioStaticSound)) {\n            return null;\n        }\n        const currentOptions = {\n            autoplay: this.autoplay,\n            loop: this.loop,\n            volume: this._volume,\n            spatialSound: this.spatialSound,\n            maxDistance: this.maxDistance,\n            useCustomAttenuation: this.useCustomAttenuation,\n            rolloffFactor: this.rolloffFactor,\n            refDistance: this.refDistance,\n            distanceModel: this.distanceModel,\n        };\n        const clonedSound = new Sound(this.name + \"_cloned\", this._soundV2.buffer, this._scene, null, currentOptions);\n        clonedSound._optionsV2 = this._optionsV2;\n        if (this.useCustomAttenuation) {\n            clonedSound.setAttenuationFunction(this._customAttenuationFunction);\n        }\n        return clonedSound;\n    }\n    /**\n     * Gets the current underlying audio buffer containing the data\n     * @returns the audio buffer\n     */\n    getAudioBuffer() {\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\n            return this._soundV2.buffer._audioBuffer;\n        }\n        return null;\n    }\n    /**\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\n     * @returns the source node\n     */\n    getSoundSource() {\n        // return this._soundSource;\n        return null;\n    }\n    /**\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\n     * @returns the gain node\n     */\n    getSoundGain() {\n        return this._soundV2._outNode;\n    }\n    /**\n     * Serializes the Sound in a JSON representation\n     * @returns the JSON representation of the sound\n     */\n    serialize() {\n        const serializationObject = {\n            name: this.name,\n            url: this._url,\n            autoplay: this.autoplay,\n            loop: this.loop,\n            volume: this._volume,\n            spatialSound: this.spatialSound,\n            maxDistance: this.maxDistance,\n            rolloffFactor: this.rolloffFactor,\n            refDistance: this.refDistance,\n            distanceModel: this.distanceModel,\n            playbackRate: this.getPlaybackRate(),\n            panningModel: this._soundV2.spatial.panningModel,\n            soundTrackId: this.soundTrackId,\n            metadata: this.metadata,\n        };\n        if (this.spatialSound) {\n            if (this._connectedTransformNode) {\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\n            }\n            serializationObject.position = this._soundV2.spatial.position.asArray();\n            serializationObject.refDistance = this.refDistance;\n            serializationObject.distanceModel = this.distanceModel;\n            serializationObject.isDirectional = this._isDirectional;\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\n            serializationObject.coneInnerAngle = this.directionalConeInnerAngle;\n            serializationObject.coneOuterAngle = this.directionalConeOuterAngle;\n            serializationObject.coneOuterGain = this._soundV2.spatial.coneOuterVolume;\n        }\n        return serializationObject;\n    }\n    /**\n     * Parse a JSON representation of a sound to instantiate in a given scene\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\n     * @param scene Define the scene the new parsed sound should be created in\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\n     * @param sourceSound Define a sound place holder if do not need to instantiate a new one\n     * @returns the newly parsed sound\n     */\n    static Parse(parsedSound, scene, rootUrl, sourceSound) {\n        const soundName = parsedSound.name;\n        let soundUrl;\n        if (parsedSound.url) {\n            soundUrl = rootUrl + parsedSound.url;\n        }\n        else {\n            soundUrl = rootUrl + soundName;\n        }\n        const options = {\n            autoplay: parsedSound.autoplay,\n            loop: parsedSound.loop,\n            volume: parsedSound.volume,\n            spatialSound: parsedSound.spatialSound,\n            maxDistance: parsedSound.maxDistance,\n            rolloffFactor: parsedSound.rolloffFactor,\n            refDistance: parsedSound.refDistance,\n            distanceModel: parsedSound.distanceModel,\n            playbackRate: parsedSound.playbackRate,\n        };\n        let newSound;\n        if (!sourceSound) {\n            newSound = new Sound(soundName, soundUrl, scene, () => {\n                scene.removePendingData(newSound);\n            }, options);\n            scene.addPendingData(newSound);\n        }\n        else {\n            const setBufferAndRun = () => {\n                _RetryWithInterval(() => sourceSound._isReadyToPlay, () => {\n                    const audioBuffer = sourceSound.getAudioBuffer();\n                    if (audioBuffer) {\n                        newSound.setAudioBuffer(audioBuffer);\n                    }\n                    newSound._isReadyToPlay = true;\n                    if (newSound.autoplay) {\n                        newSound.play(0, sourceSound._optionsV2.startOffset, sourceSound._optionsV2.duration);\n                    }\n                }, undefined, 300);\n            };\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\n            setBufferAndRun();\n        }\n        if (parsedSound.position) {\n            const soundPosition = Vector3.FromArray(parsedSound.position);\n            newSound.setPosition(soundPosition);\n        }\n        if (parsedSound.isDirectional) {\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\n            if (parsedSound.localDirectionToMesh) {\n                const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\n            }\n        }\n        if (parsedSound.connectedMeshId) {\n            const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\n            if (connectedMesh) {\n                newSound.attachToMesh(connectedMesh);\n            }\n        }\n        if (parsedSound.metadata) {\n            newSound.metadata = parsedSound.metadata;\n        }\n        return newSound;\n    }\n}\n/**\n * @internal\n */\nSound._SceneComponentInitialization = (_) => {\n    throw _WarnImport(\"AudioSceneComponent\");\n};\n// Register Class Name\nRegisterClass(\"BABYLON.Sound\", Sound);\n//# sourceMappingURL=sound.js.map","import { Logger } from \"../Misc/logger\";\n/**\n * Wraps one or more Sound objects and selects one with random weight for playback.\n */\nexport class WeightedSound {\n    /**\n     * Creates a new WeightedSound from the list of sounds given.\n     * @param loop When true a Sound will be selected and played when the current playing Sound completes.\n     * @param sounds Array of Sounds that will be selected from.\n     * @param weights Array of number values for selection weights; length must equal sounds, values will be normalized to 1\n     */\n    constructor(loop, sounds, weights) {\n        /** When true a Sound will be selected and played when the current playing Sound completes. */\n        this.loop = false;\n        this._coneInnerAngle = 360;\n        this._coneOuterAngle = 360;\n        this._volume = 1;\n        /** A Sound is currently playing. */\n        this.isPlaying = false;\n        /** A Sound is currently paused. */\n        this.isPaused = false;\n        this._sounds = [];\n        this._weights = [];\n        if (sounds.length !== weights.length) {\n            throw new Error(\"Sounds length does not equal weights length\");\n        }\n        this.loop = loop;\n        this._weights = weights;\n        // Normalize the weights\n        let weightSum = 0;\n        for (const weight of weights) {\n            weightSum += weight;\n        }\n        const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;\n        for (let i = 0; i < this._weights.length; i++) {\n            this._weights[i] *= invWeightSum;\n        }\n        this._sounds = sounds;\n        for (const sound of this._sounds) {\n            sound.onEndedObservable.add(() => {\n                this._onended();\n            });\n        }\n    }\n    /**\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\n     */\n    get directionalConeInnerAngle() {\n        return this._coneInnerAngle;\n    }\n    /**\n     * The size of cone in degrees for a directional sound in which there will be no attenuation.\n     */\n    set directionalConeInnerAngle(value) {\n        if (value !== this._coneInnerAngle) {\n            if (this._coneOuterAngle < value) {\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._coneInnerAngle = value;\n            for (const sound of this._sounds) {\n                sound.directionalConeInnerAngle = value;\n            }\n        }\n    }\n    /**\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\n     */\n    get directionalConeOuterAngle() {\n        return this._coneOuterAngle;\n    }\n    /**\n     * Size of cone in degrees for a directional sound outside of which there will be no sound.\n     * Listener angles between innerAngle and outerAngle will falloff linearly.\n     */\n    set directionalConeOuterAngle(value) {\n        if (value !== this._coneOuterAngle) {\n            if (value < this._coneInnerAngle) {\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\n                return;\n            }\n            this._coneOuterAngle = value;\n            for (const sound of this._sounds) {\n                sound.directionalConeOuterAngle = value;\n            }\n        }\n    }\n    /**\n     * Playback volume.\n     */\n    get volume() {\n        return this._volume;\n    }\n    /**\n     * Playback volume.\n     */\n    set volume(value) {\n        if (value !== this._volume) {\n            for (const sound of this._sounds) {\n                sound.setVolume(value);\n            }\n        }\n    }\n    _onended() {\n        if (this._currentIndex !== undefined) {\n            this._sounds[this._currentIndex].autoplay = false;\n        }\n        if (this.loop && this.isPlaying) {\n            this.play();\n        }\n        else {\n            this.isPlaying = false;\n        }\n    }\n    /**\n     * Suspend playback\n     */\n    pause() {\n        if (this.isPlaying) {\n            this.isPaused = true;\n            if (this._currentIndex !== undefined) {\n                this._sounds[this._currentIndex].pause();\n            }\n        }\n    }\n    /**\n     * Stop playback\n     */\n    stop() {\n        this.isPlaying = false;\n        if (this._currentIndex !== undefined) {\n            this._sounds[this._currentIndex].stop();\n        }\n    }\n    /**\n     * Start playback.\n     * @param startOffset Position the clip head at a specific time in seconds.\n     */\n    play(startOffset) {\n        if (!this.isPaused) {\n            this.stop();\n            const randomValue = Math.random();\n            let total = 0;\n            for (let i = 0; i < this._weights.length; i++) {\n                total += this._weights[i];\n                if (randomValue <= total) {\n                    this._currentIndex = i;\n                    break;\n                }\n            }\n        }\n        const sound = this._sounds[this._currentIndex ?? 0];\n        if (sound.isReady()) {\n            sound.play(0, this.isPaused ? undefined : startOffset);\n        }\n        else {\n            sound.autoplay = true;\n        }\n        this.isPlaying = true;\n        this.isPaused = false;\n    }\n}\n//# sourceMappingURL=weightedsound.js.map","import { EngineStore } from \"../Engines/engineStore\";\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\n/**\n * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.\n * It will be also used in a future release to apply effects on a specific track.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\n */\nexport class SoundTrack {\n    /**\n     * Creates a new sound track.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\n     * @param scene Define the scene the sound track belongs to\n     * @param options\n     */\n    constructor(scene, options = {}) {\n        /**\n         * The unique identifier of the sound track in the scene.\n         */\n        this.id = -1;\n        this._isInitialized = false;\n        scene = scene || EngineStore.LastCreatedScene;\n        if (!scene) {\n            return;\n        }\n        this._scene = scene;\n        this.soundCollection = [];\n        this._options = options;\n        if (!this._options.mainTrack && this._scene.soundTracks) {\n            this._scene.soundTracks.push(this);\n            this.id = this._scene.soundTracks.length - 1;\n        }\n    }\n    _initializeSoundTrackAudioGraph() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\n            this._outputAudioNode = AbstractEngine.audioEngine.audioContext.createGain();\n            this._outputAudioNode.connect(AbstractEngine.audioEngine.masterGain);\n            if (this._options) {\n                if (this._options.volume) {\n                    this._outputAudioNode.gain.value = this._options.volume;\n                }\n            }\n            this._isInitialized = true;\n        }\n    }\n    /**\n     * Release the sound track and its associated resources\n     */\n    dispose() {\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.canUseWebAudio) {\n            if (this._connectedAnalyser) {\n                this._connectedAnalyser.stopDebugCanvas();\n            }\n            while (this.soundCollection.length) {\n                this.soundCollection[0].dispose();\n            }\n            if (this._outputAudioNode) {\n                this._outputAudioNode.disconnect();\n            }\n            this._outputAudioNode = null;\n        }\n    }\n    /**\n     * Adds a sound to this sound track\n     * @param sound define the sound to add\n     * @ignoreNaming\n     */\n    addSound(sound) {\n        if (!this._isInitialized) {\n            this._initializeSoundTrackAudioGraph();\n        }\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\n            sound.connectToSoundTrackAudioNode(this._outputAudioNode);\n        }\n        if (sound.soundTrackId !== undefined) {\n            if (sound.soundTrackId === -1) {\n                this._scene.mainSoundTrack.removeSound(sound);\n            }\n            else if (this._scene.soundTracks) {\n                this._scene.soundTracks[sound.soundTrackId].removeSound(sound);\n            }\n        }\n        this.soundCollection.push(sound);\n        sound.soundTrackId = this.id;\n    }\n    /**\n     * Removes a sound to this sound track\n     * @param sound define the sound to remove\n     * @ignoreNaming\n     */\n    removeSound(sound) {\n        const index = this.soundCollection.indexOf(sound);\n        if (index !== -1) {\n            this.soundCollection.splice(index, 1);\n        }\n    }\n    /**\n     * Set a global volume for the full sound track.\n     * @param newVolume Define the new volume of the sound track\n     */\n    setVolume(newVolume) {\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\n            this._outputAudioNode.gain.value = newVolume;\n        }\n    }\n    /**\n     * Switch the panning model to HRTF:\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    switchPanningModelToHRTF() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\n            for (let i = 0; i < this.soundCollection.length; i++) {\n                this.soundCollection[i].switchPanningModelToHRTF();\n            }\n        }\n    }\n    /**\n     * Switch the panning model to Equal Power:\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\n     */\n    switchPanningModelToEqualPower() {\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\n            for (let i = 0; i < this.soundCollection.length; i++) {\n                this.soundCollection[i].switchPanningModelToEqualPower();\n            }\n        }\n    }\n    /**\n     * Connect the sound track to an audio analyser allowing some amazing\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\n     * @param analyser The analyser to connect to the engine\n     */\n    connectToAnalyser(analyser) {\n        if (this._connectedAnalyser) {\n            this._connectedAnalyser.stopDebugCanvas();\n        }\n        this._connectedAnalyser = analyser;\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\n            this._outputAudioNode.disconnect();\n            this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, AbstractEngine.audioEngine.masterGain);\n        }\n    }\n}\n//# sourceMappingURL=soundTrack.js.map","import { Sound } from \"./sound\";\nimport { SoundTrack } from \"./soundTrack\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { SceneComponentConstants } from \"../sceneComponent\";\nimport { Scene } from \"../scene\";\nimport \"./audioEngine\";\nimport { PrecisionDate } from \"../Misc/precisionDate\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\n// Adds the parser to the scene parsers.\nAddParser(SceneComponentConstants.NAME_AUDIO, (parsedData, scene, container, rootUrl) => {\n    // TODO: add sound\n    let loadedSounds = [];\n    let loadedSound;\n    container.sounds = container.sounds || [];\n    if (parsedData.sounds !== undefined && parsedData.sounds !== null) {\n        for (let index = 0, cache = parsedData.sounds.length; index < cache; index++) {\n            const parsedSound = parsedData.sounds[index];\n            if (AbstractEngine.audioEngine?.canUseWebAudio) {\n                if (!parsedSound.url) {\n                    parsedSound.url = parsedSound.name;\n                }\n                if (!loadedSounds[parsedSound.url]) {\n                    loadedSound = Sound.Parse(parsedSound, scene, rootUrl);\n                    loadedSounds[parsedSound.url] = loadedSound;\n                    container.sounds.push(loadedSound);\n                }\n                else {\n                    container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));\n                }\n            }\n            else {\n                container.sounds.push(new Sound(parsedSound.name, null, scene));\n            }\n        }\n    }\n    loadedSounds = [];\n});\nObject.defineProperty(Scene.prototype, \"mainSoundTrack\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (!this._mainSoundTrack) {\n            this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });\n        }\n        return this._mainSoundTrack;\n    },\n    enumerable: true,\n    configurable: true,\n});\nScene.prototype.getSoundByName = function (name) {\n    let index;\n    for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {\n        if (this.mainSoundTrack.soundCollection[index].name === name) {\n            return this.mainSoundTrack.soundCollection[index];\n        }\n    }\n    if (this.soundTracks) {\n        for (let sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {\n            for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {\n                if (this.soundTracks[sdIndex].soundCollection[index].name === name) {\n                    return this.soundTracks[sdIndex].soundCollection[index];\n                }\n            }\n        }\n    }\n    return null;\n};\nObject.defineProperty(Scene.prototype, \"audioEnabled\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.audioEnabled;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (value) {\n            compo.enableAudio();\n        }\n        else {\n            compo.disableAudio();\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"headphone\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.headphone;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (value) {\n            compo.switchAudioModeForHeadphones();\n        }\n        else {\n            compo.switchAudioModeForNormalSpeakers();\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"audioListenerPositionProvider\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.audioListenerPositionProvider;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (value && typeof value !== \"function\") {\n            throw new Error(\"The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3\");\n        }\n        else {\n            compo.audioListenerPositionProvider = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"audioListenerRotationProvider\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.audioListenerRotationProvider;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        if (value && typeof value !== \"function\") {\n            throw new Error(\"The value passed to [Scene.audioListenerRotationProvider] must be a function that returns a Vector3\");\n        }\n        else {\n            compo.audioListenerRotationProvider = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nObject.defineProperty(Scene.prototype, \"audioPositioningRefreshRate\", {\n    get: function () {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        return compo.audioPositioningRefreshRate;\n    },\n    set: function (value) {\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO);\n        if (!compo) {\n            compo = new AudioSceneComponent(this);\n            this._addComponent(compo);\n        }\n        compo.audioPositioningRefreshRate = value;\n    },\n    enumerable: true,\n    configurable: true,\n});\n/**\n * Defines the sound scene component responsible to manage any sounds\n * in a given scene.\n * @deprecated please use AudioEngineV2 instead\n */\nexport class AudioSceneComponent {\n    /**\n     * Gets whether audio is enabled or not.\n     * Please use related enable/disable method to switch state.\n     */\n    get audioEnabled() {\n        return this._audioEnabled;\n    }\n    /**\n     * Gets whether audio is outputting to headphone or not.\n     * Please use the according Switch methods to change output.\n     */\n    get headphone() {\n        return this._headphone;\n    }\n    /**\n     * Creates a new instance of the component for the given scene\n     * @param scene Defines the scene to register the component in\n     */\n    constructor(scene) {\n        /**\n         * The component name helpful to identify the component in the list of scene components.\n         */\n        this.name = SceneComponentConstants.NAME_AUDIO;\n        this._audioEnabled = true;\n        this._headphone = false;\n        /**\n         * Gets or sets a refresh rate when using 3D audio positioning\n         */\n        this.audioPositioningRefreshRate = 500;\n        /**\n         * Gets or Sets a custom listener position for all sounds in the scene\n         * By default, this is the position of the first active camera\n         */\n        this.audioListenerPositionProvider = null;\n        /**\n         * Gets or Sets a custom listener rotation for all sounds in the scene\n         * By default, this is the rotation of the first active camera\n         */\n        this.audioListenerRotationProvider = null;\n        this._cachedCameraDirection = new Vector3();\n        this._cachedCameraPosition = new Vector3();\n        this._lastCheck = 0;\n        this._invertMatrixTemp = new Matrix();\n        this._cameraDirectionTemp = new Vector3();\n        scene = scene || EngineStore.LastCreatedScene;\n        if (!scene) {\n            return;\n        }\n        this.scene = scene;\n        scene.soundTracks = [];\n        scene.sounds = [];\n    }\n    /**\n     * Registers the component in a given scene\n     */\n    register() {\n        this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);\n    }\n    /**\n     * Rebuilds the elements related to this component in case of\n     * context lost for instance.\n     */\n    rebuild() {\n        // Nothing to do here. (Not rendering related)\n    }\n    /**\n     * Serializes the component data to the specified json object\n     * @param serializationObject The object to serialize to\n     */\n    serialize(serializationObject) {\n        serializationObject.sounds = [];\n        if (this.scene.soundTracks) {\n            for (let index = 0; index < this.scene.soundTracks.length; index++) {\n                const soundtrack = this.scene.soundTracks[index];\n                for (let soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {\n                    serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());\n                }\n            }\n        }\n    }\n    /**\n     * Adds all the elements from the container to the scene\n     * @param container the container holding the elements\n     */\n    addFromContainer(container) {\n        if (!container.sounds) {\n            return;\n        }\n        for (const sound of container.sounds) {\n            sound.play();\n            sound.autoplay = true;\n            this.scene.mainSoundTrack.addSound(sound);\n        }\n    }\n    /**\n     * Removes all the elements in the container from the scene\n     * @param container contains the elements to remove\n     * @param dispose if the removed element should be disposed (default: false)\n     */\n    removeFromContainer(container, dispose = false) {\n        if (!container.sounds) {\n            return;\n        }\n        for (const sound of container.sounds) {\n            sound.stop();\n            sound.autoplay = false;\n            this.scene.mainSoundTrack.removeSound(sound);\n            if (dispose) {\n                sound.dispose();\n            }\n        }\n    }\n    /**\n     * Disposes the component and the associated resources.\n     */\n    dispose() {\n        const scene = this.scene;\n        if (scene._mainSoundTrack) {\n            scene.mainSoundTrack.dispose();\n        }\n        if (scene.soundTracks) {\n            for (let scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {\n                scene.soundTracks[scIndex].dispose();\n            }\n        }\n    }\n    /**\n     * Disables audio in the associated scene.\n     */\n    disableAudio() {\n        const scene = this.scene;\n        this._audioEnabled = false;\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            AbstractEngine.audioEngine.audioContext.suspend();\n        }\n        let i;\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\n            scene.mainSoundTrack.soundCollection[i].pause();\n        }\n        if (scene.soundTracks) {\n            for (i = 0; i < scene.soundTracks.length; i++) {\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\n                    scene.soundTracks[i].soundCollection[j].pause();\n                }\n            }\n        }\n    }\n    /**\n     * Enables audio in the associated scene.\n     */\n    enableAudio() {\n        const scene = this.scene;\n        this._audioEnabled = true;\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\n            AbstractEngine.audioEngine.audioContext.resume();\n        }\n        let i;\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\n            if (scene.mainSoundTrack.soundCollection[i].isPaused) {\n                scene.mainSoundTrack.soundCollection[i].play();\n            }\n        }\n        if (scene.soundTracks) {\n            for (i = 0; i < scene.soundTracks.length; i++) {\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\n                    if (scene.soundTracks[i].soundCollection[j].isPaused) {\n                        scene.soundTracks[i].soundCollection[j].play();\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Switch audio to headphone output.\n     */\n    switchAudioModeForHeadphones() {\n        const scene = this.scene;\n        this._headphone = true;\n        scene.mainSoundTrack.switchPanningModelToHRTF();\n        if (scene.soundTracks) {\n            for (let i = 0; i < scene.soundTracks.length; i++) {\n                scene.soundTracks[i].switchPanningModelToHRTF();\n            }\n        }\n    }\n    /**\n     * Switch audio to normal speakers.\n     */\n    switchAudioModeForNormalSpeakers() {\n        const scene = this.scene;\n        this._headphone = false;\n        scene.mainSoundTrack.switchPanningModelToEqualPower();\n        if (scene.soundTracks) {\n            for (let i = 0; i < scene.soundTracks.length; i++) {\n                scene.soundTracks[i].switchPanningModelToEqualPower();\n            }\n        }\n    }\n    _afterRender() {\n        const now = PrecisionDate.Now;\n        if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {\n            return;\n        }\n        this._lastCheck = now;\n        const scene = this.scene;\n        if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || (scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1)) {\n            return;\n        }\n        const audioEngine = AbstractEngine.audioEngine;\n        if (!audioEngine) {\n            return;\n        }\n        if (audioEngine.audioContext) {\n            let listeningCamera = scene.activeCamera;\n            if (scene.activeCameras && scene.activeCameras.length > 0) {\n                listeningCamera = scene.activeCameras[0];\n            }\n            // A custom listener position provider was set\n            // Use the users provided position instead of camera's\n            if (this.audioListenerPositionProvider) {\n                const position = this.audioListenerPositionProvider();\n                // Set the listener position\n                audioEngine.audioContext.listener.setPosition(position.x || 0, position.y || 0, position.z || 0);\n                // Check if there is a listening camera\n            }\n            else if (listeningCamera) {\n                // Set the listener position to the listening camera global position\n                if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {\n                    this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);\n                    audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);\n                }\n            }\n            // Otherwise set the listener position to 0, 0 ,0\n            else {\n                // Set the listener position\n                audioEngine.audioContext.listener.setPosition(0, 0, 0);\n            }\n            // A custom listener rotation provider was set\n            // Use the users provided rotation instead of camera's\n            if (this.audioListenerRotationProvider) {\n                const rotation = this.audioListenerRotationProvider();\n                audioEngine.audioContext.listener.setOrientation(rotation.x || 0, rotation.y || 0, rotation.z || 0, 0, 1, 0);\n                // Check if there is a listening camera\n            }\n            else if (listeningCamera) {\n                // for VR cameras\n                if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {\n                    listeningCamera = listeningCamera.rigCameras[0];\n                }\n                listeningCamera.getViewMatrix().invertToRef(this._invertMatrixTemp);\n                Vector3.TransformNormalToRef(AudioSceneComponent._CameraDirection, this._invertMatrixTemp, this._cameraDirectionTemp);\n                this._cameraDirectionTemp.normalize();\n                // To avoid some errors on GearVR\n                if (!isNaN(this._cameraDirectionTemp.x) && !isNaN(this._cameraDirectionTemp.y) && !isNaN(this._cameraDirectionTemp.z)) {\n                    if (!this._cachedCameraDirection.equals(this._cameraDirectionTemp)) {\n                        this._cachedCameraDirection.copyFrom(this._cameraDirectionTemp);\n                        audioEngine.audioContext.listener.setOrientation(this._cameraDirectionTemp.x, this._cameraDirectionTemp.y, this._cameraDirectionTemp.z, 0, 1, 0);\n                    }\n                }\n            }\n            // Otherwise set the listener rotation to 0, 0 ,0\n            else {\n                // Set the listener position\n                audioEngine.audioContext.listener.setOrientation(0, 0, 0, 0, 1, 0);\n            }\n            let i;\n            for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\n                const sound = scene.mainSoundTrack.soundCollection[i];\n                if (sound.useCustomAttenuation) {\n                    sound.updateDistanceFromListener();\n                }\n            }\n            if (scene.soundTracks) {\n                for (i = 0; i < scene.soundTracks.length; i++) {\n                    for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\n                        const sound = scene.soundTracks[i].soundCollection[j];\n                        if (sound.useCustomAttenuation) {\n                            sound.updateDistanceFromListener();\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\nAudioSceneComponent._CameraDirection = new Vector3(0, 0, -1);\nSound._SceneComponentInitialization = (scene) => {\n    let compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);\n    if (!compo) {\n        compo = new AudioSceneComponent(scene);\n        scene._addComponent(compo);\n    }\n};\n//# sourceMappingURL=audioSceneComponent.js.map","import { Vector3 } from \"core/Maths/math.vector\";\nimport { Tools } from \"core/Misc/tools\";\nimport { AnimationEvent } from \"core/Animations/animationEvent\";\nimport { Sound } from \"core/Audio/sound\";\nimport { WeightedSound } from \"core/Audio/weightedsound\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nimport \"core/Audio/audioSceneComponent\";\nimport { GetBlobBufferSource } from \"core/Buffers/bufferUtils\";\nconst NAME = \"MSFT_audio_emitter\";\n/**\n * [Specification](https://github.com/najadojo/glTF/blob/MSFT_audio_emitter/extensions/2.0/Vendor/MSFT_audio_emitter/README.md)\n * !!! Experimental Extension Subject to Changes !!!\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_audio_emitter {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        this._loader = loader;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        this._clips = null;\n        this._emitters = null;\n    }\n    /** @internal */\n    onLoading() {\n        const extensions = this._loader.gltf.extensions;\n        if (extensions && extensions[this.name]) {\n            const extension = extensions[this.name];\n            this._clips = extension.clips;\n            this._emitters = extension.emitters;\n            ArrayItem.Assign(this._clips);\n            ArrayItem.Assign(this._emitters);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadSceneAsync(context, scene) {\n        return GLTFLoader.LoadExtensionAsync(context, scene, this.name, async (extensionContext, extension) => {\n            const promises = new Array();\n            promises.push(this._loader.loadSceneAsync(context, scene));\n            for (const emitterIndex of extension.emitters) {\n                const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                if (emitter.refDistance != undefined ||\n                    emitter.maxDistance != undefined ||\n                    emitter.rolloffFactor != undefined ||\n                    emitter.distanceModel != undefined ||\n                    emitter.innerAngle != undefined ||\n                    emitter.outerAngle != undefined) {\n                    throw new Error(`${extensionContext}: Direction or Distance properties are not allowed on emitters attached to a scene`);\n                }\n                promises.push(this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter));\n            }\n            await Promise.all(promises);\n        });\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {\n            const promises = new Array();\n            const babylonMesh = await this._loader.loadNodeAsync(extensionContext, node, (babylonMesh) => {\n                for (const emitterIndex of extension.emitters) {\n                    const emitter = ArrayItem.Get(`${extensionContext}/emitters`, this._emitters, emitterIndex);\n                    promises.push(\n                    // eslint-disable-next-line github/no-then\n                    this._loadEmitterAsync(`${extensionContext}/emitters/${emitter.index}`, emitter).then(() => {\n                        for (const sound of emitter._babylonSounds) {\n                            sound.attachToMesh(babylonMesh);\n                            if (emitter.innerAngle != undefined || emitter.outerAngle != undefined) {\n                                sound.setLocalDirectionToMesh(Vector3.Forward());\n                                sound.setDirectionalCone(2 * Tools.ToDegrees(emitter.innerAngle == undefined ? Math.PI : emitter.innerAngle), 2 * Tools.ToDegrees(emitter.outerAngle == undefined ? Math.PI : emitter.outerAngle), 0);\n                            }\n                        }\n                    }));\n                }\n                assign(babylonMesh);\n            });\n            await Promise.all(promises);\n            return babylonMesh;\n        });\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadAnimationAsync(context, animation) {\n        return GLTFLoader.LoadExtensionAsync(context, animation, this.name, async (extensionContext, extension) => {\n            const babylonAnimationGroup = await this._loader.loadAnimationAsync(context, animation);\n            const promises = new Array();\n            ArrayItem.Assign(extension.events);\n            for (const event of extension.events) {\n                promises.push(this._loadAnimationEventAsync(`${extensionContext}/events/${event.index}`, context, animation, event, babylonAnimationGroup));\n            }\n            await Promise.all(promises);\n            return babylonAnimationGroup;\n        });\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _loadClipAsync(context, clip) {\n        if (clip._objectURL) {\n            return clip._objectURL;\n        }\n        let promise;\n        if (clip.uri) {\n            promise = this._loader.loadUriAsync(context, clip, clip.uri);\n        }\n        else {\n            const bufferView = ArrayItem.Get(`${context}/bufferView`, this._loader.gltf.bufferViews, clip.bufferView);\n            promise = this._loader.loadBufferViewAsync(`/bufferViews/${bufferView.index}`, bufferView);\n        }\n        // eslint-disable-next-line github/no-then\n        clip._objectURL = promise.then((data) => {\n            const buffer = GetBlobBufferSource(data);\n            return URL.createObjectURL(new Blob([buffer], { type: clip.mimeType }));\n        });\n        return clip._objectURL;\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _loadEmitterAsync(context, emitter) {\n        emitter._babylonSounds = emitter._babylonSounds || [];\n        if (!emitter._babylonData) {\n            const clipPromises = new Array();\n            const name = emitter.name || `emitter${emitter.index}`;\n            const options = {\n                loop: false,\n                autoplay: false,\n                volume: emitter.volume == undefined ? 1 : emitter.volume,\n            };\n            for (let i = 0; i < emitter.clips.length; i++) {\n                const clipContext = `/extensions/${this.name}/clips`;\n                const clip = ArrayItem.Get(clipContext, this._clips, emitter.clips[i].clip);\n                clipPromises.push(\n                // eslint-disable-next-line github/no-then\n                this._loadClipAsync(`${clipContext}/${emitter.clips[i].clip}`, clip).then((objectURL) => {\n                    const sound = (emitter._babylonSounds[i] = new Sound(name, objectURL, this._loader.babylonScene, null, options));\n                    sound.refDistance = emitter.refDistance || 1;\n                    sound.maxDistance = emitter.maxDistance || 256;\n                    sound.rolloffFactor = emitter.rolloffFactor || 1;\n                    sound.distanceModel = emitter.distanceModel || \"exponential\";\n                }));\n            }\n            // eslint-disable-next-line github/no-then\n            const promise = Promise.all(clipPromises).then(() => {\n                const weights = emitter.clips.map((clip) => {\n                    return clip.weight || 1;\n                });\n                const weightedSound = new WeightedSound(emitter.loop || false, emitter._babylonSounds, weights);\n                if (emitter.innerAngle) {\n                    weightedSound.directionalConeInnerAngle = 2 * Tools.ToDegrees(emitter.innerAngle);\n                }\n                if (emitter.outerAngle) {\n                    weightedSound.directionalConeOuterAngle = 2 * Tools.ToDegrees(emitter.outerAngle);\n                }\n                if (emitter.volume) {\n                    weightedSound.volume = emitter.volume;\n                }\n                emitter._babylonData.sound = weightedSound;\n            });\n            emitter._babylonData = {\n                loaded: promise,\n            };\n        }\n        return emitter._babylonData.loaded;\n    }\n    _getEventAction(context, sound, action, time, startOffset) {\n        switch (action) {\n            case \"play\" /* IMSFTAudioEmitter_AnimationEventAction.play */: {\n                return (currentFrame) => {\n                    const frameOffset = (startOffset || 0) + (currentFrame - time);\n                    sound.play(frameOffset);\n                };\n            }\n            case \"stop\" /* IMSFTAudioEmitter_AnimationEventAction.stop */: {\n                return () => {\n                    sound.stop();\n                };\n            }\n            case \"pause\" /* IMSFTAudioEmitter_AnimationEventAction.pause */: {\n                return () => {\n                    sound.pause();\n                };\n            }\n            default: {\n                throw new Error(`${context}: Unsupported action ${action}`);\n            }\n        }\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _loadAnimationEventAsync(context, animationContext, animation, event, babylonAnimationGroup) {\n        if (babylonAnimationGroup.targetedAnimations.length == 0) {\n            return Promise.resolve();\n        }\n        const babylonAnimation = babylonAnimationGroup.targetedAnimations[0];\n        const emitterIndex = event.emitter;\n        const emitter = ArrayItem.Get(`/extensions/${this.name}/emitters`, this._emitters, emitterIndex);\n        // eslint-disable-next-line github/no-then\n        return this._loadEmitterAsync(context, emitter).then(() => {\n            const sound = emitter._babylonData.sound;\n            if (sound) {\n                const babylonAnimationEvent = new AnimationEvent(event.time, this._getEventAction(context, sound, event.action, event.time, event.startOffset));\n                babylonAnimation.animation.addEvent(babylonAnimationEvent);\n                // Make sure all started audio stops when this animation is terminated.\n                babylonAnimationGroup.onAnimationGroupEndObservable.add(() => {\n                    sound.stop();\n                });\n                babylonAnimationGroup.onAnimationGroupPauseObservable.add(() => {\n                    sound.pause();\n                });\n            }\n        });\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_audio_emitter(loader));\n//# sourceMappingURL=MSFT_audio_emitter.js.map"],"names":["AnimationEvent","constructor","frame","action","onlyOnce","this","isDone","_clone","TmpRampOptions","duration","shape","TmpPlayOptions","startOffset","waitTime","TmpStopOptions","D2r","degrees","Math","PI","R2d","radians","Sound","name","_soundV2","value","autoplay","_WebAudioSoundSource","_optionsV2","loop","isPlaying","state","isReady","isPaused","maxDistance","spatialMaxDistance","useCustomAttenuation","_initSpatial","spatial","distanceModel","spatialDistanceModel","currentTime","engine","spatialSound","_isSpatial","newValue","_onReady","_onReadyObservable","Observable","urlOrArrayBuffer","scene","readyToPlayCallback","options","soundTrackId","refDistance","rolloffFactor","metadata","onEndedObservable","_localDirection","Vector3","_volume","_isReadyToPlay","_isDirectional","_isOutputConnected","_url","_onReadyToPlay","_scene","mainSoundTrack","addSound","_readyToPlayCallback","notifyObservers","play","_onended","onended","EngineStore","LastCreatedScene","_SceneComponentInitialization","_customAttenuationFunction","currentVolume","currentDistance","optionsV2","analyzerEnabled","length","loopEnd","loopStart","outBus","outBusAutoDefault","playbackRate","pitch","skipCodecCheck","spatialEnabled","spatialMinDistance","spatialRolloffFactor","stereoEnabled","offset","volume","_HasSpatialAudioOptions","spatialAutoUpdate","spatialConeInnerAngle","_SpatialAudioDefaults","coneInnerAngle","spatialConeOuterAngle","coneOuterAngle","spatialConeOuterVolume","coneOuterVolume","spatialMinUpdateTime","spatialOrientation","orientation","clone","spatialPanningModel","headphone","spatialPosition","position","spatialRotation","rotation","spatialRotationQuaternion","rotationQuaternion","undefined","Number","MAX_VALUE","streaming","AbstractEngine","audioEngine","audioEngineV2","_v2","createSoundV2","streamingOptionsV2","preloadCount","sound","_WebAudioStreamingSound","_initAsync","then","preloadInstancesAsync","_WebAudioStaticSound","ArrayBuffer","HTMLMediaElement","MediaStream","node","MediaStreamAudioSourceNode","_audioContext","mediaStream","AudioBuffer","Array","isArray","add","Logger","Error","dispose","stop","removeSound","soundTracks","_connectedTransformNode","_registerFunc","unregisterAfterWorldMatrixUpdate","getClassName","setAudioBuffer","audioBuffer","updateOptions","setPlaybackRate","setVolume","updated","_updateSpatialParameters","minDistance","panningModel","switchPanningModelToHRTF","switchPanningModelToEqualPower","connectToSoundTrackAudioNode","soundTrackAudioNode","outputNode","_outNode","disconnect","connect","setDirectionalCone","coneOuterGain","directionalConeInnerAngle","directionalConeOuterAngle","setPosition","newPosition","equals","Zero","copyFrom","isNaN","x","y","z","setLocalDirectionToMesh","newLocalDirection","_updateDirection","mat","getWorldMatrix","direction","TransformNormal","normalize","updateDistanceFromListener","activeCamera","distance","audioListenerPositionProvider","subtract","getDistanceToCamera","setAttenuationFunction","callback","time","unlock","audioEnabled","unlocked","setTimeout","ex","message","pause","newVolume","addOnce","newPlaybackRate","getPlaybackRate","getVolume","attachToMesh","transformNode","_onRegisterAfterWorldMatrixUpdate","registerAfterWorldMatrixUpdate","detachFromMesh","getBoundingInfo","boundingInfo","boundingSphere","centerWorld","absolutePosition","currentOptions","clonedSound","buffer","getAudioBuffer","_audioBuffer","getSoundSource","getSoundGain","serialize","serializationObject","url","connectedMeshId","id","asArray","isDirectional","localDirectionToMesh","Parse","parsedSound","rootUrl","sourceSound","soundName","soundUrl","newSound","setBufferAndRun","_RetryWithInterval","removePendingData","addPendingData","soundPosition","FromArray","connectedMesh","getMeshById","_","_WarnImport","RegisterClass","WeightedSound","sounds","weights","_coneInnerAngle","_coneOuterAngle","_sounds","_weights","weightSum","weight","invWeightSum","i","_currentIndex","randomValue","random","total","SoundTrack","_isInitialized","soundCollection","_options","mainTrack","push","_initializeSoundTrackAudioGraph","canUseWebAudio","audioContext","_outputAudioNode","createGain","masterGain","gain","_connectedAnalyser","stopDebugCanvas","index","indexOf","splice","connectToAnalyser","analyser","connectAudioNodes","Object","defineProperty","Scene","prototype","get","compo","_getComponent","SceneComponentConstants","NAME_AUDIO","AudioSceneComponent","_addComponent","_mainSoundTrack","enumerable","configurable","getSoundByName","sdIndex","set","enableAudio","disableAudio","switchAudioModeForHeadphones","switchAudioModeForNormalSpeakers","audioListenerRotationProvider","audioPositioningRefreshRate","_audioEnabled","_headphone","_cachedCameraDirection","_cachedCameraPosition","_lastCheck","_invertMatrixTemp","Matrix","_cameraDirectionTemp","register","_afterRenderStage","registerStep","STEP_AFTERRENDER_AUDIO","_afterRender","rebuild","soundtrack","soundId","addFromContainer","container","removeFromContainer","scIndex","suspend","j","resume","now","PrecisionDate","Now","listeningCamera","activeCameras","listener","globalPosition","setOrientation","rigCameras","getViewMatrix","invertToRef","TransformNormalToRef","_CameraDirection","NAME","MSFT_audio_emitter","loader","_loader","enabled","isExtensionUsed","_clips","_emitters","onLoading","extensions","gltf","extension","clips","emitters","ArrayItem","Assign","loadSceneAsync","context","GLTFLoader","LoadExtensionAsync","async","extensionContext","promises","emitterIndex","emitter","Get","innerAngle","outerAngle","_loadEmitterAsync","Promise","all","loadNodeAsync","assign","babylonMesh","_babylonSounds","Forward","Tools","ToDegrees","loadAnimationAsync","animation","babylonAnimationGroup","events","event","_loadAnimationEventAsync","_loadClipAsync","clip","_objectURL","promise","uri","loadUriAsync","bufferView","bufferViews","loadBufferViewAsync","data","GetBlobBufferSource","URL","createObjectURL","Blob","type","mimeType","_babylonData","clipPromises","clipContext","objectURL","babylonScene","map","weightedSound","loaded","_getEventAction","currentFrame","frameOffset","animationContext","targetedAnimations","resolve","babylonAnimation","babylonAnimationEvent","addEvent","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}