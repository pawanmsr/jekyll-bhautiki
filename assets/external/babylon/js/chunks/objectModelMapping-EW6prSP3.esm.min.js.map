{"version":3,"file":"objectModelMapping-EW6prSP3.esm.min.js","sources":["../../../../../dev/core/dist/Lights/spotLight.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/gltfPathToObjectConverter.js","../../../../../dev/loaders/dist/glTF/2.0/Extensions/objectModelMapping.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { serialize, serializeAsTexture } from \"../Misc/decorators\";\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\nimport { Node } from \"../node\";\nimport { Light } from \"./light\";\nimport { ShadowLight } from \"./shadowLight\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RegisterClass } from \"../Misc/typeStore\";\nimport { Constants } from \"core/Engines/constants\";\nNode.AddNodeConstructor(\"Light_Type_2\", (name, scene) => {\n    return () => new SpotLight(name, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);\n});\n/**\n * A spot light is defined by a position, a direction, an angle, and an exponent.\n * These values define a cone of light starting from the position, emitting toward the direction.\n * The angle, in radians, defines the size (field of illumination) of the spotlight's conical beam,\n * and the exponent defines the speed of the decay of the light with distance (reach).\n * Documentation: https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n */\nexport class SpotLight extends ShadowLight {\n    /**\n     * Gets or sets the IES profile texture used to create the spotlight\n     * @see https://playground.babylonjs.com/#UIAXAU#1\n     */\n    get iesProfileTexture() {\n        return this._iesProfileTexture;\n    }\n    set iesProfileTexture(value) {\n        if (this._iesProfileTexture === value) {\n            return;\n        }\n        this._iesProfileTexture = value;\n        if (this._iesProfileTexture && SpotLight._IsTexture(this._iesProfileTexture)) {\n            this._iesProfileTexture.onLoadObservable.addOnce(() => {\n                this._markMeshesAsLightDirty();\n            });\n        }\n    }\n    /**\n     * Gets the cone angle of the spot light in Radians.\n     */\n    get angle() {\n        return this._angle;\n    }\n    /**\n     * Sets the cone angle of the spot light in Radians.\n     */\n    set angle(value) {\n        this._angle = value;\n        this._cosHalfAngle = Math.cos(value * 0.5);\n        this._projectionTextureProjectionLightDirty = true;\n        this.forceProjectionMatrixCompute();\n        this._computeAngleValues();\n    }\n    /**\n     * Only used in gltf falloff mode, this defines the angle where\n     * the directional falloff will start before cutting at angle which could be seen\n     * as outer angle.\n     */\n    get innerAngle() {\n        return this._innerAngle;\n    }\n    /**\n     * Only used in gltf falloff mode, this defines the angle where\n     * the directional falloff will start before cutting at angle which could be seen\n     * as outer angle.\n     */\n    set innerAngle(value) {\n        this._innerAngle = value;\n        this._computeAngleValues();\n    }\n    /**\n     * Allows scaling the angle of the light for shadow generation only.\n     */\n    get shadowAngleScale() {\n        return this._shadowAngleScale;\n    }\n    /**\n     * Allows scaling the angle of the light for shadow generation only.\n     */\n    set shadowAngleScale(value) {\n        this._shadowAngleScale = value;\n        this.forceProjectionMatrixCompute();\n    }\n    /**\n     * Allows reading the projection texture\n     */\n    get projectionTextureMatrix() {\n        return this._projectionTextureMatrix;\n    }\n    /**\n     * Gets the near clip of the Spotlight for texture projection.\n     */\n    get projectionTextureLightNear() {\n        return this._projectionTextureLightNear;\n    }\n    /**\n     * Sets the near clip of the Spotlight for texture projection.\n     */\n    set projectionTextureLightNear(value) {\n        this._projectionTextureLightNear = value;\n        this._projectionTextureProjectionLightDirty = true;\n    }\n    /**\n     * Gets the far clip of the Spotlight for texture projection.\n     */\n    get projectionTextureLightFar() {\n        return this._projectionTextureLightFar;\n    }\n    /**\n     * Sets the far clip of the Spotlight for texture projection.\n     */\n    set projectionTextureLightFar(value) {\n        this._projectionTextureLightFar = value;\n        this._projectionTextureProjectionLightDirty = true;\n    }\n    /**\n     * Gets the Up vector of the Spotlight for texture projection.\n     */\n    get projectionTextureUpDirection() {\n        return this._projectionTextureUpDirection;\n    }\n    /**\n     * Sets the Up vector of the Spotlight for texture projection.\n     */\n    set projectionTextureUpDirection(value) {\n        this._projectionTextureUpDirection = value;\n        this._projectionTextureProjectionLightDirty = true;\n    }\n    /**\n     * Gets the projection texture of the light.\n     */\n    get projectionTexture() {\n        return this._projectionTexture;\n    }\n    /**\n     * Sets the projection texture of the light.\n     */\n    set projectionTexture(value) {\n        if (this._projectionTexture === value) {\n            return;\n        }\n        this._projectionTexture = value;\n        this._projectionTextureDirty = true;\n        if (this._projectionTexture && !this._projectionTexture.isReady()) {\n            if (SpotLight._IsProceduralTexture(this._projectionTexture)) {\n                this._projectionTexture.getEffect().executeWhenCompiled(() => {\n                    this._markMeshesAsLightDirty();\n                });\n            }\n            else if (SpotLight._IsTexture(this._projectionTexture)) {\n                this._projectionTexture.onLoadObservable.addOnce(() => {\n                    this._markMeshesAsLightDirty();\n                });\n            }\n        }\n    }\n    static _IsProceduralTexture(texture) {\n        return texture.onGeneratedObservable !== undefined;\n    }\n    static _IsTexture(texture) {\n        return texture.onLoadObservable !== undefined;\n    }\n    /**\n     * Gets or sets the light projection matrix as used by the projection texture\n     */\n    get projectionTextureProjectionLightMatrix() {\n        return this._projectionTextureProjectionLightMatrix;\n    }\n    set projectionTextureProjectionLightMatrix(projection) {\n        this._projectionTextureProjectionLightMatrix = projection;\n        this._projectionTextureProjectionLightDirty = false;\n        this._projectionTextureDirty = true;\n    }\n    /**\n     * Creates a SpotLight object in the scene. A spot light is a simply light oriented cone.\n     * It can cast shadows.\n     * Documentation : https://doc.babylonjs.com/features/featuresDeepDive/lights/lights_introduction\n     * @param name The light friendly name\n     * @param position The position of the spot light in the scene\n     * @param direction The direction of the light in the scene\n     * @param angle The cone angle of the light in Radians\n     * @param exponent The light decay speed with the distance from the emission spot\n     * @param scene The scene the lights belongs to\n     * @param dontAddToScene True to not add the light to the scene\n     */\n    constructor(name, position, direction, angle, exponent, scene, dontAddToScene) {\n        super(name, scene, dontAddToScene);\n        this._innerAngle = 0;\n        this._iesProfileTexture = null;\n        this._projectionTextureMatrix = Matrix.Zero();\n        this._projectionTextureLightNear = 1e-6;\n        this._projectionTextureLightFar = 1000.0;\n        this._projectionTextureUpDirection = Vector3.Up();\n        this._projectionTextureViewLightDirty = true;\n        this._projectionTextureProjectionLightDirty = true;\n        this._projectionTextureDirty = true;\n        this._projectionTextureViewTargetVector = Vector3.Zero();\n        this._projectionTextureViewLightMatrix = Matrix.Zero();\n        this._projectionTextureProjectionLightMatrix = Matrix.Zero();\n        this._projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);\n        this.position = position;\n        this.direction = direction;\n        this.angle = angle;\n        this.exponent = exponent;\n    }\n    /**\n     * Returns the string \"SpotLight\".\n     * @returns the class name\n     */\n    getClassName() {\n        return \"SpotLight\";\n    }\n    /**\n     * Returns the integer 2.\n     * @returns The light Type id as a constant defines in Light.LIGHTTYPEID_x\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    getTypeID() {\n        return Light.LIGHTTYPEID_SPOTLIGHT;\n    }\n    /**\n     * Overrides the direction setter to recompute the projection texture view light Matrix.\n     * @param value\n     */\n    _setDirection(value) {\n        super._setDirection(value);\n        this._projectionTextureViewLightDirty = true;\n    }\n    /**\n     * Overrides the position setter to recompute the projection texture view light Matrix.\n     * @param value\n     */\n    _setPosition(value) {\n        super._setPosition(value);\n        this._projectionTextureViewLightDirty = true;\n    }\n    /**\n     * Sets the passed matrix \"matrix\" as perspective projection matrix for the shadows and the passed view matrix with the fov equal to the SpotLight angle and and aspect ratio of 1.0.\n     * Returns the SpotLight.\n     * @param matrix\n     * @param viewMatrix\n     * @param renderList\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {\n        const activeCamera = this.getScene().activeCamera;\n        if (!activeCamera) {\n            return;\n        }\n        this._shadowAngleScale = this._shadowAngleScale || 1;\n        const angle = this._shadowAngleScale * this._angle;\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : activeCamera.minZ;\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : activeCamera.maxZ;\n        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;\n        Matrix.PerspectiveFovLHToRef(angle, 1.0, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, undefined, useReverseDepthBuffer);\n    }\n    _computeProjectionTextureViewLightMatrix() {\n        this._projectionTextureViewLightDirty = false;\n        this._projectionTextureDirty = true;\n        this.getAbsolutePosition().addToRef(this.getShadowDirection(), this._projectionTextureViewTargetVector);\n        Matrix.LookAtLHToRef(this.getAbsolutePosition(), this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);\n    }\n    _computeProjectionTextureProjectionLightMatrix() {\n        this._projectionTextureProjectionLightDirty = false;\n        this._projectionTextureDirty = true;\n        const lightFar = this.projectionTextureLightFar;\n        const lightNear = this.projectionTextureLightNear;\n        const p = lightFar / (lightFar - lightNear);\n        const q = -p * lightNear;\n        const s = 1.0 / Math.tan(this._angle / 2.0);\n        const a = 1.0;\n        Matrix.FromValuesToRef(s / a, 0.0, 0.0, 0.0, 0.0, s, 0.0, 0.0, 0.0, 0.0, p, 1.0, 0.0, 0.0, q, 0.0, this._projectionTextureProjectionLightMatrix);\n    }\n    /**\n     * Main function for light texture projection matrix computing.\n     */\n    _computeProjectionTextureMatrix() {\n        this._projectionTextureDirty = false;\n        this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);\n        if (this._projectionTexture instanceof Texture) {\n            const u = this._projectionTexture.uScale / 2.0;\n            const v = this._projectionTexture.vScale / 2.0;\n            Matrix.FromValuesToRef(u, 0.0, 0.0, 0.0, 0.0, v, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0, this._projectionTextureScalingMatrix);\n        }\n        this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);\n    }\n    _buildUniformLayout() {\n        this._uniformBuffer.addUniform(\"vLightData\", 4);\n        this._uniformBuffer.addUniform(\"vLightDiffuse\", 4);\n        this._uniformBuffer.addUniform(\"vLightSpecular\", 4);\n        this._uniformBuffer.addUniform(\"vLightDirection\", 3);\n        this._uniformBuffer.addUniform(\"vLightFalloff\", 4);\n        this._uniformBuffer.addUniform(\"shadowsInfo\", 3);\n        this._uniformBuffer.addUniform(\"depthValues\", 2);\n        this._uniformBuffer.create();\n    }\n    _computeAngleValues() {\n        this._lightAngleScale = 1.0 / Math.max(0.001, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);\n        this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;\n    }\n    /**\n     * Sets the passed Effect \"effect\" with the Light textures.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The light\n     */\n    transferTexturesToEffect(effect, lightIndex) {\n        if (this.projectionTexture && this.projectionTexture.isReady()) {\n            if (this._projectionTextureViewLightDirty) {\n                this._computeProjectionTextureViewLightMatrix();\n            }\n            if (this._projectionTextureProjectionLightDirty) {\n                this._computeProjectionTextureProjectionLightMatrix();\n            }\n            if (this._projectionTextureDirty) {\n                this._computeProjectionTextureMatrix();\n            }\n            effect.setMatrix(\"textureProjectionMatrix\" + lightIndex, this._projectionTextureMatrix);\n            effect.setTexture(\"projectionLightTexture\" + lightIndex, this.projectionTexture);\n        }\n        if (this._iesProfileTexture && this._iesProfileTexture.isReady()) {\n            effect.setTexture(\"iesLightTexture\" + lightIndex, this._iesProfileTexture);\n        }\n        return this;\n    }\n    /**\n     * Sets the passed Effect object with the SpotLight transformed position (or position if not parented) and normalized direction.\n     * @param effect The effect to update\n     * @param lightIndex The index of the light in the effect to update\n     * @returns The spot light\n     */\n    transferToEffect(effect, lightIndex) {\n        let normalizeDirection;\n        const offset = this._scene.floatingOriginOffset;\n        if (this.computeTransformedInformation()) {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.transformedPosition.x - offset.x, this.transformedPosition.y - offset.y, this.transformedPosition.z - offset.z, this.exponent, lightIndex);\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\n        }\n        else {\n            this._uniformBuffer.updateFloat4(\"vLightData\", this.position.x - offset.x, this.position.y - offset.y, this.position.z - offset.z, this.exponent, lightIndex);\n            normalizeDirection = Vector3.Normalize(this.direction);\n        }\n        this._uniformBuffer.updateFloat4(\"vLightDirection\", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);\n        this._uniformBuffer.updateFloat4(\"vLightFalloff\", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);\n        return this;\n    }\n    transferToNodeMaterialEffect(effect, lightDataUniformName) {\n        let normalizeDirection;\n        if (this.computeTransformedInformation()) {\n            normalizeDirection = Vector3.Normalize(this.transformedDirection);\n        }\n        else {\n            normalizeDirection = Vector3.Normalize(this.direction);\n        }\n        if (this.getScene().useRightHandedSystem) {\n            effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);\n        }\n        else {\n            effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);\n        }\n        return this;\n    }\n    /**\n     * Disposes the light and the associated resources.\n     */\n    dispose() {\n        super.dispose();\n        if (this._projectionTexture) {\n            this._projectionTexture.dispose();\n        }\n        if (this._iesProfileTexture) {\n            this._iesProfileTexture.dispose();\n            this._iesProfileTexture = null;\n        }\n    }\n    /**\n     * Gets the minZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the min for\n     * @returns the depth min z\n     */\n    getDepthMinZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        const minZ = this.shadowMinZ !== undefined ? this.shadowMinZ : (activeCamera?.minZ ?? Constants.ShadowMinZ);\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;\n    }\n    /**\n     * Gets the maxZ used for shadow according to both the scene and the light.\n     * @param activeCamera The camera we are returning the max for\n     * @returns the depth max z\n     */\n    getDepthMaxZ(activeCamera) {\n        const engine = this._scene.getEngine();\n        const maxZ = this.shadowMaxZ !== undefined ? this.shadowMaxZ : (activeCamera?.maxZ ?? Constants.ShadowMaxZ);\n        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;\n    }\n    /**\n     * Prepares the list of defines specific to the light type.\n     * @param defines the list of defines\n     * @param lightIndex defines the index of the light for the effect\n     */\n    prepareLightSpecificDefines(defines, lightIndex) {\n        defines[\"SPOTLIGHT\" + lightIndex] = true;\n        defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;\n        defines[\"IESLIGHTTEXTURE\" + lightIndex] = this._iesProfileTexture && this._iesProfileTexture.isReady() ? true : false;\n    }\n}\n__decorate([\n    serialize()\n], SpotLight.prototype, \"angle\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"innerAngle\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"shadowAngleScale\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"exponent\", void 0);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"projectionTextureLightNear\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"projectionTextureLightFar\", null);\n__decorate([\n    serialize()\n], SpotLight.prototype, \"projectionTextureUpDirection\", null);\n__decorate([\n    serializeAsTexture(\"projectedLightTexture\")\n], SpotLight.prototype, \"_projectionTexture\", void 0);\n// Register Class Name\nRegisterClass(\"BABYLON.SpotLight\", SpotLight);\n//# sourceMappingURL=spotLight.js.map","/**\n * Adding an exception here will break traversing through the glTF object tree.\n * This is used for properties that might not be in the glTF object model, but are optional and have a default value.\n * For example, the path /nodes/\\{\\}/extensions/KHR_node_visibility/visible is optional - the object can be deferred without the object fully existing.\n */\nexport const OptionalPathExceptionsList = [\n    {\n        // get the node as object when reading an extension\n        regex: new RegExp(`^/nodes/\\\\d+/extensions/`),\n    },\n];\n/**\n * A converter that takes a glTF Object Model JSON Pointer\n * and transforms it into an ObjectAccessorContainer, allowing\n * objects referenced in the glTF to be associated with their\n * respective Babylon.js objects.\n */\nexport class GLTFPathToObjectConverter {\n    constructor(_gltf, _infoTree) {\n        this._gltf = _gltf;\n        this._infoTree = _infoTree;\n    }\n    /**\n     * The pointer string is represented by a [JSON pointer](https://datatracker.ietf.org/doc/html/rfc6901).\n     * See also https://github.com/KhronosGroup/glTF/blob/main/specification/2.0/ObjectModel.adoc#core-pointers\n     * <animationPointer> := /<rootNode>/<assetIndex>/<propertyPath>\n     * <rootNode> := \"nodes\" | \"materials\" | \"meshes\" | \"cameras\" | \"extensions\"\n     * <assetIndex> := <digit> | <name>\n     * <propertyPath> := <extensionPath> | <standardPath>\n     * <extensionPath> := \"extensions\"/<name>/<standardPath>\n     * <standardPath> := <name> | <name>/<standardPath>\n     * <name> := W+\n     * <digit> := D+\n     *\n     * Examples:\n     *  - \"/nodes/0/rotation\"\n     * - \"/nodes.length\"\n     *  - \"/materials/2/emissiveFactor\"\n     *  - \"/materials/2/pbrMetallicRoughness/baseColorFactor\"\n     *  - \"/materials/2/extensions/KHR_materials_emissive_strength/emissiveStrength\"\n     *\n     * @param path The path to convert\n     * @returns The object and info associated with the path\n     */\n    convert(path) {\n        let objectTree = this._gltf;\n        let infoTree = this._infoTree;\n        let target = undefined;\n        if (!path.startsWith(\"/\")) {\n            throw new Error(\"Path must start with a /\");\n        }\n        const parts = path.split(\"/\");\n        parts.shift();\n        //if the last part has \".length\" in it, separate that as an extra part\n        if (parts[parts.length - 1].includes(\".length\")) {\n            const lastPart = parts[parts.length - 1];\n            const split = lastPart.split(\".\");\n            parts.pop();\n            parts.push(...split);\n        }\n        let ignoreObjectTree = false;\n        for (const part of parts) {\n            const isLength = part === \"length\";\n            if (isLength && !infoTree.__array__) {\n                throw new Error(`Path ${path} is invalid`);\n            }\n            if (infoTree.__ignoreObjectTree__) {\n                ignoreObjectTree = true;\n            }\n            if (infoTree.__array__ && !isLength) {\n                infoTree = infoTree.__array__;\n            }\n            else {\n                infoTree = infoTree[part];\n                if (!infoTree) {\n                    throw new Error(`Path ${path} is invalid`);\n                }\n            }\n            if (!ignoreObjectTree) {\n                if (objectTree === undefined) {\n                    // check if the path is in the exception list. If it is, break and return the last object that was found\n                    const exception = OptionalPathExceptionsList.find((e) => e.regex.test(path));\n                    if (!exception) {\n                        throw new Error(`Path ${path} is invalid`);\n                    }\n                }\n                else if (!isLength) {\n                    objectTree = objectTree?.[part];\n                }\n            }\n            if (infoTree.__target__ || isLength) {\n                target = objectTree;\n            }\n        }\n        return {\n            object: target,\n            info: infoTree,\n        };\n    }\n}\n//# sourceMappingURL=gltfPathToObjectConverter.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport { Matrix, Quaternion, Vector2 } from \"core/Maths/math.vector\";\nimport { Constants } from \"core/Engines/constants\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport { SpotLight } from \"core/Lights/spotLight\";\nimport { GLTFPathToObjectConverter } from \"./gltfPathToObjectConverter\";\nconst nodesTree = {\n    length: {\n        type: \"number\",\n        get: (nodes) => nodes.length,\n        getTarget: (nodes) => nodes.map((node) => node._babylonTransformNode),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {\n        __target__: true,\n        translation: {\n            type: \"Vector3\",\n            get: (node) => node._babylonTransformNode?.position,\n            set: (value, node) => node._babylonTransformNode?.position.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"position\"],\n        },\n        rotation: {\n            type: \"Quaternion\",\n            get: (node) => node._babylonTransformNode?.rotationQuaternion,\n            set: (value, node) => node._babylonTransformNode?.rotationQuaternion?.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"rotationQuaternion\"],\n        },\n        scale: {\n            type: \"Vector3\",\n            get: (node) => node._babylonTransformNode?.scaling,\n            set: (value, node) => node._babylonTransformNode?.scaling.copyFrom(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"scaling\"],\n        },\n        weights: {\n            length: {\n                type: \"number\",\n                get: (node) => node._numMorphTargets,\n                getTarget: (node) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            __array__: {\n                __target__: true,\n                type: \"number\",\n                get: (node, index) => (index !== undefined ? node._primitiveBabylonMeshes?.[0].morphTargetManager?.getTarget(index).influence : undefined),\n                // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n                getTarget: (node) => node._babylonTransformNode,\n                getPropertyName: [() => \"influence\"],\n            },\n            type: \"number[]\",\n            get: (node, index) => [0], // TODO: get the weights correctly\n            // set: (value: number, node: INode, index?: number) => node._babylonTransformNode?.getMorphTargetManager()?.getTarget(index)?.setInfluence(value),\n            getTarget: (node) => node._babylonTransformNode,\n            getPropertyName: [() => \"influence\"],\n        },\n        // readonly!\n        matrix: {\n            type: \"Matrix\",\n            get: (node) => Matrix.Compose(node._babylonTransformNode?.scaling, node._babylonTransformNode?.rotationQuaternion, node._babylonTransformNode?.position),\n            getTarget: (node) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        globalMatrix: {\n            type: \"Matrix\",\n            get: (node) => {\n                const matrix = Matrix.Identity();\n                // RHS/LHS support\n                let rootNode = node.parent;\n                while (rootNode && rootNode.parent) {\n                    rootNode = rootNode.parent;\n                }\n                const forceUpdate = node._babylonTransformNode?.position._isDirty || node._babylonTransformNode?.rotationQuaternion?._isDirty || node._babylonTransformNode?.scaling._isDirty;\n                if (rootNode) {\n                    // take the parent root node's world matrix, invert it, and multiply it with the current node's world matrix\n                    // This will provide the global matrix, ignoring the RHS->LHS conversion\n                    const rootMatrix = rootNode._babylonTransformNode?.computeWorldMatrix(true).invert();\n                    if (rootMatrix) {\n                        node._babylonTransformNode?.computeWorldMatrix(forceUpdate)?.multiplyToRef(rootMatrix, matrix);\n                    }\n                }\n                else if (node._babylonTransformNode) {\n                    matrix.copyFrom(node._babylonTransformNode.computeWorldMatrix(forceUpdate));\n                }\n                return matrix;\n            },\n            getTarget: (node) => node._babylonTransformNode,\n            isReadOnly: true,\n        },\n        extensions: {\n            EXT_lights_ies: {\n                multiplier: {\n                    type: \"number\",\n                    get: (node) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.intensity;\n                    },\n                    getTarget: (node) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.intensity = value;\n                            }\n                        }\n                    },\n                },\n                color: {\n                    type: \"Color3\",\n                    get: (node) => {\n                        return node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0]?.diffuse;\n                    },\n                    getTarget: (node) => node._babylonTransformNode?.getChildren((child) => child instanceof SpotLight, true)[0],\n                    set: (value, node) => {\n                        if (node._babylonTransformNode) {\n                            const light = node._babylonTransformNode.getChildren((child) => child instanceof SpotLight, true)[0];\n                            if (light) {\n                                light.diffuse = value;\n                            }\n                        }\n                    },\n                },\n            },\n            KHR_node_visibility: {\n                visible: {\n                    type: \"boolean\",\n                    get: (node) => {\n                        return node._primitiveBabylonMeshes ? node._primitiveBabylonMeshes[0].isVisible : false;\n                    },\n                    getTarget: () => undefined, // TODO: what should this return?\n                    set: (value, node) => {\n                        if (node._primitiveBabylonMeshes) {\n                            node._primitiveBabylonMeshes.forEach((mesh) => (mesh.isVisible = value));\n                        }\n                    },\n                },\n            },\n        },\n    },\n};\nconst animationsTree = {\n    length: {\n        type: \"number\",\n        get: (animations) => animations.length,\n        getTarget: (animations) => animations.map((animation) => animation._babylonAnimationGroup),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\nconst meshesTree = {\n    length: {\n        type: \"number\",\n        get: (meshes) => meshes.length,\n        getTarget: (meshes) => meshes.map((mesh) => mesh.primitives[0]._instanceData?.babylonSourceMesh),\n        getPropertyName: [() => \"length\"],\n    },\n    __array__: {},\n};\nconst camerasTree = {\n    __array__: {\n        __target__: true,\n        orthographic: {\n            xmag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoLeft ?? 0, camera._babylonCamera?.orthoRight ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoLeft = value.x;\n                        camera._babylonCamera.orthoRight = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoLeft\", () => \"orthoRight\"],\n            },\n            ymag: {\n                componentsCount: 2,\n                type: \"Vector2\",\n                get: (camera) => new Vector2(camera._babylonCamera?.orthoBottom ?? 0, camera._babylonCamera?.orthoTop ?? 0),\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.orthoBottom = value.x;\n                        camera._babylonCamera.orthoTop = value.y;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"orthoBottom\", () => \"orthoTop\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.maxZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.minZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n        perspective: {\n            aspectRatio: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.getEngine().getAspectRatio(camera._babylonCamera),\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"aspectRatio\"],\n                isReadOnly: true, // might not be the case for glTF?\n            },\n            yfov: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.fov,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.fov = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"fov\"],\n            },\n            zfar: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.maxZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.maxZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"maxZ\"],\n            },\n            znear: {\n                type: \"number\",\n                get: (camera) => camera._babylonCamera?.minZ,\n                set: (value, camera) => {\n                    if (camera._babylonCamera) {\n                        camera._babylonCamera.minZ = value;\n                    }\n                },\n                getTarget: (camera) => camera,\n                getPropertyName: [() => \"minZ\"],\n            },\n        },\n    },\n};\nconst materialsTree = {\n    __array__: {\n        __target__: true,\n        emissiveFactor: {\n            type: \"Color3\",\n            get: (material, index, payload) => GetMaterial(material, index, payload).emissiveColor,\n            set: (value, material, index, payload) => GetMaterial(material, index, payload).emissiveColor.copyFrom(value),\n            getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n            getPropertyName: [() => \"emissiveColor\"],\n        },\n        emissiveTexture: {\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"emissiveTexture\"),\n            },\n        },\n        normalTexture: {\n            scale: {\n                type: \"number\",\n                get: (material, index, payload) => GetTexture(material, payload, \"bumpTexture\")?.level,\n                set: (value, material, index, payload) => {\n                    const texture = GetTexture(material, payload, \"bumpTexture\");\n                    if (texture) {\n                        texture.level = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"level\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"bumpTexture\"),\n            },\n        },\n        occlusionTexture: {\n            strength: {\n                type: \"number\",\n                get: (material, index, payload) => GetMaterial(material, index, payload).ambientTextureStrength,\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.ambientTextureStrength = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"ambientTextureStrength\"],\n            },\n            extensions: {\n                KHR_texture_transform: GenerateTextureMap(\"ambientTexture\"),\n            },\n        },\n        pbrMetallicRoughness: {\n            baseColorFactor: {\n                type: \"Color4\",\n                get: (material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    return Color4.FromColor3(mat.albedoColor, mat.alpha);\n                },\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    mat.albedoColor.set(value.r, value.g, value.b);\n                    mat.alpha = value.a;\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                // This is correct on the animation level, but incorrect as a single property of a type Color4\n                getPropertyName: [() => \"albedoColor\", () => \"alpha\"],\n            },\n            baseColorTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"albedoTexture\"),\n                },\n            },\n            metallicFactor: {\n                type: \"number\",\n                get: (material, index, payload) => GetMaterial(material, index, payload).metallic,\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.metallic = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"metallic\"],\n            },\n            roughnessFactor: {\n                type: \"number\",\n                get: (material, index, payload) => GetMaterial(material, index, payload).roughness,\n                set: (value, material, index, payload) => {\n                    const mat = GetMaterial(material, index, payload);\n                    if (mat) {\n                        mat.roughness = value;\n                    }\n                },\n                getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                getPropertyName: [() => \"roughness\"],\n            },\n            metallicRoughnessTexture: {\n                extensions: {\n                    KHR_texture_transform: GenerateTextureMap(\"metallicTexture\"),\n                },\n            },\n        },\n        extensions: {\n            KHR_materials_anisotropy: {\n                anisotropyStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).anisotropy.intensity,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).anisotropy.intensity = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.intensity\"],\n                },\n                anisotropyRotation: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).anisotropy.angle,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).anisotropy.angle = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"anisotropy.angle\"],\n                },\n                anisotropyTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"anisotropy\", \"texture\"),\n                    },\n                },\n            },\n            KHR_materials_clearcoat: {\n                clearcoatFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.intensity,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).clearCoat.intensity = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.intensity\"],\n                },\n                clearcoatRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.roughness,\n                    set: (value, material, index, payload) => {\n                        GetMaterial(material, index, payload).clearCoat.roughness = value;\n                    },\n                    getTarget: (material, index, payload) => GetMaterial(material, index, payload),\n                    getPropertyName: [() => \"clearCoat.roughness\"],\n                },\n                clearcoatTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"texture\"),\n                    },\n                },\n                clearcoatNormalTexture: {\n                    scale: {\n                        type: \"number\",\n                        get: (material, index, payload) => GetMaterial(material, index, payload).clearCoat.bumpTexture?.level,\n                        getTarget: GetMaterial,\n                        set: (value, material, index, payload) => (GetMaterial(material, index, payload).clearCoat.bumpTexture.level = value),\n                    },\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"bumpTexture\"),\n                    },\n                },\n                clearcoatRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"clearCoat\", \"textureRoughness\"),\n                    },\n                },\n            },\n            KHR_materials_dispersion: {\n                dispersion: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.dispersion,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.dispersion = value),\n                },\n            },\n            KHR_materials_emissive_strength: {\n                emissiveStrength: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).emissiveIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).emissiveIntensity = value),\n                },\n            },\n            KHR_materials_ior: {\n                ior: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).indexOfRefraction = value),\n                },\n            },\n            KHR_materials_iridescence: {\n                iridescenceFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.intensity = value),\n                },\n                iridescenceIor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.indexOfRefraction,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.indexOfRefraction = value),\n                },\n                iridescenceTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"texture\"),\n                    },\n                },\n                iridescenceThicknessMaximum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.maximumThickness = value),\n                },\n                iridescenceThicknessMinimum: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).iridescence.minimumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).iridescence.minimumThickness = value),\n                },\n                iridescenceThicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"iridescence\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_sheen: {\n                sheenColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.color,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).sheen.color.copyFrom(value),\n                },\n                sheenColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"texture\"),\n                    },\n                },\n                sheenRoughnessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).sheen.intensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).sheen.intensity = value),\n                },\n                sheenRoughnessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"sheen\", \"thicknessTexture\"),\n                    },\n                },\n            },\n            KHR_materials_specular: {\n                specularFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicF0Factor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).metallicF0Factor = value),\n                    getPropertyName: [() => \"metallicF0Factor\"],\n                },\n                specularColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).metallicReflectanceColor.copyFrom(value),\n                    getPropertyName: [() => \"metallicReflectanceColor\"],\n                },\n                specularTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"metallicReflectanceTexture\"),\n                    },\n                },\n                specularColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"reflectanceTexture\"),\n                    },\n                },\n            },\n            KHR_materials_transmission: {\n                transmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.refractionIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.refractionIntensity = value),\n                    getPropertyName: [() => \"subSurface.refractionIntensity\"],\n                },\n                transmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"refractionIntensityTexture\"),\n                    },\n                },\n            },\n            KHR_materials_diffuse_transmission: {\n                diffuseTransmissionFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyIntensity,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.translucencyIntensity = value),\n                },\n                diffuseTransmissionTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyIntensityTexture\"),\n                    },\n                },\n                diffuseTransmissionColorFactor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.translucencyColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => value && GetMaterial(material, index, payload).subSurface.translucencyColor?.copyFrom(value),\n                },\n                diffuseTransmissionColorTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"translucencyColorTexture\"),\n                    },\n                },\n            },\n            KHR_materials_volume: {\n                attenuationColor: {\n                    type: \"Color3\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColor.copyFrom(value),\n                },\n                attenuationDistance: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.tintColorAtDistance,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.tintColorAtDistance = value),\n                },\n                thicknessFactor: {\n                    type: \"number\",\n                    get: (material, index, payload) => GetMaterial(material, index, payload).subSurface.maximumThickness,\n                    getTarget: GetMaterial,\n                    set: (value, material, index, payload) => (GetMaterial(material, index, payload).subSurface.maximumThickness = value),\n                },\n                thicknessTexture: {\n                    extensions: {\n                        KHR_texture_transform: GenerateTextureMap(\"subSurface\", \"thicknessTexture\"),\n                    },\n                },\n            },\n        },\n    },\n};\nconst extensionsTree = {\n    KHR_lights_punctual: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonLight),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light) => light._babylonLight?.diffuse,\n                    set: (value, light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.intensity,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"intensity\"],\n                },\n                range: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.range,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.range = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"range\"],\n                },\n                spot: {\n                    innerConeAngle: {\n                        type: \"number\",\n                        get: (light) => light._babylonLight?.innerAngle,\n                        set: (value, light) => (light._babylonLight ? (light._babylonLight.innerAngle = value) : undefined),\n                        getTarget: (light) => light._babylonLight,\n                        getPropertyName: [(_light) => \"innerConeAngle\"],\n                    },\n                    outerConeAngle: {\n                        type: \"number\",\n                        get: (light) => light._babylonLight?.angle,\n                        set: (value, light) => (light._babylonLight ? (light._babylonLight.angle = value) : undefined),\n                        getTarget: (light) => light._babylonLight,\n                        getPropertyName: [(_light) => \"outerConeAngle\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_area: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonLight),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                color: {\n                    type: \"Color3\",\n                    get: (light) => light._babylonLight?.diffuse,\n                    set: (value, light) => light._babylonLight?.diffuse.copyFrom(value),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"diffuse\"],\n                },\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.intensity,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.intensity = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"intensity\"],\n                },\n                size: {\n                    type: \"number\",\n                    get: (light) => light._babylonLight?.height,\n                    set: (value, light) => (light._babylonLight ? (light._babylonLight.height = value) : undefined),\n                    getTarget: (light) => light._babylonLight,\n                    getPropertyName: [(_light) => \"size\"],\n                },\n                rect: {\n                    aspect: {\n                        type: \"number\",\n                        get: (light) => light._babylonLight?.width / light._babylonLight?.height,\n                        set: (value, light) => light._babylonLight ? (light._babylonLight.width = value * light._babylonLight.height) : undefined,\n                        getTarget: (light) => light._babylonLight,\n                        getPropertyName: [(_light) => \"aspect\"],\n                    },\n                },\n            },\n        },\n    },\n    EXT_lights_ies: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonLight),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n        },\n    },\n    EXT_lights_image_based: {\n        lights: {\n            length: {\n                type: \"number\",\n                get: (lights) => lights.length,\n                getTarget: (lights) => lights.map((light) => light._babylonTexture),\n                getPropertyName: [(_lights) => \"length\"],\n            },\n            __array__: {\n                __target__: true,\n                intensity: {\n                    type: \"number\",\n                    get: (light) => light._babylonTexture?.level,\n                    set: (value, light) => {\n                        if (light._babylonTexture) {\n                            light._babylonTexture.level = value;\n                        }\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n                rotation: {\n                    type: \"Quaternion\",\n                    get: (light) => light._babylonTexture && Quaternion.FromRotationMatrix(light._babylonTexture?.getReflectionTextureMatrix()),\n                    set: (value, light) => {\n                        if (!light._babylonTexture) {\n                            return;\n                        }\n                        // Invert the rotation so that positive rotation is counter-clockwise.\n                        if (!light._babylonTexture.getScene()?.useRightHandedSystem) {\n                            value = Quaternion.Inverse(value);\n                        }\n                        Matrix.FromQuaternionToRef(value, light._babylonTexture.getReflectionTextureMatrix());\n                    },\n                    getTarget: (light) => light._babylonTexture,\n                },\n            },\n        },\n    },\n};\nfunction GetTexture(material, payload, textureType, textureInObject) {\n    const babylonMaterial = GetMaterial(material, payload);\n    return textureInObject ? babylonMaterial[textureType][textureInObject] : babylonMaterial[textureType];\n}\nfunction GetMaterial(material, _index, payload) {\n    return material._data?.[payload?.fillMode ?? Constants.MATERIAL_TriangleFillMode]?.babylonMaterial;\n}\nfunction GenerateTextureMap(textureType, textureInObject) {\n    return {\n        offset: {\n            componentsCount: 2,\n            // assuming two independent values for u and v, and NOT a Vector2\n            type: \"Vector2\",\n            get: (material, _index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uOffset, texture?.vOffset);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, _index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uOffset = value.x), (texture.vOffset = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uOffset`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vOffset`,\n            ],\n        },\n        rotation: {\n            type: \"number\",\n            get: (material, _index, payload) => GetTexture(material, payload, textureType, textureInObject)?.wAng,\n            getTarget: GetMaterial,\n            set: (value, material, _index, payload) => (GetTexture(material, payload, textureType, textureInObject).wAng = value),\n            getPropertyName: [() => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.wAng`],\n        },\n        scale: {\n            componentsCount: 2,\n            type: \"Vector2\",\n            get: (material, _index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                return new Vector2(texture?.uScale, texture?.vScale);\n            },\n            getTarget: GetMaterial,\n            set: (value, material, index, payload) => {\n                const texture = GetTexture(material, payload, textureType, textureInObject);\n                (texture.uScale = value.x), (texture.vScale = value.y);\n            },\n            getPropertyName: [\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.uScale`,\n                () => `${textureType}${textureInObject ? \".\" + textureInObject : \"\"}.vScale`,\n            ],\n        },\n    };\n}\nconst objectModelMapping = {\n    cameras: camerasTree,\n    nodes: nodesTree,\n    materials: materialsTree,\n    extensions: extensionsTree,\n    animations: animationsTree,\n    meshes: meshesTree,\n};\n/**\n * get a path-to-object converter for the given glTF tree\n * @param gltf the glTF tree to use\n * @returns a path-to-object converter for the given glTF tree\n */\nexport function GetPathToObjectConverter(gltf) {\n    return new GLTFPathToObjectConverter(gltf, objectModelMapping);\n}\n/**\n * This function will return the object accessor for the given key in the object model\n * If the key is not found, it will return undefined\n * @param key the key to get the mapping for, for example /materials/\\{\\}/emissiveFactor\n * @returns an object accessor for the given key, or undefined if the key is not found\n */\nexport function GetMappingForKey(key) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that current is an object accessor\n    if (current && current.type && current.get) {\n        return current;\n    }\n    return undefined;\n}\n/**\n * Set interpolation for a specific key in the object model\n * @param key the key to set, for example /materials/\\{\\}/emissiveFactor\n * @param interpolation the interpolation elements array\n */\nexport function SetInterpolationForKey(key, interpolation) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        current = current[part];\n    }\n    // validate that the current object is an object accessor\n    if (current && current.type && current.get) {\n        current.interpolation = interpolation;\n    }\n}\n/**\n * This will ad a new object accessor in the object model at the given key.\n * Note that this will NOT change the typescript types. To do that you will need to change the interface itself (extending it in the module that uses it)\n * @param key the key to add the object accessor at. For example /cameras/\\{\\}/perspective/aspectRatio\n * @param accessor the object accessor to add\n */\nexport function AddObjectAccessorToKey(key, accessor) {\n    // replace every `{}` in key with __array__ to match the object model\n    const keyParts = key.split(\"/\").map((part) => part.replace(/{}/g, \"__array__\"));\n    let current = objectModelMapping;\n    for (const part of keyParts) {\n        // make sure part is not empty\n        if (!part) {\n            continue;\n        }\n        if (!current[part]) {\n            if (part === \"?\") {\n                current.__ignoreObjectTree__ = true;\n                continue;\n            }\n            current[part] = {};\n            // if the part is __array__ then add the __target__ property\n            if (part === \"__array__\") {\n                current[part].__target__ = true;\n            }\n        }\n        current = current[part];\n    }\n    Object.assign(current, accessor);\n}\n//# sourceMappingURL=objectModelMapping.js.map"],"names":["Node","AddNodeConstructor","name","scene","SpotLight","Vector3","Zero","ShadowLight","iesProfileTexture","this","_iesProfileTexture","value","_IsTexture","onLoadObservable","addOnce","_markMeshesAsLightDirty","angle","_angle","_cosHalfAngle","Math","cos","_projectionTextureProjectionLightDirty","forceProjectionMatrixCompute","_computeAngleValues","innerAngle","_innerAngle","shadowAngleScale","_shadowAngleScale","projectionTextureMatrix","_projectionTextureMatrix","projectionTextureLightNear","_projectionTextureLightNear","projectionTextureLightFar","_projectionTextureLightFar","projectionTextureUpDirection","_projectionTextureUpDirection","projectionTexture","_projectionTexture","_projectionTextureDirty","isReady","_IsProceduralTexture","getEffect","executeWhenCompiled","texture","undefined","onGeneratedObservable","projectionTextureProjectionLightMatrix","_projectionTextureProjectionLightMatrix","projection","constructor","position","direction","exponent","dontAddToScene","super","Matrix","Up","_projectionTextureViewLightDirty","_projectionTextureViewTargetVector","_projectionTextureViewLightMatrix","_projectionTextureScalingMatrix","FromValues","getClassName","getTypeID","Light","LIGHTTYPEID_SPOTLIGHT","_setDirection","_setPosition","_setDefaultShadowProjectionMatrix","matrix","viewMatrix","renderList","activeCamera","getScene","minZ","shadowMinZ","maxZ","shadowMaxZ","useReverseDepthBuffer","getEngine","PerspectiveFovLHToRef","_scene","isNDCHalfZRange","_computeProjectionTextureViewLightMatrix","getAbsolutePosition","addToRef","getShadowDirection","LookAtLHToRef","_computeProjectionTextureProjectionLightMatrix","lightFar","lightNear","p","q","s","tan","FromValuesToRef","_computeProjectionTextureMatrix","multiplyToRef","Texture","u","uScale","v","vScale","_buildUniformLayout","_uniformBuffer","addUniform","create","_lightAngleScale","max","_lightAngleOffset","transferTexturesToEffect","effect","lightIndex","setMatrix","setTexture","transferToEffect","normalizeDirection","offset","floatingOriginOffset","computeTransformedInformation","updateFloat4","transformedPosition","x","y","z","Normalize","transformedDirection","range","_inverseSquaredRange","transferToNodeMaterialEffect","lightDataUniformName","useRightHandedSystem","setFloat3","dispose","getDepthMinZ","engine","Constants","ShadowMinZ","getDepthMaxZ","ShadowMaxZ","prepareLightSpecificDefines","defines","__decorate","serialize","prototype","serializeAsTexture","RegisterClass","OptionalPathExceptionsList","regex","RegExp","GLTFPathToObjectConverter","_gltf","_infoTree","convert","path","target","objectTree","infoTree","startsWith","Error","parts","split","shift","length","includes","pop","push","ignoreObjectTree","part","isLength","__array__","__ignoreObjectTree__","find","e","test","__target__","object","info","GetTexture","material","payload","textureType","textureInObject","babylonMaterial","GetMaterial","_index","_data","fillMode","MATERIAL_TriangleFillMode","GenerateTextureMap","componentsCount","type","get","Vector2","uOffset","vOffset","getTarget","set","getPropertyName","rotation","wAng","scale","index","objectModelMapping","cameras","orthographic","xmag","camera","_babylonCamera","orthoLeft","orthoRight","ymag","orthoBottom","orthoTop","zfar","znear","perspective","aspectRatio","getAspectRatio","isReadOnly","yfov","fov","nodes","map","node","_babylonTransformNode","translation","copyFrom","rotationQuaternion","scaling","weights","_numMorphTargets","_primitiveBabylonMeshes","morphTargetManager","influence","Compose","globalMatrix","Identity","rootNode","parent","forceUpdate","_isDirty","rootMatrix","computeWorldMatrix","invert","extensions","EXT_lights_ies","multiplier","getChildren","child","intensity","light","color","diffuse","KHR_node_visibility","visible","isVisible","forEach","mesh","materials","emissiveFactor","emissiveColor","emissiveTexture","KHR_texture_transform","normalTexture","level","occlusionTexture","strength","ambientTextureStrength","mat","pbrMetallicRoughness","baseColorFactor","Color4","FromColor3","albedoColor","alpha","r","g","b","a","baseColorTexture","metallicFactor","metallic","roughnessFactor","roughness","metallicRoughnessTexture","KHR_materials_anisotropy","anisotropyStrength","anisotropy","anisotropyRotation","anisotropyTexture","KHR_materials_clearcoat","clearcoatFactor","clearCoat","clearcoatRoughnessFactor","clearcoatTexture","clearcoatNormalTexture","bumpTexture","clearcoatRoughnessTexture","KHR_materials_dispersion","dispersion","subSurface","KHR_materials_emissive_strength","emissiveStrength","emissiveIntensity","KHR_materials_ior","ior","indexOfRefraction","KHR_materials_iridescence","iridescenceFactor","iridescence","iridescenceIor","iridescenceTexture","iridescenceThicknessMaximum","maximumThickness","iridescenceThicknessMinimum","minimumThickness","iridescenceThicknessTexture","KHR_materials_sheen","sheenColorFactor","sheen","sheenColorTexture","sheenRoughnessFactor","sheenRoughnessTexture","KHR_materials_specular","specularFactor","metallicF0Factor","specularColorFactor","metallicReflectanceColor","specularTexture","specularColorTexture","KHR_materials_transmission","transmissionFactor","refractionIntensity","transmissionTexture","KHR_materials_diffuse_transmission","diffuseTransmissionFactor","translucencyIntensity","diffuseTransmissionTexture","diffuseTransmissionColorFactor","translucencyColor","diffuseTransmissionColorTexture","KHR_materials_volume","attenuationColor","tintColor","attenuationDistance","tintColorAtDistance","thicknessFactor","thicknessTexture","KHR_lights_punctual","lights","_babylonLight","_lights","_light","spot","innerConeAngle","outerConeAngle","EXT_lights_area","size","height","rect","aspect","width","EXT_lights_image_based","_babylonTexture","Quaternion","FromRotationMatrix","getReflectionTextureMatrix","Inverse","FromQuaternionToRef","animations","animation","_babylonAnimationGroup","meshes","primitives","_instanceData","babylonSourceMesh","GetPathToObjectConverter","gltf","GetMappingForKey","key","keyParts","replace","current","SetInterpolationForKey","interpolation","AddObjectAccessorToKey","accessor","Object","assign"],"mappings":"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"}