import{C as e,q as n,cd as a,L as s,ce as r,e as t,o as i,E as o,_ as p,cf as c}from"./index-C7lpuH7l.esm.min.js";let m=null;async function d(){return m||(m=async function(){const e=t.LastCreatedEngine?.createCanvas(100,100)??new OffscreenCanvas(100,100);e instanceof OffscreenCanvas&&s.Warn("DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.");const{ThinEngine:n}=await import("./index-C7lpuH7l.esm.min.js").then((function(e){return e.cF}));if(!n.IsSupported)throw new Error("DumpData: No WebGL context available. Cannot dump data.");const a=new n(e,!1,{preserveDrawingBuffer:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1});t.Instances.pop(),t.OnEnginesDisposedObservable.add((e=>{a&&e!==a&&!a.isDisposed&&0===t.Instances.length&&E()})),a.getCaps().parallelShaderCompile=void 0;const r=new i(a),{passPixelShader:p}=await import("./pass.fragment-BzuUpbNM.esm.min.js"),c=new o({engine:a,name:p.name,fragmentShader:p.shader,samplerNames:["textureSampler"]});return{canvas:e,dumpEngine:{engine:a,renderer:r,wrapper:c}}}()),await m}class u{static async EncodeImageAsync(a,s,r,t,i,o){const p=await d(),c=p.dumpEngine;c.engine.setSize(s,r,!0);const m=c.engine.createRawTexture(a,s,r,e.TEXTUREFORMAT_RGBA,!1,!i,e.TEXTURE_NEAREST_NEAREST);return c.renderer.setViewport(),c.renderer.applyEffectWrapper(c.wrapper),c.wrapper.effect._bindTexture("textureSampler",m),c.renderer.draw(),m.dispose(),await new Promise(((e,a)=>{n.ToBlob(p.canvas,(n=>{n?e(n):a(new Error("EncodeImageAsync: Failed to convert canvas to blob."))}),t,o)}))}}p([c],u,"EncodeImageAsync",null);const l=u.EncodeImageAsync;async function f(e,n,a,s,r="image/png",t,i){const o=await a.readPixels(0,0,e,n);w(e,n,new Uint8Array(o.buffer),s,r,t,!0,void 0,i)}async function g(e,t,i,o="image/png",p,c=!1,m=!1,d){if(i instanceof Float32Array){const e=new Uint8Array(i.length);let n=i.length;for(;n--;){const s=i[n];e[n]=Math.round(255*a(s))}i=e}const l=await u.EncodeImageAsync(i,e,t,o,c,d);void 0!==p&&n.DownloadBlob(l,p),l.type!==o&&s.Warn(`DumpData: The requested mimeType '${o}' is not supported. The result has mimeType '${l.type}' instead.`);const f=await l.arrayBuffer();return m?f:`data:${o};base64,${r(f)}`}function w(e,n,a,s,r="image/png",t,i=!1,o=!1,p){void 0!==t||s||(t=""),g(e,n,a,r,t,i,o,p).then((e=>{s&&s(e)}))}function E(){m&&(m?.then((e=>{e.canvas instanceof HTMLCanvasElement&&e.canvas.remove(),e.dumpEngine&&(e.dumpEngine.engine.dispose(),e.dumpEngine.renderer.dispose(),e.dumpEngine.wrapper.dispose())})),m=null)}const y={DumpData:w,DumpDataAsync:g,DumpFramebuffer:f,Dispose:E};n.DumpData=w,n.DumpDataAsync=g,n.DumpFramebuffer=f;export{E as Dispose,w as DumpData,g as DumpDataAsync,f as DumpFramebuffer,y as DumpTools,l as EncodeImageAsync};
//# sourceMappingURL=dumpTools-CaxzcV1w.esm.min.js.map
