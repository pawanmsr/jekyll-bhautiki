import{C as e,S as t,Q as s,p as n,cb as r,r as i,bS as a,bR as o}from"./index-C7lpuH7l.esm.min.js";import{_ as l}from"./environmentTextureTools-CtfceH8Q.esm.min.js";import{CubeTexture as m}from"./cubeTexture-CU8CkahI.esm.min.js";import{GLTFLoader as c,ArrayItem as h}from"./glTFLoader-Cy3hFpAv.esm.min.js";import"./dumpTools-CaxzcV1w.esm.min.js";import"./abstractEngine.cubeTexture-BGdfOh0X.esm.min.js";import"./bone-C8BOn9ne.esm.min.js";import"./skeleton-CpeT1KDV.esm.min.js";import"./rawTexture-GcKYJ37d.esm.min.js";import"./assetContainer-BpinJ-Pb.esm.min.js";import"./objectModelMapping-EW6prSP3.esm.min.js";class d extends m{constructor(t,s,n,r=e.TEXTUREFORMAT_RGBA,i=e.TEXTURETYPE_UNSIGNED_BYTE,a=!1,o=!1,l=e.TEXTURE_TRILINEAR_SAMPLINGMODE,m=null){super("",t),this._texture=t.getEngine().createRawCubeTexture(s,n,r,i,a,o,l,m)}update(e,t,s,n,r=null){this._texture.getEngine().updateRawCubeTexture(this._texture,e,t,s,n,r)}updateRGBDAsync(e,t=null,s=.8,n=0){return l(this._texture,e,t,s,n).then((()=>{}))}clone(){return t.Clone((()=>{const e=this.getScene(),t=this._texture,s=new d(e,t._bufferViewArray,t.width,t.format,t.type,t.generateMipMaps,t.invertY,t.samplingMode,t._compression);return 13===t.source&&s.updateRGBDAsync(t._bufferViewArrayArray,t._sphericalPolynomial,t._lodGenerationScale,t._lodGenerationOffset),s}),this)}}const u="EXT_lights_image_based";class g{constructor(e){this.name=u,this._loader=e,this.enabled=this._loader.isExtensionUsed(u)}dispose(){this._loader=null,delete this._lights}onLoading(){const e=this._loader.gltf.extensions;if(e&&e[this.name]){const t=e[this.name];this._lights=t.lights}}loadSceneAsync(e,t){return c.LoadExtensionAsync(e,t,this.name,(async(s,n)=>{this._loader._allMaterialsDirtyRequired=!0;const r=new Array;r.push(this._loader.loadSceneAsync(e,t)),this._loader.logOpen(`${s}`);const i=h.Get(`${s}/light`,this._lights,n.light);return r.push(this._loadLightAsync(`/extensions/${this.name}/lights/${n.light}`,i).then((e=>{this._loader.babylonScene.environmentTexture=e}))),this._loader.logClose(),await Promise.all(r).then((()=>{}))}))}_loadLightAsync(e,t){if(!t._loaded){const a=new Array;this._loader.logOpen(`${e}`);const o=new Array(t.specularImages.length);for(let s=0;s<t.specularImages.length;s++){const n=t.specularImages[s];o[s]=new Array(n.length);for(let t=0;t<n.length;t++){const r=`${e}/specularImages/${s}/${t}`;this._loader.logOpen(`${r}`);const i=n[t],l=h.Get(r,this._loader.gltf.images,i);a.push(this._loader.loadImageAsync(`/images/${i}`,l).then((e=>{o[s][t]=e}))),this._loader.logClose()}}this._loader.logClose(),t._loaded=Promise.all(a).then((async()=>{const a=new d(this._loader.babylonScene,null,t.specularImageSize);if(a.name=t.name||"environment",t._babylonTexture=a,null!=t.intensity&&(a.level=t.intensity),t.rotation){let e=s.FromArray(t.rotation);this._loader.babylonScene.useRightHandedSystem||(e=s.Inverse(e)),n.FromQuaternionToRef(e,a.getReflectionTextureMatrix())}if(!t.irradianceCoefficients)throw new Error(`${e}: Irradiance coefficients are missing`);const l=r.FromArray(t.irradianceCoefficients);l.scaleInPlace(t.intensity),l.convertIrradianceToLambertianRadiance();const m=i.FromHarmonics(l),c=(o.length-1)/Math.log2(t.specularImageSize);return await a.updateRGBDAsync(o,m,c)}))}return t._loaded.then((()=>t._babylonTexture))}}a(u),o(u,!0,(e=>new g(e)));export{g as EXT_lights_image_based};
//# sourceMappingURL=EXT_lights_image_based-KGEwZSC7.esm.min.js.map
