{"version":3,"file":"dumpTools-CaxzcV1w.esm.min.js","sources":["../../../../../dev/core/dist/Misc/dumpTools.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { Constants } from \"../Engines/constants\";\nimport { EffectRenderer, EffectWrapper } from \"../Materials/effectRenderer\";\nimport { Tools } from \"./tools\";\nimport { Clamp } from \"../Maths/math.scalar.functions\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Logger } from \"./logger\";\nimport { EncodeArrayBufferToBase64 } from \"./stringTools\";\nimport { nativeOverride } from \"./decorators\";\nlet ResourcesPromise = null;\nasync function _CreateDumpResourcesAsync() {\n    // Create a compatible canvas. Prefer an HTMLCanvasElement if possible to avoid alpha issues with OffscreenCanvas + WebGL in many browsers.\n    const canvas = (EngineStore.LastCreatedEngine?.createCanvas(100, 100) ?? new OffscreenCanvas(100, 100)); // will be resized later\n    if (canvas instanceof OffscreenCanvas) {\n        Logger.Warn(\"DumpData: OffscreenCanvas will be used for dumping data. This may result in lossy alpha values.\");\n    }\n    // If WebGL via ThinEngine is not available, we cannot encode the data.\n    // If https://github.com/whatwg/html/issues/10142 is resolved, we can migrate to just BitmapRenderer and avoid an engine dependency altogether.\n    const { ThinEngine: thinEngineClass } = await import(\"../Engines/thinEngine\");\n    if (!thinEngineClass.IsSupported) {\n        throw new Error(\"DumpData: No WebGL context available. Cannot dump data.\");\n    }\n    const options = {\n        preserveDrawingBuffer: true,\n        depth: false,\n        stencil: false,\n        alpha: true,\n        premultipliedAlpha: false,\n        antialias: false,\n        failIfMajorPerformanceCaveat: false,\n    };\n    const engine = new thinEngineClass(canvas, false, options);\n    // remove this engine from the list of instances to avoid using it for other purposes\n    EngineStore.Instances.pop();\n    // However, make sure to dispose it when no other engines are left\n    EngineStore.OnEnginesDisposedObservable.add((e) => {\n        // guaranteed to run when no other instances are left\n        // only dispose if it's not the current engine\n        if (engine && e !== engine && !engine.isDisposed && EngineStore.Instances.length === 0) {\n            // Dump the engine and the associated resources\n            Dispose();\n        }\n    });\n    engine.getCaps().parallelShaderCompile = undefined;\n    const renderer = new EffectRenderer(engine);\n    const { passPixelShader } = await import(\"../Shaders/pass.fragment\");\n    const wrapper = new EffectWrapper({\n        engine,\n        name: passPixelShader.name,\n        fragmentShader: passPixelShader.shader,\n        samplerNames: [\"textureSampler\"],\n    });\n    return {\n        canvas: canvas,\n        dumpEngine: { engine, renderer, wrapper },\n    };\n}\nasync function _GetDumpResourcesAsync() {\n    if (!ResourcesPromise) {\n        ResourcesPromise = _CreateDumpResourcesAsync();\n    }\n    return await ResourcesPromise;\n}\nclass EncodingHelper {\n    /**\n     * Encodes image data to the given mime type.\n     * This is put into a helper class so we can apply the nativeOverride decorator to it.\n     * @internal\n     */\n    static async EncodeImageAsync(pixelData, width, height, mimeType, invertY, quality) {\n        const resources = await _GetDumpResourcesAsync();\n        const dumpEngine = resources.dumpEngine;\n        dumpEngine.engine.setSize(width, height, true);\n        // Create the image\n        const texture = dumpEngine.engine.createRawTexture(pixelData, width, height, Constants.TEXTUREFORMAT_RGBA, false, !invertY, Constants.TEXTURE_NEAREST_NEAREST);\n        dumpEngine.renderer.setViewport();\n        dumpEngine.renderer.applyEffectWrapper(dumpEngine.wrapper);\n        dumpEngine.wrapper.effect._bindTexture(\"textureSampler\", texture);\n        dumpEngine.renderer.draw();\n        texture.dispose();\n        return await new Promise((resolve, reject) => {\n            Tools.ToBlob(resources.canvas, (blob) => {\n                if (!blob) {\n                    reject(new Error(\"EncodeImageAsync: Failed to convert canvas to blob.\"));\n                }\n                else {\n                    resolve(blob);\n                }\n            }, mimeType, quality);\n        });\n    }\n}\n__decorate([\n    nativeOverride\n], EncodingHelper, \"EncodeImageAsync\", null);\n/**\n * Encodes pixel data to an image\n * @param pixelData 8-bit RGBA pixel data\n * @param width the width of the image\n * @param height the height of the image\n * @param mimeType the requested MIME type\n * @param invertY true to invert the image in the Y direction\n * @param quality the quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns a promise that resolves to the encoded image data. Note that the `blob.type` may differ from `mimeType` if it was not supported.\n */\nexport const EncodeImageAsync = EncodingHelper.EncodeImageAsync;\n/**\n * Dumps the current bound framebuffer\n * @param width defines the rendering width\n * @param height defines the rendering height\n * @param engine defines the hosting engine\n * @param successCallback defines the callback triggered once the data are available\n * @param mimeType defines the mime type of the result\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns a void promise\n */\n// Should have \"Async\" in the name but this is a public API and we can't break it now\n// eslint-disable-next-line no-restricted-syntax\nexport async function DumpFramebuffer(width, height, engine, successCallback, mimeType = \"image/png\", fileName, quality) {\n    // Read the contents of the framebuffer\n    const bufferView = await engine.readPixels(0, 0, width, height);\n    const data = new Uint8Array(bufferView.buffer);\n    DumpData(width, height, data, successCallback, mimeType, fileName, true, undefined, quality);\n}\n/**\n * Dumps an array buffer\n * @param width defines the rendering width\n * @param height defines the rendering height\n * @param data the data array\n * @param mimeType defines the mime type of the result\n * @param fileName defines the filename to download. If present, the result will automatically be downloaded\n * @param invertY true to invert the picture in the Y dimension\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n * @returns a promise that resolve to the final data\n */\nexport async function DumpDataAsync(width, height, data, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    // Convert if data are float32\n    if (data instanceof Float32Array) {\n        const data2 = new Uint8Array(data.length);\n        let n = data.length;\n        while (n--) {\n            const v = data[n];\n            data2[n] = Math.round(Clamp(v) * 255);\n        }\n        data = data2;\n    }\n    const blob = await EncodingHelper.EncodeImageAsync(data, width, height, mimeType, invertY, quality);\n    if (fileName !== undefined) {\n        Tools.DownloadBlob(blob, fileName);\n    }\n    if (blob.type !== mimeType) {\n        Logger.Warn(`DumpData: The requested mimeType '${mimeType}' is not supported. The result has mimeType '${blob.type}' instead.`);\n    }\n    const buffer = await blob.arrayBuffer();\n    if (toArrayBuffer) {\n        return buffer;\n    }\n    return `data:${mimeType};base64,${EncodeArrayBufferToBase64(buffer)}`;\n}\n/**\n * Dumps an array buffer\n * @param width defines the rendering width\n * @param height defines the rendering height\n * @param data the data array\n * @param successCallback defines the callback triggered once the data are available\n * @param mimeType defines the mime type of the result\n * @param fileName The name of the file to download. If present, the result will automatically be downloaded. If not defined, and `successCallback` is also not defined, the result will automatically be downloaded with an auto-generated file name.\n * @param invertY true to invert the picture in the Y dimension\n * @param toArrayBuffer true to convert the data to an ArrayBuffer (encoded as `mimeType`) instead of a base64 string\n * @param quality The quality of the image if lossy mimeType is used (e.g. image/jpeg, image/webp). See {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLCanvasElement/toBlob | HTMLCanvasElement.toBlob()}'s `quality` parameter.\n */\nexport function DumpData(width, height, data, successCallback, mimeType = \"image/png\", fileName, invertY = false, toArrayBuffer = false, quality) {\n    // For back-compat: if no fileName and no callback, force download the result\n    if (fileName === undefined && !successCallback) {\n        fileName = \"\";\n    }\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    DumpDataAsync(width, height, data, mimeType, fileName, invertY, toArrayBuffer, quality)\n        // eslint-disable-next-line github/no-then\n        .then((result) => {\n        if (successCallback) {\n            successCallback(result);\n        }\n    });\n}\n/**\n * Dispose the dump tools associated resources\n */\nexport function Dispose() {\n    if (!ResourcesPromise) {\n        return;\n    }\n    // in cases where the engine is not yet created, we need to wait for it to dispose it\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n    ResourcesPromise?.then((resources) => {\n        if (resources.canvas instanceof HTMLCanvasElement) {\n            resources.canvas.remove();\n        }\n        if (resources.dumpEngine) {\n            resources.dumpEngine.engine.dispose();\n            resources.dumpEngine.renderer.dispose();\n            resources.dumpEngine.wrapper.dispose();\n        }\n    });\n    ResourcesPromise = null;\n}\n/**\n * Object containing a set of static utilities functions to dump data from a canvas\n * @deprecated use functions\n */\nexport const DumpTools = {\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DumpData,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DumpDataAsync,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    DumpFramebuffer,\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    Dispose,\n};\n/**\n * This will be executed automatically for UMD and es5.\n * If esm dev wants the side effects to execute they will have to run it manually\n * Once we build native modules those need to be exported.\n * @internal\n */\nconst InitSideEffects = () => {\n    // References the dependencies.\n    Tools.DumpData = DumpData;\n    Tools.DumpDataAsync = DumpDataAsync;\n    Tools.DumpFramebuffer = DumpFramebuffer;\n};\nInitSideEffects();\n//# sourceMappingURL=dumpTools.js.map"],"names":["ResourcesPromise","async","_GetDumpResourcesAsync","canvas","EngineStore","LastCreatedEngine","createCanvas","OffscreenCanvas","Logger","Warn","ThinEngine","thinEngineClass","import","then","n","cF","IsSupported","Error","engine","preserveDrawingBuffer","depth","stencil","alpha","premultipliedAlpha","antialias","failIfMajorPerformanceCaveat","Instances","pop","OnEnginesDisposedObservable","add","e","isDisposed","length","Dispose","getCaps","parallelShaderCompile","undefined","renderer","EffectRenderer","passPixelShader","wrapper","EffectWrapper","name","fragmentShader","shader","samplerNames","dumpEngine","_CreateDumpResourcesAsync","EncodingHelper","EncodeImageAsync","pixelData","width","height","mimeType","invertY","quality","resources","setSize","texture","createRawTexture","Constants","TEXTUREFORMAT_RGBA","TEXTURE_NEAREST_NEAREST","setViewport","applyEffectWrapper","effect","_bindTexture","draw","dispose","Promise","resolve","reject","Tools","ToBlob","blob","__decorate","nativeOverride","DumpFramebuffer","successCallback","fileName","bufferView","readPixels","DumpData","Uint8Array","buffer","DumpDataAsync","data","toArrayBuffer","Float32Array","data2","v","Math","round","Clamp","DownloadBlob","type","arrayBuffer","EncodeArrayBufferToBase64","result","HTMLCanvasElement","remove","DumpTools"],"mappings":"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"}