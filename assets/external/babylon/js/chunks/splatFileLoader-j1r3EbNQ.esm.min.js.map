{"version":3,"file":"splatFileLoader-j1r3EbNQ.esm.min.js","sources":["../../../../../dev/core/dist/Materials/shadowDepthWrapper.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplattingFragmentDeclaration.js","../../../../../dev/core/dist/Shaders/gaussianSplatting.fragment.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplattingVertexDeclaration.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplattingUboDeclaration.js","../../../../../dev/core/dist/Shaders/ShadersInclude/gaussianSplatting.js","../../../../../dev/core/dist/Shaders/gaussianSplatting.vertex.js","../../../../../dev/core/dist/ShadersWGSL/ShadersInclude/gaussianSplattingFragmentDeclaration.js","../../../../../dev/core/dist/ShadersWGSL/gaussianSplatting.fragment.js","../../../../../dev/core/dist/ShadersWGSL/ShadersInclude/gaussianSplatting.js","../../../../../dev/core/dist/ShadersWGSL/gaussianSplatting.vertex.js","../../../../../dev/core/dist/Shaders/gaussianSplattingDepth.fragment.js","../../../../../dev/core/dist/Shaders/gaussianSplattingDepth.vertex.js","../../../../../dev/core/dist/ShadersWGSL/gaussianSplattingDepth.fragment.js","../../../../../dev/core/dist/ShadersWGSL/gaussianSplattingDepth.vertex.js","../../../../../dev/core/dist/Materials/GaussianSplatting/gaussianSplattingMaterial.js","../../../../../dev/core/dist/Maths/math.scalar.js","../../../../../dev/core/dist/Meshes/GaussianSplatting/gaussianSplattingPartProxyMesh.js","../../../../../dev/core/dist/Meshes/GaussianSplatting/gaussianSplattingMesh.js","../../../../../dev/core/dist/Particles/pointsCloudSystem.js","../../../../../dev/core/dist/Particles/cloudPoint.js","../../../../../dev/loaders/dist/SPLAT/sog.js","../../../../../dev/loaders/dist/SPLAT/splatFileLoader.js","../../../../../dev/loaders/dist/SPLAT/spz.js"],"sourcesContent":["import { Effect } from \"./effect\";\nimport { RandomGUID } from \"../Misc/guid\";\nimport { DrawWrapper } from \"./drawWrapper\";\nimport { EngineStore } from \"../Engines/engineStore\";\nclass MapMap {\n    constructor() {\n        this.mm = new Map();\n    }\n    get(a, b) {\n        const m = this.mm.get(a);\n        if (m !== undefined) {\n            return m.get(b);\n        }\n        return undefined;\n    }\n    set(a, b, v) {\n        let m = this.mm.get(a);\n        if (m === undefined) {\n            this.mm.set(a, (m = new Map()));\n        }\n        m.set(b, v);\n    }\n}\n/**\n * Class that can be used to wrap a base material to generate accurate shadows when using custom vertex/fragment code in the base material\n */\nexport class ShadowDepthWrapper {\n    /** Gets the standalone status of the wrapper */\n    get standalone() {\n        return this._options?.standalone ?? false;\n    }\n    /** Gets the base material the wrapper is built upon */\n    get baseMaterial() {\n        return this._baseMaterial;\n    }\n    /** Gets the doNotInjectCode status of the wrapper */\n    get doNotInjectCode() {\n        return this._options?.doNotInjectCode ?? false;\n    }\n    /**\n     * Instantiate a new shadow depth wrapper.\n     * It works by injecting some specific code in the vertex/fragment shaders of the base material and is used by a shadow generator to\n     * generate the shadow depth map. For more information, please refer to the documentation:\n     * https://doc.babylonjs.com/features/featuresDeepDive/lights/shadows\n     * @param baseMaterial Material to wrap\n     * @param scene Define the scene the material belongs to\n     * @param options Options used to create the wrapper\n     */\n    constructor(baseMaterial, scene, options) {\n        this._baseMaterial = baseMaterial;\n        this._scene = scene ?? EngineStore.LastCreatedScene;\n        this._options = options;\n        this._subMeshToEffect = new Map();\n        this._subMeshToDepthWrapper = new MapMap();\n        this._meshes = new Map();\n        // Register for onEffectCreated to store the effect of the base material when it is (re)generated. This effect will be used\n        // to create the depth effect later on\n        this._onEffectCreatedObserver = this._baseMaterial.onEffectCreatedObservable.add((params) => {\n            const mesh = params.subMesh?.getMesh();\n            if (mesh && !this._meshes.has(mesh)) {\n                // Register for mesh onDispose to clean up our internal maps when a mesh is disposed\n                this._meshes.set(mesh, mesh.onDisposeObservable.add((mesh) => {\n                    const iterator = this._subMeshToEffect.keys();\n                    for (let key = iterator.next(); key.done !== true; key = iterator.next()) {\n                        const subMesh = key.value;\n                        if (subMesh?.getMesh() === mesh) {\n                            this._subMeshToEffect.delete(subMesh);\n                            this._deleteDepthWrapperEffect(subMesh);\n                        }\n                    }\n                }));\n            }\n            if (this._subMeshToEffect.get(params.subMesh)?.[0] !== params.effect) {\n                this._subMeshToEffect.set(params.subMesh, [params.effect, this._scene.getEngine().currentRenderPassId]);\n                this._deleteDepthWrapperEffect(params.subMesh);\n            }\n        });\n    }\n    _deleteDepthWrapperEffect(subMesh) {\n        const depthWrapperEntries = this._subMeshToDepthWrapper.mm.get(subMesh);\n        if (depthWrapperEntries) {\n            // find and release the previous depth effect\n            depthWrapperEntries.forEach((depthWrapper) => {\n                depthWrapper.mainDrawWrapper.effect?.dispose();\n            });\n            this._subMeshToDepthWrapper.mm.delete(subMesh); // trigger a depth effect recreation\n        }\n    }\n    /**\n     * Gets the effect to use to generate the depth map\n     * @param subMesh subMesh to get the effect for\n     * @param shadowGenerator shadow generator to get the effect for\n     * @param passIdForDrawWrapper Id of the pass for which the effect from the draw wrapper must be retrieved from\n     * @returns the effect to use to generate the depth map for the subMesh + shadow generator specified\n     */\n    getEffect(subMesh, shadowGenerator, passIdForDrawWrapper) {\n        const entry = this._subMeshToDepthWrapper.mm.get(subMesh)?.get(shadowGenerator);\n        if (!entry) {\n            return null;\n        }\n        let drawWrapper = entry.drawWrapper[passIdForDrawWrapper];\n        if (!drawWrapper) {\n            drawWrapper = entry.drawWrapper[passIdForDrawWrapper] = new DrawWrapper(this._scene.getEngine());\n            drawWrapper.setEffect(entry.mainDrawWrapper.effect, entry.mainDrawWrapper.defines);\n        }\n        return drawWrapper;\n    }\n    /**\n     * Specifies that the submesh is ready to be used for depth rendering\n     * @param subMesh submesh to check\n     * @param defines the list of defines to take into account when checking the effect\n     * @param shadowGenerator combined with subMesh, it defines the effect to check\n     * @param useInstances specifies that instances should be used\n     * @param passIdForDrawWrapper Id of the pass for which the draw wrapper should be created\n     * @returns a boolean indicating that the submesh is ready or not\n     */\n    isReadyForSubMesh(subMesh, defines, shadowGenerator, useInstances, passIdForDrawWrapper) {\n        if (this.standalone) {\n            // will ensure the effect is (re)created for the base material\n            if (!this._baseMaterial.isReadyForSubMesh(subMesh.getMesh(), subMesh, useInstances)) {\n                return false;\n            }\n        }\n        return this._makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper)?.isReady() ?? false;\n    }\n    /**\n     * Disposes the resources\n     */\n    dispose() {\n        this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver);\n        this._onEffectCreatedObserver = null;\n        const iterator = this._meshes.entries();\n        for (let entry = iterator.next(); entry.done !== true; entry = iterator.next()) {\n            const [mesh, observer] = entry.value;\n            mesh.onDisposeObservable.remove(observer);\n        }\n    }\n    _makeEffect(subMesh, defines, shadowGenerator, passIdForDrawWrapper) {\n        const engine = this._scene.getEngine();\n        const origEffectAndRenderPassId = this._subMeshToEffect.get(subMesh);\n        if (!origEffectAndRenderPassId) {\n            return null;\n        }\n        const [origEffect, origRenderPassId] = origEffectAndRenderPassId;\n        if (!origEffect.isReady()) {\n            return null;\n        }\n        let params = this._subMeshToDepthWrapper.get(subMesh, shadowGenerator);\n        if (!params) {\n            const mainDrawWrapper = new DrawWrapper(engine);\n            mainDrawWrapper.defines = subMesh._getDrawWrapper(origRenderPassId)?.defines ?? null;\n            params = {\n                drawWrapper: [],\n                mainDrawWrapper,\n                depthDefines: \"\",\n                token: RandomGUID(),\n            };\n            params.drawWrapper[passIdForDrawWrapper] = mainDrawWrapper;\n            this._subMeshToDepthWrapper.set(subMesh, shadowGenerator, params);\n        }\n        const join = defines.join(\"\\n\");\n        if (params.mainDrawWrapper.effect) {\n            if (join === params.depthDefines) {\n                // we already created the depth effect and it is still up to date for this submesh + shadow generator\n                return params.mainDrawWrapper.effect;\n            }\n        }\n        params.depthDefines = join;\n        const uniforms = origEffect.getUniformNames().slice();\n        // the depth effect is either out of date or has not been created yet\n        let vertexCode = origEffect.vertexSourceCodeBeforeMigration, fragmentCode = origEffect.fragmentSourceCodeBeforeMigration;\n        if (!vertexCode && !fragmentCode) {\n            return null;\n        }\n        if (!this.doNotInjectCode) {\n            // Declare the shadow map includes\n            const vertexNormalBiasCode = this._options && this._options.remappedVariables\n                ? `#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(\",\")})`\n                : `#include<shadowMapVertexNormalBias>`, vertexMetricCode = this._options && this._options.remappedVariables\n                ? `#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(\",\")})`\n                : `#include<shadowMapVertexMetric>`, fragmentSoftTransparentShadow = this._options && this._options.remappedVariables\n                ? `#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(\",\")})`\n                : `#include<shadowMapFragmentSoftTransparentShadow>`, fragmentBlockCode = `#include<shadowMapFragment>`, vertexExtraDeclartion = `#include<shadowMapVertexExtraDeclaration>`;\n            // vertex code\n            if (origEffect.shaderLanguage === 0 /* ShaderLanguage.GLSL */) {\n                vertexCode = vertexCode.replace(/void\\s+?main/g, `\\n${vertexExtraDeclartion}\\nvoid main`);\n            }\n            else {\n                vertexCode = vertexCode.replace(/@vertex/g, `\\n${vertexExtraDeclartion}\\n@vertex`);\n            }\n            vertexCode = vertexCode.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g, vertexNormalBiasCode);\n            if (vertexCode.indexOf(\"#define SHADOWDEPTH_METRIC\") !== -1) {\n                vertexCode = vertexCode.replace(/#define SHADOWDEPTH_METRIC/g, vertexMetricCode);\n            }\n            else {\n                vertexCode = vertexCode.replace(/}\\s*$/g, vertexMetricCode + \"\\n}\");\n            }\n            vertexCode = vertexCode.replace(/#define SHADER_NAME.*?\\n|out vec4 glFragColor;\\n/g, \"\");\n            // fragment code\n            const hasLocationForSoftTransparentShadow = fragmentCode.indexOf(\"#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW\") >= 0 || fragmentCode.indexOf(\"#define CUSTOM_FRAGMENT_BEFORE_FOG\") >= 0;\n            const hasLocationForFragment = fragmentCode.indexOf(\"#define SHADOWDEPTH_FRAGMENT\") !== -1;\n            let fragmentCodeToInjectAtEnd = \"\";\n            if (!hasLocationForSoftTransparentShadow) {\n                fragmentCodeToInjectAtEnd = fragmentSoftTransparentShadow + \"\\n\";\n            }\n            else {\n                fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g, fragmentSoftTransparentShadow);\n            }\n            fragmentCode = fragmentCode.replace(/void\\s+?main/g, Effect.IncludesShadersStore[\"shadowMapFragmentExtraDeclaration\"] + \"\\nvoid main\");\n            if (hasLocationForFragment) {\n                fragmentCode = fragmentCode.replace(/#define SHADOWDEPTH_FRAGMENT/g, fragmentBlockCode);\n            }\n            else {\n                fragmentCodeToInjectAtEnd += fragmentBlockCode + \"\\n\";\n            }\n            if (fragmentCodeToInjectAtEnd) {\n                fragmentCode = fragmentCode.replace(/}\\s*$/g, fragmentCodeToInjectAtEnd + \"}\");\n            }\n            uniforms.push(\"biasAndScaleSM\", \"depthValuesSM\", \"lightDataSM\", \"softTransparentShadowSM\");\n        }\n        params.mainDrawWrapper.effect = engine.createEffect({\n            vertexSource: vertexCode,\n            fragmentSource: fragmentCode,\n            vertexToken: params.token,\n            fragmentToken: params.token,\n        }, {\n            attributes: origEffect.getAttributesNames(),\n            uniformsNames: uniforms,\n            uniformBuffersNames: origEffect.getUniformBuffersNames(),\n            samplers: origEffect.getSamplers(),\n            defines: join + \"\\n\" + origEffect.defines.replace(\"#define SHADOWS\", \"\").replace(/#define SHADOW\\d/g, \"\"),\n            indexParameters: origEffect.getIndexParameters(),\n            shaderLanguage: origEffect.shaderLanguage,\n        }, engine);\n        for (let id = 0; id < params.drawWrapper.length; ++id) {\n            if (id !== passIdForDrawWrapper) {\n                params.drawWrapper[id]?.setEffect(params.mainDrawWrapper.effect, params.mainDrawWrapper.defines);\n            }\n        }\n        return params.mainDrawWrapper.effect;\n    }\n}\n//# sourceMappingURL=shadowDepthWrapper.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./logDepthFragment\";\nimport \"./fogFragment\";\nconst name = \"gaussianSplattingFragmentDeclaration\";\nconst shader = `vec4 gaussianColor(vec4 inColor)\n{float A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*inColor.a;\n#include<logDepthFragment>\nvec3 color=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4(color,B);}\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingFragmentDeclaration = { name, shader };\n//# sourceMappingURL=gaussianSplattingFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nconst name = \"gaussianSplattingPixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vec4 vColor;varying vec2 vPosition;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<gaussianSplattingFragmentDeclaration>\nvoid main () {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec4 finalColor=gaussianColor(vColor);\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\ngl_FragColor=finalColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingPixelShader = { name, shader };\n//# sourceMappingURL=gaussianSplatting.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"gaussianSplattingVertexDeclaration\";\nconst shader = `attribute vec3 position;attribute vec4 splatIndex0;attribute vec4 splatIndex1;attribute vec4 splatIndex2;attribute vec4 splatIndex3;uniform mat4 view;uniform mat4 projection;uniform mat4 world;uniform vec4 vEyePosition;`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexDeclaration = { name, shader };\n//# sourceMappingURL=gaussianSplattingVertexDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./sceneUboDeclaration\";\nimport \"./meshUboDeclaration\";\nconst name = \"gaussianSplattingUboDeclaration\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute vec3 position;attribute vec4 splatIndex0;attribute vec4 splatIndex1;attribute vec4 splatIndex2;attribute vec4 splatIndex3;\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingUboDeclaration = { name, shader };\n//# sourceMappingURL=gaussianSplattingUboDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"gaussianSplatting\";\nconst shader = `#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)\nmat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],\nmatrix[0][1],matrix[1][1],matrix[2][1],\nmatrix[0][2],matrix[1][2],matrix[2][2]);}\n#endif\nvec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}\n#if SH_DEGREE>0 || IS_COMPOUND\nivec2 getDataUVint(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return ivec2(uint(x+0.5),uint(y+0.5));}\n#endif\nstruct Splat {vec4 center;vec4 color;vec4 covA;vec4 covB;\n#if SH_DEGREE>0\nuvec4 sh0; \n#endif\n#if SH_DEGREE>1\nuvec4 sh1;\n#endif\n#if SH_DEGREE>2\nuvec4 sh2;\n#endif\n#if IS_COMPOUND\nuint partIndex;\n#endif\n};float getSplatIndex(int localIndex)\n{float splatIndex;switch (localIndex)\n{case 0: splatIndex=splatIndex0.x; break;case 1: splatIndex=splatIndex0.y; break;case 2: splatIndex=splatIndex0.z; break;case 3: splatIndex=splatIndex0.w; break;case 4: splatIndex=splatIndex1.x; break;case 5: splatIndex=splatIndex1.y; break;case 6: splatIndex=splatIndex1.z; break;case 7: splatIndex=splatIndex1.w; break;case 8: splatIndex=splatIndex2.x; break;case 9: splatIndex=splatIndex2.y; break;case 10: splatIndex=splatIndex2.z; break;case 11: splatIndex=splatIndex2.w; break;case 12: splatIndex=splatIndex3.x; break;case 13: splatIndex=splatIndex3.y; break;case 14: splatIndex=splatIndex3.z; break;case 15: splatIndex=splatIndex3.w; break;}\nreturn splatIndex;}\nSplat readSplat(float splatIndex)\n{Splat splat;vec2 splatUV=getDataUV(splatIndex,dataTextureSize);splat.center=texture2D(centersTexture,splatUV);splat.color=texture2D(colorsTexture,splatUV);splat.covA=texture2D(covariancesATexture,splatUV)*splat.center.w;splat.covB=texture2D(covariancesBTexture,splatUV)*splat.center.w;\n#if SH_DEGREE>0 || IS_COMPOUND\nivec2 splatUVint=getDataUVint(splatIndex,dataTextureSize);\n#endif\n#if SH_DEGREE>0\nsplat.sh0=texelFetch(shTexture0,splatUVint,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=texelFetch(shTexture1,splatUVint,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=texelFetch(shTexture2,splatUVint,0);\n#endif\n#if IS_COMPOUND\nsplat.partIndex=uint(texture2D(partIndicesTexture,splatUV).r*255.0+0.5);\n#endif\nreturn splat;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nvec3 computeColorFromSHDegree(vec3 dir,const vec3 sh[16])\n{const float SH_C0=0.28209479;const float SH_C1=0.48860251;float SH_C2[5];SH_C2[0]=1.092548430;SH_C2[1]=-1.09254843;SH_C2[2]=0.315391565;SH_C2[3]=-1.09254843;SH_C2[4]=0.546274215;float SH_C3[7];SH_C3[0]=-0.59004358;SH_C3[1]=2.890611442;SH_C3[2]=-0.45704579;SH_C3[3]=0.373176332;SH_C3[4]=-0.45704579;SH_C3[5]=1.445305721;SH_C3[6]=-0.59004358;vec3 result=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nfloat x=dir.x;float y=dir.y;float z=dir.z;result+=- SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nfloat xx=x*x,yy=y*y,zz=z*z;float xy=x*y,yz=y*z,xz=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0*zz-3.0*xx-3.0*yy)*sh[12] +\nSH_C3[4]*x*(4.0*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nvec4 decompose(uint value)\n{vec4 components=vec4(\nfloat((value ) & 255u),\nfloat((value>>uint( 8)) & 255u),\nfloat((value>>uint(16)) & 255u),\nfloat((value>>uint(24)) & 255u));return components*vec4(2./255.)-vec4(1.);}\nvec3 computeSH(Splat splat,vec3 dir)\n{vec3 sh[16];sh[0]=vec3(0.,0.,0.);\n#if SH_DEGREE>0\nvec4 sh00=decompose(splat.sh0.x);vec4 sh01=decompose(splat.sh0.y);vec4 sh02=decompose(splat.sh0.z);sh[1]=vec3(sh00.x,sh00.y,sh00.z);sh[2]=vec3(sh00.w,sh01.x,sh01.y);sh[3]=vec3(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nvec4 sh03=decompose(splat.sh0.w);vec4 sh04=decompose(splat.sh1.x);vec4 sh05=decompose(splat.sh1.y);sh[4]=vec3(sh02.y,sh02.z,sh02.w);sh[5]=vec3(sh03.x,sh03.y,sh03.z);sh[6]=vec3(sh03.w,sh04.x,sh04.y);sh[7]=vec3(sh04.z,sh04.w,sh05.x);sh[8]=vec3(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nvec4 sh06=decompose(splat.sh1.z);vec4 sh07=decompose(splat.sh1.w);vec4 sh08=decompose(splat.sh2.x);vec4 sh09=decompose(splat.sh2.y);vec4 sh10=decompose(splat.sh2.z);vec4 sh11=decompose(splat.sh2.w);sh[9]=vec3(sh06.x,sh06.y,sh06.z);sh[10]=vec3(sh06.w,sh07.x,sh07.y);sh[11]=vec3(sh07.z,sh07.w,sh08.x);sh[12]=vec3(sh08.y,sh08.z,sh08.w);sh[13]=vec3(sh09.x,sh09.y,sh09.z);sh[14]=vec3(sh09.w,sh10.x,sh10.y);sh[15]=vec3(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\n#else\nvec3 computeSH(Splat splat,vec3 dir)\n{return vec3(0.,0.,0.);}\n#endif\nvec4 gaussianSplatting(vec2 meshPos,vec3 worldPos,vec2 scale,vec3 covA,vec3 covB,mat4 worldMatrix,mat4 viewMatrix,mat4 projectionMatrix)\n{mat4 modelView=viewMatrix*worldMatrix;vec4 camspace=viewMatrix*vec4(worldPos,1.);vec4 pos2d=projectionMatrix*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds\n|| pos2d.y<-bounds || pos2d.y>bounds) {return vec4(0.0,0.0,2.0,1.0);}\nmat3 Vrk=mat3(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);bool isOrtho=abs(projectionMatrix[3][3]-1.0)<0.001;mat3 J;if (isOrtho) {J=mat3(\nfocal.x,0.,0.,\n0.,focal.y,0.,\n0.,0.,0.\n);} else {J=mat3(\nfocal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.,0.,0.\n);}\nmat3 T=transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nfloat c00=cov2d[0][0];float c11=cov2d[1][1];float c01=cov2d[0][1];float detOrig=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nvec3 c2d=vec3(cov2d[0][0],c01,cov2d[1][1]);float detBlur=c2d.x*c2d.z-c2d.y*c2d.y;float compensation=sqrt(max(0.,detOrig/detBlur));vColor.w*=compensation;\n#endif\nfloat mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float epsilon=0.0001;float lambda1=mid+radius+epsilon,lambda2=mid-radius+epsilon;if (lambda2<0.0)\n{return vec4(0.0,0.0,2.0,1.0);}\nvec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vec2 vCenter=vec2(pos2d);float scaleFactor=isOrtho ? 1.0 : pos2d.w;return vec4(\nvCenter \n+ ((meshPos.x*majorAxis\n+ meshPos.y*minorAxis)*invViewport*scaleFactor)*scale,pos2d.zw);}\n#if IS_COMPOUND\nmat4 getPartWorld(uint partIndex) {return partWorld[partIndex];}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStore[name]) {\n    ShaderStore.IncludesShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplatting = { name, shader };\n//# sourceMappingURL=gaussianSplatting.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingVertexDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingUboDeclaration\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/gaussianSplatting\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\nconst name = \"gaussianSplattingVertexShader\";\nconst shader = `#include<__decl__gaussianSplattingVertex>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\nuniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform vec3 eyePosition;uniform float alpha;\n#if IS_COMPOUND\nuniform mat4 partWorld[MAX_PART_COUNT];uniform float partVisibility[MAX_PART_COUNT];\n#endif\nuniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;\n#if SH_DEGREE>0\nuniform highp usampler2D shTexture0;\n#endif\n#if SH_DEGREE>1\nuniform highp usampler2D shTexture1;\n#endif\n#if SH_DEGREE>2\nuniform highp usampler2D shTexture2;\n#endif\n#if IS_COMPOUND\nuniform sampler2D partIndicesTexture;\n#endif\nvarying vec4 vColor;varying vec2 vPosition;\n#define CUSTOM_VERTEX_DEFINITIONS\n#include<gaussianSplatting>\nvoid main () {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nfloat splatIndex=getSplatIndex(int(position.z+0.5));Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);\n#if IS_COMPOUND\nmat4 splatWorld=getPartWorld(splat.partIndex);\n#else\nmat4 splatWorld=world;\n#endif\nvec4 worldPos=splatWorld*vec4(splat.center.xyz,1.0);vColor=splat.color;vPosition=position.xy;\n#if SH_DEGREE>0\nmat3 worldRot=mat3(splatWorld);mat3 normWorldRot=inverseMat3(worldRot);vec3 eyeToSplatLocalSpace=normalize(normWorldRot*(worldPos.xyz-eyePosition));vColor.xyz=splat.color.xyz+computeSH(splat,eyeToSplatLocalSpace);\n#endif\nvColor.w*=alpha;\n#if IS_COMPOUND\nvColor.w*=partVisibility[splat.partIndex];\n#endif\nvec2 scale=vec2(1.,1.);\n#define CUSTOM_VERTEX_UPDATE\ngl_Position=gaussianSplatting(position.xy,worldPos.xyz,scale,covA,covB,splatWorld,view,projection);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexShader = { name, shader };\n//# sourceMappingURL=gaussianSplatting.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nimport \"./logDepthFragment\";\nimport \"./fogFragment\";\nconst name = \"gaussianSplattingFragmentDeclaration\";\nconst shader = `fn gaussianColor(inColor: vec4f,inPosition: vec2f)->vec4f\n{var A : f32=-dot(inPosition,inPosition);if (A>-4.0)\n{var B: f32=exp(A)*inColor.a;\n#include<logDepthFragment>\nvar color: vec3f=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4f(color,B);} else {return vec4f(0.0);}}\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingFragmentDeclarationWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplattingFragmentDeclaration.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/clipPlaneFragmentDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/fogFragmentDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nimport \"./ShadersInclude/clipPlaneFragment\";\nconst name = \"gaussianSplattingPixelShader\";\nconst shader = `#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vColor: vec4f;varying vPosition: vec2f;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<gaussianSplattingFragmentDeclaration>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvar finalColor: vec4f=gaussianColor(input.vColor,input.vPosition);\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\nfragmentOutputs.color=finalColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingPixelShaderWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplatting.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../../Engines/shaderStore\";\nconst name = \"gaussianSplatting\";\nconst shader = `fn getDataUV(index: f32,dataTextureSize: vec2f)->vec2<f32> {let y: f32=floor(index/dataTextureSize.x);let x: f32=index-y*dataTextureSize.x;return vec2f((x+0.5),(y+0.5));}\nstruct Splat {center: vec4f,\ncolor: vec4f,\ncovA: vec4f,\ncovB: vec4f,\n#if SH_DEGREE>0\nsh0: vec4<u32>,\n#endif\n#if SH_DEGREE>1\nsh1: vec4<u32>,\n#endif\n#if SH_DEGREE>2\nsh2: vec4<u32>,\n#endif\n#if IS_COMPOUND\npartIndex: u32,\n#endif\n};fn getSplatIndex(localIndex: i32,splatIndex0: vec4f,splatIndex1: vec4f,splatIndex2: vec4f,splatIndex3: vec4f)->f32 {var splatIndex: f32;switch (localIndex)\n{case 0:\n{splatIndex=splatIndex0.x;break;}\ncase 1:\n{splatIndex=splatIndex0.y;break;}\ncase 2:\n{splatIndex=splatIndex0.z;break;}\ncase 3:\n{splatIndex=splatIndex0.w;break;}\ncase 4:\n{splatIndex=splatIndex1.x;break;}\ncase 5:\n{splatIndex=splatIndex1.y;break;}\ncase 6:\n{splatIndex=splatIndex1.z;break;}\ncase 7:\n{splatIndex=splatIndex1.w;break;}\ncase 8:\n{splatIndex=splatIndex2.x;break;}\ncase 9:\n{splatIndex=splatIndex2.y;break;}\ncase 10:\n{splatIndex=splatIndex2.z;break;}\ncase 11:\n{splatIndex=splatIndex2.w;break;}\ncase 12:\n{splatIndex=splatIndex3.x;break;}\ncase 13:\n{splatIndex=splatIndex3.y;break;}\ncase 14:\n{splatIndex=splatIndex3.z;break;}\ndefault:\n{splatIndex=splatIndex3.w;break;}}\nreturn splatIndex;}\nfn readSplat(splatIndex: f32,dataTextureSize: vec2f)->Splat {var splat: Splat;let splatUV=getDataUV(splatIndex,dataTextureSize);let splatUVi32=vec2<i32>(i32(splatUV.x),i32(splatUV.y));splat.center=textureLoad(centersTexture,splatUVi32,0);splat.color=textureLoad(colorsTexture,splatUVi32,0);splat.covA=textureLoad(covariancesATexture,splatUVi32,0)*splat.center.w;splat.covB=textureLoad(covariancesBTexture,splatUVi32,0)*splat.center.w;\n#if SH_DEGREE>0\nsplat.sh0=textureLoad(shTexture0,splatUVi32,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=textureLoad(shTexture1,splatUVi32,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=textureLoad(shTexture2,splatUVi32,0);\n#endif\n#if IS_COMPOUND\nsplat.partIndex=u32(textureLoad(partIndicesTexture,splatUVi32,0).r*255.0+0.5);\n#endif\nreturn splat;}\nfn computeColorFromSHDegree(dir: vec3f,sh: array<vec3<f32>,16>)->vec3f\n{let SH_C0: f32=0.28209479;let SH_C1: f32=0.48860251;var SH_C2: array<f32,5>=array<f32,5>(\n1.092548430,\n-1.09254843,\n0.315391565,\n-1.09254843,\n0.546274215\n);var SH_C3: array<f32,7>=array<f32,7>(\n-0.59004358,\n2.890611442,\n-0.45704579,\n0.373176332,\n-0.45704579,\n1.445305721,\n-0.59004358\n);var result: vec3f=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nlet x: f32=dir.x;let y: f32=dir.y;let z: f32=dir.z;result+=-SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nlet xx: f32=x*x;let yy: f32=y*y;let zz: f32=z*z;let xy: f32=x*y;let yz: f32=y*z;let xz: f32=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0f*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0f*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0f*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0f*zz-3.0f*xx-3.0f*yy)*sh[12] +\nSH_C3[4]*x*(4.0f*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0f*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nfn decompose(value: u32)->vec4f\n{let components : vec4f=vec4f(\nf32((value ) & 255u),\nf32((value>>u32( 8)) & 255u),\nf32((value>>u32(16)) & 255u),\nf32((value>>u32(24)) & 255u));return components*vec4f(2./255.)-vec4f(1.);}\nfn computeSH(splat: Splat,dir: vec3f)->vec3f\n{var sh: array<vec3<f32>,16>;sh[0]=vec3f(0.,0.,0.);\n#if SH_DEGREE>0\nlet sh00: vec4f=decompose(splat.sh0.x);let sh01: vec4f=decompose(splat.sh0.y);let sh02: vec4f=decompose(splat.sh0.z);sh[1]=vec3f(sh00.x,sh00.y,sh00.z);sh[2]=vec3f(sh00.w,sh01.x,sh01.y);sh[3]=vec3f(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nlet sh03: vec4f=decompose(splat.sh0.w);let sh04: vec4f=decompose(splat.sh1.x);let sh05: vec4f=decompose(splat.sh1.y);sh[4]=vec3f(sh02.y,sh02.z,sh02.w);sh[5]=vec3f(sh03.x,sh03.y,sh03.z);sh[6]=vec3f(sh03.w,sh04.x,sh04.y);sh[7]=vec3f(sh04.z,sh04.w,sh05.x);sh[8]=vec3f(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nlet sh06: vec4f=decompose(splat.sh1.z);let sh07: vec4f=decompose(splat.sh1.w);let sh08: vec4f=decompose(splat.sh2.x);let sh09: vec4f=decompose(splat.sh2.y);let sh10: vec4f=decompose(splat.sh2.z);let sh11: vec4f=decompose(splat.sh2.w);sh[9]=vec3f(sh06.x,sh06.y,sh06.z);sh[10]=vec3f(sh06.w,sh07.x,sh07.y);sh[11]=vec3f(sh07.z,sh07.w,sh08.x);sh[12]=vec3f(sh08.y,sh08.z,sh08.w);sh[13]=vec3f(sh09.x,sh09.y,sh09.z);sh[14]=vec3f(sh09.w,sh10.x,sh10.y);sh[15]=vec3f(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\nfn gaussianSplatting(\nmeshPos: vec2<f32>,\nworldPos: vec3<f32>,\nscale: vec2<f32>,\ncovA: vec3<f32>,\ncovB: vec3<f32>,\nworldMatrix: mat4x4<f32>,\nviewMatrix: mat4x4<f32>,\nprojectionMatrix: mat4x4<f32>,\nfocal: vec2f,\ninvViewport: vec2f,\nkernelSize: f32\n)->vec4f {let modelView=viewMatrix*worldMatrix;let camspace=viewMatrix*vec4f(worldPos,1.0);let pos2d=projectionMatrix*camspace;let bounds=1.2*pos2d.w;if (pos2d.z<0. || pos2d.x<-bounds || pos2d.x>bounds || pos2d.y<-bounds || pos2d.y>bounds) {return vec4f(0.0,0.0,2.0,1.0);}\nlet Vrk=mat3x3<f32>(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);let isOrtho=abs(projectionMatrix[3][3]-1.0)<0.001;var J: mat3x3<f32>;if (isOrtho) {J=mat3x3<f32>(\nfocal.x,0.0,0.0,\n0.0,focal.y,0.0,\n0.0,0.0,0.0\n);} else {J=mat3x3<f32>(\nfocal.x/camspace.z,0.0,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.0,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.0,0.0,0.0\n);}\nlet T=transpose(mat3x3<f32>(\nmodelView[0].xyz,\nmodelView[1].xyz,\nmodelView[2].xyz))*J;var cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nlet c00: f32=cov2d[0][0];let c11: f32=cov2d[1][1];let c01: f32=cov2d[0][1];let detOrig: f32=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nlet c2d: vec3f=vec3f(cov2d[0][0],c01,cov2d[1][1]);let detBlur: f32=c2d.x*c2d.z-c2d.y*c2d.y;let compensation: f32=sqrt(max(0.,detOrig/detBlur));vertexOutputs.vColor.w*=compensation;\n#endif\nlet mid=(cov2d[0][0]+cov2d[1][1])/2.0;let radius=length(vec2<f32>((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));let lambda1=mid+radius;let lambda2=mid-radius;if (lambda2<0.0) {return vec4f(0.0,0.0,2.0,1.0);}\nlet diagonalVector=normalize(vec2<f32>(cov2d[0][1],lambda1-cov2d[0][0]));let majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;let minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2<f32>(diagonalVector.y,-diagonalVector.x);let vCenter=vec2<f32>(pos2d.x,pos2d.y);let scaleFactor=select(pos2d.w,1.0,isOrtho);return vec4f(\nvCenter+((meshPos.x*majorAxis+meshPos.y*minorAxis)*invViewport*scaleFactor)*scale,\npos2d.z,\npos2d.w\n);}\n#if IS_COMPOUND\nfn getPartWorld(partIndex: u32)->mat4x4<f32> {return uniforms.partWorld[partIndex];}\n#endif\n`;\n// Sideeffect\nif (!ShaderStore.IncludesShadersStoreWGSL[name]) {\n    ShaderStore.IncludesShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplatting.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/helperFunctions\";\nimport \"./ShadersInclude/clipPlaneVertexDeclaration\";\nimport \"./ShadersInclude/fogVertexDeclaration\";\nimport \"./ShadersInclude/logDepthDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\nimport \"./ShadersInclude/clipPlaneVertex\";\nimport \"./ShadersInclude/fogVertex\";\nimport \"./ShadersInclude/logDepthVertex\";\nconst name = \"gaussianSplattingVertexShader\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#include<helperFunctions>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\nattribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;attribute position: vec3f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;uniform eyePosition: vec3f;uniform alpha: f32;\n#if IS_COMPOUND\nuniform partWorld: array<mat4x4<f32>,MAX_PART_COUNT>;uniform partVisibility: array<f32,MAX_PART_COUNT>;\n#endif\nvar covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if SH_DEGREE>0\nvar shTexture0: texture_2d<u32>;\n#endif\n#if SH_DEGREE>1\nvar shTexture1: texture_2d<u32>;\n#endif\n#if SH_DEGREE>2\nvar shTexture2: texture_2d<u32>;\n#endif\n#if IS_COMPOUND\nvar partIndicesTexture: texture_2d<f32>;\n#endif\nvarying vColor: vec4f;varying vPosition: vec2f;\n#define CUSTOM_VERTEX_DEFINITIONS\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nlet splatIndex: f32=getSplatIndex(i32(input.position.z+0.5),input.splatIndex0,input.splatIndex1,input.splatIndex2,input.splatIndex3);var splat: Splat=readSplat(splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);\n#if IS_COMPOUND\nlet splatWorld: mat4x4f=getPartWorld(splat.partIndex);\n#else\nlet splatWorld: mat4x4f=mesh.world;\n#endif\nlet worldPos: vec4f=splatWorld*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position.xy;\n#if SH_DEGREE>0\nlet worldRot: mat3x3f= mat3x3f(splatWorld[0].xyz,splatWorld[1].xyz,splatWorld[2].xyz);let normWorldRot: mat3x3f=inverseMat3(worldRot);var eyeToSplatLocalSpace: vec3f=normalize(normWorldRot*(worldPos.xyz-uniforms.eyePosition.xyz));vertexOutputs.vColor=vec4f(splat.color.xyz+computeSH(splat,eyeToSplatLocalSpace),splat.color.w*uniforms.alpha);\n#else\nvertexOutputs.vColor=vec4f(splat.color.xyz,splat.color.w*uniforms.alpha);\n#endif\n#if IS_COMPOUND\nvertexOutputs.vColor.w*=uniforms.partVisibility[splat.partIndex];\n#endif\nlet scale: vec2f=vec2f(1.,1.);\n#define CUSTOM_VERTEX_UPDATE\nvertexOutputs.position=gaussianSplatting(input.position.xy,worldPos.xyz,scale,covA,covB,splatWorld,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingVertexShaderWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplatting.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nconst name = \"gaussianSplattingDepthPixelShader\";\nconst shader = `precision highp float;varying vec2 vPosition;varying vec4 vColor;\n#ifdef DEPTH_RENDER\nvarying float vDepthMetric;\n#endif\nvoid main(void) {float A=-dot(vPosition,vPosition);\n#if (defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1) || \\\n(defined(DEPTH_RENDER) && defined(ALPHA_BLENDED_DEPTH))\nfloat alpha=exp(A)*vColor.a;if (A<-4.)\ndiscard;\n#else\nif (A<-vColor.a)\ndiscard;\n#endif\n#ifdef DEPTH_RENDER\nfloat opacity=1.0;\n#ifdef ALPHA_BLENDED_DEPTH\nopacity=alpha;\n#endif\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,opacity);\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthPixelShader = { name, shader };\n//# sourceMappingURL=gaussianSplattingDepth.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingVertexDeclaration\";\nimport \"./ShadersInclude/gaussianSplattingUboDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\nconst name = \"gaussianSplattingDepthVertexShader\";\nconst shader = `#include<__decl__gaussianSplattingVertex>\nuniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform float alpha;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;\n#if IS_COMPOUND\nuniform mat4 partWorld[MAX_PART_COUNT];uniform float partVisibility[MAX_PART_COUNT];uniform sampler2D partIndicesTexture;\n#endif\nvarying vec2 vPosition;varying vec4 vColor;\n#include<gaussianSplatting>\n#ifdef DEPTH_RENDER\nuniform vec2 depthValues;varying float vDepthMetric;\n#endif\nvoid main(void) {float splatIndex=getSplatIndex(int(position.z+0.5));Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);\n#if IS_COMPOUND\nmat4 splatWorld=getPartWorld(splat.partIndex);\n#else\nmat4 splatWorld=world;\n#endif\nvec4 worldPosGS=splatWorld*vec4(splat.center.xyz,1.0);vPosition=position.xy;vColor=splat.color;vColor.w*=alpha;\n#if IS_COMPOUND\nvColor.w*=partVisibility[splat.partIndex];\n#endif\ngl_Position=gaussianSplatting(position.xy,worldPosGS.xyz,vec2(1.,1.),covA,covB,splatWorld,view,projection);\n#ifdef DEPTH_RENDER\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStore[name]) {\n    ShaderStore.ShadersStore[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthVertexShader = { name, shader };\n//# sourceMappingURL=gaussianSplattingDepth.vertex.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/gaussianSplattingFragmentDeclaration\";\nconst name = \"gaussianSplattingDepthPixelShader\";\nconst shader = `#include<gaussianSplattingFragmentDeclaration>\nvarying vPosition: vec2f;varying vColor: vec4f;\n#ifdef DEPTH_RENDER\nvarying vDepthMetric: f32;\n#endif\nfn checkDiscard(inPosition: vec2f,inColor: vec4f)->vec4f {var A : f32=-dot(inPosition,inPosition);var alpha : f32=exp(A)*inColor.a;\n#if (defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1) || \\\n(defined(DEPTH_RENDER) && defined(ALPHA_BLENDED_DEPTH))\nif (A<-4.) {discard;}\n#else\nif (A<-inColor.a) {discard;}\n#endif\n#ifdef DEPTH_RENDER\nvar opacity : f32=1.0;\n#ifdef ALPHA_BLENDED_DEPTH\nopacity=alpha;\n#endif\nreturn vec4f(fragmentInputs.vDepthMetric,0.0,0.0,opacity);\n#else\nreturn vec4f(inColor.rgb,alpha);\n#endif\n}\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=checkDiscard(fragmentInputs.vPosition,fragmentInputs.vColor);\n#if (defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1) || \\\n(defined(DEPTH_RENDER) && defined(ALPHA_BLENDED_DEPTH))\nvar alpha : f32=fragmentOutputs.color.a;\n#endif\n}\n`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthPixelShaderWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplattingDepth.fragment.js.map","// Do not edit.\nimport { ShaderStore } from \"../Engines/shaderStore\";\nimport \"./ShadersInclude/sceneUboDeclaration\";\nimport \"./ShadersInclude/meshUboDeclaration\";\nimport \"./ShadersInclude/gaussianSplatting\";\nconst name = \"gaussianSplattingDepthVertexShader\";\nconst shader = `#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;attribute position: vec3f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;uniform alpha: f32;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if IS_COMPOUND\nuniform partWorld: array<mat4x4<f32>,MAX_PART_COUNT>;uniform partVisibility: array<f32,MAX_PART_COUNT>;var partIndicesTexture: texture_2d<f32>;\n#endif\nvarying vPosition: vec2f;varying vColor: vec4f;\n#ifdef DEPTH_RENDER\nuniform depthValues: vec2f;varying vDepthMetric: f32;\n#endif\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {let splatIndex: f32=getSplatIndex(i32(input.position.z+0.5),input.splatIndex0,input.splatIndex1,input.splatIndex2,input.splatIndex3);var splat: Splat=readSplat(splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);\n#if IS_COMPOUND\nlet splatWorld: mat4x4f=getPartWorld(splat.partIndex);\n#else\nlet splatWorld: mat4x4f=mesh.world;\n#endif\nlet worldPos: vec4f=splatWorld*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position.xy;vertexOutputs.vColor=splat.color;vertexOutputs.vColor.w*=uniforms.alpha;\n#if IS_COMPOUND\nvertexOutputs.vColor.w*=uniforms.partVisibility[splat.partIndex];\n#endif\nvertexOutputs.position=gaussianSplatting(input.position.xy,worldPos.xyz,vec2f(1.0,1.0),covA,covB,splatWorld,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);\n#ifdef DEPTH_RENDER\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric=((-vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#else\nvertexOutputs.vDepthMetric=((vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#endif\n#endif\n}`;\n// Sideeffect\nif (!ShaderStore.ShadersStoreWGSL[name]) {\n    ShaderStore.ShadersStoreWGSL[name] = shader;\n}\n/** @internal */\nexport const gaussianSplattingDepthVertexShaderWGSL = { name, shader };\n//# sourceMappingURL=gaussianSplattingDepth.vertex.js.map","import { SerializationHelper } from \"../../Misc/decorators.serialization\";\nimport { VertexBuffer } from \"../../Buffers/buffer\";\nimport { MaterialDefines } from \"../../Materials/materialDefines\";\nimport { PushMaterial } from \"../../Materials/pushMaterial\";\nimport { RegisterClass } from \"../../Misc/typeStore\";\nimport { AddClipPlaneUniforms, BindClipPlane } from \"../clipPlaneMaterialHelper\";\nimport { Camera } from \"../../Cameras/camera\";\nimport { ShadowDepthWrapper } from \"../../Materials/shadowDepthWrapper\";\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial\";\nimport { Material } from \"../material\";\nimport \"../../Shaders/gaussianSplatting.fragment\";\nimport \"../../Shaders/gaussianSplatting.vertex\";\nimport \"../../ShadersWGSL/gaussianSplatting.fragment\";\nimport \"../../ShadersWGSL/gaussianSplatting.vertex\";\nimport \"../../Shaders/gaussianSplattingDepth.fragment\";\nimport \"../../Shaders/gaussianSplattingDepth.vertex\";\nimport \"../../ShadersWGSL/gaussianSplattingDepth.fragment\";\nimport \"../../ShadersWGSL/gaussianSplattingDepth.vertex\";\nimport { BindFogParameters, BindLogDepth, PrepareAttributesForInstances, PrepareDefinesForAttributes, PrepareDefinesForFrameBoundValues, PrepareDefinesForMisc, PrepareUniformsAndSamplersList, } from \"../materialHelper.functions\";\n// Can be up to 256, then we'll need to change the partIndices texture format to uint16\n// with Mac WebGL 2 on Apple Silicon, we can encounter lower MAX_UNIFORM_BLOCK_SIZE limits (16 KB compared to 64 KB)\n// Using 128 to be conservative and not fail to compile splat shaders.\nexport const GaussianSplattingMaxPartCount = 128;\n/**\n * @internal\n */\nclass GaussianSplattingMaterialDefines extends MaterialDefines {\n    /**\n     * Constructor of the defines.\n     * @param externalProperties External properties (e.g. from material plugins) to add to the defines.\n     */\n    constructor(externalProperties) {\n        super(externalProperties);\n        /** Defines whether fog is enabled */\n        this.FOG = false;\n        /** Defines whether thin instances are used */\n        this.THIN_INSTANCES = true;\n        /** Defines whether logarithmic depth is enabled */\n        this.LOGARITHMICDEPTH = false;\n        /** Defines whether clip plane 1 is enabled */\n        this.CLIPPLANE = false;\n        /** Defines whether clip plane 2 is enabled */\n        this.CLIPPLANE2 = false;\n        /** Defines whether clip plane 3 is enabled */\n        this.CLIPPLANE3 = false;\n        /** Defines whether clip plane 4 is enabled */\n        this.CLIPPLANE4 = false;\n        /** Defines whether clip plane 5 is enabled */\n        this.CLIPPLANE5 = false;\n        /** Defines whether clip plane 6 is enabled */\n        this.CLIPPLANE6 = false;\n        /** Defines the spherical harmonics degree */\n        this.SH_DEGREE = 0;\n        /** Defines whether compensation is applied */\n        this.COMPENSATION = false;\n        /** Defines whether this is a compound splat */\n        this.IS_COMPOUND = false;\n        /** Defines the maximum number of parts */\n        this.MAX_PART_COUNT = GaussianSplattingMaxPartCount;\n        this.rebuild();\n    }\n}\n/**\n * GaussianSplattingMaterial material used to render Gaussian Splatting\n * @experimental\n */\nexport class GaussianSplattingMaterial extends PushMaterial {\n    /**\n     * Instantiates a Gaussian Splatting Material in the given scene\n     * @param name The friendly name of the material\n     * @param scene The scene to add the material to\n     */\n    constructor(name, scene) {\n        super(name, scene);\n        /**\n         * Point spread function (default 0.3). Can be overriden per GS material, otherwise, using default static `KernelSize` value\n         */\n        this.kernelSize = GaussianSplattingMaterial.KernelSize;\n        this._compensation = GaussianSplattingMaterial.Compensation;\n        // set to true when material defines are dirty\n        this._isDirty = false;\n        this._sourceMesh = null;\n        this.backFaceCulling = false;\n        this.shadowDepthWrapper = GaussianSplattingMaterial._MakeGaussianSplattingShadowDepthWrapper(scene, this.shaderLanguage);\n    }\n    /**\n     * Set compensation default value is `GaussianSplattingMaterial.Compensation`\n     */\n    set compensation(value) {\n        this._isDirty = this._isDirty != value;\n        this._compensation = value;\n    }\n    /**\n     * Get compensation\n     */\n    get compensation() {\n        return this._compensation;\n    }\n    /**\n     * Gets a boolean indicating that current material needs to register RTT\n     */\n    get hasRenderTargetTextures() {\n        return false;\n    }\n    /**\n     * Specifies whether or not this material should be rendered in alpha test mode.\n     * @returns false\n     */\n    needAlphaTesting() {\n        return false;\n    }\n    /**\n     * Specifies whether or not this material should be rendered in alpha blend mode.\n     * @returns true\n     */\n    needAlphaBlending() {\n        return true;\n    }\n    /**\n     * Checks whether the material is ready to be rendered for a given mesh.\n     * @param mesh The mesh to render\n     * @param subMesh The submesh to check against\n     * @returns true if all the dependencies are ready (Textures, Effects...)\n     */\n    isReadyForSubMesh(mesh, subMesh) {\n        const useInstances = true;\n        const drawWrapper = subMesh._drawWrapper;\n        let defines = subMesh.materialDefines;\n        if (defines && this._isDirty) {\n            defines.markAsUnprocessed();\n        }\n        if (drawWrapper.effect && this.isFrozen) {\n            if (drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        if (!subMesh.materialDefines) {\n            this._callbackPluginEventGeneric(4 /* MaterialPluginEvent.GetDefineNames */, this._eventInfo);\n            defines = subMesh.materialDefines = new GaussianSplattingMaterialDefines(this._eventInfo.defineNames);\n        }\n        const scene = this.getScene();\n        if (this._isReadyForSubMesh(subMesh)) {\n            return true;\n        }\n        // Check plugin readiness\n        this._eventInfo.isReadyForSubMesh = true;\n        this._eventInfo.defines = defines;\n        this._eventInfo.subMesh = subMesh;\n        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);\n        if (!this._eventInfo.isReadyForSubMesh) {\n            return false;\n        }\n        if (!this._sourceMesh) {\n            return false;\n        }\n        const engine = scene.getEngine();\n        const gsMesh = this._sourceMesh;\n        // Misc.\n        PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, false, defines, undefined, undefined, undefined, this._isVertexOutputInvariant);\n        // Values that need to be evaluated on every frame\n        PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, true);\n        // Attribs\n        PrepareDefinesForAttributes(mesh, defines, false, false);\n        // SH is disabled for webGL1\n        if (engine.version > 1 || engine.isWebGPU) {\n            defines[\"SH_DEGREE\"] = gsMesh.shDegree;\n        }\n        defines[\"IS_COMPOUND\"] = gsMesh.isCompound;\n        // Compensation\n        const splatMaterial = gsMesh.material;\n        defines[\"COMPENSATION\"] = splatMaterial && splatMaterial.compensation ? splatMaterial.compensation : GaussianSplattingMaterial.Compensation;\n        // Get correct effect\n        if (defines.isDirty) {\n            defines.markAsProcessed();\n            scene.resetCachedMaterial();\n            //Attributes\n            PrepareAttributesForInstances(GaussianSplattingMaterial._Attribs, defines);\n            const attribs = GaussianSplattingMaterial._Attribs.slice();\n            const uniforms = GaussianSplattingMaterial._Uniforms.slice();\n            const samplers = GaussianSplattingMaterial._Samplers.slice();\n            const uniformBuffers = GaussianSplattingMaterial._UniformBuffers.slice();\n            PrepareUniformsAndSamplersList({\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: defines,\n            });\n            AddClipPlaneUniforms(uniforms);\n            // Let plugin manager prepare its uniform/sampler/ubo lists\n            if (!this._uniformBufferLayoutBuilt) {\n                this.buildUniformLayout();\n            }\n            // Prepare plugin effect\n            this._eventInfo.fallbackRank = 0;\n            this._eventInfo.defines = defines;\n            this._eventInfo.attributes = attribs;\n            this._eventInfo.uniforms = uniforms;\n            this._eventInfo.samplers = samplers;\n            this._eventInfo.uniformBuffersNames = uniformBuffers;\n            this._eventInfo.customCode = undefined;\n            this._eventInfo.mesh = mesh;\n            this._callbackPluginEventGeneric(128 /* MaterialPluginEvent.PrepareEffect */, this._eventInfo);\n            const join = defines.toString();\n            const effect = scene.getEngine().createEffect(\"gaussianSplatting\", {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: join,\n                onCompiled: this.onCompiled,\n                onError: this.onError,\n                indexParameters: {},\n                processCodeAfterIncludes: this._eventInfo.customCode,\n                shaderLanguage: this._shaderLanguage,\n                extraInitializationsAsync: async () => {\n                    if (this._shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n                        await Promise.all([import(\"../../ShadersWGSL/gaussianSplatting.fragment\"), import(\"../../ShadersWGSL/gaussianSplatting.vertex\")]);\n                    }\n                    else {\n                        await Promise.all([import(\"../../Shaders/gaussianSplatting.fragment\"), import(\"../../Shaders/gaussianSplatting.vertex\")]);\n                    }\n                },\n            }, engine);\n            subMesh.setEffect(effect, defines, this._materialContext);\n        }\n        if (!subMesh.effect || !subMesh.effect.isReady()) {\n            return false;\n        }\n        defines._renderId = scene.getRenderId();\n        drawWrapper._wasPreviouslyReady = true;\n        drawWrapper._wasPreviouslyUsingInstances = useInstances;\n        this._isDirty = false;\n        return true;\n    }\n    /**\n     * GaussianSplattingMaterial belongs to a single mesh\n     * @param mesh mesh this material belongs to\n     */\n    setSourceMesh(mesh) {\n        this._sourceMesh = mesh;\n    }\n    /**\n     * Bind material effect for a specific Gaussian Splatting mesh\n     * @param mesh Gaussian splatting mesh\n     * @param effect Splatting material or node material\n     * @param scene scene that contains mesh and camera used for rendering\n     */\n    static BindEffect(mesh, effect, scene) {\n        const engine = scene.getEngine();\n        const camera = scene.activeCamera;\n        const renderWidth = engine.getRenderWidth() * camera.viewport.width;\n        const renderHeight = engine.getRenderHeight() * camera.viewport.height;\n        const gsMaterial = mesh.material;\n        if (!gsMaterial._sourceMesh) {\n            return;\n        }\n        const gsMesh = gsMaterial._sourceMesh;\n        // check if rigcamera, get number of rigs\n        const numberOfRigs = camera?.rigParent?.rigCameras.length || 1;\n        effect.setFloat2(\"invViewport\", 1 / (renderWidth / numberOfRigs), 1 / renderHeight);\n        let focal = 1000;\n        if (camera) {\n            /*\n            more explicit version:\n            const t = camera.getProjectionMatrix().m[5];\n            const FovY = Math.atan(1.0 / t) * 2.0;\n            focal = renderHeight / 2.0 / Math.tan(FovY / 2.0);\n            Using a shorter version here to not have tan(atan) and 2.0 factor\n            */\n            const t = camera.getProjectionMatrix().m[5];\n            if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\n                focal = (renderHeight * t) / 2.0;\n            }\n            else {\n                focal = (renderWidth * t) / 2.0;\n            }\n        }\n        effect.setFloat2(\"focal\", focal, focal);\n        effect.setFloat(\"kernelSize\", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : GaussianSplattingMaterial.KernelSize);\n        effect.setFloat(\"alpha\", gsMaterial.alpha);\n        scene.bindEyePosition(effect, \"eyePosition\", true);\n        if (gsMesh.covariancesATexture) {\n            const textureSize = gsMesh.covariancesATexture.getSize();\n            effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\n            effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\n            effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\n            effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\n            effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\n            if (gsMesh.shTextures) {\n                for (let i = 0; i < gsMesh.shTextures?.length; i++) {\n                    effect.setTexture(`shTexture${i}`, gsMesh.shTextures[i]);\n                }\n            }\n            // Bind part indices texture, if the\n            if (gsMesh.partIndicesTexture) {\n                effect.setTexture(\"partIndicesTexture\", gsMesh.partIndicesTexture);\n                // Bind part world matrices\n                const partWorldData = new Float32Array(gsMesh.partCount * 16);\n                for (let i = 0; i < gsMesh.partCount; i++) {\n                    gsMesh.getWorldMatrixForPart(i).toArray(partWorldData, i * 16);\n                }\n                effect.setMatrices(\"partWorld\", partWorldData);\n                // Bind part visibility data\n                const partVisibilityData = [];\n                for (let i = 0; i < gsMesh.partCount; i++) {\n                    partVisibilityData.push(gsMesh.partVisibility[i] ?? 1.0);\n                }\n                effect.setArray(\"partVisibility\", partVisibilityData);\n            }\n        }\n    }\n    /**\n     * Binds the submesh to this material by preparing the effect and shader to draw\n     * @param world defines the world transformation matrix\n     * @param mesh defines the mesh containing the submesh\n     * @param subMesh defines the submesh to bind the material to\n     */\n    bindForSubMesh(world, mesh, subMesh) {\n        const scene = this.getScene();\n        const defines = subMesh.materialDefines;\n        if (!defines) {\n            return;\n        }\n        const effect = subMesh.effect;\n        if (!effect) {\n            return;\n        }\n        this._activeEffect = effect;\n        // Matrices Mesh.\n        mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n        mesh.transferToEffect(world);\n        // Bind data\n        const mustRebind = this._mustRebind(scene, effect, subMesh, mesh.visibility);\n        if (mustRebind) {\n            this.bindView(effect);\n            this.bindViewProjection(effect);\n            GaussianSplattingMaterial.BindEffect(mesh, this._activeEffect, scene);\n            // Clip plane\n            BindClipPlane(effect, this, scene);\n        }\n        else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {\n            this._needToBindSceneUbo = true;\n        }\n        // Fog\n        BindFogParameters(scene, mesh, effect);\n        // Log. depth\n        if (this.useLogarithmicDepth) {\n            BindLogDepth(defines, effect, scene);\n        }\n        // Bind plugins\n        this._eventInfo.subMesh = subMesh;\n        this._callbackPluginEventBindForSubMesh(this._eventInfo);\n        this._afterBind(mesh, this._activeEffect, subMesh);\n    }\n    static _BindEffectUniforms(gsMesh, gsMaterial, shaderMaterial, scene) {\n        const engine = scene.getEngine();\n        const effect = shaderMaterial.getEffect();\n        const camera = scene.activeCamera;\n        if (!camera) {\n            return;\n        }\n        gsMesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n        shaderMaterial.bindView(effect);\n        shaderMaterial.bindViewProjection(effect);\n        const renderWidth = engine.getRenderWidth() * camera.viewport.width;\n        const renderHeight = engine.getRenderHeight() * camera.viewport.height;\n        effect.setFloat2(\"invViewport\", 1 / renderWidth, 1 / renderHeight);\n        let focal = 1000;\n        if (camera) {\n            /*\n            more explicit version:\n            const t = camera.getProjectionMatrix().m[5];\n            const FovY = Math.atan(1.0 / t) * 2.0;\n            focal = renderHeight / 2.0 / Math.tan(FovY / 2.0);\n            Using a shorter version here to not have tan(atan) and 2.0 factor\n            */\n            const t = camera.getProjectionMatrix().m[5];\n            if (camera.fovMode == Camera.FOVMODE_VERTICAL_FIXED) {\n                focal = (renderHeight * t) / 2.0;\n            }\n            else {\n                focal = (renderWidth * t) / 2.0;\n            }\n        }\n        effect.setFloat2(\"focal\", focal, focal);\n        effect.setFloat(\"kernelSize\", gsMaterial && gsMaterial.kernelSize ? gsMaterial.kernelSize : GaussianSplattingMaterial.KernelSize);\n        effect.setFloat(\"alpha\", gsMaterial.alpha);\n        let minZ, maxZ;\n        const cameraIsOrtho = camera.mode === Camera.ORTHOGRAPHIC_CAMERA;\n        if (cameraIsOrtho) {\n            minZ = !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n            maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;\n        }\n        else {\n            minZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? camera.minZ : engine.isNDCHalfZRange ? 0 : camera.minZ;\n            maxZ = engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : camera.maxZ;\n        }\n        effect.setFloat2(\"depthValues\", minZ, minZ + maxZ);\n        if (gsMesh.covariancesATexture) {\n            const textureSize = gsMesh.covariancesATexture.getSize();\n            effect.setFloat2(\"dataTextureSize\", textureSize.width, textureSize.height);\n            effect.setTexture(\"covariancesATexture\", gsMesh.covariancesATexture);\n            effect.setTexture(\"covariancesBTexture\", gsMesh.covariancesBTexture);\n            effect.setTexture(\"centersTexture\", gsMesh.centersTexture);\n            effect.setTexture(\"colorsTexture\", gsMesh.colorsTexture);\n            if (gsMesh.partIndicesTexture) {\n                effect.setTexture(\"partIndicesTexture\", gsMesh.partIndicesTexture);\n                const partWorldData = new Float32Array(gsMesh.partCount * 16);\n                for (let i = 0; i < gsMesh.partCount; i++) {\n                    gsMesh.getWorldMatrixForPart(i).toArray(partWorldData, i * 16);\n                }\n                effect.setMatrices(\"partWorld\", partWorldData);\n                const partVisibilityData = [];\n                for (let i = 0; i < gsMesh.partCount; i++) {\n                    partVisibilityData.push(gsMesh.partVisibility[i] ?? 1.0);\n                }\n                effect.setArray(\"partVisibility\", partVisibilityData);\n            }\n        }\n    }\n    /**\n     * Create a depth rendering material for a Gaussian Splatting mesh\n     * @param scene scene it belongs to\n     * @param shaderLanguage GLSL or WGSL\n     * @param alphaBlendedDepth whether to enable alpha blended depth rendering\n     * @param compoundMesh whether the mesh is a compound mesh\n     * @returns depth rendering shader material\n     */\n    makeDepthRenderingMaterial(scene, shaderLanguage, alphaBlendedDepth = false, compoundMesh = false) {\n        const defines = [\"#define DEPTH_RENDER\"];\n        if (alphaBlendedDepth) {\n            defines.push(\"#define ALPHA_BLENDED_DEPTH\");\n        }\n        if (compoundMesh) {\n            defines.push(\"#define IS_COMPOUND\");\n            defines.push(`#define MAX_PART_COUNT ${GaussianSplattingMaxPartCount}`);\n        }\n        const shaderMaterial = new ShaderMaterial(\"gaussianSplattingDepthRender\", scene, {\n            vertex: \"gaussianSplattingDepth\",\n            fragment: \"gaussianSplattingDepth\",\n        }, {\n            attributes: GaussianSplattingMaterial._Attribs,\n            uniforms: GaussianSplattingMaterial._Uniforms,\n            samplers: GaussianSplattingMaterial._Samplers,\n            uniformBuffers: GaussianSplattingMaterial._UniformBuffers,\n            shaderLanguage: shaderLanguage,\n            defines: defines,\n            needAlphaBlending: alphaBlendedDepth,\n        });\n        shaderMaterial.onBindObservable.add((mesh) => {\n            const gsMaterial = mesh.material;\n            const gsMesh = mesh;\n            GaussianSplattingMaterial._BindEffectUniforms(gsMesh, gsMaterial, shaderMaterial, scene);\n        });\n        return shaderMaterial;\n    }\n    static _MakeGaussianSplattingShadowDepthWrapper(scene, shaderLanguage) {\n        const shaderMaterial = new ShaderMaterial(\"gaussianSplattingDepth\", scene, {\n            vertex: \"gaussianSplattingDepth\",\n            fragment: \"gaussianSplattingDepth\",\n        }, {\n            attributes: GaussianSplattingMaterial._Attribs,\n            uniforms: GaussianSplattingMaterial._Uniforms,\n            samplers: GaussianSplattingMaterial._Samplers,\n            uniformBuffers: GaussianSplattingMaterial._UniformBuffers,\n            shaderLanguage: shaderLanguage,\n        });\n        const shadowDepthWrapper = new ShadowDepthWrapper(shaderMaterial, scene, {\n            standalone: true,\n        });\n        shaderMaterial.onBindObservable.add((mesh) => {\n            const gsMaterial = mesh.material;\n            const gsMesh = mesh;\n            GaussianSplattingMaterial._BindEffectUniforms(gsMesh, gsMaterial, shaderMaterial, scene);\n        });\n        return shadowDepthWrapper;\n    }\n    /**\n     * Clones the material.\n     * @param name The cloned name.\n     * @returns The cloned material.\n     */\n    clone(name) {\n        const clone = SerializationHelper.Clone(() => new GaussianSplattingMaterial(name, this.getScene()), this);\n        clone.id = name;\n        clone.name = name;\n        this._clonePlugins(clone, \"\");\n        return clone;\n    }\n    /**\n     * Serializes the current material to its JSON representation.\n     * @returns The JSON representation.\n     */\n    serialize() {\n        const serializationObject = super.serialize();\n        serializationObject.customType = \"BABYLON.GaussianSplattingMaterial\";\n        return serializationObject;\n    }\n    /**\n     * Gets the class name of the material\n     * @returns \"GaussianSplattingMaterial\"\n     */\n    getClassName() {\n        return \"GaussianSplattingMaterial\";\n    }\n    /**\n     * Parse a JSON input to create back a Gaussian Splatting material.\n     * @param source The JSON data to parse\n     * @param scene The scene to create the parsed material in\n     * @param rootUrl The root url of the assets the material depends upon\n     * @returns the instantiated GaussianSplattingMaterial.\n     */\n    static Parse(source, scene, rootUrl) {\n        const material = SerializationHelper.Parse(() => new GaussianSplattingMaterial(source.name, scene), source, scene, rootUrl);\n        Material._ParsePlugins(source, material, scene, rootUrl);\n        return material;\n    }\n}\n/**\n * Point spread function (default 0.3). Can be overriden per GS material\n */\nGaussianSplattingMaterial.KernelSize = 0.3;\n/**\n * Compensation\n */\nGaussianSplattingMaterial.Compensation = false;\nGaussianSplattingMaterial._Attribs = [VertexBuffer.PositionKind, \"splatIndex0\", \"splatIndex1\", \"splatIndex2\", \"splatIndex3\"];\nGaussianSplattingMaterial._Samplers = [\"covariancesATexture\", \"covariancesBTexture\", \"centersTexture\", \"colorsTexture\", \"shTexture0\", \"shTexture1\", \"shTexture2\", \"partIndicesTexture\"];\nGaussianSplattingMaterial._UniformBuffers = [\"Scene\", \"Mesh\"];\nGaussianSplattingMaterial._Uniforms = [\n    \"world\",\n    \"view\",\n    \"projection\",\n    \"vFogInfos\",\n    \"vFogColor\",\n    \"logarithmicDepthConstant\",\n    \"invViewport\",\n    \"dataTextureSize\",\n    \"focal\",\n    \"eyePosition\",\n    \"kernelSize\",\n    \"alpha\",\n    \"depthValues\",\n    \"partWorld\",\n    \"partVisibility\",\n];\nRegisterClass(\"BABYLON.GaussianSplattingMaterial\", GaussianSplattingMaterial);\n//# sourceMappingURL=gaussianSplattingMaterial.js.map","/* eslint-disable @typescript-eslint/naming-convention */\nimport * as functions from \"./math.scalar.functions\";\nconst HCF = functions.HighestCommonFactor;\n/**\n * Scalar computation library\n */\nexport const Scalar = {\n    ...functions,\n    /**\n     * Two pi constants convenient for computation.\n     */\n    TwoPi: Math.PI * 2,\n    /**\n     * Returns -1 if value is negative and +1 is value is positive.\n     * @param value the value\n     * @returns the value itself if it's equal to zero.\n     */\n    Sign: Math.sign,\n    /**\n     * the log2 of value.\n     * @param value the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    Log2: Math.log2,\n    /**\n     * Returns the highest common factor of two integers.\n     * @param a first parameter\n     * @param b second parameter\n     * @returns HCF of a and b\n     */\n    HCF,\n};\n/* eslint-enable @typescript-eslint/naming-convention */\n//# sourceMappingURL=math.scalar.js.map","import { Mesh } from \"../mesh\";\nimport { BoundingInfo } from \"../../Culling/boundingInfo\";\nimport { PickingInfo } from \"../../Collisions/pickingInfo\";\nimport { Vector3 } from \"../../Maths/math.vector\";\n/**\n * Class used as a proxy mesh for a part of a compound Gaussian Splatting mesh\n */\nexport class GaussianSplattingPartProxyMesh extends Mesh {\n    /**\n     * Gets the index of the part in the compound mesh\n     */\n    get partIndex() {\n        return this._partIndex;\n    }\n    /**\n     * Creates a new Gaussian Splatting part proxy mesh\n     * @param name The name of the proxy mesh\n     * @param scene The scene the proxy mesh belongs to\n     * @param compoundSplatMesh The original Gaussian Splatting mesh that was merged into the compound\n     * @param proxiedMesh The Gaussian Splatting mesh that this proxy represents a part of\n     * @param partIndex The index of the part in the compound mesh\n     */\n    constructor(name, scene, compoundSplatMesh, proxiedMesh, partIndex) {\n        super(name, scene);\n        this.proxiedMesh = proxiedMesh;\n        this._partIndex = partIndex;\n        this.compoundSplatMesh = compoundSplatMesh;\n        // Set bounding info based on the source mesh's bounds\n        this.updateBoundingInfoFromProxiedMesh();\n        this.compoundSplatMesh.setWorldMatrixForPart(this.partIndex, this.getWorldMatrix());\n        // Update the proxied mesh's part matrix when this proxy's world matrix changes\n        this.onAfterWorldMatrixUpdateObservable.add(() => {\n            this.compoundSplatMesh.setWorldMatrixForPart(this.partIndex, this.getWorldMatrix());\n            this.updateBoundingInfoFromProxiedMesh();\n        });\n    }\n    /**\n     * Updates the bounding info of this proxy mesh from the proxied mesh\n     */\n    updateBoundingInfoFromProxiedMesh() {\n        const boundingInfo = this.proxiedMesh.getBoundingInfo();\n        this.setBoundingInfo(new BoundingInfo(boundingInfo.minimum.clone(), boundingInfo.maximum.clone()));\n    }\n    /**\n     * Returns the class name\n     * @returns \"GaussianSplattingPartProxyMesh\"\n     */\n    getClassName() {\n        return \"GaussianSplattingPartProxyMesh\";\n    }\n    /**\n     * Updates the part index for this proxy mesh.\n     * This should only be called internally when parts are removed from the compound mesh.\n     * @param newPartIndex the new part index\n     * @internal\n     */\n    updatePartIndex(newPartIndex) {\n        this._partIndex = newPartIndex;\n    }\n    /**\n     * Gets whether the part is visible\n     */\n    get isVisible() {\n        return this.compoundSplatMesh.getPartVisibility(this.partIndex) > 0;\n    }\n    /**\n     * Sets whether the part is visible\n     */\n    set isVisible(value) {\n        this.compoundSplatMesh.setPartVisibility(this.partIndex, value ? 1.0 : 0.0);\n    }\n    /**\n     * Gets the visibility of the part (0.0 to 1.0)\n     */\n    get visibility() {\n        return this.compoundSplatMesh.getPartVisibility(this.partIndex);\n    }\n    /**\n     * Sets the visibility of the part (0.0 to 1.0)\n     */\n    set visibility(value) {\n        this.compoundSplatMesh.setPartVisibility(this.partIndex, value);\n    }\n    /**\n     * Checks if a ray intersects with this proxy mesh using only bounding info\n     * @param ray defines the ray to test\n     * @returns the picking info with this mesh set as pickedMesh if hit\n     */\n    intersects(ray) {\n        const pickingInfo = new PickingInfo();\n        const boundingInfo = this.getBoundingInfo();\n        if (!boundingInfo) {\n            return pickingInfo;\n        }\n        // Always check against bounding info for proxy meshes\n        if (!ray.intersectsSphere(boundingInfo.boundingSphere) || !ray.intersectsBox(boundingInfo.boundingBox)) {\n            return pickingInfo;\n        }\n        // If we hit the bounding volume, report this mesh as picked\n        pickingInfo.hit = true;\n        pickingInfo.pickedMesh = this;\n        pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);\n        pickingInfo.subMeshId = 0;\n        return pickingInfo;\n    }\n}\n//# sourceMappingURL=gaussianSplattingPartProxyMesh.js.map","import { SubMesh } from \"../subMesh\";\nimport { Mesh } from \"../mesh\";\nimport { VertexData } from \"../mesh.vertexData\";\nimport { Matrix, TmpVectors, Vector2, Vector3 } from \"core/Maths/math.vector\";\nimport { Quaternion } from \"core/Maths/math.vector\";\nimport { Logger } from \"core/Misc/logger\";\nimport { GaussianSplattingMaterial, GaussianSplattingMaxPartCount } from \"core/Materials/GaussianSplatting/gaussianSplattingMaterial\";\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\nimport { Constants } from \"core/Engines/constants\";\nimport \"core/Meshes/thinInstanceMesh\";\nimport { ToHalfFloat } from \"core/Misc/textureTools\";\nimport { Scalar } from \"core/Maths/math.scalar\";\nimport { runCoroutineSync, runCoroutineAsync, createYieldingScheduler } from \"core/Misc/coroutine\";\nimport { EngineStore } from \"core/Engines/engineStore\";\nimport { Camera } from \"core/Cameras/camera\";\nimport { ImportMeshAsync } from \"core/Loading/sceneLoader\";\nimport { GaussianSplattingPartProxyMesh } from \"./gaussianSplattingPartProxyMesh\";\nconst IsNative = typeof _native !== \"undefined\";\nconst Native = IsNative ? _native : null;\n// @internal\nconst UnpackUnorm = (value, bits) => {\n    const t = (1 << bits) - 1;\n    return (value & t) / t;\n};\n// @internal\nconst Unpack111011 = (value, result) => {\n    result.x = UnpackUnorm(value >>> 21, 11);\n    result.y = UnpackUnorm(value >>> 11, 10);\n    result.z = UnpackUnorm(value, 11);\n};\n// @internal\nconst Unpack8888 = (value, result) => {\n    result[0] = UnpackUnorm(value >>> 24, 8) * 255;\n    result[1] = UnpackUnorm(value >>> 16, 8) * 255;\n    result[2] = UnpackUnorm(value >>> 8, 8) * 255;\n    result[3] = UnpackUnorm(value, 8) * 255;\n};\n// @internal\n// unpack quaternion with 2,10,10,10 format (largest element, 3x10bit element)\nconst UnpackRot = (value, result) => {\n    const norm = 1.0 / (Math.sqrt(2) * 0.5);\n    const a = (UnpackUnorm(value >>> 20, 10) - 0.5) * norm;\n    const b = (UnpackUnorm(value >>> 10, 10) - 0.5) * norm;\n    const c = (UnpackUnorm(value, 10) - 0.5) * norm;\n    const m = Math.sqrt(1.0 - (a * a + b * b + c * c));\n    switch (value >>> 30) {\n        case 0:\n            result.set(m, a, b, c);\n            break;\n        case 1:\n            result.set(a, m, b, c);\n            break;\n        case 2:\n            result.set(a, b, m, c);\n            break;\n        case 3:\n            result.set(a, b, c, m);\n            break;\n    }\n};\n/**\n * Representation of the types\n */\nvar PLYType;\n(function (PLYType) {\n    PLYType[PLYType[\"FLOAT\"] = 0] = \"FLOAT\";\n    PLYType[PLYType[\"INT\"] = 1] = \"INT\";\n    PLYType[PLYType[\"UINT\"] = 2] = \"UINT\";\n    PLYType[PLYType[\"DOUBLE\"] = 3] = \"DOUBLE\";\n    PLYType[PLYType[\"UCHAR\"] = 4] = \"UCHAR\";\n    PLYType[PLYType[\"UNDEFINED\"] = 5] = \"UNDEFINED\";\n})(PLYType || (PLYType = {}));\n/**\n * Usage types of the PLY values\n */\nvar PLYValue;\n(function (PLYValue) {\n    PLYValue[PLYValue[\"MIN_X\"] = 0] = \"MIN_X\";\n    PLYValue[PLYValue[\"MIN_Y\"] = 1] = \"MIN_Y\";\n    PLYValue[PLYValue[\"MIN_Z\"] = 2] = \"MIN_Z\";\n    PLYValue[PLYValue[\"MAX_X\"] = 3] = \"MAX_X\";\n    PLYValue[PLYValue[\"MAX_Y\"] = 4] = \"MAX_Y\";\n    PLYValue[PLYValue[\"MAX_Z\"] = 5] = \"MAX_Z\";\n    PLYValue[PLYValue[\"MIN_SCALE_X\"] = 6] = \"MIN_SCALE_X\";\n    PLYValue[PLYValue[\"MIN_SCALE_Y\"] = 7] = \"MIN_SCALE_Y\";\n    PLYValue[PLYValue[\"MIN_SCALE_Z\"] = 8] = \"MIN_SCALE_Z\";\n    PLYValue[PLYValue[\"MAX_SCALE_X\"] = 9] = \"MAX_SCALE_X\";\n    PLYValue[PLYValue[\"MAX_SCALE_Y\"] = 10] = \"MAX_SCALE_Y\";\n    PLYValue[PLYValue[\"MAX_SCALE_Z\"] = 11] = \"MAX_SCALE_Z\";\n    PLYValue[PLYValue[\"PACKED_POSITION\"] = 12] = \"PACKED_POSITION\";\n    PLYValue[PLYValue[\"PACKED_ROTATION\"] = 13] = \"PACKED_ROTATION\";\n    PLYValue[PLYValue[\"PACKED_SCALE\"] = 14] = \"PACKED_SCALE\";\n    PLYValue[PLYValue[\"PACKED_COLOR\"] = 15] = \"PACKED_COLOR\";\n    PLYValue[PLYValue[\"X\"] = 16] = \"X\";\n    PLYValue[PLYValue[\"Y\"] = 17] = \"Y\";\n    PLYValue[PLYValue[\"Z\"] = 18] = \"Z\";\n    PLYValue[PLYValue[\"SCALE_0\"] = 19] = \"SCALE_0\";\n    PLYValue[PLYValue[\"SCALE_1\"] = 20] = \"SCALE_1\";\n    PLYValue[PLYValue[\"SCALE_2\"] = 21] = \"SCALE_2\";\n    PLYValue[PLYValue[\"DIFFUSE_RED\"] = 22] = \"DIFFUSE_RED\";\n    PLYValue[PLYValue[\"DIFFUSE_GREEN\"] = 23] = \"DIFFUSE_GREEN\";\n    PLYValue[PLYValue[\"DIFFUSE_BLUE\"] = 24] = \"DIFFUSE_BLUE\";\n    PLYValue[PLYValue[\"OPACITY\"] = 25] = \"OPACITY\";\n    PLYValue[PLYValue[\"F_DC_0\"] = 26] = \"F_DC_0\";\n    PLYValue[PLYValue[\"F_DC_1\"] = 27] = \"F_DC_1\";\n    PLYValue[PLYValue[\"F_DC_2\"] = 28] = \"F_DC_2\";\n    PLYValue[PLYValue[\"F_DC_3\"] = 29] = \"F_DC_3\";\n    PLYValue[PLYValue[\"ROT_0\"] = 30] = \"ROT_0\";\n    PLYValue[PLYValue[\"ROT_1\"] = 31] = \"ROT_1\";\n    PLYValue[PLYValue[\"ROT_2\"] = 32] = \"ROT_2\";\n    PLYValue[PLYValue[\"ROT_3\"] = 33] = \"ROT_3\";\n    PLYValue[PLYValue[\"MIN_COLOR_R\"] = 34] = \"MIN_COLOR_R\";\n    PLYValue[PLYValue[\"MIN_COLOR_G\"] = 35] = \"MIN_COLOR_G\";\n    PLYValue[PLYValue[\"MIN_COLOR_B\"] = 36] = \"MIN_COLOR_B\";\n    PLYValue[PLYValue[\"MAX_COLOR_R\"] = 37] = \"MAX_COLOR_R\";\n    PLYValue[PLYValue[\"MAX_COLOR_G\"] = 38] = \"MAX_COLOR_G\";\n    PLYValue[PLYValue[\"MAX_COLOR_B\"] = 39] = \"MAX_COLOR_B\";\n    PLYValue[PLYValue[\"SH_0\"] = 40] = \"SH_0\";\n    PLYValue[PLYValue[\"SH_1\"] = 41] = \"SH_1\";\n    PLYValue[PLYValue[\"SH_2\"] = 42] = \"SH_2\";\n    PLYValue[PLYValue[\"SH_3\"] = 43] = \"SH_3\";\n    PLYValue[PLYValue[\"SH_4\"] = 44] = \"SH_4\";\n    PLYValue[PLYValue[\"SH_5\"] = 45] = \"SH_5\";\n    PLYValue[PLYValue[\"SH_6\"] = 46] = \"SH_6\";\n    PLYValue[PLYValue[\"SH_7\"] = 47] = \"SH_7\";\n    PLYValue[PLYValue[\"SH_8\"] = 48] = \"SH_8\";\n    PLYValue[PLYValue[\"SH_9\"] = 49] = \"SH_9\";\n    PLYValue[PLYValue[\"SH_10\"] = 50] = \"SH_10\";\n    PLYValue[PLYValue[\"SH_11\"] = 51] = \"SH_11\";\n    PLYValue[PLYValue[\"SH_12\"] = 52] = \"SH_12\";\n    PLYValue[PLYValue[\"SH_13\"] = 53] = \"SH_13\";\n    PLYValue[PLYValue[\"SH_14\"] = 54] = \"SH_14\";\n    PLYValue[PLYValue[\"SH_15\"] = 55] = \"SH_15\";\n    PLYValue[PLYValue[\"SH_16\"] = 56] = \"SH_16\";\n    PLYValue[PLYValue[\"SH_17\"] = 57] = \"SH_17\";\n    PLYValue[PLYValue[\"SH_18\"] = 58] = \"SH_18\";\n    PLYValue[PLYValue[\"SH_19\"] = 59] = \"SH_19\";\n    PLYValue[PLYValue[\"SH_20\"] = 60] = \"SH_20\";\n    PLYValue[PLYValue[\"SH_21\"] = 61] = \"SH_21\";\n    PLYValue[PLYValue[\"SH_22\"] = 62] = \"SH_22\";\n    PLYValue[PLYValue[\"SH_23\"] = 63] = \"SH_23\";\n    PLYValue[PLYValue[\"SH_24\"] = 64] = \"SH_24\";\n    PLYValue[PLYValue[\"SH_25\"] = 65] = \"SH_25\";\n    PLYValue[PLYValue[\"SH_26\"] = 66] = \"SH_26\";\n    PLYValue[PLYValue[\"SH_27\"] = 67] = \"SH_27\";\n    PLYValue[PLYValue[\"SH_28\"] = 68] = \"SH_28\";\n    PLYValue[PLYValue[\"SH_29\"] = 69] = \"SH_29\";\n    PLYValue[PLYValue[\"SH_30\"] = 70] = \"SH_30\";\n    PLYValue[PLYValue[\"SH_31\"] = 71] = \"SH_31\";\n    PLYValue[PLYValue[\"SH_32\"] = 72] = \"SH_32\";\n    PLYValue[PLYValue[\"SH_33\"] = 73] = \"SH_33\";\n    PLYValue[PLYValue[\"SH_34\"] = 74] = \"SH_34\";\n    PLYValue[PLYValue[\"SH_35\"] = 75] = \"SH_35\";\n    PLYValue[PLYValue[\"SH_36\"] = 76] = \"SH_36\";\n    PLYValue[PLYValue[\"SH_37\"] = 77] = \"SH_37\";\n    PLYValue[PLYValue[\"SH_38\"] = 78] = \"SH_38\";\n    PLYValue[PLYValue[\"SH_39\"] = 79] = \"SH_39\";\n    PLYValue[PLYValue[\"SH_40\"] = 80] = \"SH_40\";\n    PLYValue[PLYValue[\"SH_41\"] = 81] = \"SH_41\";\n    PLYValue[PLYValue[\"SH_42\"] = 82] = \"SH_42\";\n    PLYValue[PLYValue[\"SH_43\"] = 83] = \"SH_43\";\n    PLYValue[PLYValue[\"SH_44\"] = 84] = \"SH_44\";\n    PLYValue[PLYValue[\"UNDEFINED\"] = 85] = \"UNDEFINED\";\n})(PLYValue || (PLYValue = {}));\n/**\n * Class used to render a gaussian splatting mesh\n */\nexport class GaussianSplattingMesh extends Mesh {\n    /**\n     * If true, disables depth sorting of the splats (default: false)\n     */\n    get disableDepthSort() {\n        return this._disableDepthSort;\n    }\n    set disableDepthSort(value) {\n        if (!this._disableDepthSort && value) {\n            this._worker?.terminate();\n            this._worker = null;\n            this._disableDepthSort = true;\n        }\n        else if (this._disableDepthSort && !value) {\n            this._disableDepthSort = false;\n            this._sortIsDirty = true;\n            this._instanciateWorker();\n        }\n    }\n    /**\n     * View direction factor used to compute the SH view direction in the shader.\n     * @deprecated Not used anymore for SH rendering\n     */\n    get viewDirectionFactor() {\n        return Vector3.OneReadOnly;\n    }\n    /**\n     * SH degree. 0 = no sh (default). 1 = 3 parameters. 2 = 8 parameters. 3 = 15 parameters.\n     */\n    get shDegree() {\n        return this._shDegree;\n    }\n    /**\n     * Number of splats in the mesh\n     */\n    get splatCount() {\n        return this._splatIndex?.length;\n    }\n    /**\n     * returns the splats data array buffer that contains in order : postions (3 floats), size (3 floats), color (4 bytes), orientation quaternion (4 bytes)\n     */\n    get splatsData() {\n        return this._splatsData;\n    }\n    /**\n     * returns the SH data arrays\n     */\n    get shData() {\n        return this._shData;\n    }\n    /**\n     * True when this mesh is a compound that regroups multiple Gaussian splatting parts.\n     */\n    get isCompound() {\n        return this._partMatrices.length > 0;\n    }\n    /**\n     * returns the part indices array\n     */\n    get partIndices() {\n        return this._partIndices;\n    }\n    /**\n     * Gets the part indices texture, if the mesh is a compound\n     */\n    get partIndicesTexture() {\n        return this._partIndicesTexture;\n    }\n    /**\n     * Gets the part visibility array, if the mesh is a compound\n     */\n    get partVisibility() {\n        return this._partVisibility;\n    }\n    /**\n     * Gets the covariancesA texture\n     */\n    get covariancesATexture() {\n        return this._covariancesATexture;\n    }\n    /**\n     * Gets the covariancesB texture\n     */\n    get covariancesBTexture() {\n        return this._covariancesBTexture;\n    }\n    /**\n     * Gets the centers texture\n     */\n    get centersTexture() {\n        return this._centersTexture;\n    }\n    /**\n     * Gets the colors texture\n     */\n    get colorsTexture() {\n        return this._colorsTexture;\n    }\n    /**\n     * Gets the SH textures\n     */\n    get shTextures() {\n        return this._shTextures;\n    }\n    /**\n     * Gets the kernel size\n     * Documentation and mathematical explanations here:\n     * https://github.com/graphdeco-inria/gaussian-splatting/issues/294#issuecomment-1772688093\n     * https://github.com/autonomousvision/mip-splatting/issues/18#issuecomment-1929388931\n     */\n    get kernelSize() {\n        return this._material instanceof GaussianSplattingMaterial ? this._material.kernelSize : 0;\n    }\n    /**\n     * Get the compensation state\n     */\n    get compensation() {\n        return this._material instanceof GaussianSplattingMaterial ? this._material.compensation : false;\n    }\n    /**\n     * set rendering material\n     */\n    set material(value) {\n        this._material = value;\n        this._material.backFaceCulling = false;\n        this._material.cullBackFaces = false;\n        value.resetDrawCache();\n    }\n    /**\n     * get rendering material\n     */\n    get material() {\n        return this._material;\n    }\n    static _MakeSplatGeometryForMesh(mesh) {\n        const vertexData = new VertexData();\n        const originPositions = [-2, -2, 0, 2, -2, 0, 2, 2, 0, -2, 2, 0];\n        const originIndices = [0, 1, 2, 0, 2, 3];\n        const positions = [];\n        const indices = [];\n        for (let i = 0; i < GaussianSplattingMesh._BatchSize; i++) {\n            for (let j = 0; j < 12; j++) {\n                if (j == 2 || j == 5 || j == 8 || j == 11) {\n                    positions.push(i); // local splat index\n                }\n                else {\n                    positions.push(originPositions[j]);\n                }\n            }\n            indices.push(originIndices.map((v) => v + i * 4));\n        }\n        vertexData.positions = positions;\n        vertexData.indices = indices.flat();\n        vertexData.applyToMesh(mesh);\n    }\n    /**\n     * Creates a new gaussian splatting mesh\n     * @param name defines the name of the mesh\n     * @param url defines the url to load from (optional)\n     * @param scene defines the hosting scene (optional)\n     * @param keepInRam keep datas in ram for editing purpose\n     */\n    constructor(name, url = null, scene = null, keepInRam = false) {\n        super(name, scene);\n        this._vertexCount = 0;\n        this._worker = null;\n        this._modelViewProjectionMatrix = Matrix.Identity();\n        this._viewProjectionMatrix = Matrix.Identity();\n        this._canPostToWorker = true;\n        this._readyToDisplay = false;\n        this._covariancesATexture = null;\n        this._covariancesBTexture = null;\n        this._centersTexture = null;\n        this._colorsTexture = null;\n        this._splatPositions = null;\n        this._splatIndex = null;\n        this._shTextures = null;\n        this._splatsData = null;\n        this._shData = null;\n        this._partIndicesTexture = null;\n        this._partIndices = null;\n        this._partMatrices = [];\n        this._partVisibility = [];\n        this._partProxies = new Map();\n        this._textureSize = new Vector2(0, 0);\n        this._keepInRam = false;\n        this._delayedTextureUpdate = null;\n        this._useRGBACovariants = false;\n        this._material = null;\n        this._tmpCovariances = [0, 0, 0, 0, 0, 0];\n        this._sortIsDirty = false;\n        this._shDegree = 0;\n        this._cameraViewInfos = new Map();\n        /**\n         * Cosine value of the angle threshold to update view dependent splat sorting. Default is 0.0001.\n         */\n        this.viewUpdateThreshold = GaussianSplattingMesh._DefaultViewUpdateThreshold;\n        this._disableDepthSort = false;\n        this._loadingPromise = null;\n        this.subMeshes = [];\n        new SubMesh(0, 0, 4 * GaussianSplattingMesh._BatchSize, 0, 6 * GaussianSplattingMesh._BatchSize, this);\n        this.setEnabled(false);\n        // webGL2 and webGPU support for RG texture with float16 is fine. not webGL1\n        this._useRGBACovariants = !this.getEngine().isWebGPU && this.getEngine().version === 1.0;\n        this._keepInRam = keepInRam;\n        if (url) {\n            this._loadingPromise = this.loadFileAsync(url);\n        }\n        const gaussianSplattingMaterial = new GaussianSplattingMaterial(this.name + \"_material\", this._scene);\n        gaussianSplattingMaterial.setSourceMesh(this);\n        this._material = gaussianSplattingMaterial;\n        // delete meshes created for cameras on camera removal\n        this._scene.onCameraRemovedObservable.add((camera) => {\n            const cameraId = camera.uniqueId;\n            // delete mesh for this camera\n            if (this._cameraViewInfos.has(cameraId)) {\n                const cameraViewInfos = this._cameraViewInfos.get(cameraId);\n                cameraViewInfos?.mesh.dispose();\n                this._cameraViewInfos.delete(cameraId);\n            }\n        });\n    }\n    /**\n     * Get the loading promise when loading the mesh from a URL in the constructor\n     * @returns constructor loading promise or null if no URL was provided\n     */\n    getLoadingPromise() {\n        return this._loadingPromise;\n    }\n    /**\n     * Returns the class name\n     * @returns \"GaussianSplattingMesh\"\n     */\n    getClassName() {\n        return \"GaussianSplattingMesh\";\n    }\n    /**\n     * Returns the total number of vertices (splats) within the mesh\n     * @returns the total number of vertices\n     */\n    getTotalVertices() {\n        return this._vertexCount;\n    }\n    /**\n     * Is this node ready to be used/rendered\n     * @param completeCheck defines if a complete check (including materials and lights) has to be done (false by default)\n     * @returns true when ready\n     */\n    isReady(completeCheck = false) {\n        if (!super.isReady(completeCheck, true)) {\n            return false;\n        }\n        if (!this._readyToDisplay) {\n            // mesh is ready when worker has done at least 1 sorting\n            this._postToWorker(true);\n            return false;\n        }\n        return true;\n    }\n    _getCameraDirection(camera) {\n        const cameraViewMatrix = camera.getViewMatrix();\n        const cameraProjectionMatrix = camera.getProjectionMatrix();\n        const cameraViewProjectionMatrix = TmpVectors.Matrix[0];\n        cameraViewMatrix.multiplyToRef(cameraProjectionMatrix, cameraViewProjectionMatrix);\n        this._viewProjectionMatrix.copyFrom(cameraViewProjectionMatrix);\n        const modelViewMatrix = TmpVectors.Matrix[1];\n        this.getWorldMatrix().multiplyToRef(cameraViewMatrix, modelViewMatrix);\n        modelViewMatrix.multiplyToRef(cameraProjectionMatrix, this._modelViewProjectionMatrix);\n        // return vector used to compute distance to camera\n        const localDirection = TmpVectors.Vector3[1];\n        localDirection.set(modelViewMatrix.m[2], modelViewMatrix.m[6], modelViewMatrix.m[10]);\n        localDirection.normalize();\n        return localDirection;\n    }\n    /** @internal */\n    _postToWorker(forced = false) {\n        const scene = this._scene;\n        const frameId = scene.getFrameId();\n        // force update or at least frame update for camera is outdated\n        let outdated = false;\n        this._cameraViewInfos.forEach((cameraViewInfos) => {\n            if (cameraViewInfos.frameIdLastUpdate !== frameId) {\n                outdated = true;\n            }\n        });\n        // array of cameras used for rendering\n        const cameras = this._scene.activeCameras?.length ? this._scene.activeCameras : [this._scene.activeCamera];\n        // list view infos for active cameras\n        const activeViewInfos = [];\n        cameras.forEach((camera) => {\n            if (!camera) {\n                return;\n            }\n            const cameraId = camera.uniqueId;\n            const cameraViewInfos = this._cameraViewInfos.get(cameraId);\n            if (cameraViewInfos) {\n                activeViewInfos.push(cameraViewInfos);\n            }\n            else {\n                // mesh doesn't exist yet for this camera\n                const cameraMesh = new Mesh(this.name + \"_cameraMesh_\" + cameraId, this._scene);\n                // not visible with inspector or the scene graph\n                cameraMesh.reservedDataStore = { hidden: true };\n                cameraMesh.setEnabled(false);\n                cameraMesh.material = this.material;\n                GaussianSplattingMesh._MakeSplatGeometryForMesh(cameraMesh);\n                const newViewInfos = {\n                    camera: camera,\n                    cameraDirection: new Vector3(0, 0, 0),\n                    mesh: cameraMesh,\n                    frameIdLastUpdate: frameId,\n                    splatIndexBufferSet: false,\n                };\n                activeViewInfos.push(newViewInfos);\n                this._cameraViewInfos.set(cameraId, newViewInfos);\n            }\n        });\n        // sort view infos by last updated frame id: first item is the least recently updated\n        activeViewInfos.sort((a, b) => a.frameIdLastUpdate - b.frameIdLastUpdate);\n        const hasSortFunction = this._worker || Native?.sortSplats || this._disableDepthSort;\n        if ((forced || outdated) && hasSortFunction && (this._scene.activeCameras?.length || this._scene.activeCamera) && this._canPostToWorker) {\n            // view infos sorted by least recent updated frame id\n            activeViewInfos.forEach((cameraViewInfos) => {\n                const camera = cameraViewInfos.camera;\n                const cameraDirection = this._getCameraDirection(camera);\n                const previousCameraDirection = cameraViewInfos.cameraDirection;\n                const dot = Vector3.Dot(cameraDirection, previousCameraDirection);\n                if ((forced || Math.abs(dot - 1) >= this.viewUpdateThreshold) && this._canPostToWorker) {\n                    cameraViewInfos.cameraDirection.copyFrom(cameraDirection);\n                    cameraViewInfos.frameIdLastUpdate = frameId;\n                    this._canPostToWorker = false;\n                    if (this._worker) {\n                        this._worker.postMessage({\n                            modelViewProjection: this._modelViewProjectionMatrix.m,\n                            viewProjection: this._viewProjectionMatrix.m,\n                            depthMix: this._depthMix,\n                            cameraId: camera.uniqueId,\n                            depthScale: camera.mode === Camera.ORTHOGRAPHIC_CAMERA ? (camera.maxZ - camera.minZ) / 2.0 : 1.0,\n                        }, [this._depthMix.buffer]);\n                    }\n                    else if (Native?.sortSplats) {\n                        Native.sortSplats(this._modelViewProjectionMatrix, this._splatPositions, this._splatIndex, this._scene.useRightHandedSystem);\n                        if (cameraViewInfos.splatIndexBufferSet) {\n                            cameraViewInfos.mesh.thinInstanceBufferUpdated(\"splatIndex\");\n                        }\n                        else {\n                            cameraViewInfos.mesh.thinInstanceSetBuffer(\"splatIndex\", this._splatIndex, 16, false);\n                            cameraViewInfos.splatIndexBufferSet = true;\n                        }\n                        this._canPostToWorker = true;\n                        this._readyToDisplay = true;\n                    }\n                }\n            });\n        }\n        else if (this._disableDepthSort) {\n            activeViewInfos.forEach((cameraViewInfos) => {\n                if (!cameraViewInfos.splatIndexBufferSet) {\n                    cameraViewInfos.mesh.thinInstanceSetBuffer(\"splatIndex\", this._splatIndex, 16, false);\n                    cameraViewInfos.splatIndexBufferSet = true;\n                }\n            });\n            this._canPostToWorker = true;\n            this._readyToDisplay = true;\n        }\n    }\n    /**\n     * Triggers the draw call for the mesh. Usually, you don't need to call this method by your own because the mesh rendering is handled by the scene rendering manager\n     * @param subMesh defines the subMesh to render\n     * @param enableAlphaMode defines if alpha mode can be changed\n     * @param effectiveMeshReplacement defines an optional mesh used to provide info for the rendering\n     * @returns the current mesh\n     */\n    render(subMesh, enableAlphaMode, effectiveMeshReplacement) {\n        this._postToWorker();\n        // geometry used for shadows, bind the first found in the camera view infos\n        if (!this._geometry && this._cameraViewInfos.size) {\n            this._geometry = this._cameraViewInfos.values().next().value.mesh.geometry;\n        }\n        const cameraId = this._scene.activeCamera.uniqueId;\n        const cameraViewInfos = this._cameraViewInfos.get(cameraId);\n        if (!cameraViewInfos || !cameraViewInfos.splatIndexBufferSet) {\n            return this;\n        }\n        if (this.onBeforeRenderObservable) {\n            this.onBeforeRenderObservable.notifyObservers(this);\n        }\n        const mesh = cameraViewInfos.mesh;\n        mesh.getWorldMatrix().copyFrom(this.getWorldMatrix());\n        // Propagate render pass material overrides (e.g., GPU picking) to the inner camera mesh.\n        // When this mesh is rendered into a RenderTargetTexture with a material override (via setMaterialForRendering),\n        // the override is set on this proxy mesh but needs to be applied to the actual camera mesh that does the rendering.\n        const engine = this._scene.getEngine();\n        const renderPassId = engine.currentRenderPassId;\n        const renderPassMaterial = this.getMaterialForRenderPass(renderPassId);\n        if (renderPassMaterial) {\n            mesh.setMaterialForRenderPass(renderPassId, renderPassMaterial);\n        }\n        const ret = mesh.render(subMesh, enableAlphaMode, effectiveMeshReplacement);\n        // Clean up the temporary override to avoid affecting other render passes\n        if (renderPassMaterial) {\n            mesh.setMaterialForRenderPass(renderPassId, undefined);\n        }\n        if (this.onAfterRenderObservable) {\n            this.onAfterRenderObservable.notifyObservers(this);\n        }\n        return ret;\n    }\n    static _TypeNameToEnum(name) {\n        switch (name) {\n            case \"float\":\n                return 0 /* PLYType.FLOAT */;\n            case \"int\":\n                return 1 /* PLYType.INT */;\n            case \"uint\":\n                return 2 /* PLYType.UINT */;\n            case \"double\":\n                return 3 /* PLYType.DOUBLE */;\n            case \"uchar\":\n                return 4 /* PLYType.UCHAR */;\n        }\n        return 5 /* PLYType.UNDEFINED */;\n    }\n    static _ValueNameToEnum(name) {\n        switch (name) {\n            case \"min_x\":\n                return 0 /* PLYValue.MIN_X */;\n            case \"min_y\":\n                return 1 /* PLYValue.MIN_Y */;\n            case \"min_z\":\n                return 2 /* PLYValue.MIN_Z */;\n            case \"max_x\":\n                return 3 /* PLYValue.MAX_X */;\n            case \"max_y\":\n                return 4 /* PLYValue.MAX_Y */;\n            case \"max_z\":\n                return 5 /* PLYValue.MAX_Z */;\n            case \"min_scale_x\":\n                return 6 /* PLYValue.MIN_SCALE_X */;\n            case \"min_scale_y\":\n                return 7 /* PLYValue.MIN_SCALE_Y */;\n            case \"min_scale_z\":\n                return 8 /* PLYValue.MIN_SCALE_Z */;\n            case \"max_scale_x\":\n                return 9 /* PLYValue.MAX_SCALE_X */;\n            case \"max_scale_y\":\n                return 10 /* PLYValue.MAX_SCALE_Y */;\n            case \"max_scale_z\":\n                return 11 /* PLYValue.MAX_SCALE_Z */;\n            case \"packed_position\":\n                return 12 /* PLYValue.PACKED_POSITION */;\n            case \"packed_rotation\":\n                return 13 /* PLYValue.PACKED_ROTATION */;\n            case \"packed_scale\":\n                return 14 /* PLYValue.PACKED_SCALE */;\n            case \"packed_color\":\n                return 15 /* PLYValue.PACKED_COLOR */;\n            case \"x\":\n                return 16 /* PLYValue.X */;\n            case \"y\":\n                return 17 /* PLYValue.Y */;\n            case \"z\":\n                return 18 /* PLYValue.Z */;\n            case \"scale_0\":\n                return 19 /* PLYValue.SCALE_0 */;\n            case \"scale_1\":\n                return 20 /* PLYValue.SCALE_1 */;\n            case \"scale_2\":\n                return 21 /* PLYValue.SCALE_2 */;\n            case \"diffuse_red\":\n            case \"red\":\n                return 22 /* PLYValue.DIFFUSE_RED */;\n            case \"diffuse_green\":\n            case \"green\":\n                return 23 /* PLYValue.DIFFUSE_GREEN */;\n            case \"diffuse_blue\":\n            case \"blue\":\n                return 24 /* PLYValue.DIFFUSE_BLUE */;\n            case \"f_dc_0\":\n                return 26 /* PLYValue.F_DC_0 */;\n            case \"f_dc_1\":\n                return 27 /* PLYValue.F_DC_1 */;\n            case \"f_dc_2\":\n                return 28 /* PLYValue.F_DC_2 */;\n            case \"f_dc_3\":\n                return 29 /* PLYValue.F_DC_3 */;\n            case \"opacity\":\n                return 25 /* PLYValue.OPACITY */;\n            case \"rot_0\":\n                return 30 /* PLYValue.ROT_0 */;\n            case \"rot_1\":\n                return 31 /* PLYValue.ROT_1 */;\n            case \"rot_2\":\n                return 32 /* PLYValue.ROT_2 */;\n            case \"rot_3\":\n                return 33 /* PLYValue.ROT_3 */;\n            case \"min_r\":\n                return 34 /* PLYValue.MIN_COLOR_R */;\n            case \"min_g\":\n                return 35 /* PLYValue.MIN_COLOR_G */;\n            case \"min_b\":\n                return 36 /* PLYValue.MIN_COLOR_B */;\n            case \"max_r\":\n                return 37 /* PLYValue.MAX_COLOR_R */;\n            case \"max_g\":\n                return 38 /* PLYValue.MAX_COLOR_G */;\n            case \"max_b\":\n                return 39 /* PLYValue.MAX_COLOR_B */;\n            case \"f_rest_0\":\n                return 40 /* PLYValue.SH_0 */;\n            case \"f_rest_1\":\n                return 41 /* PLYValue.SH_1 */;\n            case \"f_rest_2\":\n                return 42 /* PLYValue.SH_2 */;\n            case \"f_rest_3\":\n                return 43 /* PLYValue.SH_3 */;\n            case \"f_rest_4\":\n                return 44 /* PLYValue.SH_4 */;\n            case \"f_rest_5\":\n                return 45 /* PLYValue.SH_5 */;\n            case \"f_rest_6\":\n                return 46 /* PLYValue.SH_6 */;\n            case \"f_rest_7\":\n                return 47 /* PLYValue.SH_7 */;\n            case \"f_rest_8\":\n                return 48 /* PLYValue.SH_8 */;\n            case \"f_rest_9\":\n                return 49 /* PLYValue.SH_9 */;\n            case \"f_rest_10\":\n                return 50 /* PLYValue.SH_10 */;\n            case \"f_rest_11\":\n                return 51 /* PLYValue.SH_11 */;\n            case \"f_rest_12\":\n                return 52 /* PLYValue.SH_12 */;\n            case \"f_rest_13\":\n                return 53 /* PLYValue.SH_13 */;\n            case \"f_rest_14\":\n                return 54 /* PLYValue.SH_14 */;\n            case \"f_rest_15\":\n                return 55 /* PLYValue.SH_15 */;\n            case \"f_rest_16\":\n                return 56 /* PLYValue.SH_16 */;\n            case \"f_rest_17\":\n                return 57 /* PLYValue.SH_17 */;\n            case \"f_rest_18\":\n                return 58 /* PLYValue.SH_18 */;\n            case \"f_rest_19\":\n                return 59 /* PLYValue.SH_19 */;\n            case \"f_rest_20\":\n                return 60 /* PLYValue.SH_20 */;\n            case \"f_rest_21\":\n                return 61 /* PLYValue.SH_21 */;\n            case \"f_rest_22\":\n                return 62 /* PLYValue.SH_22 */;\n            case \"f_rest_23\":\n                return 63 /* PLYValue.SH_23 */;\n            case \"f_rest_24\":\n                return 64 /* PLYValue.SH_24 */;\n            case \"f_rest_25\":\n                return 65 /* PLYValue.SH_25 */;\n            case \"f_rest_26\":\n                return 66 /* PLYValue.SH_26 */;\n            case \"f_rest_27\":\n                return 67 /* PLYValue.SH_27 */;\n            case \"f_rest_28\":\n                return 68 /* PLYValue.SH_28 */;\n            case \"f_rest_29\":\n                return 69 /* PLYValue.SH_29 */;\n            case \"f_rest_30\":\n                return 70 /* PLYValue.SH_30 */;\n            case \"f_rest_31\":\n                return 71 /* PLYValue.SH_31 */;\n            case \"f_rest_32\":\n                return 72 /* PLYValue.SH_32 */;\n            case \"f_rest_33\":\n                return 73 /* PLYValue.SH_33 */;\n            case \"f_rest_34\":\n                return 74 /* PLYValue.SH_34 */;\n            case \"f_rest_35\":\n                return 75 /* PLYValue.SH_35 */;\n            case \"f_rest_36\":\n                return 76 /* PLYValue.SH_36 */;\n            case \"f_rest_37\":\n                return 77 /* PLYValue.SH_37 */;\n            case \"f_rest_38\":\n                return 78 /* PLYValue.SH_38 */;\n            case \"f_rest_39\":\n                return 79 /* PLYValue.SH_39 */;\n            case \"f_rest_40\":\n                return 80 /* PLYValue.SH_40 */;\n            case \"f_rest_41\":\n                return 81 /* PLYValue.SH_41 */;\n            case \"f_rest_42\":\n                return 82 /* PLYValue.SH_42 */;\n            case \"f_rest_43\":\n                return 83 /* PLYValue.SH_43 */;\n            case \"f_rest_44\":\n                return 84 /* PLYValue.SH_44 */;\n        }\n        return 85 /* PLYValue.UNDEFINED */;\n    }\n    /**\n     * Parse a PLY file header and returns metas infos on splats and chunks\n     * @param data the loaded buffer\n     * @returns a PLYHeader\n     */\n    static ParseHeader(data) {\n        const ubuf = new Uint8Array(data);\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\n        const headerEnd = \"end_header\\n\";\n        const headerEndIndex = header.indexOf(headerEnd);\n        if (headerEndIndex < 0 || !header) {\n            // standard splat\n            return null;\n        }\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)[1]);\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\n        let chunkCount = 0;\n        if (chunkElement) {\n            chunkCount = parseInt(chunkElement[1]);\n        }\n        let rowVertexOffset = 0;\n        let rowChunkOffset = 0;\n        const offsets = {\n            double: 8,\n            int: 4,\n            uint: 4,\n            float: 4,\n            short: 2,\n            ushort: 2,\n            uchar: 1,\n            list: 0,\n        };\n        let ElementMode;\n        (function (ElementMode) {\n            ElementMode[ElementMode[\"Vertex\"] = 0] = \"Vertex\";\n            ElementMode[ElementMode[\"Chunk\"] = 1] = \"Chunk\";\n            ElementMode[ElementMode[\"SH\"] = 2] = \"SH\";\n            ElementMode[ElementMode[\"Unused\"] = 3] = \"Unused\";\n        })(ElementMode || (ElementMode = {}));\n        let chunkMode = 1 /* ElementMode.Chunk */;\n        const vertexProperties = [];\n        const chunkProperties = [];\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\n        let shDegree = 0;\n        for (const prop of filtered) {\n            if (prop.startsWith(\"property \")) {\n                const [, typeName, name] = prop.split(\" \");\n                const value = GaussianSplattingMesh._ValueNameToEnum(name);\n                if (value != 85 /* PLYValue.UNDEFINED */) {\n                    // SH degree 1,2 or 3 for 9, 24 or 45 values\n                    if (value >= 84 /* PLYValue.SH_44 */) {\n                        shDegree = 3;\n                    }\n                    else if (value >= 64 /* PLYValue.SH_24 */) {\n                        shDegree = Math.max(shDegree, 2);\n                    }\n                    else if (value >= 48 /* PLYValue.SH_8 */) {\n                        shDegree = Math.max(shDegree, 1);\n                    }\n                }\n                const type = GaussianSplattingMesh._TypeNameToEnum(typeName);\n                if (chunkMode == 1 /* ElementMode.Chunk */) {\n                    chunkProperties.push({ value, type, offset: rowChunkOffset });\n                    rowChunkOffset += offsets[typeName];\n                }\n                else if (chunkMode == 0 /* ElementMode.Vertex */) {\n                    vertexProperties.push({ value, type, offset: rowVertexOffset });\n                    rowVertexOffset += offsets[typeName];\n                }\n                else if (chunkMode == 2 /* ElementMode.SH */) {\n                    // SH doesn't count for vertex row size but its properties are used to retrieve SH\n                    vertexProperties.push({ value, type, offset: rowVertexOffset });\n                }\n                if (!offsets[typeName]) {\n                    Logger.Warn(`Unsupported property type: ${typeName}.`);\n                }\n            }\n            else if (prop.startsWith(\"element \")) {\n                const [, type] = prop.split(\" \");\n                if (type == \"chunk\") {\n                    chunkMode = 1 /* ElementMode.Chunk */;\n                }\n                else if (type == \"vertex\") {\n                    chunkMode = 0 /* ElementMode.Vertex */;\n                }\n                else if (type == \"sh\") {\n                    chunkMode = 2 /* ElementMode.SH */;\n                }\n                else {\n                    chunkMode = 3 /* ElementMode.Unused */;\n                }\n            }\n        }\n        const dataView = new DataView(data, headerEndIndex + headerEnd.length);\n        const buffer = new ArrayBuffer(GaussianSplattingMesh._RowOutputLength * vertexCount);\n        let shBuffer = null;\n        let shCoefficientCount = 0;\n        if (shDegree) {\n            const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1;\n            shCoefficientCount = shVectorCount * 3;\n            shBuffer = new ArrayBuffer(shCoefficientCount * vertexCount);\n        }\n        return {\n            vertexCount: vertexCount,\n            chunkCount: chunkCount,\n            rowVertexLength: rowVertexOffset,\n            rowChunkLength: rowChunkOffset,\n            vertexProperties: vertexProperties,\n            chunkProperties: chunkProperties,\n            dataView: dataView,\n            buffer: buffer,\n            shDegree: shDegree,\n            shCoefficientCount: shCoefficientCount,\n            shBuffer: shBuffer,\n        };\n    }\n    static _GetCompressedChunks(header, offset) {\n        if (!header.chunkCount) {\n            return null;\n        }\n        const dataView = header.dataView;\n        const compressedChunks = new Array(header.chunkCount);\n        for (let i = 0; i < header.chunkCount; i++) {\n            const currentChunk = {\n                min: new Vector3(),\n                max: new Vector3(),\n                minScale: new Vector3(),\n                maxScale: new Vector3(),\n                minColor: new Vector3(0, 0, 0),\n                maxColor: new Vector3(1, 1, 1),\n            };\n            compressedChunks[i] = currentChunk;\n            for (let propertyIndex = 0; propertyIndex < header.chunkProperties.length; propertyIndex++) {\n                const property = header.chunkProperties[propertyIndex];\n                let value;\n                switch (property.type) {\n                    case 0 /* PLYType.FLOAT */:\n                        value = dataView.getFloat32(property.offset + offset.value, true);\n                        break;\n                    default:\n                        continue;\n                }\n                switch (property.value) {\n                    case 0 /* PLYValue.MIN_X */:\n                        currentChunk.min.x = value;\n                        break;\n                    case 1 /* PLYValue.MIN_Y */:\n                        currentChunk.min.y = value;\n                        break;\n                    case 2 /* PLYValue.MIN_Z */:\n                        currentChunk.min.z = value;\n                        break;\n                    case 3 /* PLYValue.MAX_X */:\n                        currentChunk.max.x = value;\n                        break;\n                    case 4 /* PLYValue.MAX_Y */:\n                        currentChunk.max.y = value;\n                        break;\n                    case 5 /* PLYValue.MAX_Z */:\n                        currentChunk.max.z = value;\n                        break;\n                    case 6 /* PLYValue.MIN_SCALE_X */:\n                        currentChunk.minScale.x = value;\n                        break;\n                    case 7 /* PLYValue.MIN_SCALE_Y */:\n                        currentChunk.minScale.y = value;\n                        break;\n                    case 8 /* PLYValue.MIN_SCALE_Z */:\n                        currentChunk.minScale.z = value;\n                        break;\n                    case 9 /* PLYValue.MAX_SCALE_X */:\n                        currentChunk.maxScale.x = value;\n                        break;\n                    case 10 /* PLYValue.MAX_SCALE_Y */:\n                        currentChunk.maxScale.y = value;\n                        break;\n                    case 11 /* PLYValue.MAX_SCALE_Z */:\n                        currentChunk.maxScale.z = value;\n                        break;\n                    case 34 /* PLYValue.MIN_COLOR_R */:\n                        currentChunk.minColor.x = value;\n                        break;\n                    case 35 /* PLYValue.MIN_COLOR_G */:\n                        currentChunk.minColor.y = value;\n                        break;\n                    case 36 /* PLYValue.MIN_COLOR_B */:\n                        currentChunk.minColor.z = value;\n                        break;\n                    case 37 /* PLYValue.MAX_COLOR_R */:\n                        currentChunk.maxColor.x = value;\n                        break;\n                    case 38 /* PLYValue.MAX_COLOR_G */:\n                        currentChunk.maxColor.y = value;\n                        break;\n                    case 39 /* PLYValue.MAX_COLOR_B */:\n                        currentChunk.maxColor.z = value;\n                        break;\n                }\n            }\n            offset.value += header.rowChunkLength;\n        }\n        return compressedChunks;\n    }\n    static _GetSplat(header, index, compressedChunks, offset) {\n        const q = TmpVectors.Quaternion[0];\n        const temp3 = TmpVectors.Vector3[0];\n        const rowOutputLength = GaussianSplattingMesh._RowOutputLength;\n        const buffer = header.buffer;\n        const dataView = header.dataView;\n        const position = new Float32Array(buffer, index * rowOutputLength, 3);\n        const scale = new Float32Array(buffer, index * rowOutputLength + 12, 3);\n        const rgba = new Uint8ClampedArray(buffer, index * rowOutputLength + 24, 4);\n        const rot = new Uint8ClampedArray(buffer, index * rowOutputLength + 28, 4);\n        let sh = null;\n        if (header.shBuffer) {\n            sh = new Uint8ClampedArray(header.shBuffer, index * header.shCoefficientCount, header.shCoefficientCount);\n        }\n        const chunkIndex = index >> 8;\n        let r0 = 255;\n        let r1 = 0;\n        let r2 = 0;\n        let r3 = 0;\n        const plySH = [];\n        for (let propertyIndex = 0; propertyIndex < header.vertexProperties.length; propertyIndex++) {\n            const property = header.vertexProperties[propertyIndex];\n            let value;\n            switch (property.type) {\n                case 0 /* PLYType.FLOAT */:\n                    value = dataView.getFloat32(offset.value + property.offset, true);\n                    break;\n                case 1 /* PLYType.INT */:\n                    value = dataView.getInt32(offset.value + property.offset, true);\n                    break;\n                case 2 /* PLYType.UINT */:\n                    value = dataView.getUint32(offset.value + property.offset, true);\n                    break;\n                case 3 /* PLYType.DOUBLE */:\n                    value = dataView.getFloat64(offset.value + property.offset, true);\n                    break;\n                case 4 /* PLYType.UCHAR */:\n                    value = dataView.getUint8(offset.value + property.offset);\n                    break;\n                default:\n                    continue;\n            }\n            switch (property.value) {\n                case 12 /* PLYValue.PACKED_POSITION */:\n                    {\n                        const compressedChunk = compressedChunks[chunkIndex];\n                        Unpack111011(value, temp3);\n                        position[0] = Scalar.Lerp(compressedChunk.min.x, compressedChunk.max.x, temp3.x);\n                        position[1] = Scalar.Lerp(compressedChunk.min.y, compressedChunk.max.y, temp3.y);\n                        position[2] = Scalar.Lerp(compressedChunk.min.z, compressedChunk.max.z, temp3.z);\n                    }\n                    break;\n                case 13 /* PLYValue.PACKED_ROTATION */:\n                    {\n                        UnpackRot(value, q);\n                        r0 = q.x;\n                        r1 = q.y;\n                        r2 = q.z;\n                        r3 = q.w;\n                    }\n                    break;\n                case 14 /* PLYValue.PACKED_SCALE */:\n                    {\n                        const compressedChunk = compressedChunks[chunkIndex];\n                        Unpack111011(value, temp3);\n                        scale[0] = Math.exp(Scalar.Lerp(compressedChunk.minScale.x, compressedChunk.maxScale.x, temp3.x));\n                        scale[1] = Math.exp(Scalar.Lerp(compressedChunk.minScale.y, compressedChunk.maxScale.y, temp3.y));\n                        scale[2] = Math.exp(Scalar.Lerp(compressedChunk.minScale.z, compressedChunk.maxScale.z, temp3.z));\n                    }\n                    break;\n                case 15 /* PLYValue.PACKED_COLOR */:\n                    {\n                        const compressedChunk = compressedChunks[chunkIndex];\n                        Unpack8888(value, rgba);\n                        rgba[0] = Scalar.Lerp(compressedChunk.minColor.x, compressedChunk.maxColor.x, rgba[0] / 255) * 255;\n                        rgba[1] = Scalar.Lerp(compressedChunk.minColor.y, compressedChunk.maxColor.y, rgba[1] / 255) * 255;\n                        rgba[2] = Scalar.Lerp(compressedChunk.minColor.z, compressedChunk.maxColor.z, rgba[2] / 255) * 255;\n                    }\n                    break;\n                case 16 /* PLYValue.X */:\n                    position[0] = value;\n                    break;\n                case 17 /* PLYValue.Y */:\n                    position[1] = value;\n                    break;\n                case 18 /* PLYValue.Z */:\n                    position[2] = value;\n                    break;\n                case 19 /* PLYValue.SCALE_0 */:\n                    scale[0] = Math.exp(value);\n                    break;\n                case 20 /* PLYValue.SCALE_1 */:\n                    scale[1] = Math.exp(value);\n                    break;\n                case 21 /* PLYValue.SCALE_2 */:\n                    scale[2] = Math.exp(value);\n                    break;\n                case 22 /* PLYValue.DIFFUSE_RED */:\n                    rgba[0] = value;\n                    break;\n                case 23 /* PLYValue.DIFFUSE_GREEN */:\n                    rgba[1] = value;\n                    break;\n                case 24 /* PLYValue.DIFFUSE_BLUE */:\n                    rgba[2] = value;\n                    break;\n                case 26 /* PLYValue.F_DC_0 */:\n                    rgba[0] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 27 /* PLYValue.F_DC_1 */:\n                    rgba[1] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 28 /* PLYValue.F_DC_2 */:\n                    rgba[2] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 29 /* PLYValue.F_DC_3 */:\n                    rgba[3] = (0.5 + GaussianSplattingMesh._SH_C0 * value) * 255;\n                    break;\n                case 25 /* PLYValue.OPACITY */:\n                    rgba[3] = (1 / (1 + Math.exp(-value))) * 255;\n                    break;\n                case 30 /* PLYValue.ROT_0 */:\n                    r0 = value;\n                    break;\n                case 31 /* PLYValue.ROT_1 */:\n                    r1 = value;\n                    break;\n                case 32 /* PLYValue.ROT_2 */:\n                    r2 = value;\n                    break;\n                case 33 /* PLYValue.ROT_3 */:\n                    r3 = value;\n                    break;\n            }\n            if (sh && property.value >= 40 /* PLYValue.SH_0 */ && property.value <= 84 /* PLYValue.SH_44 */) {\n                const shIndex = property.value - 40 /* PLYValue.SH_0 */;\n                if (property.type == 4 /* PLYType.UCHAR */ && header.chunkCount) {\n                    // compressed ply. dataView points to beginning of vertex\n                    // could be improved with a direct copy instead of a per SH index computation + copy\n                    const compressedValue = dataView.getUint8(header.rowChunkLength * header.chunkCount + header.vertexCount * header.rowVertexLength + index * header.shCoefficientCount + shIndex);\n                    // compressed .ply SH import : https://github.com/playcanvas/engine/blob/fda3f0368b45d7381f0b5a1722bd2056128eaebe/src/scene/gsplat/gsplat-compressed-data.js#L88C81-L88C98\n                    plySH[shIndex] = (compressedValue * (8 / 255) - 4) * 127.5 + 127.5;\n                }\n                else {\n                    const clampedValue = Scalar.Clamp(value * 127.5 + 127.5, 0, 255);\n                    plySH[shIndex] = clampedValue;\n                }\n            }\n        }\n        if (sh) {\n            const shDim = header.shDegree == 1 ? 3 : header.shDegree == 2 ? 8 : 15;\n            for (let j = 0; j < shDim; j++) {\n                sh[j * 3 + 0] = plySH[j];\n                sh[j * 3 + 1] = plySH[j + shDim];\n                sh[j * 3 + 2] = plySH[j + shDim * 2];\n            }\n        }\n        q.set(r1, r2, r3, r0);\n        q.normalize();\n        rot[0] = q.w * 127.5 + 127.5;\n        rot[1] = q.x * 127.5 + 127.5;\n        rot[2] = q.y * 127.5 + 127.5;\n        rot[3] = q.z * 127.5 + 127.5;\n        offset.value += header.rowVertexLength;\n    }\n    /**\n     * Converts a .ply data with SH coefficients splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @param useCoroutine use coroutine and yield\n     * @returns the loaded splat buffer and optional array of sh coefficients\n     */\n    static *ConvertPLYWithSHToSplat(data, useCoroutine = false) {\n        const header = GaussianSplattingMesh.ParseHeader(data);\n        if (!header) {\n            return { buffer: data };\n        }\n        const offset = { value: 0 };\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\n        for (let i = 0; i < header.vertexCount; i++) {\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\n                yield;\n            }\n        }\n        let sh = null;\n        // make SH texture buffers\n        if (header.shDegree && header.shBuffer) {\n            const textureCount = Math.ceil(header.shCoefficientCount / 16); // 4 components can be stored per texture, 4 sh per component\n            let shIndexRead = 0;\n            const ubuf = new Uint8Array(header.shBuffer);\n            // sh is an array of uint8array that will be used to create sh textures\n            sh = [];\n            const splatCount = header.vertexCount;\n            const engine = EngineStore.LastCreatedEngine;\n            if (engine) {\n                const width = engine.getCaps().maxTextureSize;\n                const height = Math.ceil(splatCount / width);\n                // create array for the number of textures needed.\n                for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\n                    const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\n                    sh.push(texture);\n                }\n                for (let i = 0; i < splatCount; i++) {\n                    for (let shIndexWrite = 0; shIndexWrite < header.shCoefficientCount; shIndexWrite++) {\n                        const shValue = ubuf[shIndexRead++];\n                        const textureIndex = Math.floor(shIndexWrite / 16);\n                        const shArray = sh[textureIndex];\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                        shArray[byteIndexInTexture + offsetPerSplat] = shValue;\n                    }\n                }\n            }\n        }\n        return { buffer: header.buffer, sh: sh };\n    }\n    /**\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @param useCoroutine use coroutine and yield\n     * @returns the loaded splat buffer without SH coefficient, whether ply contains or not SH.\n     */\n    static *ConvertPLYToSplat(data, useCoroutine = false) {\n        const header = GaussianSplattingMesh.ParseHeader(data);\n        if (!header) {\n            return data;\n        }\n        const offset = { value: 0 };\n        const compressedChunks = GaussianSplattingMesh._GetCompressedChunks(header, offset);\n        for (let i = 0; i < header.vertexCount; i++) {\n            GaussianSplattingMesh._GetSplat(header, i, compressedChunks, offset);\n            if (i % GaussianSplattingMesh._PlyConversionBatchSize === 0 && useCoroutine) {\n                yield;\n            }\n        }\n        return header.buffer;\n    }\n    /**\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer\n     */\n    static async ConvertPLYToSplatAsync(data) {\n        return await runCoroutineAsync(GaussianSplattingMesh.ConvertPLYToSplat(data, true), createYieldingScheduler());\n    }\n    /**\n     * Converts a .ply with SH data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer with SH\n     */\n    static async ConvertPLYWithSHToSplatAsync(data) {\n        return await runCoroutineAsync(GaussianSplattingMesh.ConvertPLYWithSHToSplat(data, true), createYieldingScheduler());\n    }\n    /**\n     * Loads a .splat Gaussian Splatting array buffer asynchronously\n     * @param data arraybuffer containing splat file\n     * @returns a promise that resolves when the operation is complete\n     */\n    async loadDataAsync(data) {\n        return await this.updateDataAsync(data);\n    }\n    /**\n     * Loads a Gaussian or Splatting file asynchronously\n     * @param url path to the splat file to load\n     * @param scene optional scene it belongs to\n     * @returns a promise that resolves when the operation is complete\n     * @deprecated Please use SceneLoader.ImportMeshAsync instead\n     */\n    async loadFileAsync(url, scene) {\n        await ImportMeshAsync(url, (scene || EngineStore.LastCreatedScene), { pluginOptions: { splat: { gaussianSplattingMesh: this } } });\n    }\n    /**\n     * Releases resources associated with this mesh.\n     * @param doNotRecurse Set to true to not recurse into each children (recurse into each children by default)\n     */\n    dispose(doNotRecurse) {\n        this._covariancesATexture?.dispose();\n        this._covariancesBTexture?.dispose();\n        this._centersTexture?.dispose();\n        this._colorsTexture?.dispose();\n        if (this._shTextures) {\n            for (const shTexture of this._shTextures) {\n                shTexture.dispose();\n            }\n        }\n        if (this._partIndicesTexture) {\n            this._partIndicesTexture.dispose();\n        }\n        this._covariancesATexture = null;\n        this._covariancesBTexture = null;\n        this._centersTexture = null;\n        this._colorsTexture = null;\n        this._shTextures = null;\n        this._partIndicesTexture = null;\n        this._partMatrices = [];\n        this._worker?.terminate();\n        this._worker = null;\n        // delete meshes created for each camera\n        this._cameraViewInfos.forEach((cameraViewInfo) => {\n            cameraViewInfo.mesh.dispose();\n        });\n        // dispose all proxy meshes\n        this._partProxies.forEach((proxy) => {\n            proxy.dispose();\n        });\n        this._partProxies.clear();\n        super.dispose(doNotRecurse, true);\n    }\n    _copyTextures(source) {\n        this._covariancesATexture = source.covariancesATexture?.clone();\n        this._covariancesBTexture = source.covariancesBTexture?.clone();\n        this._centersTexture = source.centersTexture?.clone();\n        this._colorsTexture = source.colorsTexture?.clone();\n        this._partIndicesTexture = source._partIndicesTexture?.clone();\n        if (source._shTextures) {\n            this._shTextures = [];\n            for (const shTexture of source._shTextures) {\n                this._shTextures?.push(shTexture.clone());\n            }\n        }\n    }\n    /**\n     * Returns a new Mesh object generated from the current mesh properties.\n     * @param name is a string, the name given to the new mesh\n     * @returns a new Gaussian Splatting Mesh\n     */\n    clone(name = \"\") {\n        const newGS = new GaussianSplattingMesh(name, undefined, this.getScene());\n        newGS._copySource(this);\n        newGS.makeGeometryUnique();\n        newGS._vertexCount = this._vertexCount;\n        newGS._copyTextures(this);\n        newGS._modelViewProjectionMatrix = Matrix.Identity();\n        newGS._viewProjectionMatrix = Matrix.Identity();\n        newGS._splatPositions = this._splatPositions;\n        newGS._readyToDisplay = false;\n        newGS._disableDepthSort = this._disableDepthSort;\n        newGS._partMatrices = this._partMatrices.map((m) => m.clone());\n        newGS._instanciateWorker();\n        const binfo = this.getBoundingInfo();\n        newGS.getBoundingInfo().reConstruct(binfo.minimum, binfo.maximum, this.getWorldMatrix());\n        newGS.forcedInstanceCount = this.forcedInstanceCount;\n        newGS.setEnabled(true);\n        return newGS;\n    }\n    _makeEmptySplat(index, covA, covB, colorArray) {\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\n        this._splatPositions[4 * index + 0] = 0;\n        this._splatPositions[4 * index + 1] = 0;\n        this._splatPositions[4 * index + 2] = 0;\n        covA[index * 4 + 0] = ToHalfFloat(0);\n        covA[index * 4 + 1] = ToHalfFloat(0);\n        covA[index * 4 + 2] = ToHalfFloat(0);\n        covA[index * 4 + 3] = ToHalfFloat(0);\n        covB[index * covBSItemSize + 0] = ToHalfFloat(0);\n        covB[index * covBSItemSize + 1] = ToHalfFloat(0);\n        colorArray[index * 4 + 3] = 0;\n    }\n    _makeSplat(index, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum, options) {\n        const matrixRotation = TmpVectors.Matrix[0];\n        const matrixScale = TmpVectors.Matrix[1];\n        const quaternion = TmpVectors.Quaternion[0];\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\n        const x = fBuffer[8 * index + 0];\n        const y = fBuffer[8 * index + 1] * (options.flipY ? -1 : 1);\n        const z = fBuffer[8 * index + 2];\n        this._splatPositions[4 * index + 0] = x;\n        this._splatPositions[4 * index + 1] = y;\n        this._splatPositions[4 * index + 2] = z;\n        minimum.minimizeInPlaceFromFloats(x, y, z);\n        maximum.maximizeInPlaceFromFloats(x, y, z);\n        quaternion.set((uBuffer[32 * index + 28 + 1] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 2] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 3] - 127.5) / 127.5, -(uBuffer[32 * index + 28 + 0] - 127.5) / 127.5);\n        quaternion.normalize();\n        quaternion.toRotationMatrix(matrixRotation);\n        Matrix.ScalingToRef(fBuffer[8 * index + 3 + 0] * 2, fBuffer[8 * index + 3 + 1] * 2, fBuffer[8 * index + 3 + 2] * 2, matrixScale);\n        const m = matrixRotation.multiplyToRef(matrixScale, TmpVectors.Matrix[0]).m;\n        const covariances = this._tmpCovariances;\n        covariances[0] = m[0] * m[0] + m[1] * m[1] + m[2] * m[2];\n        covariances[1] = m[0] * m[4] + m[1] * m[5] + m[2] * m[6];\n        covariances[2] = m[0] * m[8] + m[1] * m[9] + m[2] * m[10];\n        covariances[3] = m[4] * m[4] + m[5] * m[5] + m[6] * m[6];\n        covariances[4] = m[4] * m[8] + m[5] * m[9] + m[6] * m[10];\n        covariances[5] = m[8] * m[8] + m[9] * m[9] + m[10] * m[10];\n        // normalize covA, covB\n        let factor = -10000;\n        for (let covIndex = 0; covIndex < 6; covIndex++) {\n            factor = Math.max(factor, Math.abs(covariances[covIndex]));\n        }\n        this._splatPositions[4 * index + 3] = factor;\n        const transform = factor;\n        covA[index * 4 + 0] = ToHalfFloat(covariances[0] / transform);\n        covA[index * 4 + 1] = ToHalfFloat(covariances[1] / transform);\n        covA[index * 4 + 2] = ToHalfFloat(covariances[2] / transform);\n        covA[index * 4 + 3] = ToHalfFloat(covariances[3] / transform);\n        covB[index * covBSItemSize + 0] = ToHalfFloat(covariances[4] / transform);\n        covB[index * covBSItemSize + 1] = ToHalfFloat(covariances[5] / transform);\n        // colors\n        colorArray[index * 4 + 0] = uBuffer[32 * index + 24 + 0];\n        colorArray[index * 4 + 1] = uBuffer[32 * index + 24 + 1];\n        colorArray[index * 4 + 2] = uBuffer[32 * index + 24 + 2];\n        colorArray[index * 4 + 3] = uBuffer[32 * index + 24 + 3];\n    }\n    // NB: partIndices is assumed to be padded to a round texture size\n    _updateTextures(covA, covB, colorArray, sh, partIndices) {\n        const textureSize = this._getTextureSize(this._vertexCount);\n        // Update the textures\n        const createTextureFromData = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n        };\n        const createTextureFromDataU8 = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_BYTE);\n        };\n        const createTextureFromDataU32 = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_UNSIGNED_INTEGER);\n        };\n        const createTextureFromDataF16 = (data, width, height, format) => {\n            return new RawTexture(data, width, height, format, this._scene, false, false, Constants.TEXTURE_BILINEAR_SAMPLINGMODE, Constants.TEXTURETYPE_HALF_FLOAT);\n        };\n        const firstTime = this._covariancesATexture === null;\n        const textureSizeChanged = this._textureSize.y != textureSize.y;\n        if (!firstTime && !textureSizeChanged) {\n            this._delayedTextureUpdate = { covA, covB, colors: colorArray, centers: this._splatPositions, sh, partIndices };\n            const positions = Float32Array.from(this._splatPositions);\n            const vertexCount = this._vertexCount;\n            if (this._worker) {\n                this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\n            }\n            // Handle SH textures in update path - create if they don't exist\n            if (sh && !this._shTextures) {\n                this._shTextures = [];\n                for (const shData of sh) {\n                    const buffer = new Uint32Array(shData.buffer);\n                    const shTexture = createTextureFromDataU32(buffer, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA_INTEGER);\n                    shTexture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                    shTexture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                    this._shTextures.push(shTexture);\n                }\n            }\n            // Handle compound data, if any\n            if (partIndices && !this._partIndicesTexture) {\n                const buffer = new Uint8Array(partIndices);\n                this._partIndicesTexture = createTextureFromDataU8(buffer, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RED);\n                this._partIndicesTexture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                this._partIndicesTexture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n            }\n            if (this._worker) {\n                this._worker.postMessage({ partIndices: partIndices ?? null });\n            }\n            this._postToWorker(true);\n        }\n        else {\n            this._textureSize = textureSize;\n            this._covariancesATexture = createTextureFromDataF16(covA, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\n            this._covariancesBTexture = createTextureFromDataF16(covB, textureSize.x, textureSize.y, this._useRGBACovariants ? Constants.TEXTUREFORMAT_RGBA : Constants.TEXTUREFORMAT_RG);\n            this._centersTexture = createTextureFromData(this._splatPositions, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\n            this._colorsTexture = createTextureFromDataU8(colorArray, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA);\n            if (sh) {\n                this._shTextures = [];\n                for (const shData of sh) {\n                    const buffer = new Uint32Array(shData.buffer);\n                    const shTexture = createTextureFromDataU32(buffer, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RGBA_INTEGER);\n                    shTexture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                    shTexture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                    this._shTextures.push(shTexture);\n                }\n            }\n            if (partIndices) {\n                const buffer = new Uint8Array(partIndices);\n                this._partIndicesTexture = createTextureFromDataU8(buffer, textureSize.x, textureSize.y, Constants.TEXTUREFORMAT_RED);\n                this._partIndicesTexture.wrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n                this._partIndicesTexture.wrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n            }\n            if (firstTime) {\n                this._instanciateWorker();\n            }\n            else {\n                if (this._worker) {\n                    const positions = Float32Array.from(this._splatPositions);\n                    const vertexCount = this._vertexCount;\n                    this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\n                    this._worker.postMessage({ partIndices: partIndices ?? null });\n                }\n                this._postToWorker(true);\n            }\n        }\n    }\n    *_updateData(data, isAsync, sh, partIndices, options = { flipY: false }) {\n        // if a covariance texture is present, then it's not a creation but an update\n        if (!this._covariancesATexture) {\n            this._readyToDisplay = false;\n        }\n        // Parse the data\n        const uBuffer = new Uint8Array(data);\n        const fBuffer = new Float32Array(uBuffer.buffer);\n        if (this._keepInRam) {\n            this._splatsData = data;\n            this._shData = sh ? sh.map((arr) => new Uint8Array(arr)) : null;\n        }\n        const vertexCount = uBuffer.length / GaussianSplattingMesh._RowOutputLength;\n        if (vertexCount != this._vertexCount) {\n            this._updateSplatIndexBuffer(vertexCount);\n        }\n        this._vertexCount = vertexCount;\n        // degree == 1 for 1 texture (3 terms), 2 for 2 textures(8 terms) and 3 for 3 textures (15 terms)\n        this._shDegree = sh ? sh.length : 0;\n        const textureSize = this._getTextureSize(vertexCount);\n        const textureLength = textureSize.x * textureSize.y;\n        const lineCountUpdate = GaussianSplattingMesh.ProgressiveUpdateAmount ?? textureSize.y;\n        const textureLengthPerUpdate = textureSize.x * lineCountUpdate;\n        this._splatPositions = new Float32Array(4 * textureLength);\n        const covA = new Uint16Array(textureLength * 4);\n        const covB = new Uint16Array((this._useRGBACovariants ? 4 : 2) * textureLength);\n        const colorArray = new Uint8Array(textureLength * 4);\n        // Ensure that partMatrices.length is at least the maximum part index + 1\n        if (partIndices) {\n            // We always keep part indices in RAM because they are needed for sorting\n            this._partIndices = new Uint8Array(textureLength);\n            this._partIndices.set(partIndices);\n            let maxPartIndex = -1;\n            for (let i = 0; i < partIndices.length; i++) {\n                maxPartIndex = Math.max(maxPartIndex, partIndices[i]);\n            }\n            this._ensureMinimumPartMatricesLength(maxPartIndex + 1);\n        }\n        const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\n        const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\n        if (GaussianSplattingMesh.ProgressiveUpdateAmount) {\n            // create textures with not filled-yet array, then update directly portions of it\n            this._updateTextures(covA, covB, colorArray, sh, this._partIndices ? this._partIndices : undefined);\n            this.setEnabled(true);\n            const partCount = Math.ceil(textureSize.y / lineCountUpdate);\n            for (let partIndex = 0; partIndex < partCount; partIndex++) {\n                const updateLine = partIndex * lineCountUpdate;\n                const splatIndexBase = updateLine * textureSize.x;\n                for (let i = 0; i < textureLengthPerUpdate; i++) {\n                    this._makeSplat(splatIndexBase + i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum, options);\n                }\n                this._updateSubTextures(this._splatPositions, covA, covB, colorArray, updateLine, Math.min(lineCountUpdate, textureSize.y - updateLine));\n                // Update the binfo\n                this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\n                if (isAsync) {\n                    yield;\n                }\n            }\n            // sort will be dirty here as just finished filled positions will not be sorted\n            const positions = Float32Array.from(this._splatPositions);\n            const vertexCount = this._vertexCount;\n            if (this._worker) {\n                this._worker.postMessage({ positions, vertexCount }, [positions.buffer]);\n                this._worker.postMessage({ partIndices });\n            }\n            this._sortIsDirty = true;\n        }\n        else {\n            const paddedVertexCount = (vertexCount + 15) & ~0xf;\n            for (let i = 0; i < vertexCount; i++) {\n                this._makeSplat(i, fBuffer, uBuffer, covA, covB, colorArray, minimum, maximum, options);\n                if (isAsync && i % GaussianSplattingMesh._SplatBatchSize === 0) {\n                    yield;\n                }\n            }\n            // pad the rest\n            for (let i = vertexCount; i < paddedVertexCount; i++) {\n                this._makeEmptySplat(i, covA, covB, colorArray);\n            }\n            // textures\n            this._updateTextures(covA, covB, colorArray, sh, this._partIndices ? this._partIndices : undefined);\n            // Update the binfo\n            this.getBoundingInfo().reConstruct(minimum, maximum, this.getWorldMatrix());\n            this.setEnabled(true);\n            this._sortIsDirty = true;\n        }\n        this._postToWorker(true);\n    }\n    /**\n     * Update asynchronously the buffer\n     * @param data array buffer containing center, color, orientation and scale of splats\n     * @param sh optional array of uint8 array for SH data\n     * @param partIndices optional array of uint8 for rig node indices\n     * @returns a promise\n     */\n    async updateDataAsync(data, sh, partIndices) {\n        return await runCoroutineAsync(this._updateData(data, true, sh, partIndices), createYieldingScheduler());\n    }\n    /**\n     * @experimental\n     * Update data from GS (position, orientation, color, scaling)\n     * @param data array that contain all the datas\n     * @param sh optional array of uint8 array for SH data\n     * @param options optional informations on how to treat data (needs to be 3rd for backward compatibility)\n     * @param partIndices optional array of uint8 for rig node indices\n     */\n    updateData(data, sh, options = { flipY: true }, partIndices) {\n        runCoroutineSync(this._updateData(data, false, sh, partIndices, options));\n    }\n    /**\n     * Refreshes the bounding info, taking into account all the thin instances defined\n     * @returns the current Gaussian Splatting\n     */\n    refreshBoundingInfo() {\n        this.thinInstanceRefreshBoundingInfo(false);\n        return this;\n    }\n    // in case size is different\n    _updateSplatIndexBuffer(vertexCount) {\n        const paddedVertexCount = (vertexCount + 15) & ~0xf;\n        if (!this._splatIndex || vertexCount != this._splatIndex.length) {\n            this._splatIndex = new Float32Array(paddedVertexCount);\n            for (let i = 0; i < paddedVertexCount; i++) {\n                this._splatIndex[i] = i;\n            }\n            // update meshes for knowns cameras\n            this._cameraViewInfos.forEach((cameraViewInfos) => {\n                cameraViewInfos.mesh.thinInstanceSetBuffer(\"splatIndex\", this._splatIndex, 16, false);\n            });\n        }\n        // Update depthMix\n        if ((!this._depthMix || vertexCount != this._depthMix.length) && !IsNative) {\n            this._depthMix = new BigInt64Array(paddedVertexCount);\n        }\n        this.forcedInstanceCount = Math.max(paddedVertexCount >> 4, 1);\n    }\n    _updateSubTextures(centers, covA, covB, colors, lineStart, lineCount, sh, partIndices) {\n        const updateTextureFromData = (texture, data, width, lineStart, lineCount) => {\n            this.getEngine().updateTextureData(texture.getInternalTexture(), data, 0, lineStart, width, lineCount, 0, 0, false);\n        };\n        const textureSize = this._getTextureSize(this._vertexCount);\n        const covBSItemSize = this._useRGBACovariants ? 4 : 2;\n        const texelStart = lineStart * textureSize.x;\n        const texelCount = lineCount * textureSize.x;\n        const covAView = new Uint16Array(covA.buffer, texelStart * 4 * Uint16Array.BYTES_PER_ELEMENT, texelCount * 4);\n        const covBView = new Uint16Array(covB.buffer, texelStart * covBSItemSize * Uint16Array.BYTES_PER_ELEMENT, texelCount * covBSItemSize);\n        const colorsView = new Uint8Array(colors.buffer, texelStart * 4, texelCount * 4);\n        const centersView = new Float32Array(centers.buffer, texelStart * 4 * Float32Array.BYTES_PER_ELEMENT, texelCount * 4);\n        updateTextureFromData(this._covariancesATexture, covAView, textureSize.x, lineStart, lineCount);\n        updateTextureFromData(this._covariancesBTexture, covBView, textureSize.x, lineStart, lineCount);\n        updateTextureFromData(this._centersTexture, centersView, textureSize.x, lineStart, lineCount);\n        updateTextureFromData(this._colorsTexture, colorsView, textureSize.x, lineStart, lineCount);\n        if (sh) {\n            for (let i = 0; i < sh.length; i++) {\n                const componentCount = 4;\n                const shView = new Uint32Array(sh[i].buffer, texelStart * componentCount * 4, texelCount * componentCount);\n                updateTextureFromData(this._shTextures[i], shView, textureSize.x, lineStart, lineCount);\n            }\n        }\n        if (partIndices && this._partIndicesTexture) {\n            const partIndicesView = new Uint8Array(partIndices.buffer, texelStart, texelCount);\n            updateTextureFromData(this._partIndicesTexture, partIndicesView, textureSize.x, lineStart, lineCount);\n        }\n    }\n    _instanciateWorker() {\n        if (!this._vertexCount) {\n            return;\n        }\n        if (this._disableDepthSort) {\n            return;\n        }\n        this._updateSplatIndexBuffer(this._vertexCount);\n        // no worker in native\n        if (IsNative) {\n            return;\n        }\n        // Start the worker thread\n        this._worker?.terminate();\n        this._worker = new Worker(URL.createObjectURL(new Blob([\"(\", GaussianSplattingMesh._CreateWorker.toString(), \")(self)\"], {\n            type: \"application/javascript\",\n        })));\n        const positions = Float32Array.from(this._splatPositions);\n        const partIndices = this._partIndices ? new Uint8Array(this._partIndices) : null;\n        const partMatrices = this._partMatrices.map((matrix) => new Float32Array(matrix.m));\n        this._worker.postMessage({ positions }, [positions.buffer]);\n        this._worker.postMessage({ partIndices });\n        this._worker.postMessage({ partMatrices });\n        this._worker.onmessage = (e) => {\n            // Recompute vertexCountPadded in case _vertexCount has changed since the last update\n            const vertexCountPadded = (this._vertexCount + 15) & ~0xf;\n            // If the vertex count changed, we discard this result and trigger a new sort\n            if (e.data.depthMix.length != vertexCountPadded) {\n                this._canPostToWorker = true;\n                this._postToWorker(true);\n                this._sortIsDirty = false;\n                return;\n            }\n            this._depthMix = e.data.depthMix;\n            const cameraId = e.data.cameraId;\n            const indexMix = new Uint32Array(e.data.depthMix.buffer);\n            if (this._splatIndex) {\n                for (let j = 0; j < vertexCountPadded; j++) {\n                    this._splatIndex[j] = indexMix[2 * j];\n                }\n            }\n            if (this._delayedTextureUpdate) {\n                const textureSize = this._getTextureSize(vertexCountPadded);\n                this._updateSubTextures(this._delayedTextureUpdate.centers, this._delayedTextureUpdate.covA, this._delayedTextureUpdate.covB, this._delayedTextureUpdate.colors, 0, textureSize.y, this._delayedTextureUpdate.sh, this._delayedTextureUpdate.partIndices);\n                this._delayedTextureUpdate = null;\n            }\n            // get mesh for camera and update its instance buffer\n            const cameraViewInfos = this._cameraViewInfos.get(cameraId);\n            if (cameraViewInfos) {\n                if (cameraViewInfos.splatIndexBufferSet) {\n                    cameraViewInfos.mesh.thinInstanceBufferUpdated(\"splatIndex\");\n                }\n                else {\n                    cameraViewInfos.mesh.thinInstanceSetBuffer(\"splatIndex\", this._splatIndex, 16, false);\n                    cameraViewInfos.splatIndexBufferSet = true;\n                }\n            }\n            this._canPostToWorker = true;\n            this._readyToDisplay = true;\n            // sort is dirty when GS is visible for progressive update with a this message arriving but positions were partially filled\n            // another update needs to be kicked. The kick can't happen just when the position buffer is ready because _canPostToWorker might be false.\n            if (this._sortIsDirty) {\n                this._postToWorker(true);\n                this._sortIsDirty = false;\n            }\n        };\n    }\n    _getTextureSize(length) {\n        const engine = this._scene.getEngine();\n        const width = engine.getCaps().maxTextureSize;\n        let height = 1;\n        if (engine.version === 1 && !engine.isWebGPU) {\n            while (width * height < length) {\n                height *= 2;\n            }\n        }\n        else {\n            height = Math.ceil(length / width);\n        }\n        if (height > width) {\n            Logger.Error(\"GaussianSplatting texture size: (\" + width + \", \" + height + \"), maxTextureSize: \" + width);\n            height = width;\n        }\n        return new Vector2(width, height);\n    }\n    /**\n     * Gets the number of parts in the compound\n     * @returns the number of parts in the compound, or 0 if the mesh is not a compound\n     */\n    get partCount() {\n        return this._partMatrices.length;\n    }\n    /**\n     * Sets the world matrix for a specific part of the compound (if this mesh is a compound).\n     * This will trigger a re-sort of the mesh.\n     * @param partIndex index of the part, that must be between 0 and partCount - 1\n     * @param worldMatrix the world matrix to set\n     */\n    setWorldMatrixForPart(partIndex, worldMatrix) {\n        this._partMatrices[partIndex].copyFrom(worldMatrix);\n        if (this._worker) {\n            this._worker.postMessage({ partMatrices: this._partMatrices.map((matrix) => new Float32Array(matrix.m)) });\n        }\n        this._postToWorker(true);\n    }\n    /**\n     * Gets the world matrix for a specific part of the compound (if this mesh is a compound).\n     * @param partIndex index of the part, that must be between 0 and partCount - 1\n     * @returns the world matrix for the part, or the current world matrix of the mesh if the mesh is not a compound\n     */\n    getWorldMatrixForPart(partIndex) {\n        return this._partMatrices[partIndex] ?? this.getWorldMatrix();\n    }\n    /**\n     * Gets the visibility for a specific part of the compound (if this mesh is a compound).\n     * @param partIndex index of the part, that must be between 0 and partCount - 1\n     * @returns the visibility value (0.0 to 1.0) for the part\n     */\n    getPartVisibility(partIndex) {\n        return this._partVisibility[partIndex] ?? 1.0;\n    }\n    /**\n     * Sets the visibility for a specific part of the compound (if this mesh is a compound).\n     * @param partIndex index of the part, that must be between 0 and partCount - 1\n     * @param value the visibility value (0.0 to 1.0) to set\n     */\n    setPartVisibility(partIndex, value) {\n        this._partVisibility[partIndex] = Math.max(0.0, Math.min(1.0, value));\n    }\n    /**\n     * Ensure that the part world matrix array is at least the given length.\n     * NB: This length is used as reference for the number of parts in the compound.\n     * Newly inserted parts are initialized with the current world matrix of the mesh.\n     * @param length - The minimum length to ensure\n     */\n    _ensureMinimumPartMatricesLength(length) {\n        if (this._partMatrices.length < length) {\n            this._resizePartMatrices(length);\n        }\n    }\n    /**\n     * This sets the number of parts in the compound.\n     * Warning: This must be consistent with the indices used in the partIndices texture.\n     * Newly inserted parts are initialized with the current world matrix of the mesh.\n     * @param length - The length to resize to\n     */\n    _resizePartMatrices(length) {\n        if (this._partMatrices.length == length) {\n            return;\n        }\n        else if (this._partMatrices.length > length) {\n            this._partMatrices = this._partMatrices.slice(0, length);\n            this._partVisibility = this._partVisibility.slice(0, length);\n        }\n        else {\n            this.computeWorldMatrix(true);\n            const defaultMatrix = this.getWorldMatrix();\n            while (this._partMatrices.length < length) {\n                this._partMatrices.push(defaultMatrix.clone());\n                this._partVisibility.push(1.0);\n            }\n        }\n        if (this._worker) {\n            this._worker.postMessage({ partMatrices: this._partMatrices.map((matrix) => new Float32Array(matrix.m)) });\n        }\n        this._postToWorker(true);\n    }\n    /**\n     * Add another mesh to this mesh, as a new part. This makes the current mesh a compound, if not already.\n     * NB: The current mesh needs to be loaded with keepInRam: true.\n     * @param other - The other mesh to add. This must be loaded with keepInRam: true.\n     * @param disposeOther - Whether to dispose the other mesh after adding it to the current mesh.\n     * @returns a placeholder mesh that can be used to manipulate the part transform\n     */\n    addPart(other, disposeOther = true) {\n        if (this.partCount >= GaussianSplattingMaxPartCount) {\n            throw new Error(`Cannot add part, as the maximum part count (${GaussianSplattingMaxPartCount}) has been reached`);\n        }\n        const splatCountA = this._vertexCount;\n        const splatsDataA = splatCountA == 0 ? new ArrayBuffer(0) : this.splatsData;\n        const shDataA = this.shData;\n        const splatCountB = other._vertexCount;\n        const splatsDataB = other.splatsData;\n        const shDataB = other.shData;\n        const mergedShDataLength = Math.max(shDataA?.length || 0, shDataB?.length || 0);\n        const hasMergedShData = shDataA !== null && shDataB !== null;\n        // Sanity checks\n        if (!splatsDataA) {\n            throw new Error(`To call addPart(), the current mesh must be loaded with keepInRam: true`);\n        }\n        const expectedSplatsDataSizeA = splatCountA * GaussianSplattingMesh._RowOutputLength;\n        if (splatsDataA.byteLength !== expectedSplatsDataSizeA) {\n            throw new Error(`splatsDataA size (${splatsDataA.byteLength}) does not match expected size (${expectedSplatsDataSizeA})`);\n        }\n        if (!splatsDataB) {\n            throw new Error(`To call addPart(), the other mesh must be loaded with keepInRam: true`);\n        }\n        const expectedSplatsDataSizeB = splatCountB * GaussianSplattingMesh._RowOutputLength;\n        if (splatsDataB.byteLength !== expectedSplatsDataSizeB) {\n            throw new Error(`splatsDataB size (${splatsDataB.byteLength}) does not match expected size (${expectedSplatsDataSizeB})`);\n        }\n        if (other.partIndices) {\n            throw new Error(`To call addPart(), the other mesh must not be a compound`);\n        }\n        // Concatenate splatsData (ArrayBuffer)\n        const mergedSplatsData = new Uint8Array(splatsDataA.byteLength + splatsDataB.byteLength);\n        mergedSplatsData.set(new Uint8Array(splatsDataA), 0);\n        mergedSplatsData.set(new Uint8Array(splatsDataB), splatsDataA.byteLength);\n        let mergedShData = undefined;\n        if (hasMergedShData) {\n            // Note: We need to calculate the texture size and pad accordingly\n            // Each SH texture texel stores 16 bytes (4 RGBA uint32 components)\n            const bytesPerTexel = 16;\n            const totalSplatCount = splatCountA + splatCountB;\n            mergedShData = [];\n            for (let i = 0; i < mergedShDataLength; i++) {\n                const mergedShDataItem = new Uint8Array(totalSplatCount * bytesPerTexel);\n                if (i < (shDataA?.length ?? 0)) {\n                    mergedShDataItem.set(shDataA[i], 0);\n                }\n                if (i < (shDataB?.length ?? 0)) {\n                    const byteOffset = bytesPerTexel * splatCountA;\n                    mergedShDataItem.set(shDataB[i], byteOffset);\n                }\n                mergedShData.push(mergedShDataItem);\n            }\n        }\n        // Concatenate partIndices (Uint8Array)\n        let newPartIndex = this.partCount;\n        let partIndicesA = this.partIndices;\n        if (!partIndicesA) {\n            partIndicesA = new Uint8Array(splatCountA);\n            newPartIndex = splatCountA > 0 ? 1 : 0;\n            //newPartIndex = 1;\n        }\n        if (partIndicesA.length < splatCountA) {\n            throw new Error(`partIndices length (${partIndicesA.length}) should be at least vertexCount (${splatCountA}) in the current mesh`);\n        }\n        const partIndicesB = new Uint8Array(splatCountB).fill(newPartIndex);\n        const mergedPartIndices = new Uint8Array(splatCountA + splatCountB);\n        mergedPartIndices.set(partIndicesA.slice(0, splatCountA), 0);\n        mergedPartIndices.set(partIndicesB, splatCountA);\n        this.updateData(mergedSplatsData.buffer, mergedShData, { flipY: false }, mergedPartIndices);\n        // Merge part matrices (TODO)\n        const partWorldMatrix = other.getWorldMatrix();\n        this.setWorldMatrixForPart(newPartIndex, partWorldMatrix);\n        // Create a proxy mesh to manipulate the part transform\n        const proxyMesh = new GaussianSplattingPartProxyMesh(other.name, this.getScene(), this, other, newPartIndex);\n        if (disposeOther) {\n            other.dispose();\n        }\n        // Set the initial world matrix\n        const quaternion = new Quaternion();\n        partWorldMatrix.decompose(proxyMesh.scaling, quaternion, proxyMesh.position);\n        proxyMesh.rotationQuaternion = quaternion;\n        proxyMesh.computeWorldMatrix(true);\n        // Store the proxy in the map\n        this._partProxies.set(newPartIndex, proxyMesh);\n        return proxyMesh;\n    }\n    /**\n     * Remove a part from this compound mesh.\n     * @param index - The index of the part to remove\n     */\n    removePart(index) {\n        if (index < 0 || index >= this.partCount) {\n            throw new Error(`Part index ${index} is out of range [0, ${this.partCount})`);\n        }\n        // Get the current data\n        const splatsData = this.splatsData;\n        const shData = this.shData;\n        const partIndices = this.partIndices;\n        if (!splatsData || !partIndices) {\n            throw new Error(\"Cannot remove part from a non-compound mesh or mesh without keepInRam\");\n        }\n        const splatCount = this._vertexCount;\n        const rowLength = GaussianSplattingMesh._RowOutputLength;\n        // Count splats that will remain (not in the removed part)\n        let newSplatCount = 0;\n        for (let i = 0; i < splatCount; i++) {\n            if (partIndices[i] !== index) {\n                newSplatCount++;\n            }\n        }\n        // Build new splats data excluding the removed part\n        const newSplatsData = new Uint8Array(newSplatCount * rowLength);\n        const newPartIndices = new Uint8Array(newSplatCount);\n        let newShData = undefined;\n        if (shData) {\n            const bytesPerTexel = 16;\n            newShData = [];\n            for (let i = 0; i < shData.length; i++) {\n                newShData.push(new Uint8Array(newSplatCount * bytesPerTexel));\n            }\n        }\n        let writeIndex = 0;\n        for (let readIndex = 0; readIndex < splatCount; readIndex++) {\n            const currentPartIndex = partIndices[readIndex];\n            if (currentPartIndex === index) {\n                // Skip splats from the removed part\n                continue;\n            }\n            // Copy splat data\n            const srcOffset = readIndex * rowLength;\n            const dstOffset = writeIndex * rowLength;\n            newSplatsData.set(new Uint8Array(splatsData, srcOffset, rowLength), dstOffset);\n            // Renumber part indices: indices > removed index get decremented\n            newPartIndices[writeIndex] = currentPartIndex > index ? currentPartIndex - 1 : currentPartIndex;\n            // Copy SH data if present\n            if (shData && newShData) {\n                const bytesPerTexel = 16;\n                for (let shIndex = 0; shIndex < shData.length; shIndex++) {\n                    const srcShOffset = readIndex * bytesPerTexel;\n                    const dstShOffset = writeIndex * bytesPerTexel;\n                    newShData[shIndex].set(new Uint8Array(shData[shIndex].buffer, srcShOffset, bytesPerTexel), dstShOffset);\n                }\n            }\n            writeIndex++;\n        }\n        // Remove the part matrix and visibility\n        this._partMatrices.splice(index, 1);\n        this._partVisibility.splice(index, 1);\n        // Update worker with new part matrices\n        if (this._worker) {\n            this._worker.postMessage({ partMatrices: this._partMatrices.map((matrix) => new Float32Array(matrix.m)) });\n        }\n        // Update the mesh with the new data\n        this.updateData(newSplatsData.buffer, newShData, { flipY: false }, newPartIndices);\n        // Dispose and remove the proxy for the removed part\n        const proxyToRemove = this._partProxies.get(index);\n        if (proxyToRemove) {\n            proxyToRemove.dispose();\n            this._partProxies.delete(index);\n        }\n        // Update the proxy map: renumber proxies with index > removed index\n        const proxiesToUpdate = [];\n        this._partProxies.forEach((proxy, proxyIndex) => {\n            if (proxyIndex > index) {\n                proxiesToUpdate.push([proxyIndex, proxy]);\n            }\n        });\n        // Remove and re-add with updated indices\n        for (const [oldIndex, proxy] of proxiesToUpdate) {\n            this._partProxies.delete(oldIndex);\n            // Update the proxy's internal partIndex\n            proxy.updatePartIndex(oldIndex - 1);\n            this._partProxies.set(oldIndex - 1, proxy);\n        }\n    }\n    /**\n     * Modifies the splats according to the passed transformation matrix.\n     * @param transform defines the transform matrix to use\n     * @returns the current mesh\n     */\n    bakeTransformIntoVertices(transform) {\n        const arrayBuffer = this.splatsData;\n        if (!arrayBuffer) {\n            Logger.Error(\"Cannot bake transform into vertices if splatsData is not kept in RAM\");\n            return this;\n        }\n        // Check for uniform scaling\n        const m = transform.m;\n        const scaleX = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\n        const scaleY = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\n        const scaleZ = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\n        const epsilon = 0.001;\n        if (Math.abs(scaleX - scaleY) > epsilon || Math.abs(scaleX - scaleZ) > epsilon) {\n            Logger.Error(\"Gaussian Splatting bakeTransformIntoVertices does not support non-uniform scaling\");\n            return this;\n        }\n        const uBuffer = new Uint8Array(arrayBuffer);\n        const fBuffer = new Float32Array(arrayBuffer);\n        const temp = TmpVectors.Vector3[0];\n        let index;\n        const quaternion = TmpVectors.Quaternion[0];\n        const transformedQuaternion = TmpVectors.Quaternion[1];\n        transform.decompose(temp, transformedQuaternion, temp);\n        for (index = 0; index < this._vertexCount; index++) {\n            const floatIndex = index * 8; // 8 floats per splat (center.x, center.y, center.z, scale.x, scale.y, scale.z, ...)\n            Vector3.TransformCoordinatesFromFloatsToRef(fBuffer[floatIndex], fBuffer[floatIndex + 1], fBuffer[floatIndex + 2], transform, temp);\n            fBuffer[floatIndex] = temp.x;\n            fBuffer[floatIndex + 1] = temp.y;\n            fBuffer[floatIndex + 2] = temp.z;\n            // Apply uniform scaling to splat scales\n            fBuffer[floatIndex + 3] *= scaleX;\n            fBuffer[floatIndex + 4] *= scaleX;\n            fBuffer[floatIndex + 5] *= scaleX;\n            // Unpack quaternion from uint8array (matching _GetSplat packing convention)\n            quaternion.set((uBuffer[32 * index + 28 + 1] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 2] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 3] - 127.5) / 127.5, (uBuffer[32 * index + 28 + 0] - 127.5) / 127.5);\n            quaternion.normalize();\n            // If there is a negative scaling, we need to flip the quaternion to keep the correct handedness\n            if (this.scaling.x < 0) {\n                quaternion.x = -quaternion.x;\n                quaternion.w = -quaternion.w;\n            }\n            if (this.scaling.y < 0) {\n                quaternion.y = -quaternion.y;\n                quaternion.w = -quaternion.w;\n            }\n            if (this.scaling.z < 0) {\n                quaternion.z = -quaternion.z;\n                quaternion.w = -quaternion.w;\n            }\n            // Transform the quaternion\n            transformedQuaternion.multiplyToRef(quaternion, quaternion);\n            quaternion.normalize();\n            // Pack quaternion back to uint8array (matching _GetSplat packing convention)\n            uBuffer[32 * index + 28 + 0] = Math.round(quaternion.w * 127.5 + 127.5);\n            uBuffer[32 * index + 28 + 1] = Math.round(quaternion.x * 127.5 + 127.5);\n            uBuffer[32 * index + 28 + 2] = Math.round(quaternion.y * 127.5 + 127.5);\n            uBuffer[32 * index + 28 + 3] = Math.round(quaternion.z * 127.5 + 127.5);\n        }\n        this.updateData(arrayBuffer, this.shData ?? undefined, { flipY: false });\n        return this;\n    }\n}\nGaussianSplattingMesh._RowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // Vector3 position, Vector3 scale, 1 u8 quaternion, 1 color with alpha\nGaussianSplattingMesh._SH_C0 = 0.28209479177387814;\n// batch size between 2 yield calls. This value is a tradeoff between updates overhead and framerate hiccups\n// This step is faster the PLY conversion. So batch size can be bigger\nGaussianSplattingMesh._SplatBatchSize = 327680;\n// batch size between 2 yield calls during the PLY to splat conversion.\nGaussianSplattingMesh._PlyConversionBatchSize = 32768;\nGaussianSplattingMesh._BatchSize = 16; // 16 splats per instance\nGaussianSplattingMesh._DefaultViewUpdateThreshold = 1e-4;\n/**\n * Set the number of batch (a batch is 16384 splats) after which a display update is performed\n * A value of 0 (default) means display update will not happens before splat is ready.\n */\nGaussianSplattingMesh.ProgressiveUpdateAmount = 0;\nGaussianSplattingMesh._CreateWorker = function (self) {\n    let positions;\n    let depthMix;\n    let indices;\n    let floatMix;\n    let partIndices;\n    let partMatrices;\n    function multiplyMatrices(matrix1, matrix2) {\n        const result = new Float32Array(16);\n        for (let i = 0; i < 4; i++) {\n            for (let j = 0; j < 4; j++) {\n                for (let k = 0; k < 4; k++) {\n                    result[j * 4 + i] += matrix1[k * 4 + i] * matrix2[j * 4 + k];\n                }\n            }\n        }\n        return result;\n    }\n    self.onmessage = (e) => {\n        // updated on init\n        if (e.data.positions) {\n            positions = e.data.positions;\n        }\n        // update on rig node changed\n        else if (e.data.partMatrices) {\n            partMatrices = e.data.partMatrices;\n        }\n        // update on rig node indices changed\n        else if (e.data.partIndices !== undefined) {\n            partIndices = e.data.partIndices;\n        }\n        // update on view changed\n        else {\n            const cameraId = e.data.cameraId;\n            const globalModelViewProjection = e.data.modelViewProjection;\n            const viewProjection = e.data.viewProjection;\n            const vertexCountPadded = (positions.length / 4 + 15) & ~0xf;\n            if (!positions || !globalModelViewProjection) {\n                // Sanity check, it shouldn't happen!\n                throw new Error(\"positions or modelViewProjection matrix is not defined!\");\n            }\n            depthMix = e.data.depthMix;\n            indices = new Uint32Array(depthMix.buffer);\n            floatMix = new Float32Array(depthMix.buffer);\n            // Sort\n            for (let j = 0; j < vertexCountPadded; j++) {\n                indices[2 * j] = j;\n            }\n            const depthScale = e.data.depthScale;\n            if (partMatrices && partIndices) {\n                // If there are rig node matrices, we use them instead of the global model view proj\n                // Precompute modelViewProj for each rig node\n                const modelViewProjs = partMatrices.map((model) => multiplyMatrices(viewProjection, model));\n                // NB: For performance reasons, we assume that part indices are valid\n                const length = partIndices.length;\n                for (let j = 0; j < vertexCountPadded; j++) {\n                    // NB: We need this 'min' because vertex array is padded, not partIndices\n                    const partIndex = partIndices[Math.min(j, length - 1)];\n                    const mvp = modelViewProjs[partIndex];\n                    floatMix[2 * j + 1] = 10000 - (mvp[2] * positions[4 * j + 0] + mvp[6] * positions[4 * j + 1] + mvp[10] * positions[4 * j + 2] + mvp[14]) * depthScale;\n                }\n            }\n            else {\n                // If there are no rig node matrices, we use the global model view proj\n                const mvp = globalModelViewProjection;\n                for (let j = 0; j < vertexCountPadded; j++) {\n                    floatMix[2 * j + 1] = 10000 - (mvp[2] * positions[4 * j + 0] + mvp[6] * positions[4 * j + 1] + mvp[10] * positions[4 * j + 2] + mvp[14]) * depthScale;\n                }\n            }\n            depthMix.sort();\n            self.postMessage({ depthMix, cameraId }, [depthMix.buffer]);\n        }\n    };\n};\n//# sourceMappingURL=gaussianSplattingMesh.js.map","import { Color4, Color3 } from \"../Maths/math\";\nimport { Vector2, Vector3, Vector4, TmpVectors, Matrix } from \"../Maths/math.vector\";\nimport { Logger } from \"../Misc/logger\";\nimport { VertexBuffer } from \"../Buffers/buffer\";\nimport { VertexData } from \"../Meshes/mesh.vertexData\";\nimport { Mesh } from \"../Meshes/mesh\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { CloudPoint, PointsGroup } from \"./cloudPoint\";\nimport { Ray } from \"../Culling/ray\";\nimport { StandardMaterial } from \"../Materials/standardMaterial\";\nimport { BaseTexture } from \"./../Materials/Textures/baseTexture\";\nimport { RandomRange } from \"../Maths/math.scalar.functions\";\n/** Defines the 4 color options */\nexport var PointColor;\n(function (PointColor) {\n    /** color value */\n    PointColor[PointColor[\"Color\"] = 2] = \"Color\";\n    /** uv value */\n    PointColor[PointColor[\"UV\"] = 1] = \"UV\";\n    /** random value */\n    PointColor[PointColor[\"Random\"] = 0] = \"Random\";\n    /** stated value */\n    PointColor[PointColor[\"Stated\"] = 3] = \"Stated\";\n})(PointColor || (PointColor = {}));\n/**\n * The PointCloudSystem (PCS) is a single updatable mesh. The points corresponding to the vertices of this big mesh.\n * As it is just a mesh, the PointCloudSystem has all the same properties as any other BJS mesh : not more, not less. It can be scaled, rotated, translated, enlighted, textured, moved, etc.\n\n * The PointCloudSystem is also a particle system, with each point being a particle. It provides some methods to manage the particles.\n * However it is behavior agnostic. This means it has no emitter, no particle physics, no particle recycler. You have to implement your own behavior.\n *\n * Full documentation here : TO BE ENTERED\n */\nexport class PointsCloudSystem {\n    /**\n     * Gets the particle positions computed by the Point Cloud System\n     */\n    get positions() {\n        return this._positions32;\n    }\n    /**\n     * Gets the particle colors computed by the Point Cloud System\n     */\n    get colors() {\n        return this._colors32;\n    }\n    /**\n     * Gets the particle uvs computed by the Point Cloud System\n     */\n    get uvs() {\n        return this._uvs32;\n    }\n    /**\n     * Creates a PCS (Points Cloud System) object\n     * @param name (String) is the PCS name, this will be the underlying mesh name\n     * @param pointSize (number) is the size for each point. Has no effect on a WebGPU engine.\n     * @param scene (Scene) is the scene in which the PCS is added\n     * @param options defines the options of the PCS e.g.\n     * * updatable (optional boolean, default true) : if the PCS must be updatable or immutable\n     */\n    constructor(name, pointSize, scene, options) {\n        /**\n         *  The PCS array of cloud point objects. Just access each particle as with any classic array.\n         *  Example : var p = SPS.particles[i];\n         */\n        this.particles = new Array();\n        /**\n         * The PCS total number of particles. Read only. Use PCS.counter instead if you need to set your own value.\n         */\n        this.nbParticles = 0;\n        /**\n         * This a counter for your own usage. It's not set by any SPS functions.\n         */\n        this.counter = 0;\n        /**\n         * This empty object is intended to store some PCS specific or temporary values in order to lower the Garbage Collector activity.\n         * Please read :\n         */\n        this.vars = {};\n        this._promises = [];\n        this._positions = new Array();\n        this._indices = new Array();\n        this._normals = new Array();\n        this._colors = new Array();\n        this._uvs = new Array();\n        this._updatable = true;\n        this._isVisibilityBoxLocked = false;\n        this._alwaysVisible = false;\n        this._groups = new Array(); //start indices for each group of particles\n        this._groupCounter = 0;\n        this._computeParticleColor = true;\n        this._computeParticleTexture = true;\n        this._computeParticleRotation = true;\n        this._computeBoundingBox = false;\n        this._isReady = false;\n        this.name = name;\n        this._size = pointSize;\n        this._scene = scene || EngineStore.LastCreatedScene;\n        if (options && options.updatable !== undefined) {\n            this._updatable = options.updatable;\n        }\n        else {\n            this._updatable = true;\n        }\n    }\n    /**\n     * Builds the PCS underlying mesh. Returns a standard Mesh.\n     * If no points were added to the PCS, the returned mesh is just a single point.\n     * @param material The material to use to render the mesh. If not provided, will create a default one\n     * @returns a promise for the created mesh\n     */\n    async buildMeshAsync(material) {\n        await Promise.all(this._promises);\n        this._isReady = true;\n        return await this._buildMeshAsync(material);\n    }\n    async _buildMeshAsync(material) {\n        if (this.nbParticles === 0) {\n            this.addPoints(1);\n        }\n        this._positions32 = new Float32Array(this._positions);\n        this._uvs32 = new Float32Array(this._uvs);\n        this._colors32 = new Float32Array(this._colors);\n        const vertexData = new VertexData();\n        vertexData.set(this._positions32, VertexBuffer.PositionKind);\n        if (this._uvs32.length > 0) {\n            vertexData.set(this._uvs32, VertexBuffer.UVKind);\n        }\n        let ec = 0; //emissive color value 0 for UVs, 1 for color\n        if (this._colors32.length > 0) {\n            ec = 1;\n            vertexData.set(this._colors32, VertexBuffer.ColorKind);\n        }\n        const mesh = new Mesh(this.name, this._scene);\n        vertexData.applyToMesh(mesh, this._updatable);\n        this.mesh = mesh;\n        // free memory\n        this._positions = null;\n        this._uvs = null;\n        this._colors = null;\n        if (!this._updatable) {\n            this.particles.length = 0;\n        }\n        let mat = material;\n        if (!mat) {\n            mat = new StandardMaterial(\"point cloud material\", this._scene);\n            mat.emissiveColor = new Color3(ec, ec, ec);\n            mat.disableLighting = true;\n            mat.pointsCloud = true;\n            mat.pointSize = this._size;\n        }\n        mesh.material = mat;\n        return mesh;\n    }\n    // adds a new particle object in the particles array\n    _addParticle(idx, group, groupId, idxInGroup) {\n        const cp = new CloudPoint(idx, group, groupId, idxInGroup, this);\n        this.particles.push(cp);\n        return cp;\n    }\n    _randomUnitVector(particle) {\n        particle.position = new Vector3(Math.random(), Math.random(), Math.random());\n        particle.color = new Color4(1, 1, 1, 1);\n    }\n    _getColorIndicesForCoord(pointsGroup, x, y, width) {\n        const imageData = pointsGroup._groupImageData;\n        const color = y * (width * 4) + x * 4;\n        const colorIndices = [color, color + 1, color + 2, color + 3];\n        const redIndex = colorIndices[0];\n        const greenIndex = colorIndices[1];\n        const blueIndex = colorIndices[2];\n        const alphaIndex = colorIndices[3];\n        const redForCoord = imageData[redIndex];\n        const greenForCoord = imageData[greenIndex];\n        const blueForCoord = imageData[blueIndex];\n        const alphaForCoord = imageData[alphaIndex];\n        return new Color4(redForCoord / 255, greenForCoord / 255, blueForCoord / 255, alphaForCoord);\n    }\n    _setPointsColorOrUV(mesh, pointsGroup, isVolume, colorFromTexture, hasTexture, color, range, uvSetIndex) {\n        uvSetIndex = uvSetIndex ?? 0;\n        if (isVolume) {\n            mesh.updateFacetData();\n        }\n        const boundInfo = mesh.getBoundingInfo();\n        const diameter = 2 * boundInfo.boundingSphere.radius;\n        let meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        const meshUV = mesh.getVerticesData(VertexBuffer.UVKind + (uvSetIndex ? uvSetIndex + 1 : \"\"));\n        const meshCol = mesh.getVerticesData(VertexBuffer.ColorKind);\n        const place = Vector3.Zero();\n        mesh.computeWorldMatrix();\n        const meshMatrix = mesh.getWorldMatrix();\n        if (!meshMatrix.isIdentity()) {\n            meshPos = meshPos.slice(0);\n            for (let p = 0; p < meshPos.length / 3; p++) {\n                Vector3.TransformCoordinatesFromFloatsToRef(meshPos[3 * p], meshPos[3 * p + 1], meshPos[3 * p + 2], meshMatrix, place);\n                meshPos[3 * p] = place.x;\n                meshPos[3 * p + 1] = place.y;\n                meshPos[3 * p + 2] = place.z;\n            }\n        }\n        let idxPoints = 0;\n        let id0 = 0;\n        let id1 = 0;\n        let id2 = 0;\n        let v0X = 0;\n        let v0Y = 0;\n        let v0Z = 0;\n        let v1X = 0;\n        let v1Y = 0;\n        let v1Z = 0;\n        let v2X = 0;\n        let v2Y = 0;\n        let v2Z = 0;\n        const vertex0 = Vector3.Zero();\n        const vertex1 = Vector3.Zero();\n        const vertex2 = Vector3.Zero();\n        const vec0 = Vector3.Zero();\n        const vec1 = Vector3.Zero();\n        let uv0X = 0;\n        let uv0Y = 0;\n        let uv1X = 0;\n        let uv1Y = 0;\n        let uv2X = 0;\n        let uv2Y = 0;\n        const uv0 = Vector2.Zero();\n        const uv1 = Vector2.Zero();\n        const uv2 = Vector2.Zero();\n        const uvec0 = Vector2.Zero();\n        const uvec1 = Vector2.Zero();\n        let col0X = 0;\n        let col0Y = 0;\n        let col0Z = 0;\n        let col0A = 0;\n        let col1X = 0;\n        let col1Y = 0;\n        let col1Z = 0;\n        let col1A = 0;\n        let col2X = 0;\n        let col2Y = 0;\n        let col2Z = 0;\n        let col2A = 0;\n        const col0 = Vector4.Zero();\n        const col1 = Vector4.Zero();\n        const col2 = Vector4.Zero();\n        const colvec0 = Vector4.Zero();\n        const colvec1 = Vector4.Zero();\n        let lamda = 0;\n        let mu = 0;\n        range = range ? range : 0;\n        let facetPoint;\n        let uvPoint;\n        let colPoint = new Vector4(0, 0, 0, 0);\n        let norm = Vector3.Zero();\n        let tang = Vector3.Zero();\n        let biNorm = Vector3.Zero();\n        let angle = 0;\n        let facetPlaneVec = Vector3.Zero();\n        let gap = 0;\n        let distance = 0;\n        const ray = new Ray(Vector3.Zero(), new Vector3(1, 0, 0));\n        let pickInfo;\n        let direction = Vector3.Zero();\n        for (let index = 0; index < meshInd.length / 3; index++) {\n            id0 = meshInd[3 * index];\n            id1 = meshInd[3 * index + 1];\n            id2 = meshInd[3 * index + 2];\n            v0X = meshPos[3 * id0];\n            v0Y = meshPos[3 * id0 + 1];\n            v0Z = meshPos[3 * id0 + 2];\n            v1X = meshPos[3 * id1];\n            v1Y = meshPos[3 * id1 + 1];\n            v1Z = meshPos[3 * id1 + 2];\n            v2X = meshPos[3 * id2];\n            v2Y = meshPos[3 * id2 + 1];\n            v2Z = meshPos[3 * id2 + 2];\n            vertex0.set(v0X, v0Y, v0Z);\n            vertex1.set(v1X, v1Y, v1Z);\n            vertex2.set(v2X, v2Y, v2Z);\n            vertex1.subtractToRef(vertex0, vec0);\n            vertex2.subtractToRef(vertex1, vec1);\n            if (meshUV) {\n                uv0X = meshUV[2 * id0];\n                uv0Y = meshUV[2 * id0 + 1];\n                uv1X = meshUV[2 * id1];\n                uv1Y = meshUV[2 * id1 + 1];\n                uv2X = meshUV[2 * id2];\n                uv2Y = meshUV[2 * id2 + 1];\n                uv0.set(uv0X, uv0Y);\n                uv1.set(uv1X, uv1Y);\n                uv2.set(uv2X, uv2Y);\n                uv1.subtractToRef(uv0, uvec0);\n                uv2.subtractToRef(uv1, uvec1);\n            }\n            if (meshCol && colorFromTexture) {\n                col0X = meshCol[4 * id0];\n                col0Y = meshCol[4 * id0 + 1];\n                col0Z = meshCol[4 * id0 + 2];\n                col0A = meshCol[4 * id0 + 3];\n                col1X = meshCol[4 * id1];\n                col1Y = meshCol[4 * id1 + 1];\n                col1Z = meshCol[4 * id1 + 2];\n                col1A = meshCol[4 * id1 + 3];\n                col2X = meshCol[4 * id2];\n                col2Y = meshCol[4 * id2 + 1];\n                col2Z = meshCol[4 * id2 + 2];\n                col2A = meshCol[4 * id2 + 3];\n                col0.set(col0X, col0Y, col0Z, col0A);\n                col1.set(col1X, col1Y, col1Z, col1A);\n                col2.set(col2X, col2Y, col2Z, col2A);\n                col1.subtractToRef(col0, colvec0);\n                col2.subtractToRef(col1, colvec1);\n            }\n            let width;\n            let height;\n            let deltaS;\n            let deltaV;\n            let h;\n            let s;\n            let v;\n            let hsvCol;\n            const statedColor = new Color3(0, 0, 0);\n            const colPoint3 = new Color3(0, 0, 0);\n            let pointColors;\n            let particle;\n            for (let i = 0; i < pointsGroup._groupDensity[index]; i++) {\n                idxPoints = this.particles.length;\n                this._addParticle(idxPoints, pointsGroup, this._groupCounter, index + i);\n                particle = this.particles[idxPoints];\n                //form a point inside the facet v0, v1, v2;\n                lamda = Math.sqrt(RandomRange(0, 1));\n                mu = RandomRange(0, 1);\n                facetPoint = vertex0.add(vec0.scale(lamda)).add(vec1.scale(lamda * mu));\n                if (isVolume) {\n                    norm = mesh.getFacetNormal(index).normalize().scale(-1);\n                    tang = vec0.clone().normalize();\n                    biNorm = Vector3.Cross(norm, tang);\n                    angle = RandomRange(0, 2 * Math.PI);\n                    facetPlaneVec = tang.scale(Math.cos(angle)).add(biNorm.scale(Math.sin(angle)));\n                    angle = RandomRange(0.1, Math.PI / 2);\n                    direction = facetPlaneVec.scale(Math.cos(angle)).add(norm.scale(Math.sin(angle)));\n                    ray.origin = facetPoint.add(direction.scale(0.00001));\n                    ray.direction = direction;\n                    ray.length = diameter;\n                    pickInfo = ray.intersectsMesh(mesh);\n                    if (pickInfo.hit) {\n                        distance = pickInfo.pickedPoint.subtract(facetPoint).length();\n                        gap = RandomRange(0, 1) * distance;\n                        facetPoint.addInPlace(direction.scale(gap));\n                    }\n                }\n                particle.position = facetPoint.clone();\n                this._positions.push(particle.position.x, particle.position.y, particle.position.z);\n                if (colorFromTexture !== undefined) {\n                    if (meshUV) {\n                        uvPoint = uv0.add(uvec0.scale(lamda)).add(uvec1.scale(lamda * mu));\n                        if (colorFromTexture) {\n                            //Set particle color to texture color\n                            if (hasTexture && pointsGroup._groupImageData !== null) {\n                                width = pointsGroup._groupImgWidth;\n                                height = pointsGroup._groupImgHeight;\n                                pointColors = this._getColorIndicesForCoord(pointsGroup, Math.round(uvPoint.x * width), Math.round(uvPoint.y * height), width);\n                                particle.color = pointColors;\n                                this._colors.push(pointColors.r, pointColors.g, pointColors.b, pointColors.a);\n                            }\n                            else {\n                                if (meshCol) {\n                                    //failure in texture and colors available\n                                    colPoint = col0.add(colvec0.scale(lamda)).add(colvec1.scale(lamda * mu));\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                }\n                                else {\n                                    colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                                }\n                            }\n                        }\n                        else {\n                            //Set particle uv based on a mesh uv\n                            particle.uv = uvPoint.clone();\n                            this._uvs.push(particle.uv.x, particle.uv.y);\n                        }\n                    }\n                }\n                else {\n                    if (color) {\n                        statedColor.set(color.r, color.g, color.b);\n                        deltaS = RandomRange(-range, range);\n                        deltaV = RandomRange(-range, range);\n                        hsvCol = statedColor.toHSV();\n                        h = hsvCol.r;\n                        s = hsvCol.g + deltaS;\n                        v = hsvCol.b + deltaV;\n                        if (s < 0) {\n                            s = 0;\n                        }\n                        if (s > 1) {\n                            s = 1;\n                        }\n                        if (v < 0) {\n                            v = 0;\n                        }\n                        if (v > 1) {\n                            v = 1;\n                        }\n                        Color3.HSVtoRGBToRef(h, s, v, colPoint3);\n                        colPoint.set(colPoint3.r, colPoint3.g, colPoint3.b, 1);\n                    }\n                    else {\n                        colPoint = col0.set(Math.random(), Math.random(), Math.random(), 1);\n                    }\n                    particle.color = new Color4(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                    this._colors.push(colPoint.x, colPoint.y, colPoint.z, colPoint.w);\n                }\n            }\n        }\n    }\n    // stores mesh texture in dynamic texture for color pixel retrieval\n    // when pointColor type is color for surface points\n    _colorFromTexture(mesh, pointsGroup, isVolume) {\n        if (mesh.material === null) {\n            Logger.Warn(mesh.name + \"has no material.\");\n            pointsGroup._groupImageData = null;\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n            return;\n        }\n        const mat = mesh.material;\n        const textureList = mat.getActiveTextures();\n        if (textureList.length === 0) {\n            Logger.Warn(mesh.name + \"has no usable texture.\");\n            pointsGroup._groupImageData = null;\n            this._setPointsColorOrUV(mesh, pointsGroup, isVolume, true, false);\n            return;\n        }\n        const clone = mesh.clone();\n        clone.setEnabled(false);\n        this._promises.push(new Promise((resolve) => {\n            BaseTexture.WhenAllReady(textureList, () => {\n                let n = pointsGroup._textureNb;\n                if (n < 0) {\n                    n = 0;\n                }\n                if (n > textureList.length - 1) {\n                    n = textureList.length - 1;\n                }\n                const finalize = () => {\n                    pointsGroup._groupImgWidth = textureList[n].getSize().width;\n                    pointsGroup._groupImgHeight = textureList[n].getSize().height;\n                    this._setPointsColorOrUV(clone, pointsGroup, isVolume, true, true, undefined, undefined, textureList[n].coordinatesIndex);\n                    clone.dispose();\n                    resolve();\n                };\n                pointsGroup._groupImageData = null;\n                const dataPromise = textureList[n].readPixels();\n                if (!dataPromise) {\n                    finalize();\n                }\n                else {\n                    // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                    dataPromise.then((data) => {\n                        pointsGroup._groupImageData = data;\n                        finalize();\n                    });\n                }\n            });\n        }));\n    }\n    // calculates the point density per facet of a mesh for surface points\n    _calculateDensity(nbPoints, positions, indices) {\n        let id0;\n        let id1;\n        let id2;\n        let v0X;\n        let v0Y;\n        let v0Z;\n        let v1X;\n        let v1Y;\n        let v1Z;\n        let v2X;\n        let v2Y;\n        let v2Z;\n        const vertex0 = Vector3.Zero();\n        const vertex1 = Vector3.Zero();\n        const vertex2 = Vector3.Zero();\n        const vec0 = Vector3.Zero();\n        const vec1 = Vector3.Zero();\n        const normal = Vector3.Zero();\n        let area;\n        const cumulativeAreas = [];\n        let surfaceArea = 0;\n        const nbFacets = indices.length / 3;\n        //surface area\n        for (let index = 0; index < nbFacets; index++) {\n            id0 = indices[3 * index];\n            id1 = indices[3 * index + 1];\n            id2 = indices[3 * index + 2];\n            v0X = positions[3 * id0];\n            v0Y = positions[3 * id0 + 1];\n            v0Z = positions[3 * id0 + 2];\n            v1X = positions[3 * id1];\n            v1Y = positions[3 * id1 + 1];\n            v1Z = positions[3 * id1 + 2];\n            v2X = positions[3 * id2];\n            v2Y = positions[3 * id2 + 1];\n            v2Z = positions[3 * id2 + 2];\n            vertex0.set(v0X, v0Y, v0Z);\n            vertex1.set(v1X, v1Y, v1Z);\n            vertex2.set(v2X, v2Y, v2Z);\n            vertex1.subtractToRef(vertex0, vec0);\n            vertex2.subtractToRef(vertex1, vec1);\n            Vector3.CrossToRef(vec0, vec1, normal);\n            area = 0.5 * normal.length();\n            surfaceArea += area;\n            cumulativeAreas[index] = surfaceArea;\n        }\n        const density = new Array(nbFacets);\n        let remainingPoints = nbPoints;\n        for (let index = nbFacets - 1; index > 0; index--) {\n            const cumulativeArea = cumulativeAreas[index];\n            if (cumulativeArea === 0) {\n                // avoiding division by 0 upon degenerate triangles\n                density[index] = 0;\n            }\n            else {\n                const area = cumulativeArea - cumulativeAreas[index - 1];\n                const facetPointsWithFraction = (area / cumulativeArea) * remainingPoints;\n                const floored = Math.floor(facetPointsWithFraction);\n                const fraction = facetPointsWithFraction - floored;\n                const extraPoint = Number(Math.random() < fraction);\n                const facetPoints = floored + extraPoint;\n                density[index] = facetPoints;\n                remainingPoints -= facetPoints;\n            }\n        }\n        density[0] = remainingPoints;\n        return density;\n    }\n    /**\n     * Adds points to the PCS in random positions within a unit sphere\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param pointFunction is an optional javascript function to be called for each particle on PCS creation\n     * @returns the number of groups in the system\n     */\n    addPoints(nb, pointFunction = this._randomUnitVector) {\n        const pointsGroup = new PointsGroup(this._groupCounter, pointFunction);\n        let cp;\n        // particles\n        let idx = this.nbParticles;\n        for (let i = 0; i < nb; i++) {\n            cp = this._addParticle(idx, pointsGroup, this._groupCounter, i);\n            if (pointsGroup && pointsGroup._positionFunction) {\n                pointsGroup._positionFunction(cp, idx, i);\n            }\n            this._positions.push(cp.position.x, cp.position.y, cp.position.z);\n            if (cp.color) {\n                this._colors.push(cp.color.r, cp.color.g, cp.color.b, cp.color.a);\n            }\n            if (cp.uv) {\n                this._uvs.push(cp.uv.x, cp.uv.y);\n            }\n            idx++;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter;\n    }\n    /**\n     * Adds points to the PCS from the surface of the model shape\n     * @param mesh is any Mesh object that will be used as a surface model for the points\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n     * @returns the number of groups in the system\n     */\n    addSurfacePoints(mesh, nb, colorWith, color, range) {\n        let colored = colorWith ? colorWith : 0 /* PointColor.Random */;\n        if (isNaN(colored) || colored < 0 || colored > 3) {\n            colored = 0 /* PointColor.Random */;\n        }\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        this._groups.push(this._groupCounter);\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n        if (colored === 2 /* PointColor.Color */) {\n            pointsGroup._textureNb = color ? color : 0;\n        }\n        else {\n            color = color ? color : new Color4(1, 1, 1, 1);\n        }\n        switch (colored) {\n            case 2 /* PointColor.Color */:\n                this._colorFromTexture(mesh, pointsGroup, false);\n                break;\n            case 1 /* PointColor.UV */:\n                this._setPointsColorOrUV(mesh, pointsGroup, false, false, false);\n                break;\n            case 0 /* PointColor.Random */:\n                this._setPointsColorOrUV(mesh, pointsGroup, false);\n                break;\n            case 3 /* PointColor.Stated */:\n                this._setPointsColorOrUV(mesh, pointsGroup, false, undefined, undefined, color, range);\n                break;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter - 1;\n    }\n    /**\n     * Adds points to the PCS inside the model shape\n     * @param mesh is any Mesh object that will be used as a surface model for the points\n     * @param nb (positive integer) the number of particles to be created from this model\n     * @param colorWith determines whether a point is colored using color (default), uv, random, stated or none (invisible)\n     * @param color (color4) to be used when colorWith is stated or color (number) when used to specify texture position\n     * @param range (number from 0 to 1) to determine the variation in shape and tone for a stated color\n     * @returns the number of groups in the system\n     */\n    addVolumePoints(mesh, nb, colorWith, color, range) {\n        let colored = colorWith ? colorWith : 0 /* PointColor.Random */;\n        if (isNaN(colored) || colored < 0 || colored > 3) {\n            colored = 0 /* PointColor.Random */;\n        }\n        const meshPos = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const meshInd = mesh.getIndices();\n        this._groups.push(this._groupCounter);\n        const pointsGroup = new PointsGroup(this._groupCounter, null);\n        pointsGroup._groupDensity = this._calculateDensity(nb, meshPos, meshInd);\n        if (colored === 2 /* PointColor.Color */) {\n            pointsGroup._textureNb = color ? color : 0;\n        }\n        else {\n            color = color ? color : new Color4(1, 1, 1, 1);\n        }\n        switch (colored) {\n            case 2 /* PointColor.Color */:\n                this._colorFromTexture(mesh, pointsGroup, true);\n                break;\n            case 1 /* PointColor.UV */:\n                this._setPointsColorOrUV(mesh, pointsGroup, true, false, false);\n                break;\n            case 0 /* PointColor.Random */:\n                this._setPointsColorOrUV(mesh, pointsGroup, true);\n                break;\n            case 3 /* PointColor.Stated */:\n                this._setPointsColorOrUV(mesh, pointsGroup, true, undefined, undefined, color, range);\n                break;\n        }\n        this.nbParticles += nb;\n        this._groupCounter++;\n        return this._groupCounter - 1;\n    }\n    /**\n     *  Sets all the particles : this method actually really updates the mesh according to the particle positions, rotations, colors, textures, etc.\n     *  This method calls `updateParticle()` for each particle of the SPS.\n     *  For an animated SPS, it is usually called within the render loop.\n     * @param start The particle index in the particle array where to start to compute the particle property values _(default 0)_\n     * @param end The particle index in the particle array where to stop to compute the particle property values _(default nbParticle - 1)_\n     * @param update If the mesh must be finally updated on this call after all the particle computations _(default true)_\n     * @returns the PCS.\n     */\n    setParticles(start = 0, end = this.nbParticles - 1, update = true) {\n        if (!this._updatable || !this._isReady) {\n            return this;\n        }\n        // custom beforeUpdate\n        this.beforeUpdateParticles(start, end, update);\n        const rotMatrix = TmpVectors.Matrix[0];\n        const mesh = this.mesh;\n        const colors32 = this._colors32;\n        const positions32 = this._positions32;\n        const uvs32 = this._uvs32;\n        const tempVectors = TmpVectors.Vector3;\n        const camAxisX = tempVectors[5].copyFromFloats(1.0, 0.0, 0.0);\n        const camAxisY = tempVectors[6].copyFromFloats(0.0, 1.0, 0.0);\n        const camAxisZ = tempVectors[7].copyFromFloats(0.0, 0.0, 1.0);\n        const minimum = tempVectors[8].setAll(Number.MAX_VALUE);\n        const maximum = tempVectors[9].setAll(-Number.MAX_VALUE);\n        Matrix.IdentityToRef(rotMatrix);\n        let idx = 0; // current index of the particle\n        if (this.mesh?.isFacetDataEnabled) {\n            this._computeBoundingBox = true;\n        }\n        end = end >= this.nbParticles ? this.nbParticles - 1 : end;\n        if (this._computeBoundingBox) {\n            if (start != 0 || end != this.nbParticles - 1) {\n                // only some particles are updated, then use the current existing BBox basis. Note : it can only increase.\n                const boundingInfo = this.mesh?.getBoundingInfo();\n                if (boundingInfo) {\n                    minimum.copyFrom(boundingInfo.minimum);\n                    maximum.copyFrom(boundingInfo.maximum);\n                }\n            }\n        }\n        idx = 0; // particle index\n        let pindex = 0; //index in positions array\n        let cindex = 0; //index in color array\n        let uindex = 0; //index in uv array\n        // particle loop\n        for (let p = start; p <= end; p++) {\n            const particle = this.particles[p];\n            idx = particle.idx;\n            pindex = 3 * idx;\n            cindex = 4 * idx;\n            uindex = 2 * idx;\n            // call to custom user function to update the particle properties\n            this.updateParticle(particle);\n            const particleRotationMatrix = particle._rotationMatrix;\n            const particlePosition = particle.position;\n            const particleGlobalPosition = particle._globalPosition;\n            if (this._computeParticleRotation) {\n                particle.getRotationMatrix(rotMatrix);\n            }\n            const particleHasParent = particle.parentId !== null;\n            if (particleHasParent) {\n                const parent = this.particles[particle.parentId];\n                const parentRotationMatrix = parent._rotationMatrix;\n                const parentGlobalPosition = parent._globalPosition;\n                const rotatedY = particlePosition.x * parentRotationMatrix[1] + particlePosition.y * parentRotationMatrix[4] + particlePosition.z * parentRotationMatrix[7];\n                const rotatedX = particlePosition.x * parentRotationMatrix[0] + particlePosition.y * parentRotationMatrix[3] + particlePosition.z * parentRotationMatrix[6];\n                const rotatedZ = particlePosition.x * parentRotationMatrix[2] + particlePosition.y * parentRotationMatrix[5] + particlePosition.z * parentRotationMatrix[8];\n                particleGlobalPosition.x = parentGlobalPosition.x + rotatedX;\n                particleGlobalPosition.y = parentGlobalPosition.y + rotatedY;\n                particleGlobalPosition.z = parentGlobalPosition.z + rotatedZ;\n                if (this._computeParticleRotation) {\n                    const rotMatrixValues = rotMatrix.m;\n                    particleRotationMatrix[0] =\n                        rotMatrixValues[0] * parentRotationMatrix[0] + rotMatrixValues[1] * parentRotationMatrix[3] + rotMatrixValues[2] * parentRotationMatrix[6];\n                    particleRotationMatrix[1] =\n                        rotMatrixValues[0] * parentRotationMatrix[1] + rotMatrixValues[1] * parentRotationMatrix[4] + rotMatrixValues[2] * parentRotationMatrix[7];\n                    particleRotationMatrix[2] =\n                        rotMatrixValues[0] * parentRotationMatrix[2] + rotMatrixValues[1] * parentRotationMatrix[5] + rotMatrixValues[2] * parentRotationMatrix[8];\n                    particleRotationMatrix[3] =\n                        rotMatrixValues[4] * parentRotationMatrix[0] + rotMatrixValues[5] * parentRotationMatrix[3] + rotMatrixValues[6] * parentRotationMatrix[6];\n                    particleRotationMatrix[4] =\n                        rotMatrixValues[4] * parentRotationMatrix[1] + rotMatrixValues[5] * parentRotationMatrix[4] + rotMatrixValues[6] * parentRotationMatrix[7];\n                    particleRotationMatrix[5] =\n                        rotMatrixValues[4] * parentRotationMatrix[2] + rotMatrixValues[5] * parentRotationMatrix[5] + rotMatrixValues[6] * parentRotationMatrix[8];\n                    particleRotationMatrix[6] =\n                        rotMatrixValues[8] * parentRotationMatrix[0] + rotMatrixValues[9] * parentRotationMatrix[3] + rotMatrixValues[10] * parentRotationMatrix[6];\n                    particleRotationMatrix[7] =\n                        rotMatrixValues[8] * parentRotationMatrix[1] + rotMatrixValues[9] * parentRotationMatrix[4] + rotMatrixValues[10] * parentRotationMatrix[7];\n                    particleRotationMatrix[8] =\n                        rotMatrixValues[8] * parentRotationMatrix[2] + rotMatrixValues[9] * parentRotationMatrix[5] + rotMatrixValues[10] * parentRotationMatrix[8];\n                }\n            }\n            else {\n                particleGlobalPosition.x = 0;\n                particleGlobalPosition.y = 0;\n                particleGlobalPosition.z = 0;\n                if (this._computeParticleRotation) {\n                    const rotMatrixValues = rotMatrix.m;\n                    particleRotationMatrix[0] = rotMatrixValues[0];\n                    particleRotationMatrix[1] = rotMatrixValues[1];\n                    particleRotationMatrix[2] = rotMatrixValues[2];\n                    particleRotationMatrix[3] = rotMatrixValues[4];\n                    particleRotationMatrix[4] = rotMatrixValues[5];\n                    particleRotationMatrix[5] = rotMatrixValues[6];\n                    particleRotationMatrix[6] = rotMatrixValues[8];\n                    particleRotationMatrix[7] = rotMatrixValues[9];\n                    particleRotationMatrix[8] = rotMatrixValues[10];\n                }\n            }\n            const pivotBackTranslation = tempVectors[11];\n            if (particle.translateFromPivot) {\n                pivotBackTranslation.setAll(0.0);\n            }\n            else {\n                pivotBackTranslation.copyFrom(particle.pivot);\n            }\n            // positions\n            const tmpVertex = tempVectors[0];\n            tmpVertex.copyFrom(particle.position);\n            const vertexX = tmpVertex.x - particle.pivot.x;\n            const vertexY = tmpVertex.y - particle.pivot.y;\n            const vertexZ = tmpVertex.z - particle.pivot.z;\n            let rotatedX = vertexX * particleRotationMatrix[0] + vertexY * particleRotationMatrix[3] + vertexZ * particleRotationMatrix[6];\n            let rotatedY = vertexX * particleRotationMatrix[1] + vertexY * particleRotationMatrix[4] + vertexZ * particleRotationMatrix[7];\n            let rotatedZ = vertexX * particleRotationMatrix[2] + vertexY * particleRotationMatrix[5] + vertexZ * particleRotationMatrix[8];\n            rotatedX += pivotBackTranslation.x;\n            rotatedY += pivotBackTranslation.y;\n            rotatedZ += pivotBackTranslation.z;\n            const px = (positions32[pindex] = particleGlobalPosition.x + camAxisX.x * rotatedX + camAxisY.x * rotatedY + camAxisZ.x * rotatedZ);\n            const py = (positions32[pindex + 1] = particleGlobalPosition.y + camAxisX.y * rotatedX + camAxisY.y * rotatedY + camAxisZ.y * rotatedZ);\n            const pz = (positions32[pindex + 2] = particleGlobalPosition.z + camAxisX.z * rotatedX + camAxisY.z * rotatedY + camAxisZ.z * rotatedZ);\n            if (this._computeBoundingBox) {\n                minimum.minimizeInPlaceFromFloats(px, py, pz);\n                maximum.maximizeInPlaceFromFloats(px, py, pz);\n            }\n            if (this._computeParticleColor && particle.color) {\n                const color = particle.color;\n                const colors32 = this._colors32;\n                colors32[cindex] = color.r;\n                colors32[cindex + 1] = color.g;\n                colors32[cindex + 2] = color.b;\n                colors32[cindex + 3] = color.a;\n            }\n            if (this._computeParticleTexture && particle.uv) {\n                const uv = particle.uv;\n                const uvs32 = this._uvs32;\n                uvs32[uindex] = uv.x;\n                uvs32[uindex + 1] = uv.y;\n            }\n        }\n        // if the VBO must be updated\n        if (mesh) {\n            if (update) {\n                if (this._computeParticleColor) {\n                    mesh.updateVerticesData(VertexBuffer.ColorKind, colors32, false, false);\n                }\n                if (this._computeParticleTexture) {\n                    mesh.updateVerticesData(VertexBuffer.UVKind, uvs32, false, false);\n                }\n                mesh.updateVerticesData(VertexBuffer.PositionKind, positions32, false, false);\n            }\n            if (this._computeBoundingBox) {\n                if (mesh.hasBoundingInfo) {\n                    mesh.getBoundingInfo().reConstruct(minimum, maximum, mesh._worldMatrix);\n                }\n                else {\n                    mesh.buildBoundingInfo(minimum, maximum, mesh._worldMatrix);\n                }\n            }\n        }\n        this.afterUpdateParticles(start, end, update);\n        return this;\n    }\n    /**\n     * Disposes the PCS.\n     */\n    dispose() {\n        this.mesh?.dispose();\n        this.vars = null;\n        // drop references to internal big arrays for the GC\n        this._positions = null;\n        this._indices = null;\n        this._normals = null;\n        this._uvs = null;\n        this._colors = null;\n        this._indices32 = null;\n        this._positions32 = null;\n        this._uvs32 = null;\n        this._colors32 = null;\n    }\n    /**\n     * Visibility helper : Recomputes the visible size according to the mesh bounding box\n     * doc :\n     * @returns the PCS.\n     */\n    refreshVisibleSize() {\n        if (!this._isVisibilityBoxLocked) {\n            this.mesh?.refreshBoundingInfo();\n        }\n        return this;\n    }\n    /**\n     * Visibility helper : Sets the size of a visibility box, this sets the underlying mesh bounding box.\n     * @param size the size (float) of the visibility box\n     * note : this doesn't lock the PCS mesh bounding box.\n     * doc :\n     */\n    setVisibilityBox(size) {\n        if (!this.mesh) {\n            return;\n        }\n        const vis = size / 2;\n        this.mesh.buildBoundingInfo(new Vector3(-vis, -vis, -vis), new Vector3(vis, vis, vis));\n    }\n    /**\n     * Gets whether the PCS is always visible or not\n     * doc :\n     */\n    get isAlwaysVisible() {\n        return this._alwaysVisible;\n    }\n    /**\n     * Sets the PCS as always visible or not\n     * doc :\n     */\n    set isAlwaysVisible(val) {\n        if (!this.mesh) {\n            return;\n        }\n        this._alwaysVisible = val;\n        this.mesh.alwaysSelectAsActiveMesh = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle rotations or not\n     * Default value : false. The PCS is faster when it's set to false\n     * Note : particle rotations are only applied to parent particles\n     * Note : the particle rotations aren't stored values, so setting `computeParticleRotation` to false will prevents the particle to rotate\n     */\n    set computeParticleRotation(val) {\n        this._computeParticleRotation = val;\n    }\n    /**\n     * Tells to `setParticles()` to compute the particle colors or not.\n     * Default value : true. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    set computeParticleColor(val) {\n        this._computeParticleColor = val;\n    }\n    set computeParticleTexture(val) {\n        this._computeParticleTexture = val;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle colors or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle colors are stored values, so setting `computeParticleColor` to false will keep yet the last colors set.\n     */\n    get computeParticleColor() {\n        return this._computeParticleColor;\n    }\n    /**\n     * Gets if `setParticles()` computes the particle textures or not.\n     * Default value : false. The PCS is faster when it's set to false.\n     * Note : the particle textures are stored values, so setting `computeParticleTexture` to false will keep yet the last colors set.\n     */\n    get computeParticleTexture() {\n        return this._computeParticleTexture;\n    }\n    /**\n     * Tells to `setParticles()` to compute or not the mesh bounding box when computing the particle positions.\n     */\n    set computeBoundingBox(val) {\n        this._computeBoundingBox = val;\n    }\n    /**\n     * Gets if `setParticles()` computes or not the mesh bounding box when computing the particle positions.\n     */\n    get computeBoundingBox() {\n        return this._computeBoundingBox;\n    }\n    // =======================================================================\n    // Particle behavior logic\n    // these following methods may be overwritten by users to fit their needs\n    /**\n     * This function does nothing. It may be overwritten to set all the particle first values.\n     * The PCS doesn't call this function, you may have to call it by your own.\n     * doc :\n     */\n    initParticles() { }\n    /**\n     * This function does nothing. It may be overwritten to recycle a particle\n     * The PCS doesn't call this function, you can to call it\n     * doc :\n     * @param particle The particle to recycle\n     * @returns the recycled particle\n     */\n    recycleParticle(particle) {\n        return particle;\n    }\n    /**\n     * Updates a particle : this function should  be overwritten by the user.\n     * It is called on each particle by `setParticles()`. This is the place to code each particle behavior.\n     * doc :\n     * @example : just set a particle position or velocity and recycle conditions\n     * @param particle The particle to update\n     * @returns the updated particle\n     */\n    updateParticle(particle) {\n        return particle;\n    }\n    /**\n     * This will be called before any other treatment by `setParticles()` and will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    beforeUpdateParticles(start, stop, update) { }\n    /**\n     * This will be called  by `setParticles()` after all the other treatments and just before the actual mesh update.\n     * This will be passed three parameters.\n     * This does nothing and may be overwritten by the user.\n     * @param start the particle index in the particle array where to start to iterate, same than the value passed to setParticle()\n     * @param stop the particle index in the particle array where to stop to iterate, same than the value passed to setParticle()\n     * @param update the boolean update value actually passed to setParticles()\n     */\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    afterUpdateParticles(start, stop, update) { }\n}\n//# sourceMappingURL=pointsCloudSystem.js.map","import { Color4, Vector2, Vector3, TmpVectors, Quaternion } from \"../Maths/math\";\n/**\n * Represents one particle of a points cloud system.\n */\nexport class CloudPoint {\n    /**\n     * Creates a Point Cloud object.\n     * Don't create particles manually, use instead the PCS internal tools like _addParticle()\n     * @param particleIndex (integer) is the particle index in the PCS pool. It's also the particle identifier.\n     * @param group (PointsGroup) is the group the particle belongs to\n     * @param groupId (integer) is the group identifier in the PCS.\n     * @param idxInGroup (integer) is the index of the particle in the current point group (ex: the 10th point of addPoints(30))\n     * @param pcs defines the PCS it is associated to\n     */\n    constructor(particleIndex, group, groupId, idxInGroup, pcs) {\n        /**\n         * particle global index\n         */\n        this.idx = 0;\n        /**\n         * The color of the particle\n         */\n        this.color = new Color4(1.0, 1.0, 1.0, 1.0);\n        /**\n         * The world space position of the particle.\n         */\n        this.position = Vector3.Zero();\n        /**\n         * The world space rotation of the particle. (Not use if rotationQuaternion is set)\n         */\n        this.rotation = Vector3.Zero();\n        /**\n         * The uv of the particle.\n         */\n        this.uv = new Vector2(0.0, 0.0);\n        /**\n         * The current speed of the particle.\n         */\n        this.velocity = Vector3.Zero();\n        /**\n         * The pivot point in the particle local space.\n         */\n        this.pivot = Vector3.Zero();\n        /**\n         * Must the particle be translated from its pivot point in its local space ?\n         * In this case, the pivot point is set at the origin of the particle local space and the particle is translated.\n         * Default : false\n         */\n        this.translateFromPivot = false;\n        /**\n         * Index of this particle in the global \"positions\" array (Internal use)\n         * @internal\n         */\n        this._pos = 0;\n        /**\n         * @internal Index of this particle in the global \"indices\" array (Internal use)\n         */\n        this._ind = 0;\n        /**\n         * Group id of this particle\n         */\n        this.groupId = 0;\n        /**\n         * Index of the particle in its group id (Internal use)\n         */\n        this.idxInGroup = 0;\n        /**\n         * @internal Still set as invisible in order to skip useless computations (Internal use)\n         */\n        this._stillInvisible = false;\n        /**\n         * @internal Last computed particle rotation matrix\n         */\n        this._rotationMatrix = [1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0];\n        /**\n         * Parent particle Id, if any.\n         * Default null.\n         */\n        this.parentId = null;\n        /**\n         * @internal Internal global position in the PCS.\n         */\n        this._globalPosition = Vector3.Zero();\n        this.idx = particleIndex;\n        this._group = group;\n        this.groupId = groupId;\n        this.idxInGroup = idxInGroup;\n        this._pcs = pcs;\n    }\n    /**\n     * get point size\n     */\n    get size() {\n        return this.size;\n    }\n    /**\n     * Set point size\n     */\n    set size(scale) {\n        this.size = scale;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    get quaternion() {\n        return this.rotationQuaternion;\n    }\n    /**\n     * Legacy support, changed quaternion to rotationQuaternion\n     */\n    set quaternion(q) {\n        this.rotationQuaternion = q;\n    }\n    /**\n     * Returns a boolean. True if the particle intersects a mesh, else false\n     * The intersection is computed on the particle position and Axis Aligned Bounding Box (AABB) or Sphere\n     * @param target is the object (point or mesh) what the intersection is computed against\n     * @param isSphere is boolean flag when false (default) bounding box of mesh is used, when true the bounding sphere is used\n     * @returns true if it intersects\n     */\n    intersectsMesh(target, isSphere) {\n        if (!target.hasBoundingInfo) {\n            return false;\n        }\n        if (!this._pcs.mesh) {\n            throw new Error(\"Point Cloud System doesnt contain the Mesh\");\n        }\n        if (isSphere) {\n            return target.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));\n        }\n        const bbox = target.getBoundingInfo().boundingBox;\n        const maxX = bbox.maximumWorld.x;\n        const minX = bbox.minimumWorld.x;\n        const maxY = bbox.maximumWorld.y;\n        const minY = bbox.minimumWorld.y;\n        const maxZ = bbox.maximumWorld.z;\n        const minZ = bbox.minimumWorld.z;\n        const x = this.position.x + this._pcs.mesh.position.x;\n        const y = this.position.y + this._pcs.mesh.position.y;\n        const z = this.position.z + this._pcs.mesh.position.z;\n        return minX <= x && x <= maxX && minY <= y && y <= maxY && minZ <= z && z <= maxZ;\n    }\n    /**\n     * get the rotation matrix of the particle\n     * @internal\n     */\n    getRotationMatrix(m) {\n        let quaternion;\n        if (this.rotationQuaternion) {\n            quaternion = this.rotationQuaternion;\n        }\n        else {\n            quaternion = TmpVectors.Quaternion[0];\n            const rotation = this.rotation;\n            Quaternion.RotationYawPitchRollToRef(rotation.y, rotation.x, rotation.z, quaternion);\n        }\n        quaternion.toRotationMatrix(m);\n    }\n}\n/**\n * Represents a group of points in a points cloud system\n *  * PCS internal tool, don't use it manually.\n */\nexport class PointsGroup {\n    /**\n     * Get or set the groupId\n     * @deprecated Please use groupId instead\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    get groupID() {\n        return this.groupId;\n    }\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    set groupID(groupID) {\n        this.groupId = groupID;\n    }\n    /**\n     * Creates a points group object. This is an internal reference to produce particles for the PCS.\n     * PCS internal tool, don't use it manually.\n     * @internal\n     */\n    constructor(id, posFunction) {\n        this.groupId = id;\n        this._positionFunction = posFunction;\n    }\n}\n//# sourceMappingURL=cloudPoint.js.map","import { Scalar } from \"core/Maths/math.scalar\";\nconst SH_C0 = 0.28209479177387814;\nasync function LoadWebpImageData(rootUrlOrData, filename, engine) {\n    const promise = new Promise((resolve, reject) => {\n        const image = engine.createCanvasImage();\n        if (!image) {\n            throw new Error(\"Failed to create ImageBitmap\");\n        }\n        image.onload = () => {\n            try {\n                // Draw to canvas\n                const canvas = engine.createCanvas(image.width, image.height);\n                if (!canvas) {\n                    throw new Error(\"Failed to create canvas\");\n                }\n                const ctx = canvas.getContext(\"2d\");\n                if (!ctx) {\n                    throw new Error(\"Failed to get 2D context\");\n                }\n                ctx.drawImage(image, 0, 0);\n                // Extract pixel data (RGBA per pixel)\n                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n                resolve({ bits: new Uint8Array(imageData.data.buffer), width: imageData.width });\n            }\n            catch (error) {\n                // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                reject(`Error loading image ${image.src} with exception: ${error}`);\n            }\n        };\n        image.onerror = (error) => {\n            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n            reject(`Error loading image ${image.src} with exception: ${error}`);\n        };\n        image.crossOrigin = \"anonymous\"; // To avoid CORS issues\n        let objectUrl;\n        if (typeof rootUrlOrData === \"string\") {\n            // old behavior: URL + filename\n            if (!filename) {\n                throw new Error(\"filename is required when using a URL\");\n            }\n            image.src = rootUrlOrData + filename;\n        }\n        else {\n            // new behavior: Uint8Array\n            const blob = new Blob([rootUrlOrData], { type: \"image/webp\" });\n            objectUrl = URL.createObjectURL(blob);\n            image.src = objectUrl;\n        }\n    });\n    return await promise;\n}\nasync function ParseSogDatas(data, imageDataArrays, scene) {\n    const splatCount = data.count ? data.count : data.means.shape[0];\n    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\n    const buffer = new ArrayBuffer(rowOutputLength * splatCount);\n    const position = new Float32Array(buffer);\n    const scale = new Float32Array(buffer);\n    const rgba = new Uint8ClampedArray(buffer);\n    const rot = new Uint8ClampedArray(buffer);\n    // Undo the symmetric log transform used at encode time:\n    const unlog = (n) => Math.sign(n) * (Math.exp(Math.abs(n)) - 1);\n    const meansl = imageDataArrays[0].bits;\n    const meansu = imageDataArrays[1].bits;\n    // Check that data.means.mins is an array\n    if (!Array.isArray(data.means.mins) || !Array.isArray(data.means.maxs)) {\n        throw new Error(\"Missing arrays in SOG data.\");\n    }\n    // --- Positions\n    for (let i = 0; i < splatCount; i++) {\n        const index = i * 4;\n        for (let j = 0; j < 3; j++) {\n            const meansMin = data.means.mins[j];\n            const meansMax = data.means.maxs[j];\n            const meansup = meansu[index + j];\n            const meanslow = meansl[index + j];\n            const q = (meansup << 8) | meanslow;\n            const n = Scalar.Lerp(meansMin, meansMax, q / 65535);\n            position[i * 8 + j] = unlog(n);\n        }\n    }\n    // --- Scales\n    const scales = imageDataArrays[2].bits;\n    if (data.version === 2) {\n        if (!data.scales.codebook) {\n            throw new Error(\"Missing codebook in SOG version 2 scales data.\");\n        }\n        for (let i = 0; i < splatCount; i++) {\n            const index = i * 4;\n            for (let j = 0; j < 3; j++) {\n                const sc = data.scales.codebook[scales[index + j]];\n                const sce = Math.exp(sc);\n                scale[i * 8 + 3 + j] = sce;\n            }\n        }\n    }\n    else {\n        if (!Array.isArray(data.scales.mins) || !Array.isArray(data.scales.maxs)) {\n            throw new Error(\"Missing arrays in SOG scales data.\");\n        }\n        for (let i = 0; i < splatCount; i++) {\n            const index = i * 4;\n            for (let j = 0; j < 3; j++) {\n                const sc = scales[index + j];\n                const lsc = Scalar.Lerp(data.scales.mins[j], data.scales.maxs[j], sc / 255);\n                const lsce = Math.exp(lsc);\n                scale[i * 8 + 3 + j] = lsce;\n            }\n        }\n    }\n    // --- Colors/SH0\n    const colors = imageDataArrays[4].bits;\n    if (data.version === 2) {\n        if (!data.sh0.codebook) {\n            throw new Error(\"Missing codebook in SOG version 2 sh0 data.\");\n        }\n        for (let i = 0; i < splatCount; i++) {\n            const index = i * 4;\n            for (let j = 0; j < 3; j++) {\n                const component = 0.5 + data.sh0.codebook[colors[index + j]] * SH_C0;\n                rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * component)));\n            }\n            rgba[i * 32 + 24 + 3] = colors[index + 3];\n        }\n    }\n    else {\n        if (!Array.isArray(data.sh0.mins) || !Array.isArray(data.sh0.maxs)) {\n            throw new Error(\"Missing arrays in SOG sh0 data.\");\n        }\n        for (let i = 0; i < splatCount; i++) {\n            const index = i * 4;\n            for (let j = 0; j < 4; j++) {\n                const colorsMin = data.sh0.mins[j];\n                const colorsMax = data.sh0.maxs[j];\n                const colort = colors[index + j];\n                const c = Scalar.Lerp(colorsMin, colorsMax, colort / 255);\n                let csh;\n                if (j < 3) {\n                    csh = 0.5 + c * SH_C0;\n                }\n                else {\n                    csh = 1.0 / (1.0 + Math.exp(-c));\n                }\n                rgba[i * 32 + 24 + j] = Math.max(0, Math.min(255, Math.round(255 * csh)));\n            }\n        }\n    }\n    // --- Rotations\n    // Dequantize the stored three components:\n    const toComp = (c) => ((c / 255 - 0.5) * 2.0) / Math.SQRT2;\n    const quatArray = imageDataArrays[3].bits;\n    for (let i = 0; i < splatCount; i++) {\n        const quatsr = quatArray[i * 4 + 0];\n        const quatsg = quatArray[i * 4 + 1];\n        const quatsb = quatArray[i * 4 + 2];\n        const quatsa = quatArray[i * 4 + 3];\n        const a = toComp(quatsr);\n        const b = toComp(quatsg);\n        const c = toComp(quatsb);\n        const mode = quatsa - 252; // 0..3 (R,G,B,A is one of the four components)\n        // Reconstruct the omitted component so that ||q|| = 1 and w.l.o.g. the omitted one is non-negative\n        const t = a * a + b * b + c * c;\n        const d = Math.sqrt(Math.max(0, 1 - t));\n        // Place components according to mode\n        let q;\n        switch (mode) {\n            case 0:\n                q = [d, a, b, c];\n                break; // omitted = x\n            case 1:\n                q = [a, d, b, c];\n                break; // omitted = y\n            case 2:\n                q = [a, b, d, c];\n                break; // omitted = z\n            case 3:\n                q = [a, b, c, d];\n                break; // omitted = w\n            default:\n                throw new Error(\"Invalid quaternion mode\");\n        }\n        rot[i * 32 + 28 + 0] = q[0] * 127.5 + 127.5;\n        rot[i * 32 + 28 + 1] = q[1] * 127.5 + 127.5;\n        rot[i * 32 + 28 + 2] = q[2] * 127.5 + 127.5;\n        rot[i * 32 + 28 + 3] = q[3] * 127.5 + 127.5;\n    }\n    // --- SH\n    if (data.shN) {\n        const coeffCounts = [0, 3, 8, 15];\n        const coeffs = data.shN.bands ? coeffCounts[data.shN.bands] : data.shN.shape[1] / 3; // 3 components per coeff\n        const shCentroids = imageDataArrays[5].bits;\n        const shLabelsData = imageDataArrays[6].bits;\n        const shCentroidsWidth = imageDataArrays[5].width;\n        const shComponentCount = coeffs * 3;\n        const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\n        //let shIndexRead = byteOffset;\n        // sh is an array of uint8array that will be used to create sh textures\n        const sh = [];\n        const engine = scene.getEngine();\n        const width = engine.getCaps().maxTextureSize;\n        const height = Math.ceil(splatCount / width);\n        // create array for the number of textures needed.\n        for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\n            const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\n            sh.push(texture);\n        }\n        if (data.version === 2) {\n            if (!data.shN.codebook) {\n                throw new Error(\"Missing codebook in SOG version 2 shN data.\");\n            }\n            for (let i = 0; i < splatCount; i++) {\n                const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);\n                const u = (n % 64) * coeffs;\n                const v = Math.floor(n / 64);\n                for (let k = 0; k < coeffs; k++) {\n                    for (let j = 0; j < 3; j++) {\n                        const shIndexWrite = k * 3 + j;\n                        const textureIndex = Math.floor(shIndexWrite / 16);\n                        const shArray = sh[textureIndex];\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                        const shValue = data.shN.codebook[shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4]] * 127.5 + 127.5;\n                        shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));\n                    }\n                }\n            }\n        }\n        else {\n            for (let i = 0; i < splatCount; i++) {\n                const n = shLabelsData[i * 4 + 0] + (shLabelsData[i * 4 + 1] << 8);\n                const u = (n % 64) * coeffs;\n                const v = Math.floor(n / 64);\n                const shMin = data.shN.mins;\n                const shMax = data.shN.maxs;\n                for (let j = 0; j < 3; j++) {\n                    for (let k = 0; k < coeffs / 3; k++) {\n                        const shIndexWrite = k * 3 + j;\n                        const textureIndex = Math.floor(shIndexWrite / 16);\n                        const shArray = sh[textureIndex];\n                        const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                        const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                        const shValue = Scalar.Lerp(shMin, shMax, shCentroids[(u + k) * 4 + j + v * shCentroidsWidth * 4] / 255) * 127.5 + 127.5;\n                        shArray[byteIndexInTexture + offsetPerSplat] = Math.max(0, Math.min(255, shValue));\n                    }\n                }\n            }\n        }\n        return await new Promise((resolve) => {\n            resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, sh: sh });\n        });\n    }\n    return await new Promise((resolve) => {\n        resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false });\n    });\n}\n/**\n * Parse SOG data from either a SOGRootData object (with webp files loaded from rootUrl) or from a Map of filenames to Uint8Array file data (including meta.json)\n * @param dataOrFiles Either the SOGRootData or a Map of filenames to Uint8Array file data (including meta.json)\n * @param rootUrl Base URL to load webp files from (if dataOrFiles is SOGRootData)\n * @param scene The Babylon.js scene\n * @returns Parsed data\n */\nexport async function ParseSogMeta(dataOrFiles, rootUrl, scene) {\n    let data;\n    let files;\n    if (dataOrFiles instanceof Map) {\n        files = dataOrFiles;\n        const metaFile = files.get(\"meta.json\");\n        if (!metaFile) {\n            throw new Error(\"meta.json not found in files Map\");\n        }\n        data = JSON.parse(new TextDecoder().decode(metaFile));\n    }\n    else {\n        data = dataOrFiles;\n    }\n    // Collect all file names\n    const urls = [...data.means.files, ...data.scales.files, ...data.quats.files, ...data.sh0.files];\n    if (data.shN) {\n        urls.push(...data.shN.files);\n    }\n    // Load webp images in parallel\n    const imageDataArrays = await Promise.all(urls.map(async (fileName) => {\n        if (files && files.has(fileName)) {\n            // load from in-memory Uint8Array\n            const fileData = files.get(fileName);\n            return await LoadWebpImageData(fileData, fileName, scene.getEngine());\n        }\n        else {\n            // fallback: load from URL\n            return await LoadWebpImageData(rootUrl, fileName, scene.getEngine());\n        }\n    }));\n    return await ParseSogDatas(data, imageDataArrays, scene);\n}\n//# sourceMappingURL=sog.js.map","import { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\nimport { SPLATFileLoaderMetadata } from \"./splatFileLoader.metadata\";\nimport { GaussianSplattingMesh } from \"core/Meshes/GaussianSplatting/gaussianSplattingMesh\";\nimport { AssetContainer } from \"core/assetContainer\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { Logger } from \"core/Misc/logger\";\nimport { Vector3 } from \"core/Maths/math.vector\";\nimport { PointsCloudSystem } from \"core/Particles/pointsCloudSystem\";\nimport { Color4 } from \"core/Maths/math.color\";\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\nimport { ParseSpz } from \"./spz\";\nimport { ParseSogMeta } from \"./sog\";\nimport { Tools } from \"core/Misc/tools\";\n/**\n * @experimental\n * SPLAT file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class SPLATFileLoader {\n    /**\n     * Creates loader for gaussian splatting files\n     * @param loadingOptions options for loading and parsing splat and PLY files.\n     */\n    constructor(loadingOptions = SPLATFileLoader._DefaultLoadingOptions) {\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = SPLATFileLoaderMetadata.name;\n        this._assetContainer = null;\n        /**\n         * Defines the extensions the splat loader is able to load.\n         * force data to come in as an ArrayBuffer\n         */\n        this.extensions = SPLATFileLoaderMetadata.extensions;\n        this._loadingOptions = loadingOptions;\n    }\n    /** @internal */\n    createPlugin(options) {\n        return new SPLATFileLoader(options[SPLATFileLoaderMetadata.name]);\n    }\n    /**\n     * Imports  from the loaded gaussian splatting data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the gaussian splatting data to load\n     * @param rootUrl root url to load from\n     * @param _onProgress callback called while file is loading\n     * @param _fileName Defines the name of the file to load\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\n     */\n    async importMeshAsync(meshesNames, scene, data, rootUrl, _onProgress, _fileName) {\n        // eslint-disable-next-line github/no-then\n        return await this._parseAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            };\n        });\n    }\n    static _BuildPointCloud(pointcloud, data) {\n        if (!data.byteLength) {\n            return false;\n        }\n        const uBuffer = new Uint8Array(data);\n        const fBuffer = new Float32Array(data);\n        // parsed array contains room for position(3floats), normal(3floats), color (4b), quantized quaternion (4b)\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n        const vertexCount = uBuffer.length / rowLength;\n        const pointcloudfunc = function (particle, i) {\n            const x = fBuffer[8 * i + 0];\n            const y = fBuffer[8 * i + 1];\n            const z = fBuffer[8 * i + 2];\n            particle.position = new Vector3(x, y, z);\n            const r = uBuffer[rowLength * i + 24 + 0] / 255;\n            const g = uBuffer[rowLength * i + 24 + 1] / 255;\n            const b = uBuffer[rowLength * i + 24 + 2] / 255;\n            particle.color = new Color4(r, g, b, 1);\n        };\n        pointcloud.addPoints(vertexCount, pointcloudfunc);\n        return true;\n    }\n    static _BuildMesh(scene, parsedPLY) {\n        const mesh = new Mesh(\"PLYMesh\", scene);\n        const uBuffer = new Uint8Array(parsedPLY.data);\n        const fBuffer = new Float32Array(parsedPLY.data);\n        const rowLength = 3 * 4 + 3 * 4 + 4 + 4;\n        const vertexCount = uBuffer.length / rowLength;\n        const positions = [];\n        const vertexData = new VertexData();\n        for (let i = 0; i < vertexCount; i++) {\n            const x = fBuffer[8 * i + 0];\n            const y = fBuffer[8 * i + 1];\n            const z = fBuffer[8 * i + 2];\n            positions.push(x, y, z);\n        }\n        if (parsedPLY.hasVertexColors) {\n            const colors = new Float32Array(vertexCount * 4);\n            for (let i = 0; i < vertexCount; i++) {\n                const r = uBuffer[rowLength * i + 24 + 0] / 255;\n                const g = uBuffer[rowLength * i + 24 + 1] / 255;\n                const b = uBuffer[rowLength * i + 24 + 2] / 255;\n                colors[i * 4 + 0] = r;\n                colors[i * 4 + 1] = g;\n                colors[i * 4 + 2] = b;\n                colors[i * 4 + 3] = 1;\n            }\n            vertexData.colors = colors;\n        }\n        vertexData.positions = positions;\n        vertexData.indices = parsedPLY.faces;\n        vertexData.applyToMesh(mesh);\n        return mesh;\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax, @typescript-eslint/naming-convention\n    async _unzipWithFFlateAsync(data) {\n        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n        // @ts-ignore\n        let fflate = this._loadingOptions.fflate;\n        // ensure fflate is loaded\n        if (!fflate) {\n            if (typeof window.fflate === \"undefined\") {\n                await Tools.LoadScriptAsync(this._loadingOptions.deflateURL ?? \"https://unpkg.com/fflate/umd/index.js\");\n            }\n            fflate = window.fflate;\n        }\n        const { unzipSync } = fflate;\n        const unzipped = unzipSync(data); // { [filename: string]: Uint8Array }\n        const files = new Map();\n        for (const [name, content] of Object.entries(unzipped)) {\n            files.set(name, content);\n        }\n        return files;\n    }\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _parseAsync(meshesNames, scene, data, rootUrl) {\n        const babylonMeshesArray = []; //The mesh for babylon\n        const makeGSFromParsedSOG = (parsedSOG) => {\n            scene._blockEntityCollection = !!this._assetContainer;\n            const gaussianSplatting = this._loadingOptions.gaussianSplattingMesh ?? new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n            gaussianSplatting._parentContainer = this._assetContainer;\n            babylonMeshesArray.push(gaussianSplatting);\n            gaussianSplatting.updateData(parsedSOG.data, parsedSOG.sh, { flipY: false });\n            gaussianSplatting.scaling.y *= -1;\n            gaussianSplatting.computeWorldMatrix(true);\n            scene._blockEntityCollection = false;\n        };\n        // check if data is json string\n        if (typeof data === \"string\") {\n            const dataSOG = JSON.parse(data);\n            if (dataSOG && dataSOG.means && dataSOG.scales && dataSOG.quats && dataSOG.sh0) {\n                return new Promise((resolve) => {\n                    ParseSogMeta(dataSOG, rootUrl, scene)\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                        .then((parsedSOG) => {\n                        makeGSFromParsedSOG(parsedSOG);\n                        resolve(babylonMeshesArray);\n                    })\n                        // eslint-disable-next-line github/no-then\n                        .catch(() => {\n                        throw new Error(\"Failed to parse SOG data.\");\n                    });\n                });\n            }\n        }\n        const u8 = data instanceof ArrayBuffer ? new Uint8Array(data) : data;\n        // ZIP signature check for SOG\n        if (u8[0] === 0x50 && u8[1] === 0x4b) {\n            return new Promise((resolve) => {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                this._unzipWithFFlateAsync(u8).then((files) => {\n                    ParseSogMeta(files, rootUrl, scene)\n                        // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                        .then((parsedSOG) => {\n                        makeGSFromParsedSOG(parsedSOG);\n                        resolve(babylonMeshesArray);\n                    }) // eslint-disable-next-line github/no-then\n                        .catch(() => {\n                        throw new Error(\"Failed to parse SOG zip data.\");\n                    });\n                });\n            });\n        }\n        const readableStream = new ReadableStream({\n            start(controller) {\n                controller.enqueue(new Uint8Array(data)); // Enqueue the ArrayBuffer as a Uint8Array\n                controller.close();\n            },\n        });\n        // Use GZip DecompressionStream\n        const decompressionStream = new DecompressionStream(\"gzip\");\n        const decompressedStream = readableStream.pipeThrough(decompressionStream);\n        return new Promise((resolve) => {\n            new Response(decompressedStream)\n                .arrayBuffer()\n                // eslint-disable-next-line github/no-then\n                .then((buffer) => {\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                ParseSpz(buffer, scene, this._loadingOptions).then((parsedSPZ) => {\n                    scene._blockEntityCollection = !!this._assetContainer;\n                    const gaussianSplatting = this._loadingOptions.gaussianSplattingMesh ?? new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n                    if (parsedSPZ.trainedWithAntialiasing) {\n                        const gsMaterial = gaussianSplatting.material;\n                        gsMaterial.kernelSize = 0.1;\n                        gsMaterial.compensation = true;\n                    }\n                    gaussianSplatting._parentContainer = this._assetContainer;\n                    babylonMeshesArray.push(gaussianSplatting);\n                    gaussianSplatting.updateData(parsedSPZ.data, parsedSPZ.sh, { flipY: false });\n                    if (!this._loadingOptions.flipY) {\n                        gaussianSplatting.scaling.y *= -1.0;\n                        gaussianSplatting.computeWorldMatrix(true);\n                    }\n                    scene._blockEntityCollection = false;\n                    this.applyAutoCameraLimits(parsedSPZ, scene);\n                    resolve(babylonMeshesArray);\n                });\n            })\n                // eslint-disable-next-line github/no-then\n                .catch(() => {\n                // Catch any decompression errors\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                SPLATFileLoader._ConvertPLYToSplat(data).then(async (parsedPLY) => {\n                    scene._blockEntityCollection = !!this._assetContainer;\n                    switch (parsedPLY.mode) {\n                        case 0 /* Mode.Splat */:\n                            {\n                                const gaussianSplatting = this._loadingOptions.gaussianSplattingMesh ?? new GaussianSplattingMesh(\"GaussianSplatting\", null, scene, this._loadingOptions.keepInRam);\n                                gaussianSplatting._parentContainer = this._assetContainer;\n                                babylonMeshesArray.push(gaussianSplatting);\n                                gaussianSplatting.updateData(parsedPLY.data, parsedPLY.sh, { flipY: false });\n                                gaussianSplatting.scaling.y *= -1.0;\n                                if (parsedPLY.chirality === \"RightHanded\") {\n                                    gaussianSplatting.scaling.y *= -1.0;\n                                }\n                                switch (parsedPLY.upAxis) {\n                                    case \"X\":\n                                        gaussianSplatting.rotation = new Vector3(0, 0, Math.PI / 2);\n                                        break;\n                                    case \"Y\":\n                                        gaussianSplatting.rotation = new Vector3(0, 0, Math.PI);\n                                        break;\n                                    case \"Z\":\n                                        gaussianSplatting.rotation = new Vector3(-Math.PI / 2, Math.PI, 0);\n                                        break;\n                                }\n                                gaussianSplatting.computeWorldMatrix(true);\n                            }\n                            break;\n                        case 1 /* Mode.PointCloud */:\n                            {\n                                const pointcloud = new PointsCloudSystem(\"PointCloud\", 1, scene);\n                                if (SPLATFileLoader._BuildPointCloud(pointcloud, parsedPLY.data)) {\n                                    // eslint-disable-next-line github/no-then\n                                    await pointcloud.buildMeshAsync().then((mesh) => {\n                                        babylonMeshesArray.push(mesh);\n                                    });\n                                }\n                                else {\n                                    pointcloud.dispose();\n                                }\n                            }\n                            break;\n                        case 2 /* Mode.Mesh */:\n                            {\n                                if (parsedPLY.faces) {\n                                    babylonMeshesArray.push(SPLATFileLoader._BuildMesh(scene, parsedPLY));\n                                }\n                                else {\n                                    throw new Error(\"PLY mesh doesn't contain face informations.\");\n                                }\n                            }\n                            break;\n                        default:\n                            throw new Error(\"Unsupported Splat mode\");\n                    }\n                    scene._blockEntityCollection = false;\n                    this.applyAutoCameraLimits(parsedPLY, scene);\n                    resolve(babylonMeshesArray);\n                });\n            });\n        });\n    }\n    /**\n     * Applies camera limits based on parsed meta data\n     * @param meta parsed splat meta data\n     * @param scene\n     */\n    applyAutoCameraLimits(meta, scene) {\n        if (this._loadingOptions.disableAutoCameraLimits) {\n            return;\n        }\n        if ((meta.safeOrbitCameraRadiusMin !== undefined || meta.safeOrbitCameraElevationMinMax !== undefined) && scene.activeCamera?.getClassName() === \"ArcRotateCamera\") {\n            const arcCam = scene.activeCamera;\n            if (meta.safeOrbitCameraElevationMinMax) {\n                arcCam.lowerBetaLimit = Math.PI * 0.5 - meta.safeOrbitCameraElevationMinMax[1];\n                arcCam.upperBetaLimit = Math.PI * 0.5 - meta.safeOrbitCameraElevationMinMax[0];\n            }\n            if (meta.safeOrbitCameraRadiusMin) {\n                arcCam.lowerRadiusLimit = meta.safeOrbitCameraRadiusMin;\n            }\n        }\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadAssetContainerAsync(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        this._assetContainer = container;\n        return (this.importMeshAsync(null, scene, data, rootUrl)\n            // eslint-disable-next-line github/no-then\n            .then((result) => {\n            for (const mesh of result.meshes) {\n                container.meshes.push(mesh);\n            }\n            // mesh material will be null before 1st rendered frame.\n            this._assetContainer = null;\n            return container;\n        })\n            // eslint-disable-next-line github/no-then\n            .catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        }));\n    }\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    loadAsync(scene, data, rootUrl) {\n        //Get the 3D model\n        // eslint-disable-next-line github/no-then\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\n            // return void\n        });\n    }\n    /**\n     * Code from https://github.com/dylanebert/gsplat.js/blob/main/src/loaders/PLYLoader.ts Under MIT license\n     * Converts a .ply data array buffer to splat\n     * if data array buffer is not ply, returns the original buffer\n     * @param data the .ply data to load\n     * @returns the loaded splat buffer\n     */\n    static _ConvertPLYToSplat(data) {\n        const ubuf = new Uint8Array(data);\n        const header = new TextDecoder().decode(ubuf.slice(0, 1024 * 10));\n        const headerEnd = \"end_header\\n\";\n        const headerEndIndex = header.indexOf(headerEnd);\n        if (headerEndIndex < 0 || !header) {\n            // standard splat\n            return new Promise((resolve) => {\n                resolve({ mode: 0 /* Mode.Splat */, data: data, rawSplat: true });\n            });\n        }\n        const vertexCount = parseInt(/element vertex (\\d+)\\n/.exec(header)[1]);\n        const faceElement = /element face (\\d+)\\n/.exec(header);\n        let faceCount = 0;\n        if (faceElement) {\n            faceCount = parseInt(faceElement[1]);\n        }\n        const chunkElement = /element chunk (\\d+)\\n/.exec(header);\n        let chunkCount = 0;\n        if (chunkElement) {\n            chunkCount = parseInt(chunkElement[1]);\n        }\n        let rowVertexOffset = 0;\n        let rowChunkOffset = 0;\n        const offsets = {\n            double: 8,\n            int: 4,\n            uint: 4,\n            float: 4,\n            short: 2,\n            ushort: 2,\n            uchar: 1,\n            list: 0,\n        };\n        const ElementMode = {\n            Vertex: 0,\n            Chunk: 1,\n            SH: 2,\n            Float_Tuple: 3,\n            Float: 4,\n            Uchar: 5,\n        };\n        let chunkMode = ElementMode.Chunk;\n        const vertexProperties = [];\n        const chunkProperties = [];\n        const filtered = header.slice(0, headerEndIndex).split(\"\\n\");\n        const metaData = {};\n        for (const prop of filtered) {\n            if (prop.startsWith(\"property \")) {\n                const [, type, name] = prop.split(\" \");\n                if (chunkMode == ElementMode.Chunk) {\n                    chunkProperties.push({ name, type, offset: rowChunkOffset });\n                    rowChunkOffset += offsets[type];\n                }\n                else if (chunkMode == ElementMode.Vertex) {\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\n                    rowVertexOffset += offsets[type];\n                }\n                else if (chunkMode == ElementMode.SH) {\n                    vertexProperties.push({ name, type, offset: rowVertexOffset });\n                }\n                else if (chunkMode == ElementMode.Float_Tuple) {\n                    const view = new DataView(data, rowChunkOffset, offsets.float * 2);\n                    metaData.safeOrbitCameraElevationMinMax = [view.getFloat32(0, true), view.getFloat32(4, true)];\n                }\n                else if (chunkMode == ElementMode.Float) {\n                    const view = new DataView(data, rowChunkOffset, offsets.float);\n                    metaData.safeOrbitCameraRadiusMin = view.getFloat32(0, true);\n                }\n                else if (chunkMode == ElementMode.Uchar) {\n                    const view = new DataView(data, rowChunkOffset, offsets.uchar);\n                    if (name == \"up_axis\") {\n                        metaData.upAxis = view.getUint8(0) == 0 ? \"X\" : view.getUint8(0) == 1 ? \"Y\" : \"Z\";\n                    }\n                    else if (name == \"chirality\") {\n                        metaData.chirality = view.getUint8(0) == 0 ? \"LeftHanded\" : \"RightHanded\";\n                    }\n                }\n                if (!offsets[type]) {\n                    Logger.Warn(`Unsupported property type: ${type}.`);\n                }\n            }\n            else if (prop.startsWith(\"element \")) {\n                const [, type] = prop.split(\" \");\n                if (type == \"chunk\") {\n                    chunkMode = ElementMode.Chunk;\n                }\n                else if (type == \"vertex\") {\n                    chunkMode = ElementMode.Vertex;\n                }\n                else if (type == \"sh\") {\n                    chunkMode = ElementMode.SH;\n                }\n                else if (type == \"safe_orbit_camera_elevation_min_max_radians\") {\n                    chunkMode = ElementMode.Float_Tuple;\n                }\n                else if (type == \"safe_orbit_camera_radius_min\") {\n                    chunkMode = ElementMode.Float;\n                }\n                else if (type == \"up_axis\" || type == \"chirality\") {\n                    chunkMode = ElementMode.Uchar;\n                }\n            }\n        }\n        const rowVertexLength = rowVertexOffset;\n        const rowChunkLength = rowChunkOffset;\n        // eslint-disable-next-line github/no-then\n        return GaussianSplattingMesh.ConvertPLYWithSHToSplatAsync(data).then(async (splatsData) => {\n            const dataView = new DataView(data, headerEndIndex + headerEnd.length);\n            let offset = rowChunkLength * chunkCount + rowVertexLength * vertexCount;\n            // faces\n            const faces = [];\n            if (faceCount) {\n                for (let i = 0; i < faceCount; i++) {\n                    const faceVertexCount = dataView.getUint8(offset);\n                    if (faceVertexCount != 3) {\n                        continue; // only support triangles\n                    }\n                    offset += 1;\n                    for (let j = 0; j < faceVertexCount; j++) {\n                        const vertexIndex = dataView.getUint32(offset + (2 - j) * 4, true); // change face winding\n                        faces.push(vertexIndex);\n                    }\n                    offset += 12;\n                }\n            }\n            // early exit for chunked/quantized ply\n            if (chunkCount) {\n                return await new Promise((resolve) => {\n                    resolve({ mode: 0 /* Mode.Splat */, data: splatsData.buffer, sh: splatsData.sh, faces: faces, hasVertexColors: false, compressed: true, rawSplat: false });\n                });\n            }\n            // count available properties. if all necessary are present then it's a splat. Otherwise, it's a point cloud\n            // if faces are found, then it's a standard mesh\n            let propertyCount = 0;\n            let propertyColorCount = 0;\n            const splatProperties = [\"x\", \"y\", \"z\", \"scale_0\", \"scale_1\", \"scale_2\", \"opacity\", \"rot_0\", \"rot_1\", \"rot_2\", \"rot_3\"];\n            const splatColorProperties = [\"red\", \"green\", \"blue\", \"f_dc_0\", \"f_dc_1\", \"f_dc_2\"];\n            for (let propertyIndex = 0; propertyIndex < vertexProperties.length; propertyIndex++) {\n                const property = vertexProperties[propertyIndex];\n                if (splatProperties.includes(property.name)) {\n                    propertyCount++;\n                }\n                if (splatColorProperties.includes(property.name)) {\n                    propertyColorCount++;\n                }\n            }\n            const hasMandatoryProperties = propertyCount == splatProperties.length && propertyColorCount == 3;\n            const currentMode = faceCount ? 2 /* Mode.Mesh */ : hasMandatoryProperties ? 0 /* Mode.Splat */ : 1 /* Mode.PointCloud */;\n            // parsed ready ready to be used as a splat\n            return await new Promise((resolve) => {\n                resolve({\n                    ...metaData,\n                    mode: currentMode,\n                    data: splatsData.buffer,\n                    sh: splatsData.sh,\n                    faces: faces,\n                    hasVertexColors: !!propertyColorCount,\n                    compressed: false,\n                    rawSplat: false,\n                });\n            });\n        });\n    }\n}\nSPLATFileLoader._DefaultLoadingOptions = {\n    keepInRam: false,\n    flipY: false,\n};\n// Add this loader into the register plugin\nRegisterSceneLoaderPlugin(new SPLATFileLoader());\n//# sourceMappingURL=splatFileLoader.js.map","/* eslint-disable @typescript-eslint/promise-function-async */\nimport { Scalar } from \"core/Maths/math.scalar\";\n/**\n * Parses SPZ data and returns a promise resolving to an IParsedPLY object.\n * @param data The ArrayBuffer containing SPZ data.\n * @param scene The Babylon.js scene.\n * @param loadingOptions Options for loading Gaussian Splatting files.\n * @returns A promise resolving to the parsed SPZ data.\n */\nexport function ParseSpz(data, scene, loadingOptions) {\n    const ubuf = new Uint8Array(data);\n    const ubufu32 = new Uint32Array(data.slice(0, 12)); // Only need ubufu32[0] to [2]\n    // debug infos\n    const splatCount = ubufu32[2];\n    const shDegree = ubuf[12];\n    const fractionalBits = ubuf[13];\n    const flags = ubuf[14];\n    const reserved = ubuf[15];\n    const version = ubufu32[1];\n    // check magic and version\n    if (reserved || ubufu32[0] != 0x5053474e || (version != 2 && version != 3)) {\n        // reserved must be 0\n        return new Promise((resolve) => {\n            resolve({ mode: 3 /* Mode.Reject */, data: buffer, hasVertexColors: false });\n        });\n    }\n    const rowOutputLength = 3 * 4 + 3 * 4 + 4 + 4; // 32\n    const buffer = new ArrayBuffer(rowOutputLength * splatCount);\n    const positionScale = 1.0 / (1 << fractionalBits);\n    const int32View = new Int32Array(1);\n    const uint8View = new Uint8Array(int32View.buffer);\n    const read24bComponent = function (u8, offset) {\n        uint8View[0] = u8[offset + 0];\n        uint8View[1] = u8[offset + 1];\n        uint8View[2] = u8[offset + 2];\n        uint8View[3] = u8[offset + 2] & 0x80 ? 0xff : 0x00;\n        return int32View[0] * positionScale;\n    };\n    let byteOffset = 16;\n    const position = new Float32Array(buffer);\n    const scale = new Float32Array(buffer);\n    const rgba = new Uint8ClampedArray(buffer);\n    const rot = new Uint8ClampedArray(buffer);\n    // positions\n    for (let i = 0; i < splatCount; i++) {\n        position[i * 8 + 0] = read24bComponent(ubuf, byteOffset + 0);\n        position[i * 8 + 1] = read24bComponent(ubuf, byteOffset + 3);\n        position[i * 8 + 2] = read24bComponent(ubuf, byteOffset + 6);\n        byteOffset += 9;\n    }\n    // colors\n    const shC0 = 0.282;\n    for (let i = 0; i < splatCount; i++) {\n        for (let component = 0; component < 3; component++) {\n            const byteValue = ubuf[byteOffset + splatCount + i * 3 + component];\n            // 0.15 is hard coded value from spz\n            // Scale factor for DC color components. To convert to RGB, we should multiply by 0.282, but it can\n            // be useful to represent base colors that are out of range if the higher spherical harmonics bands\n            // bring them back into range so we multiply by a smaller value.\n            const value = (byteValue - 127.5) / (0.15 * 255);\n            rgba[i * 32 + 24 + component] = Scalar.Clamp((0.5 + shC0 * value) * 255, 0, 255);\n        }\n        rgba[i * 32 + 24 + 3] = ubuf[byteOffset + i];\n    }\n    byteOffset += splatCount * 4;\n    // scales\n    for (let i = 0; i < splatCount; i++) {\n        scale[i * 8 + 3 + 0] = Math.exp(ubuf[byteOffset + 0] / 16.0 - 10.0);\n        scale[i * 8 + 3 + 1] = Math.exp(ubuf[byteOffset + 1] / 16.0 - 10.0);\n        scale[i * 8 + 3 + 2] = Math.exp(ubuf[byteOffset + 2] / 16.0 - 10.0);\n        byteOffset += 3;\n    }\n    // convert quaternion\n    if (version >= 3) {\n        /*\n            In version 3, rotations are represented as the smallest three components of the normalized rotation quaternion, for optimal rotation accuracy.\n            The largest component can be derived from the others and is not stored. Its index is stored on 2 bits\n            and each of the smallest three components is encoded as a 10-bit signed integer.\n        */\n        const sqrt12 = Math.SQRT1_2;\n        for (let i = 0; i < splatCount; i++) {\n            const r = [ubuf[byteOffset + 0], ubuf[byteOffset + 1], ubuf[byteOffset + 2], ubuf[byteOffset + 3]];\n            const comp = r[0] + (r[1] << 8) + (r[2] << 16) + (r[3] << 24);\n            const cmask = (1 << 9) - 1;\n            const rotation = [];\n            const iLargest = comp >>> 30;\n            let remaining = comp;\n            let sumSquares = 0;\n            for (let i = 3; i >= 0; --i) {\n                if (i !== iLargest) {\n                    const mag = remaining & cmask;\n                    const negbit = (remaining >>> 9) & 0x1;\n                    remaining = remaining >>> 10;\n                    rotation[i] = sqrt12 * (mag / cmask);\n                    if (negbit === 1) {\n                        rotation[i] = -rotation[i];\n                    }\n                    // accumulate the sum of squares\n                    sumSquares += rotation[i] * rotation[i];\n                }\n            }\n            const square = 1 - sumSquares;\n            rotation[iLargest] = Math.sqrt(Math.max(square, 0));\n            const shuffle = [3, 0, 1, 2]; // shuffle to match the order of the quaternion components in the splat file\n            for (let j = 0; j < 4; j++) {\n                rot[i * 32 + 28 + j] = Math.round(127.5 + rotation[shuffle[j]] * 127.5);\n            }\n            byteOffset += 4;\n        }\n    }\n    else {\n        /*\n            In version 2, rotations are represented as the `(x, y, z)` components of the normalized rotation quaternion. The\n            `w` component can be derived from the others and is not stored. Each component is encoded as an\n            8-bit signed integer.\n        */\n        for (let i = 0; i < splatCount; i++) {\n            const x = ubuf[byteOffset + 0];\n            const y = ubuf[byteOffset + 1];\n            const z = ubuf[byteOffset + 2];\n            const nx = x / 127.5 - 1;\n            const ny = y / 127.5 - 1;\n            const nz = z / 127.5 - 1;\n            rot[i * 32 + 28 + 1] = x;\n            rot[i * 32 + 28 + 2] = y;\n            rot[i * 32 + 28 + 3] = z;\n            const v = 1 - (nx * nx + ny * ny + nz * nz);\n            rot[i * 32 + 28 + 0] = 127.5 + Math.sqrt(v < 0 ? 0 : v) * 127.5;\n            byteOffset += 3;\n        }\n    }\n    //SH\n    if (shDegree) {\n        // shVectorCount is : 3 for dim = 1, 8 for dim = 2 and 15 for dim = 3\n        // number of vec3 vector needed per splat\n        const shVectorCount = (shDegree + 1) * (shDegree + 1) - 1; // minus 1 because sh0 is color\n        // number of component values : 3 per vector3 (45)\n        const shComponentCount = shVectorCount * 3;\n        const textureCount = Math.ceil(shComponentCount / 16); // 4 components can be stored per texture, 4 sh per component\n        let shIndexRead = byteOffset;\n        // sh is an array of uint8array that will be used to create sh textures\n        const sh = [];\n        const engine = scene.getEngine();\n        const width = engine.getCaps().maxTextureSize;\n        const height = Math.ceil(splatCount / width);\n        // create array for the number of textures needed.\n        for (let textureIndex = 0; textureIndex < textureCount; textureIndex++) {\n            const texture = new Uint8Array(height * width * 4 * 4); // 4 components per texture, 4 sh per component\n            sh.push(texture);\n        }\n        for (let i = 0; i < splatCount; i++) {\n            for (let shIndexWrite = 0; shIndexWrite < shComponentCount; shIndexWrite++) {\n                const shValue = ubuf[shIndexRead++];\n                const textureIndex = Math.floor(shIndexWrite / 16);\n                const shArray = sh[textureIndex];\n                const byteIndexInTexture = shIndexWrite % 16; // [0..15]\n                const offsetPerSplat = i * 16; // 16 sh values per texture per splat.\n                shArray[byteIndexInTexture + offsetPerSplat] = shValue;\n            }\n        }\n        return new Promise((resolve) => {\n            resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, sh: sh, trainedWithAntialiasing: !!flags });\n        });\n    }\n    return new Promise((resolve) => {\n        resolve({ mode: 0 /* Mode.Splat */, data: buffer, hasVertexColors: false, trainedWithAntialiasing: !!flags });\n    });\n}\n//# sourceMappingURL=spz.js.map"],"names":["MapMap","constructor","this","mm","Map","get","a","b","m","undefined","set","v","ShadowDepthWrapper","standalone","_options","baseMaterial","_baseMaterial","doNotInjectCode","scene","options","_scene","EngineStore","LastCreatedScene","_subMeshToEffect","_subMeshToDepthWrapper","_meshes","_onEffectCreatedObserver","onEffectCreatedObservable","add","params","mesh","subMesh","getMesh","has","onDisposeObservable","iterator","keys","key","next","done","value","delete","_deleteDepthWrapperEffect","effect","getEngine","currentRenderPassId","depthWrapperEntries","forEach","depthWrapper","mainDrawWrapper","dispose","getEffect","shadowGenerator","passIdForDrawWrapper","entry","drawWrapper","DrawWrapper","setEffect","defines","isReadyForSubMesh","useInstances","_makeEffect","isReady","remove","entries","observer","engine","origEffectAndRenderPassId","origEffect","origRenderPassId","_getDrawWrapper","depthDefines","token","RandomGUID","join","uniforms","getUniformNames","slice","vertexCode","vertexSourceCodeBeforeMigration","fragmentCode","fragmentSourceCodeBeforeMigration","vertexNormalBiasCode","remappedVariables","vertexMetricCode","fragmentSoftTransparentShadow","fragmentBlockCode","vertexExtraDeclartion","shaderLanguage","replace","indexOf","hasLocationForSoftTransparentShadow","hasLocationForFragment","fragmentCodeToInjectAtEnd","Effect","IncludesShadersStore","push","createEffect","vertexSource","fragmentSource","vertexToken","fragmentToken","attributes","getAttributesNames","uniformsNames","uniformBuffersNames","getUniformBuffersNames","samplers","getSamplers","indexParameters","getIndexParameters","id","length","name","ShaderStore","shader","ShadersStore","gaussianSplattingPixelShader","gaussianSplattingVertexShader","IncludesShadersStoreWGSL","ShadersStoreWGSL","gaussianSplattingPixelShaderWGSL","gaussianSplattingVertexShaderWGSL","GaussianSplattingMaxPartCount","GaussianSplattingMaterialDefines","MaterialDefines","externalProperties","super","FOG","THIN_INSTANCES","LOGARITHMICDEPTH","CLIPPLANE","CLIPPLANE2","CLIPPLANE3","CLIPPLANE4","CLIPPLANE5","CLIPPLANE6","SH_DEGREE","COMPENSATION","IS_COMPOUND","MAX_PART_COUNT","rebuild","GaussianSplattingMaterial","PushMaterial","kernelSize","KernelSize","_compensation","Compensation","_isDirty","_sourceMesh","backFaceCulling","shadowDepthWrapper","_MakeGaussianSplattingShadowDepthWrapper","compensation","hasRenderTargetTextures","needAlphaTesting","needAlphaBlending","_drawWrapper","materialDefines","markAsUnprocessed","isFrozen","_wasPreviouslyReady","_wasPreviouslyUsingInstances","_callbackPluginEventGeneric","_eventInfo","defineNames","getScene","_isReadyForSubMesh","_callbackPluginEventIsReadyForSubMesh","gsMesh","PrepareDefinesForMisc","_useLogarithmicDepth","pointsCloud","fogEnabled","_isVertexOutputInvariant","PrepareDefinesForFrameBoundValues","PrepareDefinesForAttributes","version","isWebGPU","shDegree","isCompound","splatMaterial","material","isDirty","markAsProcessed","resetCachedMaterial","PrepareAttributesForInstances","_Attribs","attribs","_Uniforms","_Samplers","uniformBuffers","_UniformBuffers","PrepareUniformsAndSamplersList","AddClipPlaneUniforms","_uniformBufferLayoutBuilt","buildUniformLayout","fallbackRank","customCode","toString","onCompiled","onError","processCodeAfterIncludes","_shaderLanguage","extraInitializationsAsync","async","Promise","all","resolve","then","gaussianSplatting_fragment","gaussianSplatting_vertex","gaussianSplatting_fragment$1","gaussianSplatting_vertex$1","_materialContext","_renderId","getRenderId","setSourceMesh","BindEffect","camera","activeCamera","renderWidth","getRenderWidth","viewport","width","renderHeight","getRenderHeight","height","gsMaterial","numberOfRigs","rigParent","rigCameras","setFloat2","focal","t","getProjectionMatrix","fovMode","Camera","FOVMODE_VERTICAL_FIXED","setFloat","alpha","bindEyePosition","covariancesATexture","textureSize","getSize","setTexture","covariancesBTexture","centersTexture","colorsTexture","shTextures","i","partIndicesTexture","partWorldData","Float32Array","partCount","getWorldMatrixForPart","toArray","setMatrices","partVisibilityData","partVisibility","setArray","bindForSubMesh","world","_activeEffect","getMeshUniformBuffer","bindToEffect","transferToEffect","_mustRebind","visibility","bindView","bindViewProjection","BindClipPlane","_features","needToAlwaysBindUniformBuffers","_needToBindSceneUbo","BindFogParameters","useLogarithmicDepth","BindLogDepth","_callbackPluginEventBindForSubMesh","_afterBind","_BindEffectUniforms","shaderMaterial","minZ","maxZ","mode","ORTHOGRAPHIC_CAMERA","useReverseDepthBuffer","isNDCHalfZRange","makeDepthRenderingMaterial","alphaBlendedDepth","compoundMesh","ShaderMaterial","vertex","fragment","onBindObservable","clone","SerializationHelper","Clone","_clonePlugins","serialize","serializationObject","customType","getClassName","Parse","source","rootUrl","Material","_ParsePlugins","VertexBuffer","PositionKind","RegisterClass","HCF","functions.HighestCommonFactor","Scalar","functions","TwoPi","Math","PI","Sign","sign","Log2","log2","GaussianSplattingPartProxyMesh","Mesh","partIndex","_partIndex","compoundSplatMesh","proxiedMesh","updateBoundingInfoFromProxiedMesh","setWorldMatrixForPart","getWorldMatrix","onAfterWorldMatrixUpdateObservable","boundingInfo","getBoundingInfo","setBoundingInfo","BoundingInfo","minimum","maximum","updatePartIndex","newPartIndex","isVisible","getPartVisibility","setPartVisibility","intersects","ray","pickingInfo","PickingInfo","intersectsSphere","boundingSphere","intersectsBox","boundingBox","hit","pickedMesh","distance","Vector3","Distance","origin","center","subMeshId","IsNative","_native","Native","UnpackUnorm","bits","Unpack111011","result","x","y","z","Unpack8888","UnpackRot","norm","sqrt","c","PLYType","PLYValue","PointColor","GaussianSplattingMesh","disableDepthSort","_disableDepthSort","_worker","terminate","_sortIsDirty","_instanciateWorker","viewDirectionFactor","OneReadOnly","_shDegree","splatCount","_splatIndex","splatsData","_splatsData","shData","_shData","_partMatrices","partIndices","_partIndices","_partIndicesTexture","_partVisibility","_covariancesATexture","_covariancesBTexture","_centersTexture","_colorsTexture","_shTextures","_material","cullBackFaces","resetDrawCache","_MakeSplatGeometryForMesh","vertexData","VertexData","originPositions","originIndices","positions","indices","_BatchSize","j","map","flat","applyToMesh","url","keepInRam","_vertexCount","_modelViewProjectionMatrix","Matrix","Identity","_viewProjectionMatrix","_canPostToWorker","_readyToDisplay","_splatPositions","_partProxies","_textureSize","Vector2","_keepInRam","_delayedTextureUpdate","_useRGBACovariants","_tmpCovariances","_cameraViewInfos","viewUpdateThreshold","_DefaultViewUpdateThreshold","_loadingPromise","subMeshes","SubMesh","setEnabled","loadFileAsync","gaussianSplattingMaterial","onCameraRemovedObservable","cameraId","uniqueId","cameraViewInfos","getLoadingPromise","getTotalVertices","completeCheck","_postToWorker","_getCameraDirection","cameraViewMatrix","getViewMatrix","cameraProjectionMatrix","cameraViewProjectionMatrix","TmpVectors","multiplyToRef","copyFrom","modelViewMatrix","localDirection","normalize","forced","frameId","getFrameId","outdated","frameIdLastUpdate","cameras","activeCameras","activeViewInfos","cameraMesh","reservedDataStore","hidden","newViewInfos","cameraDirection","splatIndexBufferSet","sort","hasSortFunction","sortSplats","previousCameraDirection","dot","Dot","abs","postMessage","modelViewProjection","viewProjection","depthMix","_depthMix","depthScale","buffer","useRightHandedSystem","thinInstanceBufferUpdated","thinInstanceSetBuffer","render","enableAlphaMode","effectiveMeshReplacement","_geometry","size","values","geometry","onBeforeRenderObservable","notifyObservers","renderPassId","renderPassMaterial","getMaterialForRenderPass","setMaterialForRenderPass","ret","onAfterRenderObservable","_TypeNameToEnum","_ValueNameToEnum","ParseHeader","data","ubuf","Uint8Array","header","TextDecoder","decode","headerEnd","headerEndIndex","vertexCount","parseInt","exec","chunkElement","chunkCount","rowVertexOffset","rowChunkOffset","offsets","double","int","uint","float","short","ushort","uchar","list","ElementMode","chunkMode","vertexProperties","chunkProperties","filtered","split","prop","startsWith","typeName","max","type","offset","Logger","Warn","dataView","DataView","ArrayBuffer","_RowOutputLength","shBuffer","shCoefficientCount","rowVertexLength","rowChunkLength","_GetCompressedChunks","compressedChunks","Array","currentChunk","min","minScale","maxScale","minColor","maxColor","propertyIndex","property","getFloat32","_GetSplat","index","q","Quaternion","temp3","rowOutputLength","position","scale","rgba","Uint8ClampedArray","rot","sh","chunkIndex","r0","r1","r2","r3","plySH","getInt32","getUint32","getFloat64","getUint8","compressedChunk","Lerp","w","exp","_SH_C0","shIndex","compressedValue","clampedValue","Clamp","shDim","ConvertPLYWithSHToSplat","useCoroutine","_PlyConversionBatchSize","textureCount","ceil","shIndexRead","LastCreatedEngine","getCaps","maxTextureSize","textureIndex","texture","shIndexWrite","shValue","floor","ConvertPLYToSplat","ConvertPLYToSplatAsync","runCoroutineAsync","createYieldingScheduler","ConvertPLYWithSHToSplatAsync","loadDataAsync","updateDataAsync","ImportMeshAsync","pluginOptions","splat","gaussianSplattingMesh","doNotRecurse","shTexture","cameraViewInfo","proxy","clear","_copyTextures","newGS","_copySource","makeGeometryUnique","binfo","reConstruct","forcedInstanceCount","_makeEmptySplat","covA","covB","colorArray","covBSItemSize","ToHalfFloat","_makeSplat","fBuffer","uBuffer","matrixRotation","matrixScale","quaternion","flipY","minimizeInPlaceFromFloats","maximizeInPlaceFromFloats","toRotationMatrix","ScalingToRef","covariances","factor","covIndex","transform","_updateTextures","_getTextureSize","createTextureFromData","format","RawTexture","Constants","TEXTURE_BILINEAR_SAMPLINGMODE","TEXTURETYPE_FLOAT","createTextureFromDataU8","TEXTURETYPE_UNSIGNED_BYTE","createTextureFromDataU32","TEXTURE_NEAREST_SAMPLINGMODE","TEXTURETYPE_UNSIGNED_INTEGER","createTextureFromDataF16","TEXTURETYPE_HALF_FLOAT","firstTime","textureSizeChanged","TEXTUREFORMAT_RGBA","TEXTUREFORMAT_RG","Uint32Array","TEXTUREFORMAT_RGBA_INTEGER","wrapU","TEXTURE_CLAMP_ADDRESSMODE","wrapV","TEXTUREFORMAT_RED","from","colors","centers","_updateData","isAsync","arr","_updateSplatIndexBuffer","textureLength","lineCountUpdate","ProgressiveUpdateAmount","textureLengthPerUpdate","Uint16Array","maxPartIndex","_ensureMinimumPartMatricesLength","Number","MAX_VALUE","updateLine","splatIndexBase","_updateSubTextures","paddedVertexCount","_SplatBatchSize","updateData","runCoroutineSync","refreshBoundingInfo","thinInstanceRefreshBoundingInfo","BigInt64Array","lineStart","lineCount","updateTextureFromData","updateTextureData","getInternalTexture","texelStart","texelCount","covAView","BYTES_PER_ELEMENT","covBView","colorsView","centersView","componentCount","shView","partIndicesView","Worker","URL","createObjectURL","Blob","_CreateWorker","partMatrices","matrix","onmessage","e","vertexCountPadded","indexMix","Error","worldMatrix","_resizePartMatrices","computeWorldMatrix","defaultMatrix","addPart","other","disposeOther","splatCountA","splatsDataA","shDataA","splatCountB","splatsDataB","shDataB","mergedShDataLength","hasMergedShData","expectedSplatsDataSizeA","byteLength","expectedSplatsDataSizeB","mergedSplatsData","mergedShData","bytesPerTexel","totalSplatCount","mergedShDataItem","byteOffset","partIndicesA","partIndicesB","fill","mergedPartIndices","partWorldMatrix","proxyMesh","decompose","scaling","rotationQuaternion","removePart","rowLength","newSplatCount","newSplatsData","newPartIndices","newShData","writeIndex","readIndex","currentPartIndex","srcOffset","dstOffset","srcShOffset","dstShOffset","splice","proxyToRemove","proxiesToUpdate","proxyIndex","oldIndex","bakeTransformIntoVertices","arrayBuffer","scaleX","scaleY","scaleZ","temp","transformedQuaternion","floatIndex","TransformCoordinatesFromFloatsToRef","round","self","floatMix","globalModelViewProjection","modelViewProjs","model","matrix1","matrix2","k","multiplyMatrices","mvp","CloudPoint","particleIndex","group","groupId","idxInGroup","pcs","idx","color","Color4","Zero","rotation","uv","velocity","pivot","translateFromPivot","_pos","_ind","_stillInvisible","_rotationMatrix","parentId","_globalPosition","_group","_pcs","intersectsMesh","target","isSphere","hasBoundingInfo","intersectsPoint","bbox","maxX","maximumWorld","minX","minimumWorld","maxY","minY","getRotationMatrix","RotationYawPitchRollToRef","PointsGroup","groupID","posFunction","_positionFunction","PointsCloudSystem","_positions32","_colors32","uvs","_uvs32","pointSize","particles","nbParticles","counter","vars","_promises","_positions","_indices","_normals","_colors","_uvs","_updatable","_isVisibilityBoxLocked","_alwaysVisible","_groups","_groupCounter","_computeParticleColor","_computeParticleTexture","_computeParticleRotation","_computeBoundingBox","_isReady","_size","updatable","buildMeshAsync","_buildMeshAsync","addPoints","UVKind","ec","ColorKind","mat","StandardMaterial","emissiveColor","Color3","disableLighting","_addParticle","cp","_randomUnitVector","particle","random","_getColorIndicesForCoord","pointsGroup","imageData","_groupImageData","colorIndices","greenIndex","blueIndex","alphaIndex","redForCoord","greenForCoord","blueForCoord","alphaForCoord","_setPointsColorOrUV","isVolume","colorFromTexture","hasTexture","range","uvSetIndex","updateFacetData","diameter","radius","meshPos","getVerticesData","meshInd","getIndices","meshUV","meshCol","place","meshMatrix","isIdentity","p","idxPoints","id0","id1","id2","v0X","v0Y","v0Z","v1X","v1Y","v1Z","v2X","v2Y","v2Z","vertex0","vertex1","vertex2","vec0","vec1","uv0X","uv0Y","uv1X","uv1Y","uv2X","uv2Y","uv0","uv1","uv2","uvec0","uvec1","col0X","col0Y","col0Z","col0A","col1X","col1Y","col1Z","col1A","col2X","col2Y","col2Z","col2A","col0","Vector4","col1","col2","colvec0","colvec1","facetPoint","uvPoint","lamda","mu","colPoint","tang","biNorm","angle","facetPlaneVec","gap","Ray","pickInfo","direction","deltaS","deltaV","h","s","hsvCol","subtractToRef","statedColor","colPoint3","pointColors","_groupDensity","RandomRange","getFacetNormal","Cross","cos","sin","pickedPoint","subtract","addInPlace","_groupImgWidth","_groupImgHeight","r","g","toHSV","HSVtoRGBToRef","_colorFromTexture","textureList","getActiveTextures","BaseTexture","WhenAllReady","n","_textureNb","finalize","coordinatesIndex","dataPromise","readPixels","_calculateDensity","nbPoints","normal","area","cumulativeAreas","surfaceArea","nbFacets","CrossToRef","density","remainingPoints","cumulativeArea","facetPointsWithFraction","floored","fraction","facetPoints","nb","pointFunction","addSurfacePoints","colorWith","colored","isNaN","addVolumePoints","setParticles","start","end","update","beforeUpdateParticles","rotMatrix","colors32","positions32","uvs32","tempVectors","camAxisX","copyFromFloats","camAxisY","camAxisZ","setAll","IdentityToRef","isFacetDataEnabled","pindex","cindex","uindex","updateParticle","particleRotationMatrix","particlePosition","particleGlobalPosition","parent","parentRotationMatrix","parentGlobalPosition","rotatedY","rotatedX","rotatedZ","rotMatrixValues","pivotBackTranslation","tmpVertex","vertexX","vertexY","vertexZ","px","py","pz","updateVerticesData","_worldMatrix","buildBoundingInfo","afterUpdateParticles","_indices32","refreshVisibleSize","setVisibilityBox","vis","isAlwaysVisible","val","alwaysSelectAsActiveMesh","computeParticleRotation","computeParticleColor","computeParticleTexture","computeBoundingBox","initParticles","recycleParticle","stop","SH_C0","LoadWebpImageData","rootUrlOrData","filename","promise","reject","image","createCanvasImage","objectUrl","onload","canvas","createCanvas","ctx","getContext","drawImage","getImageData","error","src","onerror","crossOrigin","blob","ParseSogMeta","dataOrFiles","files","metaFile","JSON","parse","urls","means","scales","quats","sh0","shN","imageDataArrays","fileName","fileData","count","shape","unlog","meansl","meansu","isArray","mins","maxs","meansMin","meansMax","codebook","sc","sce","lsc","lsce","component","colorsMin","colorsMax","colort","csh","toComp","SQRT2","quatArray","quatsr","quatsg","quatsb","quatsa","d","coeffCounts","coeffs","bands","shCentroids","shLabelsData","shCentroidsWidth","shComponentCount","u","shArray","byteIndexInTexture","offsetPerSplat","shMin","shMax","hasVertexColors","ParseSogDatas","SPLATFileLoader","loadingOptions","_DefaultLoadingOptions","SPLATFileLoaderMetadata","_assetContainer","extensions","_loadingOptions","createPlugin","importMeshAsync","meshesNames","_onProgress","_fileName","_parseAsync","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","spriteManagers","_BuildPointCloud","pointcloud","_BuildMesh","parsedPLY","faces","_unzipWithFFlateAsync","fflate","window","Tools","LoadScriptAsync","deflateURL","unzipSync","unzipped","content","Object","babylonMeshesArray","makeGSFromParsedSOG","parsedSOG","_blockEntityCollection","gaussianSplatting","_parentContainer","dataSOG","catch","u8","readableStream","ReadableStream","controller","enqueue","close","decompressionStream","DecompressionStream","decompressedStream","pipeThrough","Response","ubufu32","fractionalBits","flags","reserved","positionScale","int32View","Int32Array","uint8View","read24bComponent","sqrt12","SQRT1_2","comp","cmask","iLargest","remaining","sumSquares","mag","negbit","square","shuffle","nx","ny","nz","trainedWithAntialiasing","ParseSpz","parsedSPZ","applyAutoCameraLimits","_ConvertPLYToSplat","chirality","upAxis","meta","disableAutoCameraLimits","safeOrbitCameraRadiusMin","safeOrbitCameraElevationMinMax","arcCam","lowerBetaLimit","upperBetaLimit","lowerRadiusLimit","loadAssetContainerAsync","container","AssetContainer","ex","loadAsync","rawSplat","faceElement","faceCount","metaData","view","faceVertexCount","vertexIndex","compressed","propertyCount","propertyColorCount","splatProperties","splatColorProperties","includes","hasMandatoryProperties","currentMode","RegisterSceneLoaderPlugin"],"mappings":"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,IAAK,eACD,OAAO,GACX,IAAK,IACD,OAAO,GACX,IAAK,IACD,OAAO,GACX,IAAK,IACD,OAAO,GACX,IAAK,UACD,OAAO,GACX,IAAK,UACD,OAAO,GACX,IAAK,UACD,OAAO,GACX,IAAK,cACL,IAAK,MACD,OAAO,GACX,IAAK,gBACL,IAAK,QACD,OAAO,GACX,IAAK,eACL,IAAK,OACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,SACD,OAAO,GACX,IAAK,UACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,QACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,WACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YACD,OAAO,GACX,IAAK,YAC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"}