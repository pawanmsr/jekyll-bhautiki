{"version":3,"file":"engine.multiRender-BgP1BPfI.esm.min.js","sources":["../../../../../dev/core/dist/Engines/WebGPU/Extensions/engine.multiRender.js"],"sourcesContent":["import { InternalTexture } from \"../../../Materials/Textures/internalTexture\";\nimport { Logger } from \"../../../Misc/logger\";\nimport { Constants } from \"../../constants\";\nimport { WebGPUEngine } from \"../../webgpuEngine\";\nWebGPUEngine.prototype.unBindMultiColorAttachmentFramebuffer = function (rtWrapper, disableGenerateMipMaps = false, onBeforeUnbind) {\n    if (onBeforeUnbind) {\n        onBeforeUnbind();\n    }\n    this._endCurrentRenderPass();\n    if (!rtWrapper.disableAutomaticMSAAResolve) {\n        this.resolveMultiFramebuffer(rtWrapper, false);\n    }\n    if (!disableGenerateMipMaps) {\n        this.generateMipMapsMultiFramebuffer(rtWrapper);\n    }\n    this._currentRenderTarget = null;\n    this._mrtAttachments = [];\n    this._cacheRenderPipeline.setMRT([]);\n    this._cacheRenderPipeline.setMRTAttachments(this._mrtAttachments);\n};\nWebGPUEngine.prototype.createMultipleRenderTarget = function (size, options, initializeBuffers) {\n    let generateMipMaps = false;\n    let generateDepthBuffer = true;\n    let generateStencilBuffer = false;\n    let generateDepthTexture = false;\n    let depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH16;\n    let textureCount = 1;\n    let samples = 1;\n    const defaultType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n    const defaultSamplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;\n    const defaultUseSRGBBuffer = false;\n    const defaultFormat = Constants.TEXTUREFORMAT_RGBA;\n    const defaultTarget = Constants.TEXTURE_2D;\n    let types = [];\n    let samplingModes = [];\n    let useSRGBBuffers = [];\n    let formats = [];\n    let targets = [];\n    let faceIndex = [];\n    let layerIndex = [];\n    let layers = [];\n    let labels = [];\n    let creationFlags = [];\n    let dontCreateTextures = false;\n    const rtWrapper = this._createHardwareRenderTargetWrapper(true, false, size);\n    if (options !== undefined) {\n        generateMipMaps = options.generateMipMaps ?? false;\n        generateDepthBuffer = options.generateDepthBuffer ?? true;\n        generateStencilBuffer = options.generateStencilBuffer ?? false;\n        generateDepthTexture = options.generateDepthTexture ?? false;\n        textureCount = options.textureCount ?? 1;\n        depthTextureFormat = options.depthTextureFormat ?? Constants.TEXTUREFORMAT_DEPTH16;\n        types = options.types || types;\n        samplingModes = options.samplingModes || samplingModes;\n        useSRGBBuffers = options.useSRGBBuffers || useSRGBBuffers;\n        formats = options.formats || formats;\n        targets = options.targetTypes || targets;\n        faceIndex = options.faceIndex || faceIndex;\n        layerIndex = options.layerIndex || layerIndex;\n        layers = options.layerCounts || layers;\n        labels = options.labels || labels;\n        creationFlags = options.creationFlags || creationFlags;\n        samples = options.samples ?? samples;\n        dontCreateTextures = options.dontCreateTextures ?? false;\n    }\n    const width = size.width ?? size;\n    const height = size.height ?? size;\n    const textures = [];\n    const attachments = [];\n    const defaultAttachments = [];\n    rtWrapper.label = options?.label ?? \"MultiRenderTargetWrapper\";\n    rtWrapper._generateDepthBuffer = generateDepthBuffer;\n    rtWrapper._generateStencilBuffer = generateStencilBuffer;\n    rtWrapper._attachments = attachments;\n    rtWrapper._defaultAttachments = defaultAttachments;\n    let depthStencilTexture = null;\n    if ((generateDepthBuffer || generateStencilBuffer || generateDepthTexture) && !dontCreateTextures) {\n        if (!generateDepthTexture) {\n            // The caller doesn't want a depth texture, so we are free to use the depth texture format we want.\n            // So, we will align with what the WebGL engine does\n            if (generateDepthBuffer && generateStencilBuffer) {\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH24_STENCIL8;\n            }\n            else if (generateDepthBuffer) {\n                depthTextureFormat = Constants.TEXTUREFORMAT_DEPTH32_FLOAT;\n            }\n            else {\n                depthTextureFormat = Constants.TEXTUREFORMAT_STENCIL8;\n            }\n        }\n        depthStencilTexture = rtWrapper.createDepthStencilTexture(0, false, generateStencilBuffer, 1, depthTextureFormat, rtWrapper.label + \"-DepthStencil\");\n    }\n    const mipmapsCreationOnly = options !== undefined && typeof options === \"object\" && options.createMipMaps && !generateMipMaps;\n    for (let i = 0; i < textureCount; i++) {\n        let samplingMode = samplingModes[i] || defaultSamplingMode;\n        let type = types[i] || defaultType;\n        const format = formats[i] || defaultFormat;\n        const useSRGBBuffer = (useSRGBBuffers[i] || defaultUseSRGBBuffer) && this._caps.supportSRGBBuffers;\n        const target = targets[i] || defaultTarget;\n        const layerCount = layers[i] ?? 1;\n        const creationFlag = creationFlags[i];\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloatLinearFiltering) {\n            // if floating point linear (FLOAT) then force to NEAREST_SAMPLINGMODE\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        else if (type === Constants.TEXTURETYPE_HALF_FLOAT && !this._caps.textureHalfFloatLinearFiltering) {\n            // if floating point linear (HALF_FLOAT) then force to NEAREST_SAMPLINGMODE\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        if (type === Constants.TEXTURETYPE_FLOAT && !this._caps.textureFloat) {\n            type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n            Logger.Warn(\"Float textures are not supported. Render target forced to TEXTURETYPE_UNSIGNED_BYTE type\");\n        }\n        attachments.push(i + 1);\n        defaultAttachments.push(initializeBuffers ? i + 1 : i === 0 ? 1 : 0);\n        if (target === -1 || dontCreateTextures) {\n            continue;\n        }\n        const texture = new InternalTexture(this, 6 /* InternalTextureSource.MultiRenderTarget */);\n        textures[i] = texture;\n        switch (target) {\n            case Constants.TEXTURE_CUBE_MAP:\n                texture.isCube = true;\n                break;\n            case Constants.TEXTURE_3D:\n                texture.is3D = true;\n                texture.baseDepth = texture.depth = layerCount;\n                break;\n            case Constants.TEXTURE_2D_ARRAY:\n                texture.is2DArray = true;\n                texture.baseDepth = texture.depth = layerCount;\n                break;\n        }\n        texture.baseWidth = width;\n        texture.baseHeight = height;\n        texture.width = width;\n        texture.height = height;\n        texture.isReady = true;\n        texture.samples = 1;\n        texture.generateMipMaps = generateMipMaps;\n        texture.samplingMode = samplingMode;\n        texture.type = type;\n        texture._cachedWrapU = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n        texture._cachedWrapV = Constants.TEXTURE_CLAMP_ADDRESSMODE;\n        texture._useSRGBBuffer = useSRGBBuffer;\n        texture.format = format;\n        texture.label = labels[i] ?? rtWrapper.label + \"-Texture\" + i;\n        this._internalTexturesCache.push(texture);\n        if (mipmapsCreationOnly) {\n            // createGPUTextureForInternalTexture will only create a texture with mipmaps if generateMipMaps is true, as InternalTexture has no createMipMaps property, separate from generateMipMaps.\n            texture.generateMipMaps = true;\n        }\n        this._textureHelper.createGPUTextureForInternalTexture(texture, undefined, undefined, undefined, creationFlag);\n        if (mipmapsCreationOnly) {\n            texture.generateMipMaps = false;\n        }\n    }\n    if (depthStencilTexture) {\n        depthStencilTexture.incrementReferences();\n        textures[textureCount] = depthStencilTexture;\n        this._internalTexturesCache.push(depthStencilTexture);\n    }\n    rtWrapper.setTextures(textures);\n    rtWrapper.setLayerAndFaceIndices(layerIndex, faceIndex);\n    if (!dontCreateTextures) {\n        this.updateMultipleRenderTargetTextureSampleCount(rtWrapper, samples);\n    }\n    else {\n        rtWrapper._samples = samples;\n    }\n    return rtWrapper;\n};\nWebGPUEngine.prototype.updateMultipleRenderTargetTextureSampleCount = function (rtWrapper, samples) {\n    if (!rtWrapper || !rtWrapper.textures || rtWrapper.textures.length === 0 || rtWrapper.textures[0].samples === samples) {\n        return samples;\n    }\n    const count = rtWrapper.textures.length;\n    if (count === 0) {\n        return 1;\n    }\n    samples = Math.min(samples, this.getCaps().maxMSAASamples);\n    // Release existing MSAA textures\n    for (let i = 0; i < count; ++i) {\n        const texture = rtWrapper.textures[i];\n        const gpuTextureWrapper = texture._hardwareTexture;\n        gpuTextureWrapper?.releaseMSAATextures();\n    }\n    // Sets new sample count. The MSAA textures will be created on demand.\n    for (let i = 0; i < count; ++i) {\n        const texture = rtWrapper.textures[i];\n        texture.samples = samples;\n    }\n    if (rtWrapper._depthStencilTexture) {\n        rtWrapper._depthStencilTexture.samples = samples;\n    }\n    rtWrapper._samples = samples;\n    return samples;\n};\nWebGPUEngine.prototype.generateMipMapsMultiFramebuffer = function (texture) {\n    const rtWrapper = texture;\n    if (!rtWrapper.isMulti) {\n        return;\n    }\n    const attachments = rtWrapper._attachments;\n    const count = attachments.length;\n    for (let i = 0; i < count; i++) {\n        const texture = rtWrapper.textures[i];\n        if (texture.generateMipMaps && !texture.isCube && !texture.is3D) {\n            this._generateMipmaps(texture);\n        }\n    }\n};\nWebGPUEngine.prototype.resolveMultiFramebuffer = function (texture, resolveColors = true) {\n    this.resolveFramebuffer(texture, resolveColors);\n};\nWebGPUEngine.prototype.bindAttachments = function (attachments) {\n    if (attachments.length === 0 || !this._currentRenderTarget) {\n        return;\n    }\n    this._mrtAttachments = attachments;\n    if (this._currentRenderPass) {\n        // the render pass has already been created, we need to call setMRTAttachments to update the state of the attachments\n        this._cacheRenderPipeline.setMRTAttachments(attachments);\n    }\n    else {\n        // the render pass is not created yet so we don't need to call setMRTAttachments: it will be called as part of the render pass creation (see WebGPUEngine._startRenderTargetRenderPass)\n    }\n};\nWebGPUEngine.prototype.buildTextureLayout = function (textureStatus, backBufferLayout = false) {\n    const result = [];\n    if (backBufferLayout) {\n        result.push(1);\n    }\n    else {\n        for (let i = 0; i < textureStatus.length; i++) {\n            if (textureStatus[i]) {\n                result.push(i + 1);\n            }\n            else {\n                result.push(0);\n            }\n        }\n    }\n    return result;\n};\nWebGPUEngine.prototype.restoreSingleAttachment = function () {\n    // not sure what to do, probably nothing... This function and restoreSingleAttachmentForRenderTarget are not called in Babylon.js so it's hard to know the use case\n};\nWebGPUEngine.prototype.restoreSingleAttachmentForRenderTarget = function () {\n    // not sure what to do, probably nothing... This function and restoreSingleAttachment are not called in Babylon.js so it's hard to know the use case\n};\n//# sourceMappingURL=engine.multiRender.js.map"],"names":["WebGPUEngine","prototype","unBindMultiColorAttachmentFramebuffer","rtWrapper","disableGenerateMipMaps","onBeforeUnbind","this","_endCurrentRenderPass","disableAutomaticMSAAResolve","resolveMultiFramebuffer","generateMipMapsMultiFramebuffer","_currentRenderTarget","_mrtAttachments","_cacheRenderPipeline","setMRT","setMRTAttachments","createMultipleRenderTarget","size","options","initializeBuffers","generateMipMaps","generateDepthBuffer","generateStencilBuffer","generateDepthTexture","depthTextureFormat","Constants","TEXTUREFORMAT_DEPTH16","textureCount","samples","defaultType","TEXTURETYPE_UNSIGNED_BYTE","defaultSamplingMode","TEXTURE_TRILINEAR_SAMPLINGMODE","defaultFormat","TEXTUREFORMAT_RGBA","defaultTarget","TEXTURE_2D","types","samplingModes","useSRGBBuffers","formats","targets","faceIndex","layerIndex","layers","labels","creationFlags","dontCreateTextures","_createHardwareRenderTargetWrapper","undefined","targetTypes","layerCounts","width","height","textures","attachments","defaultAttachments","label","_generateDepthBuffer","_generateStencilBuffer","_attachments","_defaultAttachments","depthStencilTexture","TEXTUREFORMAT_DEPTH24_STENCIL8","TEXTUREFORMAT_DEPTH32_FLOAT","TEXTUREFORMAT_STENCIL8","createDepthStencilTexture","mipmapsCreationOnly","createMipMaps","i","samplingMode","type","format","useSRGBBuffer","_caps","supportSRGBBuffers","target","layerCount","creationFlag","TEXTURETYPE_FLOAT","textureFloatLinearFiltering","TEXTURETYPE_HALF_FLOAT","textureHalfFloatLinearFiltering","TEXTURE_NEAREST_SAMPLINGMODE","textureFloat","Logger","Warn","push","texture","InternalTexture","TEXTURE_CUBE_MAP","isCube","TEXTURE_3D","is3D","baseDepth","depth","TEXTURE_2D_ARRAY","is2DArray","baseWidth","baseHeight","isReady","_cachedWrapU","TEXTURE_CLAMP_ADDRESSMODE","_cachedWrapV","_useSRGBBuffer","_internalTexturesCache","_textureHelper","createGPUTextureForInternalTexture","incrementReferences","setTextures","setLayerAndFaceIndices","_samples","updateMultipleRenderTargetTextureSampleCount","length","count","Math","min","getCaps","maxMSAASamples","gpuTextureWrapper","_hardwareTexture","releaseMSAATextures","_depthStencilTexture","isMulti","_generateMipmaps","resolveColors","resolveFramebuffer","bindAttachments","_currentRenderPass","buildTextureLayout","textureStatus","backBufferLayout","result","restoreSingleAttachment","restoreSingleAttachmentForRenderTarget"],"mappings":"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"}