{"version":3,"file":"rawTexture-GcKYJ37d.esm.min.js","sources":["../../../../../dev/core/dist/Materials/Textures/rawTexture.js"],"sourcesContent":["import { Texture } from \"./texture\";\nimport { Constants } from \"../../Engines/constants\";\n/**\n * Raw texture can help creating a texture directly from an array of data.\n * This can be super useful if you either get the data from an uncompressed source or\n * if you wish to create your texture pixel by pixel.\n */\nexport class RawTexture extends Texture {\n    /**\n     * Instantiates a new RawTexture.\n     * Raw texture can help creating a texture directly from an array of data.\n     * This can be super useful if you either get the data from an uncompressed source or\n     * if you wish to create your texture pixel by pixel.\n     * @param data define the array of data to use to create the texture (null to create an empty texture)\n     * @param width define the width of the texture\n     * @param height define the height of the texture\n     * @param format define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps define whether mip maps should be generated or not\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @param waitDataToBeReady If set to true Rawtexture will wait data to be set in order to be flaged as ready.\n     * @param mipLevelCount defines the number of mip levels to allocate for the texture\n     */\n    constructor(data, width, height, \n    /**\n     * Define the format of the data (RGB, RGBA... Engine.TEXTUREFORMAT_xxx)\n     */\n    format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_UNSIGNED_BYTE, creationFlags, useSRGBBuffer, waitDataToBeReady, mipLevelCount) {\n        super(null, sceneOrEngine, !generateMipMaps, invertY, undefined, undefined, undefined, undefined, undefined, undefined, undefined, undefined, creationFlags);\n        this.format = format;\n        if (!this._engine) {\n            return;\n        }\n        if (!this._engine._caps.textureFloatLinearFiltering && type === Constants.TEXTURETYPE_FLOAT) {\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === Constants.TEXTURETYPE_HALF_FLOAT) {\n            samplingMode = Constants.TEXTURE_NEAREST_SAMPLINGMODE;\n        }\n        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags ?? 0, useSRGBBuffer ?? false, mipLevelCount);\n        this.wrapU = Texture.CLAMP_ADDRESSMODE;\n        this.wrapV = Texture.CLAMP_ADDRESSMODE;\n        this._waitingForData = !!waitDataToBeReady && !data;\n    }\n    /**\n     * Updates the texture underlying data.\n     * @param data Define the new data of the texture\n     */\n    update(data) {\n        this.updateMipLevel(data, 0);\n    }\n    /**\n     * Updates a specific mip level of the texture.\n     * @param data The new data for the mip level\n     * @param mipLevel The mip level to update (0 is the base level)\n     */\n    updateMipLevel(data, mipLevel) {\n        this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer, mipLevel);\n        this._waitingForData = false;\n    }\n    /**\n     * Clones the texture.\n     * @returns the cloned texture\n     */\n    clone() {\n        if (!this._texture) {\n            return super.clone();\n        }\n        const rawTexture = new RawTexture(null, this.getSize().width, this.getSize().height, this.format, this.getScene(), this._texture.generateMipMaps, this._invertY, this.samplingMode, this._texture.type, this._texture._creationFlags, this._useSRGBBuffer);\n        rawTexture._texture = this._texture;\n        this._texture.incrementReferences();\n        return rawTexture;\n    }\n    isReady() {\n        return super.isReady() && !this._waitingForData;\n    }\n    /**\n     * Creates a luminance texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @returns the luminance texture\n     */\n    static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n    }\n    /**\n     * Creates a luminance alpha texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @returns the luminance alpha texture\n     */\n    static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_LUMINANCE_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n    }\n    /**\n     * Creates an alpha texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @returns the alpha texture\n     */\n    static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_ALPHA, sceneOrEngine, generateMipMaps, invertY, samplingMode);\n    }\n    /**\n     * Creates a RGB texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @returns the RGB alpha texture\n     */\n    static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_UNSIGNED_BYTE, creationFlags = 0, useSRGBBuffer = false) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGB, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);\n    }\n    /**\n     * Creates a RGBA texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @param waitDataToBeReady if set to true this will force texture to wait for data to be set before it is considered ready.\n     * @returns the RGBA texture\n     */\n    static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_UNSIGNED_BYTE, creationFlags = 0, useSRGBBuffer = false, waitDataToBeReady = false) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer, waitDataToBeReady);\n    }\n    /**\n     * Creates a RGBA storage texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @param useSRGBBuffer defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU).\n     * @returns the RGBA texture\n     */\n    static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_UNSIGNED_BYTE, useSRGBBuffer = false) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_RGBA, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE, useSRGBBuffer);\n    }\n    /**\n     * Creates a R texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @returns the R texture\n     */\n    static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_FLOAT) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);\n    }\n    /**\n     * Creates a R storage texture from some data.\n     * @param data Define the texture data\n     * @param width Define the width of the texture\n     * @param height Define the height of the texture\n     * @param sceneOrEngine defines the scene or engine the texture will belong to\n     * @param generateMipMaps Define whether or not to create mip maps for the texture\n     * @param invertY define if the data should be flipped on Y when uploaded to the GPU\n     * @param samplingMode define the texture sampling mode (Texture.xxx_SAMPLINGMODE)\n     * @param type define the format of the data (int, float... Engine.TEXTURETYPE_xxx)\n     * @returns the R texture\n     */\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = Constants.TEXTURETYPE_FLOAT) {\n        return new RawTexture(data, width, height, Constants.TEXTUREFORMAT_R, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, Constants.TEXTURE_CREATIONFLAG_STORAGE);\n    }\n}\n//# sourceMappingURL=rawTexture.js.map"],"names":["RawTexture","Texture","constructor","data","width","height","format","sceneOrEngine","generateMipMaps","invertY","samplingMode","Constants","TEXTURE_TRILINEAR_SAMPLINGMODE","type","TEXTURETYPE_UNSIGNED_BYTE","creationFlags","useSRGBBuffer","waitDataToBeReady","mipLevelCount","super","undefined","this","_engine","_caps","textureFloatLinearFiltering","TEXTURETYPE_FLOAT","TEXTURE_NEAREST_SAMPLINGMODE","textureHalfFloatLinearFiltering","TEXTURETYPE_HALF_FLOAT","_texture","createRawTexture","wrapU","CLAMP_ADDRESSMODE","wrapV","_waitingForData","update","updateMipLevel","mipLevel","_getEngine","updateRawTexture","_useSRGBBuffer","clone","rawTexture","getSize","getScene","_invertY","_creationFlags","incrementReferences","isReady","CreateLuminanceTexture","TEXTUREFORMAT_LUMINANCE","CreateLuminanceAlphaTexture","TEXTUREFORMAT_LUMINANCE_ALPHA","CreateAlphaTexture","TEXTUREFORMAT_ALPHA","CreateRGBTexture","TEXTUREFORMAT_RGB","CreateRGBATexture","TEXTUREFORMAT_RGBA","CreateRGBAStorageTexture","TEXTURE_CREATIONFLAG_STORAGE","CreateRTexture","TRILINEAR_SAMPLINGMODE","TEXTUREFORMAT_R","CreateRStorageTexture"],"mappings":"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"}