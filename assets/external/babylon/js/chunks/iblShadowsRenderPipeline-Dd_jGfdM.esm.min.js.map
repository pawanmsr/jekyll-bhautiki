{"version":3,"file":"iblShadowsRenderPipeline-Dd_jGfdM.esm.min.js","sources":["../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsVoxelRenderer.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsVoxelTracingPass.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsSpatialBlurPass.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsAccumulationPass.js","../../../../../dev/core/dist/Materials/Textures/rawTexture3D.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsPluginMaterial.js","../../../../../dev/core/dist/Rendering/IBLShadows/iblShadowsRenderPipeline.js"],"sourcesContent":["import { Constants } from \"../../Engines/constants\";\nimport { Engine } from \"../../Engines/engine\";\nimport { ShaderMaterial } from \"../../Materials/shaderMaterial\";\nimport { MultiRenderTarget } from \"../../Materials/Textures/multiRenderTarget\";\nimport { RenderTargetTexture } from \"../../Materials/Textures/renderTargetTexture\";\nimport { Color4 } from \"../../Maths/math.color\";\nimport { Matrix, Vector3, Vector4 } from \"../../Maths/math.vector\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { Logger } from \"../../Misc/logger\";\nimport { Observable } from \"../../Misc/observable\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { ProceduralTexture } from \"../../Materials/Textures/Procedurals/proceduralTexture\";\nimport { EffectRenderer, EffectWrapper } from \"../../Materials/effectRenderer\";\n/**\n * Voxel-based shadow rendering for IBL's.\n * This should not be instanciated directly, as it is part of a scene component\n * @internal\n * @see https://playground.babylonjs.com/#8R5SSE#222\n */\nexport class _IblShadowsVoxelRenderer {\n    /**\n     * Return the voxel grid texture.\n     * @returns The voxel grid texture.\n     */\n    getVoxelGrid() {\n        if (this._engine.isWebGPU) {\n            return this._voxelGrid;\n        }\n        else if (this._triPlanarVoxelization) {\n            return this._combinedVoxelGridPT;\n        }\n        else {\n            return this._voxelGridZaxis;\n        }\n    }\n    /**\n     * The debug pass post process\n     * @returns The debug pass post process\n     */\n    getDebugPassPP() {\n        if (!this._voxelDebugPass) {\n            this._createDebugPass();\n        }\n        return this._voxelDebugPass;\n    }\n    /**\n     * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\n     */\n    get triPlanarVoxelization() {\n        return this._triPlanarVoxelization;\n    }\n    /**\n     * Whether to use tri-planar voxelization. More expensive, but can help with artifacts.\n     */\n    set triPlanarVoxelization(enabled) {\n        if (this._engine.isWebGPU) {\n            // WebGPU only supports tri-planar voxelization.\n            this._triPlanarVoxelization = true;\n            return;\n        }\n        if (this._triPlanarVoxelization === enabled) {\n            return;\n        }\n        this._triPlanarVoxelization = enabled;\n        this._disposeVoxelTextures();\n        this._createTextures();\n    }\n    /**\n     * Set the matrix to use for scaling the world space to voxel space\n     * @param matrix The matrix to use for scaling the world space to voxel space\n     */\n    setWorldScaleMatrix(matrix) {\n        this._invWorldScaleMatrix = matrix;\n    }\n    /**\n     * @returns Whether voxelization is currently happening.\n     */\n    isVoxelizationInProgress() {\n        return this._voxelizationInProgress;\n    }\n    /**\n     * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\n     */\n    get voxelResolutionExp() {\n        return this._voxelResolutionExp;\n    }\n    /**\n     * Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\n     */\n    set voxelResolutionExp(resolutionExp) {\n        if (this._voxelResolutionExp === resolutionExp && this._voxelGridZaxis) {\n            return;\n        }\n        this._voxelResolutionExp = Math.round(Math.min(Math.max(resolutionExp, 3), 9));\n        this._voxelResolution = Math.pow(2.0, this._voxelResolutionExp);\n        this._disposeVoxelTextures();\n        this._createTextures();\n    }\n    /**\n     * Shows only the voxels that were rendered along a particular axis (while using triPlanarVoxelization).\n     * If not set, the combined voxel grid will be shown.\n     * Note: This only works when the debugMipNumber is set to 0 because we don't generate mips for each axis.\n     * @param axis The axis to show (0 = x, 1 = y, 2 = z)\n     */\n    set voxelDebugAxis(axis) {\n        this._voxelDebugAxis = axis;\n    }\n    get voxelDebugAxis() {\n        return this._voxelDebugAxis;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * The mip level to show in the debug display\n     * @param mipNum The mip level to show in the debug display\n     */\n    setDebugMipNumber(mipNum) {\n        this._debugMipNumber = mipNum;\n    }\n    /**\n     * Sets the name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * Enable or disable the debug view for this pass\n     */\n    get voxelDebugEnabled() {\n        return this._voxelDebugEnabled;\n    }\n    set voxelDebugEnabled(enabled) {\n        if (this._voxelDebugEnabled === enabled) {\n            return;\n        }\n        this._voxelDebugEnabled = enabled;\n        if (enabled) {\n            this._voxelSlabDebugRT = new RenderTargetTexture(\"voxelSlabDebug\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, this._scene, {\n                generateDepthBuffer: true,\n                generateMipMaps: false,\n                type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n                format: Constants.TEXTUREFORMAT_RGBA,\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            });\n            this._voxelSlabDebugRT.noPrePassRenderer = true;\n        }\n        if (this._voxelSlabDebugRT) {\n            this._removeVoxelRTs([this._voxelSlabDebugRT]);\n        }\n        // Add the slab debug RT if needed.\n        if (this._voxelDebugEnabled) {\n            this._addRTsForRender([this._voxelSlabDebugRT], this._includedMeshes, this._voxelDebugAxis, 1, true);\n            this._setDebugBindingsBound = this._setDebugBindings.bind(this);\n            this._scene.onBeforeRenderObservable.add(this._setDebugBindingsBound);\n        }\n        else {\n            this._scene.onBeforeRenderObservable.removeCallback(this._setDebugBindingsBound);\n        }\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        const isWebGPU = this._engine.isWebGPU;\n        if (!this._voxelDebugPass) {\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                textureFormat: Constants.TEXTUREFORMAT_RGBA,\n                textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                uniforms: [\"sizeParams\", \"mipNumber\"],\n                samplers: [\"voxelTexture\", \"voxelSlabTexture\"],\n                engine: this._engine,\n                reusable: false,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblVoxelGrid3dDebug.fragment\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblVoxelGrid3dDebug.fragment\"));\n                    }\n                },\n            };\n            this._voxelDebugPass = new PostProcess(this.debugPassName, \"iblVoxelGrid3dDebug\", debugOptions);\n            this._voxelDebugPass.onApplyObservable.add((effect) => {\n                if (this._voxelDebugAxis === 0) {\n                    effect.setTexture(\"voxelTexture\", this._voxelGridXaxis);\n                }\n                else if (this._voxelDebugAxis === 1) {\n                    effect.setTexture(\"voxelTexture\", this._voxelGridYaxis);\n                }\n                else if (this._voxelDebugAxis === 2) {\n                    effect.setTexture(\"voxelTexture\", this._voxelGridZaxis);\n                }\n                else {\n                    effect.setTexture(\"voxelTexture\", this.getVoxelGrid());\n                }\n                effect.setTexture(\"voxelSlabTexture\", this._voxelSlabDebugRT);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n                effect.setFloat(\"mipNumber\", this._debugMipNumber);\n            });\n        }\n    }\n    /**\n     * Instanciates the voxel renderer\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The render pipeline this pass is associated with\n     * @param resolutionExp Resolution of the voxel grid. The final resolution will be 2^resolutionExp.\n     * @param triPlanarVoxelization Whether to use tri-planar voxelization. Only applies to WebGL. Voxelization will take longer but will reduce missing geometry.\n     * @returns The voxel renderer\n     */\n    constructor(scene, iblShadowsRenderPipeline, resolutionExp = 6, triPlanarVoxelization = true) {\n        this._voxelMrtsXaxis = [];\n        this._voxelMrtsYaxis = [];\n        this._voxelMrtsZaxis = [];\n        this._voxelClearColor = new Color4(0, 0, 0, 1);\n        /**\n         * Observable that triggers when the voxelization is complete\n         */\n        this.onVoxelizationCompleteObservable = new Observable();\n        this._renderTargets = [];\n        this._triPlanarVoxelization = true;\n        this._voxelizationInProgress = false;\n        this._invWorldScaleMatrix = Matrix.Identity();\n        this._voxelResolution = 64;\n        this._voxelResolutionExp = 6;\n        this._mipArray = [];\n        this._voxelDebugEnabled = false;\n        this._voxelDebugAxis = -1;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._includedMeshes = [];\n        this._debugMipNumber = 0;\n        this._debugPassName = \"Voxelization Debug Pass\";\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._triPlanarVoxelization = this._engine.isWebGPU || triPlanarVoxelization;\n        if (!this._engine.getCaps().drawBuffersExtension) {\n            Logger.Error(\"Can't do voxel rendering without the draw buffers extension.\");\n        }\n        const isWebGPU = this._engine.isWebGPU;\n        this._maxDrawBuffers = this._engine.getCaps().maxDrawBuffers || 0;\n        this._copyMipEffectRenderer = new EffectRenderer(this._engine);\n        this._copyMipEffectWrapper = new EffectWrapper({\n            engine: this._engine,\n            fragmentShader: \"copyTexture3DLayerToTexture\",\n            useShaderStore: true,\n            uniformNames: [\"layerNum\"],\n            samplerNames: [\"textureSampler\"],\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await import(\"../../ShadersWGSL/copyTexture3DLayerToTexture.fragment\");\n                }\n                else {\n                    await import(\"../../Shaders/copyTexture3DLayerToTexture.fragment\");\n                }\n            },\n        });\n        this.voxelResolutionExp = resolutionExp;\n    }\n    _generateMipMaps() {\n        const iterations = Math.ceil(Math.log2(this._voxelResolution));\n        for (let i = 1; i < iterations + 1; i++) {\n            this._generateMipMap(i);\n        }\n    }\n    _generateMipMap(lodLevel) {\n        // Generate a mip map for the given level by triggering the render of the procedural mip texture.\n        const mipTarget = this._mipArray[lodLevel - 1];\n        if (!mipTarget) {\n            return;\n        }\n        mipTarget.setTexture(\"srcMip\", lodLevel === 1 ? this.getVoxelGrid() : this._mipArray[lodLevel - 2]);\n        mipTarget.render();\n    }\n    _copyMipMaps() {\n        const iterations = Math.ceil(Math.log2(this._voxelResolution));\n        for (let i = 1; i < iterations + 1; i++) {\n            this._copyMipMap(i);\n        }\n    }\n    _copyMipMap(lodLevel) {\n        // Now, copy this mip into the mip chain of the voxel grid.\n        // TODO - this currently isn't working. \"textureSampler\" isn't being properly set to mipTarget.\n        const mipTarget = this._mipArray[lodLevel - 1];\n        if (!mipTarget) {\n            return;\n        }\n        const voxelGrid = this.getVoxelGrid();\n        let rt;\n        if (voxelGrid instanceof RenderTargetTexture && voxelGrid.renderTarget) {\n            rt = voxelGrid.renderTarget;\n        }\n        else {\n            rt = voxelGrid._rtWrapper;\n        }\n        if (rt) {\n            this._copyMipEffectRenderer.saveStates();\n            const bindSize = mipTarget.getSize().width;\n            // Render to each layer of the voxel grid.\n            for (let layer = 0; layer < bindSize; layer++) {\n                this._engine.bindFramebuffer(rt, 0, bindSize, bindSize, true, lodLevel, layer);\n                this._copyMipEffectRenderer.applyEffectWrapper(this._copyMipEffectWrapper);\n                this._copyMipEffectWrapper.effect.setTexture(\"textureSampler\", mipTarget);\n                this._copyMipEffectWrapper.effect.setInt(\"layerNum\", layer);\n                this._copyMipEffectRenderer.draw();\n                this._engine.unBindFramebuffer(rt, true);\n            }\n            this._copyMipEffectRenderer.restoreStates();\n        }\n    }\n    _computeNumberOfSlabs() {\n        return Math.ceil(this._voxelResolution / this._maxDrawBuffers);\n    }\n    _createTextures() {\n        const isWebGPU = this._engine.isWebGPU;\n        const size = {\n            width: this._voxelResolution,\n            height: this._voxelResolution,\n            depth: this._voxelResolution,\n        };\n        const voxelAxisOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n        };\n        // We can render up to maxDrawBuffers voxel slices of the grid per render.\n        // We call this a slab.\n        const numSlabs = this._computeNumberOfSlabs();\n        const voxelCombinedOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: true,\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_R,\n            samplingMode: Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await import(\"../../ShadersWGSL/iblCombineVoxelGrids.fragment\");\n                }\n                else {\n                    await import(\"../../Shaders/iblCombineVoxelGrids.fragment\");\n                }\n            },\n        };\n        if (this._engine.isWebGPU) {\n            this._voxelGrid = new RenderTargetTexture(\"voxelGrid\", size, this._scene, {\n                ...voxelCombinedOptions,\n                format: Constants.TEXTUREFORMAT_RGBA,\n                creationFlags: Constants.TEXTURE_CREATIONFLAG_STORAGE,\n            });\n            this._voxelGridRT = new RenderTargetTexture(\"voxelGridRT\", { width: Math.min(size.width * 2.0, 2048), height: Math.min(size.height * 2.0, 2048) }, this._scene, voxelAxisOptions);\n        }\n        else if (this._triPlanarVoxelization) {\n            this._voxelGridXaxis = new RenderTargetTexture(\"voxelGridXaxis\", size, this._scene, voxelAxisOptions);\n            this._voxelGridYaxis = new RenderTargetTexture(\"voxelGridYaxis\", size, this._scene, voxelAxisOptions);\n            this._voxelGridZaxis = new RenderTargetTexture(\"voxelGridZaxis\", size, this._scene, voxelAxisOptions);\n            this._voxelMrtsXaxis = this._createVoxelMRTs(\"x_axis_\", this._voxelGridXaxis, numSlabs);\n            this._voxelMrtsYaxis = this._createVoxelMRTs(\"y_axis_\", this._voxelGridYaxis, numSlabs);\n            this._voxelMrtsZaxis = this._createVoxelMRTs(\"z_axis_\", this._voxelGridZaxis, numSlabs);\n            this._combinedVoxelGridPT = new ProceduralTexture(\"combinedVoxelGrid\", size, \"iblCombineVoxelGrids\", this._scene, voxelCombinedOptions, false);\n            this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._combinedVoxelGridPT), 1);\n            this._combinedVoxelGridPT.setFloat(\"layer\", 0.0);\n            this._combinedVoxelGridPT.setTexture(\"voxelXaxisSampler\", this._voxelGridXaxis);\n            this._combinedVoxelGridPT.setTexture(\"voxelYaxisSampler\", this._voxelGridYaxis);\n            this._combinedVoxelGridPT.setTexture(\"voxelZaxisSampler\", this._voxelGridZaxis);\n            // We will render this only after voxelization is completed for the 3 axes.\n            this._combinedVoxelGridPT.autoClear = false;\n            this._combinedVoxelGridPT.wrapU = Texture.CLAMP_ADDRESSMODE;\n            this._combinedVoxelGridPT.wrapV = Texture.CLAMP_ADDRESSMODE;\n        }\n        else {\n            this._voxelGridZaxis = new RenderTargetTexture(\"voxelGridZaxis\", size, this._scene, voxelCombinedOptions);\n            this._voxelMrtsZaxis = this._createVoxelMRTs(\"z_axis_\", this._voxelGridZaxis, numSlabs);\n        }\n        const generateVoxelMipOptions = {\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_R,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await import(\"../../ShadersWGSL/iblGenerateVoxelMip.fragment\");\n                }\n                else {\n                    await import(\"../../Shaders/iblGenerateVoxelMip.fragment\");\n                }\n            },\n        };\n        this._mipArray = new Array(Math.ceil(Math.log2(this._voxelResolution)));\n        for (let mipIdx = 1; mipIdx <= this._mipArray.length; mipIdx++) {\n            const mipDim = this._voxelResolution >> mipIdx;\n            const mipSize = { width: mipDim, height: mipDim, depth: mipDim };\n            this._mipArray[mipIdx - 1] = new ProceduralTexture(\"voxelMip\" + mipIdx, mipSize, \"iblGenerateVoxelMip\", this._scene, generateVoxelMipOptions, false);\n            this._scene.proceduralTextures.splice(this._scene.proceduralTextures.indexOf(this._mipArray[mipIdx - 1]), 1);\n            const mipTarget = this._mipArray[mipIdx - 1];\n            mipTarget.autoClear = false;\n            mipTarget.wrapU = Texture.CLAMP_ADDRESSMODE;\n            mipTarget.wrapV = Texture.CLAMP_ADDRESSMODE;\n            mipTarget.setTexture(\"srcMip\", mipIdx > 1 ? this._mipArray[mipIdx - 2] : this.getVoxelGrid());\n            mipTarget.setInt(\"layerNum\", 0);\n        }\n        this._createVoxelMaterials();\n    }\n    _createVoxelMRTs(name, voxelRT, numSlabs) {\n        voxelRT.wrapU = Texture.CLAMP_ADDRESSMODE;\n        voxelRT.wrapV = Texture.CLAMP_ADDRESSMODE;\n        voxelRT.noPrePassRenderer = true;\n        const mrtArray = [];\n        const targetTypes = new Array(this._maxDrawBuffers).fill(Constants.TEXTURE_3D);\n        for (let mrtIndex = 0; mrtIndex < numSlabs; mrtIndex++) {\n            let layerIndices = new Array(this._maxDrawBuffers).fill(0);\n            layerIndices = layerIndices.map((value, index) => mrtIndex * this._maxDrawBuffers + index);\n            let textureNames = new Array(this._maxDrawBuffers).fill(\"\");\n            textureNames = textureNames.map((value, index) => \"voxel_grid_\" + name + (mrtIndex * this._maxDrawBuffers + index));\n            const mrt = new MultiRenderTarget(\"mrt_\" + name + mrtIndex, { width: this._voxelResolution, height: this._voxelResolution, depth: this._voxelResolution }, this._maxDrawBuffers, // number of draw buffers\n            this._scene, {\n                types: new Array(this._maxDrawBuffers).fill(Constants.TEXTURETYPE_UNSIGNED_BYTE),\n                samplingModes: new Array(this._maxDrawBuffers).fill(Constants.TEXTURE_TRILINEAR_SAMPLINGMODE),\n                generateMipMaps: false,\n                targetTypes,\n                formats: new Array(this._maxDrawBuffers).fill(Constants.TEXTUREFORMAT_R),\n                faceIndex: new Array(this._maxDrawBuffers).fill(0),\n                layerIndex: layerIndices,\n                layerCounts: new Array(this._maxDrawBuffers).fill(this._voxelResolution),\n                generateDepthBuffer: false,\n                generateStencilBuffer: false,\n            }, textureNames);\n            mrt.clearColor = new Color4(0, 0, 0, 1);\n            mrt.noPrePassRenderer = true;\n            for (let i = 0; i < this._maxDrawBuffers; i++) {\n                mrt.setInternalTexture(voxelRT.getInternalTexture(), i);\n            }\n            mrtArray.push(mrt);\n        }\n        return mrtArray;\n    }\n    _disposeVoxelTextures() {\n        this._stopVoxelization();\n        for (let i = 0; i < this._voxelMrtsZaxis.length; i++) {\n            if (this._triPlanarVoxelization) {\n                this._voxelMrtsXaxis[i].dispose(true);\n                this._voxelMrtsYaxis[i].dispose(true);\n            }\n            this._voxelMrtsZaxis[i].dispose(true);\n        }\n        if (this._triPlanarVoxelization) {\n            this._voxelGridXaxis?.dispose();\n            this._voxelGridYaxis?.dispose();\n            this._combinedVoxelGridPT?.dispose();\n        }\n        this._voxelGridZaxis?.dispose();\n        for (const mip of this._mipArray) {\n            mip.dispose();\n        }\n        this._voxelMaterial?.dispose();\n        this._voxelSlabDebugMaterial?.dispose();\n        this._mipArray = [];\n        this._voxelMrtsXaxis = [];\n        this._voxelMrtsYaxis = [];\n        this._voxelMrtsZaxis = [];\n    }\n    _createVoxelMaterials() {\n        const isWebGPU = this._engine.isWebGPU;\n        this._voxelMaterial = new ShaderMaterial(\"voxelization\", this._scene, \"iblVoxelGrid\", {\n            uniforms: [\"world\", \"viewMatrix\", \"invTransWorld\", \"invWorldScale\", \"nearPlane\", \"farPlane\", \"stepSize\"],\n            defines: [\"MAX_DRAW_BUFFERS \" + this._maxDrawBuffers],\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblVoxelGrid.fragment\"), import(\"../../ShadersWGSL/iblVoxelGrid.vertex\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblVoxelGrid.fragment\"), import(\"../../Shaders/iblVoxelGrid.vertex\")]);\n                }\n            },\n        });\n        this._voxelMaterial.cullBackFaces = false;\n        this._voxelMaterial.backFaceCulling = false;\n        this._voxelMaterial.depthFunction = Engine.ALWAYS;\n        this._voxelSlabDebugMaterial = new ShaderMaterial(\"voxelSlabDebug\", this._scene, \"iblVoxelSlabDebug\", {\n            uniforms: [\"world\", \"viewMatrix\", \"cameraViewMatrix\", \"projection\", \"invWorldScale\", \"nearPlane\", \"farPlane\", \"stepSize\"],\n            defines: [\"MAX_DRAW_BUFFERS \" + this._maxDrawBuffers],\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblVoxelSlabDebug.fragment\"), import(\"../../ShadersWGSL/iblVoxelSlabDebug.vertex\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblVoxelSlabDebug.fragment\"), import(\"../../Shaders/iblVoxelSlabDebug.vertex\")]);\n                }\n            },\n        });\n    }\n    _setDebugBindings() {\n        this._voxelSlabDebugMaterial.setMatrix(\"projection\", this._scene.activeCamera.getProjectionMatrix());\n        this._voxelSlabDebugMaterial.setMatrix(\"cameraViewMatrix\", this._scene.activeCamera.getViewMatrix());\n    }\n    /**\n     * Checks if the voxel renderer is ready to voxelize scene\n     * @returns true if the voxel renderer is ready to voxelize scene\n     */\n    isReady() {\n        let allReady = this.getVoxelGrid().isReady();\n        for (let i = 0; i < this._mipArray.length; i++) {\n            const mipReady = this._mipArray[i].isReady();\n            allReady &&= mipReady;\n        }\n        if (!allReady || this._voxelizationInProgress) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * If the MRT's are already in the list of render targets, this will\n     * remove them so that they don't get rendered again.\n     */\n    _stopVoxelization() {\n        // If the MRT's are already in the list of render targets, remove them.\n        this._removeVoxelRTs(this._voxelMrtsXaxis);\n        this._removeVoxelRTs(this._voxelMrtsYaxis);\n        this._removeVoxelRTs(this._voxelMrtsZaxis);\n        this._removeVoxelRTs([this._voxelGridRT]);\n    }\n    _removeVoxelRTs(rts) {\n        // const currentRTs = this._scene.customRenderTargets;\n        const rtIdx = this._renderTargets.findIndex((rt) => {\n            if (rt === rts[0]) {\n                return true;\n            }\n            return false;\n        });\n        if (rtIdx >= 0) {\n            this._renderTargets.splice(rtIdx, rts.length);\n        }\n        else {\n            const rtIdx = this._scene.customRenderTargets.findIndex((rt) => {\n                if (rt === rts[0]) {\n                    return true;\n                }\n                return false;\n            });\n            if (rtIdx >= 0) {\n                this._scene.customRenderTargets.splice(rtIdx, rts.length);\n            }\n        }\n    }\n    /**\n     * Renders voxel grid of scene for IBL shadows\n     * @param includedMeshes\n     */\n    updateVoxelGrid(includedMeshes) {\n        if (this._voxelizationInProgress) {\n            return;\n        }\n        this._stopVoxelization();\n        this._includedMeshes = includedMeshes;\n        this._voxelizationInProgress = true;\n        if (this._engine.isWebGPU) {\n            this._voxelGridRT.renderList = includedMeshes;\n            this._addRTsForRender([this._voxelGridRT], includedMeshes, 0);\n        }\n        else if (this._triPlanarVoxelization) {\n            this._addRTsForRender(this._voxelMrtsXaxis, includedMeshes, 0);\n            this._addRTsForRender(this._voxelMrtsYaxis, includedMeshes, 1);\n            this._addRTsForRender(this._voxelMrtsZaxis, includedMeshes, 2);\n        }\n        else {\n            this._addRTsForRender(this._voxelMrtsZaxis, includedMeshes, 2);\n        }\n        if (this._voxelDebugEnabled) {\n            this._addRTsForRender([this._voxelSlabDebugRT], includedMeshes, this._voxelDebugAxis, 1, true);\n        }\n        this._renderVoxelGridBound = this._renderVoxelGrid.bind(this);\n        this._scene.onAfterRenderObservable.add(this._renderVoxelGridBound);\n    }\n    _renderVoxelGrid() {\n        if (this._voxelizationInProgress) {\n            let allReady = this.getVoxelGrid().isReady();\n            for (let i = 0; i < this._mipArray.length; i++) {\n                const mipReady = this._mipArray[i].isReady();\n                allReady &&= mipReady;\n            }\n            for (let i = 0; i < this._renderTargets.length; i++) {\n                const rttReady = this._renderTargets[i].isReadyForRendering();\n                allReady &&= rttReady;\n            }\n            if (allReady) {\n                if (this._engine.isWebGPU) {\n                    // Clear the voxel grid storage texture.\n                    // Need to clear each layer individually.\n                    // Would a compute shader be faster here to clear all layers in one go?\n                    if (this._voxelGrid && this._voxelGrid.renderTarget) {\n                        for (let layer = 0; layer < this._voxelResolution; layer++) {\n                            this._engine.bindFramebuffer(this._voxelGrid.renderTarget, 0, undefined, undefined, true, 0, layer);\n                            this._engine.clear(this._voxelClearColor, true, false, false);\n                            this._engine.unBindFramebuffer(this._voxelGrid.renderTarget, true);\n                        }\n                    }\n                }\n                for (const rt of this._renderTargets) {\n                    rt.render();\n                }\n                this._stopVoxelization();\n                if (this._triPlanarVoxelization && !this._engine.isWebGPU) {\n                    this._combinedVoxelGridPT.render();\n                }\n                this._generateMipMaps();\n                // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\n                this._copyMipEffectWrapper.effect.whenCompiledAsync().then(() => {\n                    this._copyMipMaps();\n                    this._scene.onAfterRenderObservable.removeCallback(this._renderVoxelGridBound);\n                    this._voxelizationInProgress = false;\n                    this.onVoxelizationCompleteObservable.notifyObservers();\n                });\n            }\n        }\n    }\n    _addRTsForRender(mrts, includedMeshes, axis, shaderType = 0, continuousRender = false) {\n        const slabSize = 1.0 / this._computeNumberOfSlabs();\n        let voxelMaterial;\n        if (shaderType === 0) {\n            voxelMaterial = this._voxelMaterial;\n        }\n        else {\n            voxelMaterial = this._voxelSlabDebugMaterial;\n        }\n        // We need to update the world scale uniform for every mesh being rendered to the voxel grid.\n        for (let mrtIndex = 0; mrtIndex < mrts.length; mrtIndex++) {\n            const mrt = mrts[mrtIndex];\n            mrt.renderList = [];\n            const nearPlane = mrtIndex * slabSize;\n            const farPlane = (mrtIndex + 1) * slabSize;\n            const stepSize = slabSize / this._maxDrawBuffers;\n            const cameraPosition = new Vector3(0, 0, 0);\n            let targetPosition = new Vector3(0, 0, 1);\n            if (axis === 0) {\n                targetPosition = new Vector3(1, 0, 0);\n            }\n            else if (axis === 1) {\n                targetPosition = new Vector3(0, 1, 0);\n            }\n            let upDirection = new Vector3(0, 1, 0);\n            if (axis === 1) {\n                upDirection = new Vector3(1, 0, 0);\n            }\n            mrt.onBeforeRenderObservable.clear();\n            mrt.onBeforeRenderObservable.add(() => {\n                voxelMaterial.setMatrix(\"viewMatrix\", Matrix.LookAtLH(cameraPosition, targetPosition, upDirection));\n                voxelMaterial.setMatrix(\"invWorldScale\", this._invWorldScaleMatrix);\n                voxelMaterial.setFloat(\"nearPlane\", nearPlane);\n                voxelMaterial.setFloat(\"farPlane\", farPlane);\n                voxelMaterial.setFloat(\"stepSize\", stepSize);\n                if (this._engine.isWebGPU) {\n                    this._voxelMaterial.useVertexPulling = true;\n                    this._voxelMaterial.setTexture(\"voxel_storage\", this.getVoxelGrid());\n                }\n            });\n            // Set this material on every mesh in the scene (for this RT)\n            if (includedMeshes.length === 0) {\n                return;\n            }\n            for (const mesh of includedMeshes) {\n                if (mesh) {\n                    if (mesh.subMeshes && mesh.subMeshes.length > 0) {\n                        mrt.renderList?.push(mesh);\n                        mrt.setMaterialForRendering(mesh, voxelMaterial);\n                    }\n                    const meshes = mesh.getChildMeshes();\n                    for (const childMesh of meshes) {\n                        if (childMesh.subMeshes && childMesh.subMeshes.length > 0) {\n                            mrt.renderList?.push(childMesh);\n                            mrt.setMaterialForRendering(childMesh, voxelMaterial);\n                        }\n                    }\n                }\n            }\n        }\n        // Add the MRT's to render.\n        if (continuousRender) {\n            for (const mrt of mrts) {\n                if (this._scene.customRenderTargets.indexOf(mrt) === -1) {\n                    this._scene.customRenderTargets.push(mrt);\n                }\n            }\n        }\n        else {\n            this._renderTargets = this._renderTargets.concat(mrts);\n        }\n    }\n    /**\n     * Called by the pipeline to resize resources.\n     */\n    resize() {\n        this._voxelSlabDebugRT?.resize({ width: this._scene.getEngine().getRenderWidth(), height: this._scene.getEngine().getRenderHeight() });\n    }\n    /**\n     * Disposes the voxel renderer and associated resources\n     */\n    dispose() {\n        this._disposeVoxelTextures();\n        if (this._voxelSlabDebugRT) {\n            this._removeVoxelRTs([this._voxelSlabDebugRT]);\n            this._voxelSlabDebugRT.dispose();\n        }\n        if (this._voxelDebugPass) {\n            this._voxelDebugPass.dispose();\n        }\n        // TODO - dispose all created voxel materials.\n    }\n}\n//# sourceMappingURL=iblShadowsVoxelRenderer.js.map","import { Constants } from \"../../Engines/constants\";\nimport { Matrix, Vector4 } from \"../../Maths/math.vector\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer\";\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\nimport { Logger } from \"../../Misc/logger\";\n/**\n * Build cdf maps for IBL importance sampling during IBL shadow computation.\n * This should not be instantiated directly, as it is part of a scene component\n * @internal\n */\nexport class _IblShadowsVoxelTracingPass {\n    /**\n     * The opacity of the shadow cast from the voxel grid\n     */\n    get voxelShadowOpacity() {\n        return this._voxelShadowOpacity;\n    }\n    /**\n     * The opacity of the shadow cast from the voxel grid\n     */\n    set voxelShadowOpacity(value) {\n        this._voxelShadowOpacity = value;\n    }\n    /**\n     * The opacity of the screen-space shadow\n     */\n    get ssShadowOpacity() {\n        return this._ssShadowOpacity;\n    }\n    /**\n     * The opacity of the screen-space shadow\n     */\n    set ssShadowOpacity(value) {\n        this._ssShadowOpacity = value;\n    }\n    /**\n     * The number of samples used in the screen space shadow pass.\n     */\n    get sssSamples() {\n        return this._sssSamples;\n    }\n    /**\n     * The number of samples used in the screen space shadow pass.\n     */\n    set sssSamples(value) {\n        this._sssSamples = value;\n    }\n    /**\n     * The stride used in the screen space shadow pass. This controls the distance between samples.\n     */\n    get sssStride() {\n        return this._sssStride;\n    }\n    /**\n     * The stride used in the screen space shadow pass. This controls the distance between samples.\n     */\n    set sssStride(value) {\n        this._sssStride = value;\n    }\n    /**\n     * The maximum distance that the screen-space shadow will be able to occlude.\n     */\n    get sssMaxDist() {\n        return this._sssMaxDist;\n    }\n    /**\n     * The maximum distance that the screen-space shadow will be able to occlude.\n     */\n    set sssMaxDist(value) {\n        this._sssMaxDist = value;\n    }\n    /**\n     * The thickness of the screen-space shadow\n     */\n    get sssThickness() {\n        return this._sssThickness;\n    }\n    /**\n     * The thickness of the screen-space shadow\n     */\n    set sssThickness(value) {\n        this._sssThickness = value;\n    }\n    /**\n     * The bias to apply to the voxel sampling in the direction of the surface normal of the geometry.\n     */\n    get voxelNormalBias() {\n        return this._voxelNormalBias;\n    }\n    set voxelNormalBias(value) {\n        this._voxelNormalBias = value;\n    }\n    /**\n     * The bias to apply to the voxel sampling in the direction of the light.\n     */\n    get voxelDirectionBias() {\n        return this._voxelDirectionBias;\n    }\n    set voxelDirectionBias(value) {\n        this._voxelDirectionBias = value;\n    }\n    /**\n     * The number of directions to sample for the voxel tracing.\n     */\n    get sampleDirections() {\n        return this._sampleDirections;\n    }\n    /**\n     * The number of directions to sample for the voxel tracing.\n     */\n    set sampleDirections(value) {\n        this._sampleDirections = value;\n    }\n    /**\n     * The current rotation of the environment map, in radians.\n     */\n    get envRotation() {\n        return this._envRotation;\n    }\n    /**\n     * The current rotation of the environment map, in radians.\n     */\n    set envRotation(value) {\n        this._envRotation = value;\n    }\n    /**\n     * Returns the output texture of the pass.\n     * @returns The output texture.\n     */\n    getOutputTexture() {\n        return this._outputTexture;\n    }\n    /**\n     * Gets the debug pass post process. This will create the resources for the pass\n     * if they don't already exist.\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPassPP) {\n            this._createDebugPass();\n        }\n        return this._debugPassPP;\n    }\n    /**\n     * The name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * Set the matrix to use for scaling the world space to voxel space\n     * @param matrix The matrix to use for scaling the world space to voxel space\n     */\n    setWorldScaleMatrix(matrix) {\n        this._invWorldScaleMatrix = matrix;\n    }\n    /**\n     * Render the shadows in color rather than black and white.\n     * This is slightly more expensive than black and white shadows but can be much\n     * more accurate when the strongest lights in the IBL are non-white.\n     */\n    set coloredShadows(value) {\n        this._coloredShadows = value;\n    }\n    get coloredShadows() {\n        return this._coloredShadows;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        const isWebGPU = this._engine.isWebGPU;\n        if (!this._debugPassPP) {\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                uniforms: [\"sizeParams\"],\n                samplers: [\"debugSampler\"],\n                engine: this._engine,\n                reusable: true,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment\"));\n                    }\n                },\n            };\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\n            this._debugPassPP.autoClear = false;\n            this._debugPassPP.onApplyObservable.add((effect) => {\n                // update the caustic texture with what we just rendered.\n                effect.setTexture(\"debugSampler\", this._outputTexture);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n            });\n        }\n    }\n    /**\n     * Instantiates the shadow voxel-tracing pass\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\n     * @returns The shadow voxel-tracing pass\n     */\n    constructor(scene, iblShadowsRenderPipeline) {\n        this._voxelShadowOpacity = 1.0;\n        this._sssSamples = 16;\n        this._sssStride = 8;\n        this._sssMaxDist = 0.05;\n        this._sssThickness = 0.5;\n        this._ssShadowOpacity = 1.0;\n        this._cameraInvView = Matrix.Identity();\n        this._cameraInvProj = Matrix.Identity();\n        this._invWorldScaleMatrix = Matrix.Identity();\n        this._frameId = 0;\n        this._sampleDirections = 4;\n        this._shadowParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._sssParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._opacityParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._voxelBiasParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._voxelNormalBias = 1.4;\n        this._voxelDirectionBias = 1.75;\n        /**\n         * Is the effect enabled\n         */\n        this.enabled = true;\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        this._debugPassName = \"Voxel Tracing Debug Pass\";\n        /** The default rotation of the environment map will align the shadows with the default lighting orientation */\n        this._envRotation = 0.0;\n        this._coloredShadows = false;\n        this._debugVoxelMarchEnabled = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._renderWhenGBufferReady = null;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._renderPipeline = iblShadowsRenderPipeline;\n        this._createTextures();\n    }\n    _createTextures() {\n        const defines = this._createDefines();\n        const isWebGPU = this._engine.isWebGPU;\n        const textureOptions = {\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowVoxelTracing.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblShadowVoxelTracing.fragment\")]);\n                }\n            },\n        };\n        this._outputTexture = new ProceduralTexture(\"voxelTracingPass\", {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        }, \"iblShadowVoxelTracing\", this._scene, textureOptions);\n        this._outputTexture.refreshRate = -1;\n        this._outputTexture.autoClear = false;\n        this._outputTexture.defines = defines;\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\n        this._setBindings(this._scene.activeCamera);\n        this._renderWhenGBufferReady = this._render.bind(this);\n        // Don't start rendering until the first vozelization is done.\n        this._renderPipeline.onVoxelizationCompleteObservable.addOnce(() => {\n            this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady);\n        });\n    }\n    _createDefines() {\n        let defines = \"\";\n        if (this._scene.useRightHandedSystem) {\n            defines += \"#define RIGHT_HANDED\\n\";\n        }\n        if (this._debugVoxelMarchEnabled) {\n            defines += \"#define VOXEL_MARCH_DIAGNOSTIC_INFO_OPTION 1u\\n\";\n        }\n        if (this._coloredShadows) {\n            defines += \"#define COLOR_SHADOWS 1u\\n\";\n        }\n        return defines;\n    }\n    _setBindings(camera) {\n        this._outputTexture.defines = this._createDefines();\n        this._outputTexture.setMatrix(\"viewMtx\", camera.getViewMatrix());\n        this._outputTexture.setMatrix(\"projMtx\", camera.getProjectionMatrix());\n        camera.getProjectionMatrix().invertToRef(this._cameraInvProj);\n        camera.getViewMatrix().invertToRef(this._cameraInvView);\n        this._outputTexture.setMatrix(\"invProjMtx\", this._cameraInvProj);\n        this._outputTexture.setMatrix(\"invViewMtx\", this._cameraInvView);\n        this._outputTexture.setMatrix(\"wsNormalizationMtx\", this._invWorldScaleMatrix);\n        this._frameId++;\n        let rotation = 0.0;\n        if (this._scene.environmentTexture) {\n            rotation = this._scene.environmentTexture.rotationY ?? 0;\n        }\n        rotation = this._scene.useRightHandedSystem ? -(rotation + 0.5 * Math.PI) : rotation - 0.5 * Math.PI;\n        rotation = rotation % (2.0 * Math.PI);\n        this._shadowParameters.set(this._sampleDirections, this._frameId, 1.0, rotation);\n        this._outputTexture.setVector4(\"shadowParameters\", this._shadowParameters);\n        const voxelGrid = this._renderPipeline._getVoxelGridTexture();\n        const highestMip = Math.floor(Math.log2(voxelGrid.getSize().width));\n        this._voxelBiasParameters.set(this._voxelNormalBias, this._voxelDirectionBias, highestMip, 0.0);\n        this._outputTexture.setVector4(\"voxelBiasParameters\", this._voxelBiasParameters);\n        // SSS Options.\n        this._sssParameters.set(this._sssSamples, this._sssStride, this._sssMaxDist, this._sssThickness);\n        this._outputTexture.setVector4(\"sssParameters\", this._sssParameters);\n        this._opacityParameters.set(this._voxelShadowOpacity, this._ssShadowOpacity, 0.0, 0.0);\n        this._outputTexture.setVector4(\"shadowOpacity\", this._opacityParameters);\n        this._outputTexture.setTexture(\"voxelGridSampler\", voxelGrid);\n        this._outputTexture.setTexture(\"blueNoiseSampler\", this._renderPipeline._getNoiseTexture());\n        const cdfGenerator = this._scene.iblCdfGenerator;\n        if (!cdfGenerator) {\n            Logger.Warn(\"IBLShadowsVoxelTracingPass: Can't bind for render because iblCdfGenerator is not enabled.\");\n            return false;\n        }\n        this._outputTexture.setTexture(\"icdfSampler\", cdfGenerator.getIcdfTexture());\n        if (this._coloredShadows && this._scene.environmentTexture) {\n            this._outputTexture.setTexture(\"iblSampler\", this._scene.environmentTexture);\n        }\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        if (!geometryBufferRenderer) {\n            Logger.Warn(\"IBLShadowsVoxelTracingPass: Can't bind for render because GeometryBufferRenderer is not enabled.\");\n            return false;\n        }\n        const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n        const wnormalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"worldNormalSampler\", geometryBufferRenderer.getGBuffer().textures[wnormalIndex]);\n        return true;\n    }\n    _render() {\n        if (this.enabled && this._outputTexture.isReady() && this._outputTexture.getEffect()?.isReady()) {\n            if (this._setBindings(this._scene.activeCamera)) {\n                this._outputTexture.render();\n            }\n        }\n    }\n    /**\n     * Called by render pipeline when canvas resized.\n     * @param scaleFactor The factor by which to scale the canvas size.\n     */\n    resize(scaleFactor = 1.0) {\n        const newSize = {\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\n        };\n        // Don't resize if the size is the same as the current size.\n        if (this._outputTexture.getSize().width === newSize.width && this._outputTexture.getSize().height === newSize.height) {\n            return;\n        }\n        this._outputTexture.resize(newSize, false);\n    }\n    /**\n     * Checks if the pass is ready\n     * @returns true if the pass is ready\n     */\n    isReady() {\n        return (this._outputTexture.isReady() &&\n            !(this._debugPassPP && !this._debugPassPP.isReady()) &&\n            this._scene.iblCdfGenerator &&\n            this._scene.iblCdfGenerator.getIcdfTexture().isReady() &&\n            this._renderPipeline._getVoxelGridTexture().isReady());\n    }\n    /**\n     * Disposes the associated resources\n     */\n    dispose() {\n        if (this._scene.geometryBufferRenderer && this._renderWhenGBufferReady) {\n            const gBuffer = this._scene.geometryBufferRenderer.getGBuffer();\n            gBuffer.onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady);\n        }\n        this._outputTexture.dispose();\n        if (this._debugPassPP) {\n            this._debugPassPP.dispose();\n        }\n    }\n}\n//# sourceMappingURL=iblShadowsVoxelTracingPass.js.map","import { Constants } from \"../../Engines/constants\";\nimport { Vector4 } from \"../../Maths/math.vector\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer\";\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\n/**\n * This should not be instanciated directly, as it is part of a scene component\n * @internal\n */\nexport class _IblShadowsSpatialBlurPass {\n    /**\n     * Returns the output texture of the pass.\n     * @returns The output texture.\n     */\n    getOutputTexture() {\n        return this._outputTexture;\n    }\n    /**\n     * Gets the debug pass post process\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPassPP) {\n            this._createDebugPass();\n        }\n        return this._debugPassPP;\n    }\n    /**\n     * Sets the name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * The scale of the voxel grid in world space. This is used to scale the blur radius in world space.\n     * @param scale The scale of the voxel grid in world space.\n     */\n    setWorldScale(scale) {\n        this._worldScale = scale;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        if (!this._debugPassPP) {\n            const isWebGPU = this._engine.isWebGPU;\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                textureFormat: Constants.TEXTUREFORMAT_RGBA,\n                textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                uniforms: [\"sizeParams\"],\n                samplers: [\"debugSampler\"],\n                engine: this._engine,\n                reusable: false,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment\"));\n                    }\n                },\n            };\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\n            this._debugPassPP.autoClear = false;\n            this._debugPassPP.onApplyObservable.add((effect) => {\n                // update the caustic texture with what we just rendered.\n                effect.setTexture(\"debugSampler\", this._outputTexture);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n            });\n        }\n    }\n    /**\n     * Instanciates the importance sampling renderer\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\n     * @returns The importance sampling renderer\n     */\n    constructor(scene, iblShadowsRenderPipeline) {\n        this._worldScale = 1.0;\n        this._blurParameters = new Vector4(0.0, 0.0, 0.0, 0.0);\n        /**\n         * Is the effect enabled\n         */\n        this.enabled = true;\n        this._debugPassName = \"Spatial Blur Debug Pass\";\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._renderWhenGBufferReady = null;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._renderPipeline = iblShadowsRenderPipeline;\n        this._createTextures();\n    }\n    _createTextures() {\n        const isWebGPU = this._engine.isWebGPU;\n        const textureOptions = {\n            type: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowSpatialBlur.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblShadowSpatialBlur.fragment\")]);\n                }\n            },\n        };\n        this._outputTexture = new ProceduralTexture(\"spatialBlurPass\", {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        }, \"iblShadowSpatialBlur\", this._scene, textureOptions, false, false, Constants.TEXTURETYPE_UNSIGNED_BYTE);\n        this._outputTexture.refreshRate = -1;\n        this._outputTexture.autoClear = false;\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\n        this._setBindings();\n        this._renderWhenGBufferReady = this._render.bind(this);\n        // Don't start rendering until the first vozelization is done.\n        this._renderPipeline.onVoxelizationCompleteObservable.addOnce(() => {\n            this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady);\n        });\n    }\n    _setBindings() {\n        this._outputTexture.setTexture(\"voxelTracingSampler\", this._renderPipeline._getVoxelTracingTexture());\n        const iterationCount = 1;\n        this._blurParameters.set(iterationCount, this._worldScale, 0.0, 0.0);\n        this._outputTexture.setVector4(\"blurParameters\", this._blurParameters);\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        if (!geometryBufferRenderer) {\n            return false;\n        }\n        const depthIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"depthSampler\", geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n        const wnormalIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"worldNormalSampler\", geometryBufferRenderer.getGBuffer().textures[wnormalIndex]);\n        return true;\n    }\n    _render() {\n        if (this.enabled && this._outputTexture.isReady() && this._outputTexture.getEffect()?.isReady()) {\n            if (this._setBindings()) {\n                this._outputTexture.render();\n            }\n        }\n    }\n    /**\n     * Called by render pipeline when canvas resized.\n     * @param scaleFactor The factor by which to scale the canvas size.\n     */\n    resize(scaleFactor = 1.0) {\n        const newSize = {\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\n        };\n        // Don't resize if the size is the same as the current size.\n        if (this._outputTexture.getSize().width === newSize.width && this._outputTexture.getSize().height === newSize.height) {\n            return;\n        }\n        this._outputTexture.resize(newSize, false);\n    }\n    /**\n     * Checks if the pass is ready\n     * @returns true if the pass is ready\n     */\n    isReady() {\n        return this._outputTexture.isReady() && !(this._debugPassPP && !this._debugPassPP.isReady());\n    }\n    /**\n     * Disposes the associated resources\n     */\n    dispose() {\n        if (this._scene.geometryBufferRenderer && this._renderWhenGBufferReady) {\n            const gBuffer = this._scene.geometryBufferRenderer.getGBuffer();\n            gBuffer.onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady);\n        }\n        this._outputTexture.dispose();\n        if (this._debugPassPP) {\n            this._debugPassPP.dispose();\n        }\n    }\n}\n//# sourceMappingURL=iblShadowsSpatialBlurPass.js.map","import { Constants } from \"../../Engines/constants\";\nimport { Vector4 } from \"../../Maths/math.vector\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { GeometryBufferRenderer } from \"../../Rendering/geometryBufferRenderer\";\nimport { ProceduralTexture } from \"core/Materials/Textures/Procedurals/proceduralTexture\";\nimport { Observable } from \"../../Misc/observable\";\n/**\n * This should not be instantiated directly, as it is part of a scene component\n * @internal\n */\nexport class _IblShadowsAccumulationPass {\n    /**\n     * Returns the output texture of the pass.\n     * @returns The output texture.\n     */\n    getOutputTexture() {\n        return this._outputTexture;\n    }\n    /**\n     * Gets the debug pass post process\n     * @returns The post process\n     */\n    getDebugPassPP() {\n        if (!this._debugPassPP) {\n            this._createDebugPass();\n        }\n        return this._debugPassPP;\n    }\n    /**\n     * Gets the name of the debug pass\n     * @returns The name of the debug pass\n     */\n    get debugPassName() {\n        return this._debugPassName;\n    }\n    /**\n     * A value that controls how much of the previous frame's accumulation to keep.\n     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.\n     */\n    get remanence() {\n        return this._remanence;\n    }\n    /**\n     * A value that controls how much of the previous frame's accumulation to keep.\n     * The higher the value, the faster the shadows accumulate but the more potential ghosting you'll see.\n     */\n    set remanence(value) {\n        this._remanence = value;\n    }\n    /**\n     * Reset the accumulation.\n     */\n    get reset() {\n        return this._reset;\n    }\n    /**\n     * Reset the accumulation.\n     */\n    set reset(value) {\n        this._reset = value;\n    }\n    /**\n     * Tell the pass that the camera is moving. This will cause the accumulation\n     * rate to change.\n     */\n    set isMoving(value) {\n        this._isMoving = value;\n    }\n    /**\n     * Sets params that control the position and scaling of the debug display on the screen.\n     * @param x Screen X offset of the debug display (0-1)\n     * @param y Screen Y offset of the debug display (0-1)\n     * @param widthScale X scale of the debug display (0-1)\n     * @param heightScale Y scale of the debug display (0-1)\n     */\n    setDebugDisplayParams(x, y, widthScale, heightScale) {\n        this._debugSizeParams.set(x, y, widthScale, heightScale);\n    }\n    /**\n     * Creates the debug post process effect for this pass\n     */\n    _createDebugPass() {\n        if (!this._debugPassPP) {\n            const isWebGPU = this._engine.isWebGPU;\n            const debugOptions = {\n                width: this._engine.getRenderWidth(),\n                height: this._engine.getRenderHeight(),\n                textureFormat: Constants.TEXTUREFORMAT_RGBA,\n                textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n                samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n                uniforms: [\"sizeParams\"],\n                samplers: [\"debugSampler\"],\n                engine: this._engine,\n                reusable: false,\n                shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n                extraInitializations: (useWebGPU, list) => {\n                    if (useWebGPU) {\n                        list.push(import(\"../../ShadersWGSL/iblShadowDebug.fragment\"));\n                    }\n                    else {\n                        list.push(import(\"../../Shaders/iblShadowDebug.fragment\"));\n                    }\n                },\n            };\n            this._debugPassPP = new PostProcess(this.debugPassName, \"iblShadowDebug\", debugOptions);\n            this._debugPassPP.autoClear = false;\n            this._debugPassPP.onApplyObservable.add((effect) => {\n                // update the caustic texture with what we just rendered.\n                effect.setTexture(\"debugSampler\", this._outputTexture);\n                effect.setVector4(\"sizeParams\", this._debugSizeParams);\n            });\n        }\n    }\n    /**\n     * Instantiates the accumulation pass\n     * @param scene Scene to attach to\n     * @param iblShadowsRenderPipeline The IBL shadows render pipeline\n     * @returns The accumulation pass\n     */\n    constructor(scene, iblShadowsRenderPipeline) {\n        this._accumulationParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        /** Enable the debug view for this pass */\n        this.debugEnabled = false;\n        /**\n         * Is the effect enabled\n         */\n        this.enabled = true;\n        /**\n         * Observable that triggers when the accumulation texture is ready\n         */\n        this.onReadyObservable = new Observable();\n        this._debugPassName = \"Shadow Accumulation Debug Pass\";\n        this._remanence = 0.9;\n        this._reset = true;\n        this._isMoving = false;\n        this._debugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this._renderWhenGBufferReady = null;\n        this._scene = scene;\n        this._engine = scene.getEngine();\n        this._renderPipeline = iblShadowsRenderPipeline;\n        this._createTextures();\n    }\n    _createTextures() {\n        const isWebGPU = this._engine.isWebGPU;\n        const outputTextureOptions = {\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/iblShadowAccumulation.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/iblShadowAccumulation.fragment\")]);\n                }\n            },\n        };\n        this._outputTexture = new ProceduralTexture(\"shadowAccumulationPass\", {\n            width: this._engine.getRenderWidth(),\n            height: this._engine.getRenderHeight(),\n        }, \"iblShadowAccumulation\", this._scene, outputTextureOptions);\n        this._outputTexture.refreshRate = 1;\n        this._outputTexture.autoClear = false;\n        this._outputTexture.onGeneratedObservable.addOnce(() => {\n            this.onReadyObservable.notifyObservers();\n        });\n        // Need to set all the textures first so that the effect gets created with the proper uniforms.\n        this._setOutputTextureBindings();\n        this._renderWhenGBufferReady = this._render.bind(this);\n        // Don't start rendering until the first vozelization is done.\n        this._renderPipeline.onVoxelizationCompleteObservable.addOnce(() => {\n            this._scene.geometryBufferRenderer.getGBuffer().onAfterRenderObservable.add(this._renderWhenGBufferReady);\n        });\n        // Create the accumulation texture for the previous frame.\n        // We'll copy the output of the accumulation pass to this texture at the start of every frame.\n        const accumulationOptions = {\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/pass.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/pass.fragment\")]);\n                }\n            },\n        };\n        this._oldAccumulationCopy = new ProceduralTexture(\"oldAccumulationRT\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, \"pass\", this._scene, accumulationOptions, false);\n        this._oldAccumulationCopy.autoClear = false;\n        this._oldAccumulationCopy.refreshRate = 1;\n        this._oldAccumulationCopy.onBeforeGenerationObservable.add(this._setAccumulationCopyBindings.bind(this));\n        this._setAccumulationCopyBindings();\n        // Create the local position texture for the previous frame.\n        // We'll copy the previous local position texture to this texture at the start of every frame.\n        const localPositionOptions = {\n            type: Constants.TEXTURETYPE_HALF_FLOAT,\n            format: Constants.TEXTUREFORMAT_RGBA,\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            generateDepthBuffer: false,\n            generateMipMaps: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializationsAsync: async () => {\n                if (isWebGPU) {\n                    await Promise.all([import(\"../../ShadersWGSL/pass.fragment\")]);\n                }\n                else {\n                    await Promise.all([import(\"../../Shaders/pass.fragment\")]);\n                }\n            },\n        };\n        this._oldPositionCopy = new ProceduralTexture(\"oldLocalPositionRT\", { width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, \"pass\", this._scene, localPositionOptions, false);\n        this._updatePositionCopy();\n        this._oldPositionCopy.autoClear = false;\n        this._oldPositionCopy.refreshRate = 1;\n        this._oldPositionCopy.onBeforeGenerationObservable.add(this._updatePositionCopy.bind(this));\n    }\n    _setOutputTextureBindings() {\n        const remanence = this._isMoving ? this.remanence : 0.99;\n        this._accumulationParams.set(remanence, this.reset ? 1.0 : 0.0, this._renderPipeline.voxelGridSize, 0.0);\n        this._outputTexture.setTexture(\"spatialBlurSampler\", this._renderPipeline._getSpatialBlurTexture());\n        this._outputTexture.setVector4(\"accumulationParameters\", this._accumulationParams);\n        this._outputTexture.setTexture(\"oldAccumulationSampler\", this._oldAccumulationCopy ? this._oldAccumulationCopy : this._renderPipeline._dummyTexture2d);\n        this._outputTexture.setTexture(\"prevPositionSampler\", this._oldPositionCopy ? this._oldPositionCopy : this._renderPipeline._dummyTexture2d);\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        if (!geometryBufferRenderer) {\n            return false;\n        }\n        const velocityIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"motionSampler\", geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n        const wPositionIndex = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        this._outputTexture.setTexture(\"positionSampler\", geometryBufferRenderer.getGBuffer().textures[wPositionIndex]);\n        this.reset = false;\n        this._isMoving = false;\n        return true;\n    }\n    _updatePositionCopy() {\n        const geometryBufferRenderer = this._scene.geometryBufferRenderer;\n        const index = geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n        this._oldPositionCopy.setTexture(\"textureSampler\", geometryBufferRenderer.getGBuffer().textures[index]);\n    }\n    _setAccumulationCopyBindings() {\n        this._oldAccumulationCopy.setTexture(\"textureSampler\", this._outputTexture);\n    }\n    _render() {\n        if (this.enabled && this._outputTexture.isReady() && this._outputTexture.getEffect()?.isReady()) {\n            if (this._setOutputTextureBindings()) {\n                this._outputTexture.render();\n            }\n        }\n    }\n    /**\n     * Called by render pipeline when canvas resized.\n     * @param scaleFactor The factor by which to scale the canvas size.\n     */\n    resize(scaleFactor = 1.0) {\n        const newSize = {\n            width: Math.max(1.0, Math.floor(this._engine.getRenderWidth() * scaleFactor)),\n            height: Math.max(1.0, Math.floor(this._engine.getRenderHeight() * scaleFactor)),\n        };\n        // Don't resize if the size is the same as the current size.\n        if (this._outputTexture.getSize().width === newSize.width && this._outputTexture.getSize().height === newSize.height) {\n            return;\n        }\n        this._outputTexture.resize(newSize, false);\n        this._oldAccumulationCopy.resize(newSize, false);\n        this._oldPositionCopy.resize({ width: this._engine.getRenderWidth(), height: this._engine.getRenderHeight() }, false);\n        this.reset = true;\n    }\n    _disposeTextures() {\n        this._oldAccumulationCopy.dispose();\n        this._oldPositionCopy.dispose();\n        this._outputTexture.dispose();\n    }\n    /**\n     * Checks if the pass is ready\n     * @returns true if the pass is ready\n     */\n    isReady() {\n        return (this._oldAccumulationCopy &&\n            this._oldAccumulationCopy.isReady() &&\n            this._oldPositionCopy &&\n            this._oldPositionCopy.isReady() &&\n            this._outputTexture.isReady() &&\n            !(this._debugPassPP && !this._debugPassPP.isReady()));\n    }\n    /**\n     * Disposes the associated resources\n     */\n    dispose() {\n        if (this._scene.geometryBufferRenderer && this._renderWhenGBufferReady) {\n            const gBuffer = this._scene.geometryBufferRenderer.getGBuffer();\n            gBuffer.onAfterRenderObservable.removeCallback(this._renderWhenGBufferReady);\n        }\n        this._disposeTextures();\n        if (this._debugPassPP) {\n            this._debugPassPP.dispose();\n        }\n        this.onReadyObservable.clear();\n    }\n}\n//# sourceMappingURL=iblShadowsAccumulationPass.js.map","import { Texture } from \"./texture\";\nimport { Constants } from \"../../Engines/constants\";\n/**\n * Class used to store 3D textures containing user data\n */\nexport class RawTexture3D extends Texture {\n    /**\n     * Gets the width of the texture\n     */\n    get width() {\n        return this._texture ? this._texture.width : 0;\n    }\n    /**\n     * Gets the height of the texture\n     */\n    get height() {\n        return this._texture ? this._texture.height : 0;\n    }\n    /**\n     * Gets the depth of the texture\n     */\n    get depth() {\n        return this._texture ? this._texture.depth : 0;\n    }\n    /**\n     * Create a new RawTexture3D\n     * @param data defines the data of the texture\n     * @param width defines the width of the texture\n     * @param height defines the height of the texture\n     * @param depth defines the depth of the texture\n     * @param format defines the texture format to use\n     * @param scene defines the hosting scene\n     * @param generateMipMaps defines a boolean indicating if mip levels should be generated (true by default)\n     * @param invertY defines if texture must be stored with Y axis inverted\n     * @param samplingMode defines the sampling mode to use (Texture.TRILINEAR_SAMPLINGMODE by default)\n     * @param textureType defines the texture Type (Engine.TEXTURETYPE_UNSIGNED_BYTE, Engine.TEXTURETYPE_FLOAT...)\n     * @param creationFlags specific flags to use when creating the texture (Constants.TEXTURE_CREATIONFLAG_STORAGE for storage textures, for eg)\n     */\n    constructor(data, width, height, depth, \n    /** Gets or sets the texture format to use */\n    format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE, creationFlags) {\n        super(null, scene, !generateMipMaps, invertY);\n        this.format = format;\n        this._texture = scene.getEngine().createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);\n        this.is3D = true;\n    }\n    /**\n     * Update the texture with new data\n     * @param data defines the data to store in the texture\n     */\n    update(data) {\n        if (!this._texture) {\n            return;\n        }\n        this._getEngine().updateRawTexture3D(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);\n    }\n}\n//# sourceMappingURL=rawTexture3D.js.map","import { __decorate } from \"tslib\";\nimport { MaterialDefines } from \"core/Materials/materialDefines\";\nimport { MaterialPluginBase } from \"core/Materials/materialPluginBase\";\nimport { Constants } from \"core/Engines/constants\";\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\nimport { expandToProperty, serialize } from \"core/Misc/decorators\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\n/**\n * @internal\n */\nclass MaterialIBLShadowsRenderDefines extends MaterialDefines {\n    constructor() {\n        super(...arguments);\n        this.RENDER_WITH_IBL_SHADOWS = false;\n        this.COLORED_IBL_SHADOWS = false;\n    }\n}\n/**\n * Plugin used to render the contribution from IBL shadows.\n */\nexport class IBLShadowsPluginMaterial extends MaterialPluginBase {\n    get isColored() {\n        return this._isColored;\n    }\n    set isColored(value) {\n        if (this._isColored === value) {\n            return;\n        }\n        this._isColored = value;\n        this._markAllSubMeshesAsTexturesDirty();\n    }\n    _markAllSubMeshesAsTexturesDirty() {\n        this._enable(this._isEnabled);\n        this._internalMarkAllSubMeshesAsTexturesDirty();\n    }\n    /**\n     * Gets a boolean indicating that the plugin is compatible with a give shader language.\n     * @returns true if the plugin is compatible with the shader language\n     */\n    isCompatible() {\n        return true;\n    }\n    constructor(material) {\n        super(material, IBLShadowsPluginMaterial.Name, 310, new MaterialIBLShadowsRenderDefines());\n        /**\n         * The opacity of the shadows.\n         */\n        this.shadowOpacity = 1.0;\n        this._isEnabled = false;\n        this._isColored = false;\n        /**\n         * Defines if the plugin is enabled in the material.\n         */\n        this.isEnabled = false;\n        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[Constants.MATERIAL_TextureDirtyFlag];\n    }\n    prepareDefines(defines) {\n        defines.RENDER_WITH_IBL_SHADOWS = this._isEnabled;\n        defines.COLORED_IBL_SHADOWS = this.isColored;\n    }\n    getClassName() {\n        return \"IBLShadowsPluginMaterial\";\n    }\n    getUniforms() {\n        return {\n            ubo: [\n                { name: \"renderTargetSize\", size: 2, type: \"vec2\" },\n                { name: \"shadowOpacity\", size: 1, type: \"float\" },\n            ],\n            fragment: `#ifdef RENDER_WITH_IBL_SHADOWS\r\n                    uniform vec2 renderTargetSize;\r\n                    uniform float shadowOpacity;\r\n                #endif`,\n        };\n    }\n    getSamplers(samplers) {\n        samplers.push(\"iblShadowsTexture\");\n    }\n    bindForSubMesh(uniformBuffer) {\n        if (this._isEnabled) {\n            uniformBuffer.bindTexture(\"iblShadowsTexture\", this.iblShadowsTexture);\n            uniformBuffer.updateFloat2(\"renderTargetSize\", this._material.getScene().getEngine().getRenderWidth(), this._material.getScene().getEngine().getRenderHeight());\n            uniformBuffer.updateFloat(\"shadowOpacity\", this.shadowOpacity);\n        }\n    }\n    getCustomCode(shaderType, shaderLanguage) {\n        let frag;\n        if (shaderLanguage === 1 /* ShaderLanguage.WGSL */) {\n            frag = {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    var iblShadowsTextureSampler: sampler;\r\n                    var iblShadowsTexture: texture_2d<f32>;\r\n\r\n                    #ifdef COLORED_IBL_SHADOWS\r\n                        fn computeIndirectShadow() -> vec3f {\r\n                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;\r\n                            var shadowValue: vec3f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rgb;\r\n                            return mix(shadowValue, vec3f(1.0), 1.0 - uniforms.shadowOpacity);\r\n                        }\r\n                    #else\r\n                        fn computeIndirectShadow() -> vec2f {\r\n                            var uv = fragmentInputs.position.xy / uniforms.renderTargetSize;\r\n                            var shadowValue: vec2f = textureSample(iblShadowsTexture, iblShadowsTextureSampler, uv).rg;\r\n                            return mix(shadowValue, vec2f(1.0), 1.0 - uniforms.shadowOpacity);\r\n                        }\r\n                    #endif\r\n                #endif\r\n            `,\n            };\n            if (this._material instanceof PBRBaseMaterial) {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifndef UNLIT\r\n                        #ifdef REFLECTION\r\n                            #ifdef COLORED_IBL_SHADOWS\r\n                                var shadowValue: vec3f = computeIndirectShadow();\r\n                                finalIrradiance *= shadowValue;\r\n                                finalRadianceScaled *= mix(vec3f(1.0), shadowValue, roughness);\r\n                            #else\r\n                                var shadowValue: vec2f = computeIndirectShadow();\r\n                                finalIrradiance *= vec3f(shadowValue.x);\r\n                                finalRadianceScaled *= vec3f(mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness));\r\n                            #endif\r\n                        #endif\r\n                    #else\r\n                        finalDiffuse *= computeIndirectShadow().x;\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n            else if (this._material instanceof OpenPBRMaterial) {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                frag[\"CUSTOM_FRAGMENT_BEFORE_IBLLAYERCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifndef UNLIT\r\n                        #ifdef REFLECTION\r\n                            #ifdef COLORED_IBL_SHADOWS\r\n                                var shadowValue: vec3f = computeIndirectShadow();\r\n                                ambient_occlusion = min(ambient_occlusion, shadowValue);\r\n                            #else\r\n                                var shadowValue: vec2f = computeIndirectShadow();\r\n                                ambient_occlusion = min(ambient_occlusion, vec3f(shadowValue.x));\r\n                                specular_ambient_occlusion = min(specular_ambient_occlusion, pow(shadowValue.y, 4.0));\r\n                            #endif\r\n                        #endif\r\n                    #else\r\n                        ambient_occlusion = min(ambient_occlusion, vec3f(computeIndirectShadow().x));\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n            else {\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifdef COLORED_IBL_SHADOWS\r\n                        var shadowValue: vec3f = computeIndirectShadow();\r\n                        color *= toGammaSpace(vec4f(shadowValue, 1.0f));\r\n                    #else\r\n                        var shadowValue: vec2f = computeIndirectShadow();\r\n                        color *= toGammaSpace(vec4f(shadowValue.x, shadowValue.x, shadowValue.x, 1.0f));\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n        }\n        else {\n            frag = {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                CUSTOM_FRAGMENT_DEFINITIONS: `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    uniform sampler2D iblShadowsTexture;\r\n                #ifdef COLORED_IBL_SHADOWS\r\n                    vec3 computeIndirectShadow() {\r\n                        vec2 uv = gl_FragCoord.xy / renderTargetSize;\r\n                        vec3 shadowValue = texture2D(iblShadowsTexture, uv).rgb;\r\n                        return mix(shadowValue.rgb, vec3(1.0), 1.0 - shadowOpacity);\r\n                    }\r\n                #else\r\n                    vec2 computeIndirectShadow() {\r\n                        vec2 uv = gl_FragCoord.xy / renderTargetSize;\r\n                        vec2 shadowValue = texture2D(iblShadowsTexture, uv).rg;\r\n                        return mix(shadowValue.rg, vec2(1.0), 1.0 - shadowOpacity);\r\n                    }\r\n                #endif\r\n                #endif\r\n            `,\n            };\n            if (this._material instanceof PBRBaseMaterial) {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifndef UNLIT\r\n                        #ifdef REFLECTION\r\n                            #ifdef COLORED_IBL_SHADOWS\r\n                                vec3 shadowValue = computeIndirectShadow();\r\n                                finalIrradiance.rgb *= shadowValue.rgb;\r\n                                finalRadianceScaled *= mix(vec3(1.0), shadowValue.rgb, roughness);\r\n                            #else\r\n                                vec2 shadowValue = computeIndirectShadow();\r\n                                finalIrradiance *= shadowValue.x;\r\n                                finalRadianceScaled *= mix(pow(shadowValue.y, 4.0), shadowValue.x, roughness);\r\n                            #endif\r\n                        #endif\r\n                    #else\r\n                        finalDiffuse *= computeIndirectShadow().x;\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n            else if (this._material instanceof OpenPBRMaterial) {\n                // eslint-disable-next-line @typescript-eslint/naming-convention\n                frag[\"CUSTOM_FRAGMENT_BEFORE_IBLLAYERCOMPOSITION\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifndef UNLIT\r\n                        #ifdef REFLECTION\r\n                            #ifdef COLORED_IBL_SHADOWS\r\n                                vec3 shadowValue = computeIndirectShadow();\r\n                                ambient_occlusion = min(ambient_occlusion, shadowValue);\r\n                            #else\r\n                                vec2 shadowValue = computeIndirectShadow();\r\n                                ambient_occlusion = min(ambient_occlusion, vec3(shadowValue.x));\r\n                                specular_ambient_occlusion = min(specular_ambient_occlusion, pow(shadowValue.y, 4.0));\r\n                            #endif\r\n                        #endif\r\n                    #else\r\n                        ambient_occlusion = min(ambient_occlusion, vec3(computeIndirectShadow().x));\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n            else {\n                frag[\"CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\"] = `\r\n                #ifdef RENDER_WITH_IBL_SHADOWS\r\n                    #ifdef COLORED_IBL_SHADOWS\r\n                        vec3 shadowValue = computeIndirectShadow();\r\n                        color.rgb *= toGammaSpace(shadowValue.rgb);\r\n                    #else\r\n                        vec2 shadowValue = computeIndirectShadow();\r\n                        color.rgb *= toGammaSpace(shadowValue.x);\r\n                    #endif\r\n                #endif\r\n            `;\n            }\n        }\n        return shaderType === \"vertex\" ? null : frag;\n    }\n}\n/**\n * Defines the name of the plugin.\n */\nIBLShadowsPluginMaterial.Name = \"IBLShadowsPluginMaterial\";\n__decorate([\n    serialize()\n], IBLShadowsPluginMaterial.prototype, \"shadowOpacity\", void 0);\n__decorate([\n    serialize(),\n    expandToProperty(\"_markAllSubMeshesAsTexturesDirty\")\n], IBLShadowsPluginMaterial.prototype, \"isEnabled\", void 0);\nRegisterClass(`BABYLON.IBLShadowsPluginMaterial`, IBLShadowsPluginMaterial);\n//# sourceMappingURL=iblShadowsPluginMaterial.js.map","import { Constants } from \"../../Engines/constants\";\nimport { EngineStore } from \"../../Engines/engineStore\";\nimport { Matrix, Vector3, Vector4, Quaternion } from \"../../Maths/math.vector\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { Logger } from \"../../Misc/logger\";\nimport { _IblShadowsVoxelRenderer } from \"./iblShadowsVoxelRenderer\";\nimport { _IblShadowsVoxelTracingPass } from \"./iblShadowsVoxelTracingPass\";\nimport { PostProcess } from \"../../PostProcesses/postProcess\";\nimport { _IblShadowsSpatialBlurPass } from \"./iblShadowsSpatialBlurPass\";\nimport { _IblShadowsAccumulationPass } from \"./iblShadowsAccumulationPass\";\nimport { PostProcessRenderPipeline } from \"../../PostProcesses/RenderPipeline/postProcessRenderPipeline\";\nimport { PostProcessRenderEffect } from \"core/PostProcesses/RenderPipeline/postProcessRenderEffect\";\nimport { GeometryBufferRenderer } from \"core/Rendering/geometryBufferRenderer\";\nimport { RawTexture } from \"core/Materials/Textures/rawTexture\";\nimport { RawTexture3D } from \"core/Materials/Textures/rawTexture3D\";\nimport { Engine } from \"core/Engines/engine\";\nimport { IBLShadowsPluginMaterial } from \"./iblShadowsPluginMaterial\";\nimport { PBRBaseMaterial } from \"core/Materials/PBR/pbrBaseMaterial\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\nimport { Observable } from \"core/Misc/observable\";\nimport \"../geometryBufferRendererSceneComponent\";\nimport \"../iblCdfGeneratorSceneComponent\";\nimport { OpenPBRMaterial } from \"core/Materials/PBR/openpbrMaterial\";\nimport { Tools } from \"../../Misc/tools\";\n/**\n * Voxel-based shadow rendering for IBL's.\n * This should not be instanciated directly, as it is part of a scene component\n */\nexport class IblShadowsRenderPipeline extends PostProcessRenderPipeline {\n    /**\n     * Reset the shadow accumulation. This has a similar affect to lowering the remanence for a single frame.\n     * This is useful when making a sudden change to the IBL.\n     */\n    resetAccumulation() {\n        this._accumulationPass.reset = true;\n    }\n    /**\n     * How dark the shadows appear. 1.0 is full opacity, 0.0 is no shadows.\n     */\n    get shadowOpacity() {\n        return this._shadowOpacity;\n    }\n    set shadowOpacity(value) {\n        this._shadowOpacity = value;\n        this._setPluginParameters();\n    }\n    /**\n     * Render the shadows in color rather than black and white.\n     * This is slightly more expensive than black and white shadows but can be much\n     * more accurate when the strongest lights in the IBL are non-white.\n     */\n    get coloredShadows() {\n        return this._coloredShadows;\n    }\n    set coloredShadows(value) {\n        this._coloredShadows = value;\n        this._voxelTracingPass.coloredShadows = value;\n        this._setPluginParameters();\n    }\n    /**\n     * A multiplier for the render size of the shadows. Used for rendering lower-resolution shadows.\n     */\n    get shadowRenderSizeFactor() {\n        return this._renderSizeFactor;\n    }\n    set shadowRenderSizeFactor(value) {\n        this._renderSizeFactor = Math.max(Math.min(value, 1.0), 0.0);\n        this._voxelTracingPass.resize(value);\n        this._spatialBlurPass.resize(value);\n        this._accumulationPass.resize(value);\n        this._setPluginParameters();\n    }\n    /**\n     * How dark the voxel shadows appear. 1.0 is full opacity, 0.0 is no shadows.\n     */\n    get voxelShadowOpacity() {\n        return this._voxelTracingPass?.voxelShadowOpacity;\n    }\n    set voxelShadowOpacity(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.voxelShadowOpacity = value;\n    }\n    /**\n     * How dark the screen-space shadows appear. 1.0 is full opacity, 0.0 is no shadows.\n     */\n    get ssShadowOpacity() {\n        return this._voxelTracingPass?.ssShadowOpacity;\n    }\n    set ssShadowOpacity(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.ssShadowOpacity = value;\n    }\n    /**\n     * The number of samples used in the screen space shadow pass.\n     */\n    get ssShadowSampleCount() {\n        return this._voxelTracingPass?.sssSamples;\n    }\n    set ssShadowSampleCount(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.sssSamples = value;\n    }\n    /**\n     * The stride of the screen-space shadow pass. This controls the distance between samples\n     * in pixels.\n     */\n    get ssShadowStride() {\n        return this._voxelTracingPass?.sssStride;\n    }\n    set ssShadowStride(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.sssStride = value;\n    }\n    /**\n     * A scale for the maximum distance a screen-space shadow can be cast in world-space.\n     * The maximum distance that screen-space shadows cast is derived from the voxel size\n     * and this value so shouldn't need to change if you scale your scene\n     */\n    get ssShadowDistanceScale() {\n        return this._sssMaxDistScale;\n    }\n    set ssShadowDistanceScale(value) {\n        this._sssMaxDistScale = value;\n        this._updateSsShadowParams();\n    }\n    /**\n     * Screen-space shadow thickness scale. This value controls the assumed thickness of\n     * on-screen surfaces in world-space. It scales with the size of the shadow-casting\n     * region so shouldn't need to change if you scale your scene.\n     */\n    get ssShadowThicknessScale() {\n        return this._sssThicknessScale;\n    }\n    set ssShadowThicknessScale(value) {\n        this._sssThicknessScale = value;\n        this._updateSsShadowParams();\n    }\n    /**\n     * Returns the texture containing the voxel grid data\n     * @returns The texture containing the voxel grid data\n     * @internal\n     */\n    _getVoxelGridTexture() {\n        const tex = this._voxelRenderer?.getVoxelGrid();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture3d;\n    }\n    /**\n     * Returns the noise texture.\n     * @returns The noise texture.\n     * @internal\n     */\n    _getNoiseTexture() {\n        const tex = this._noiseTexture;\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Returns the voxel-tracing texture.\n     * @returns The voxel-tracing texture.\n     * @internal\n     */\n    _getVoxelTracingTexture() {\n        const tex = this._voxelTracingPass?.getOutputTexture();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Returns the spatial blur texture.\n     * @returns The spatial blur texture.\n     * @internal\n     */\n    _getSpatialBlurTexture() {\n        const tex = this._spatialBlurPass.getOutputTexture();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Returns the accumulated shadow texture.\n     * @returns The accumulated shadow texture.\n     * @internal\n     */\n    _getAccumulatedTexture() {\n        const tex = this._accumulationPass?.getOutputTexture();\n        if (tex && tex.isReady()) {\n            return tex;\n        }\n        return this._dummyTexture2d;\n    }\n    /**\n     * Turn on or off the debug view of the G-Buffer. This will display only the targets\n     * of the g-buffer that are used by the shadow pipeline.\n     */\n    get gbufferDebugEnabled() {\n        return this._gbufferDebugEnabled;\n    }\n    set gbufferDebugEnabled(enabled) {\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable G-Buffer debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        this._gbufferDebugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._getGBufferDebugPass().name, this.cameras);\n        }\n        else {\n            this._disableEffect(this._getGBufferDebugPass().name, this.cameras);\n        }\n    }\n    /**\n     * Turn on or off the debug view of the CDF importance sampling data\n     */\n    get cdfDebugEnabled() {\n        return this.scene.iblCdfGenerator ? this.scene.iblCdfGenerator.debugEnabled : false;\n    }\n    /**\n     * Turn on or off the debug view of the CDF importance sampling data\n     */\n    set cdfDebugEnabled(enabled) {\n        if (!this.scene.iblCdfGenerator) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable importance sampling debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this.scene.iblCdfGenerator.debugEnabled) {\n            return;\n        }\n        this.scene.iblCdfGenerator.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this.scene.iblCdfGenerator.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this.scene.iblCdfGenerator.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * This displays the voxel grid in slices spread across the screen.\n     * It also displays what slices of the model are stored in each layer\n     * of the voxel grid. Each red stripe represents one layer while each gradient\n     * (from bright red to black) represents the layers rendered in a single draw call.\n     */\n    get voxelDebugEnabled() {\n        return this._voxelRenderer?.voxelDebugEnabled;\n    }\n    set voxelDebugEnabled(enabled) {\n        if (!this._voxelRenderer) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable voxel debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        this._voxelRenderer.voxelDebugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._voxelRenderer.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._voxelRenderer.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * When using tri-planar voxelization (the default), this value can be used to\n     * display only the voxelization result for that axis. z-axis = 0, y-axis = 1, x-axis = 2\n     */\n    get voxelDebugAxis() {\n        return this._voxelRenderer?.voxelDebugAxis;\n    }\n    set voxelDebugAxis(axisNum) {\n        if (!this._voxelRenderer) {\n            return;\n        }\n        this._voxelRenderer.voxelDebugAxis = axisNum;\n    }\n    /**\n     * Displays a given mip of the voxel grid. `voxelDebugAxis` must be undefined in this\n     * case because we only generate mips for the combined voxel grid.\n     */\n    set voxelDebugDisplayMip(mipNum) {\n        if (!this._voxelRenderer) {\n            return;\n        }\n        this._voxelRenderer.setDebugMipNumber(mipNum);\n    }\n    /**\n     * Display the debug view for just the shadow samples taken this frame.\n     */\n    get voxelTracingDebugEnabled() {\n        return this._voxelTracingPass?.debugEnabled;\n    }\n    set voxelTracingDebugEnabled(enabled) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable voxel tracing debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this._voxelTracingPass.debugEnabled) {\n            return;\n        }\n        this._voxelTracingPass.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._voxelTracingPass.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._voxelTracingPass.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * Display the debug view for the spatial blur pass\n     */\n    get spatialBlurPassDebugEnabled() {\n        return this._spatialBlurPass.debugEnabled;\n    }\n    set spatialBlurPassDebugEnabled(enabled) {\n        if (!this._spatialBlurPass) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable spatial blur debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this._spatialBlurPass.debugEnabled) {\n            return;\n        }\n        this._spatialBlurPass.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._spatialBlurPass.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._spatialBlurPass.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * Display the debug view for the shadows accumulated over time.\n     */\n    get accumulationPassDebugEnabled() {\n        return this._accumulationPass?.debugEnabled;\n    }\n    set accumulationPassDebugEnabled(enabled) {\n        if (!this._accumulationPass) {\n            return;\n        }\n        if (enabled && !this.allowDebugPasses) {\n            Logger.Warn(\"Can't enable accumulation pass debug view without setting allowDebugPasses to true.\");\n            return;\n        }\n        if (enabled === this._accumulationPass.debugEnabled) {\n            return;\n        }\n        this._accumulationPass.debugEnabled = enabled;\n        if (enabled) {\n            this._enableEffect(this._accumulationPass.debugPassName, this.cameras);\n        }\n        else {\n            this._disableEffect(this._accumulationPass.debugPassName, this.cameras);\n        }\n    }\n    /**\n     * Add a mesh to be used for shadow-casting in the IBL shadow pipeline.\n     * These meshes will be written to the voxel grid.\n     * @param mesh A mesh or list of meshes that you want to cast shadows\n     */\n    addShadowCastingMesh(mesh) {\n        if (Array.isArray(mesh)) {\n            for (const m of mesh) {\n                if (m && this._shadowCastingMeshes.indexOf(m) === -1) {\n                    this._shadowCastingMeshes.push(m);\n                }\n            }\n        }\n        else {\n            if (mesh && this._shadowCastingMeshes.indexOf(mesh) === -1) {\n                this._shadowCastingMeshes.push(mesh);\n            }\n        }\n    }\n    /**\n     * Remove a mesh from the shadow-casting list. The mesh will no longer be written\n     * to the voxel grid and will not cast shadows.\n     * @param mesh The mesh or list of meshes that you don't want to cast shadows.\n     */\n    removeShadowCastingMesh(mesh) {\n        if (Array.isArray(mesh)) {\n            for (const m of mesh) {\n                const index = this._shadowCastingMeshes.indexOf(m);\n                if (index !== -1) {\n                    this._shadowCastingMeshes.splice(index, 1);\n                }\n            }\n        }\n        else {\n            const index = this._shadowCastingMeshes.indexOf(mesh);\n            if (index !== -1) {\n                this._shadowCastingMeshes.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * Clear the list of shadow-casting meshes. This will remove all meshes from the list\n     */\n    clearShadowCastingMeshes() {\n        this._shadowCastingMeshes.length = 0;\n    }\n    /**\n     * The exponent of the resolution of the voxel shadow grid. Higher resolutions will result in sharper\n     * shadows but are more expensive to compute and require more memory.\n     * The resolution is calculated as 2 to the power of this number.\n     */\n    get resolutionExp() {\n        return this._voxelRenderer.voxelResolutionExp;\n    }\n    set resolutionExp(newResolution) {\n        if (newResolution === this._voxelRenderer.voxelResolutionExp) {\n            return;\n        }\n        if (this._voxelRenderer.isVoxelizationInProgress()) {\n            Logger.Warn(\"Can't change the resolution of the voxel grid while voxelization is in progress.\");\n            return;\n        }\n        this._voxelRenderer.voxelResolutionExp = Math.max(1, Math.min(newResolution, 8));\n        this._accumulationPass.reset = true;\n    }\n    /**\n     * The number of different directions to sample during the voxel tracing pass\n     */\n    get sampleDirections() {\n        return this._voxelTracingPass?.sampleDirections;\n    }\n    /**\n     * The number of different directions to sample during the voxel tracing pass\n     */\n    set sampleDirections(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.sampleDirections = value;\n    }\n    /**\n     * The decree to which the shadows persist between frames. 0.0 is no persistence, 1.0 is full persistence.\n     **/\n    get shadowRemanence() {\n        return this._accumulationPass?.remanence;\n    }\n    /**\n     * The decree to which the shadows persist between frames. 0.0 is no persistence, 1.0 is full persistence.\n     **/\n    set shadowRemanence(value) {\n        if (!this._accumulationPass) {\n            return;\n        }\n        this._accumulationPass.remanence = value;\n    }\n    /**\n     * The global Y-axis rotation of the IBL for shadows. This should match the Y-rotation of the environment map applied to materials, skybox, etc.\n     */\n    get envRotation() {\n        return this._voxelTracingPass?.envRotation;\n    }\n    /**\n     * The global Y-axis rotation of the IBL for shadows. This should match the Y-rotation of the environment map applied to materials, skybox, etc.\n     */\n    set envRotation(value) {\n        if (!this._voxelTracingPass) {\n            return;\n        }\n        this._voxelTracingPass.envRotation = value;\n        this._accumulationPass.reset = true;\n    }\n    /**\n     * Allow debug passes to be enabled. Default is false.\n     */\n    get allowDebugPasses() {\n        return this._allowDebugPasses;\n    }\n    /**\n     * Allow debug passes to be enabled. Default is false.\n     */\n    set allowDebugPasses(value) {\n        if (this._allowDebugPasses === value) {\n            return;\n        }\n        this._allowDebugPasses = value;\n        if (value && this.scene.iblCdfGenerator) {\n            if (this.scene.iblCdfGenerator.isReady()) {\n                this._createDebugPasses();\n            }\n            else {\n                this.scene.iblCdfGenerator.onGeneratedObservable.addOnce(() => {\n                    this._createDebugPasses();\n                });\n            }\n        }\n        else {\n            this._disposeDebugPasses();\n        }\n    }\n    /**\n     *  Support test.\n     */\n    static get IsSupported() {\n        const engine = EngineStore.LastCreatedEngine;\n        if (!engine) {\n            return false;\n        }\n        return engine._features.supportIBLShadows;\n    }\n    /**\n     * Toggle the shadow tracing on or off\n     * @param enabled Toggle the shadow tracing on or off\n     */\n    toggleShadow(enabled) {\n        this._enabled = enabled;\n        this._voxelTracingPass.enabled = enabled;\n        this._spatialBlurPass.enabled = enabled;\n        this._accumulationPass.enabled = enabled;\n        for (const mat of this._materialsWithRenderPlugin) {\n            if (mat.pluginManager) {\n                const plugin = mat.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);\n                plugin.isEnabled = enabled;\n            }\n        }\n        this._setPluginParameters();\n    }\n    /**\n     * Trigger the scene to be re-voxelized. This should be run when any shadow-casters have been added, removed or moved.\n     */\n    updateVoxelization() {\n        if (this._shadowCastingMeshes.length === 0) {\n            Logger.Warn(\"IBL Shadows: updateVoxelization called with no shadow-casting meshes to voxelize.\");\n            return;\n        }\n        this._voxelRenderer.updateVoxelGrid(this._shadowCastingMeshes);\n        this._voxelRenderer.onVoxelizationCompleteObservable.addOnce(() => {\n            this.onVoxelizationCompleteObservable.notifyObservers();\n        });\n        this._updateSsShadowParams();\n    }\n    /**\n     * Trigger the scene bounds of shadow-casters to be calculated. This is the world size that the voxel grid will cover and will always be a cube.\n     */\n    updateSceneBounds() {\n        const bounds = {\n            min: new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE),\n            max: new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE),\n        };\n        for (const mesh of this._shadowCastingMeshes) {\n            const localBounds = mesh.getHierarchyBoundingVectors(true);\n            bounds.min = Vector3.Minimize(bounds.min, localBounds.min);\n            bounds.max = Vector3.Maximize(bounds.max, localBounds.max);\n        }\n        const size = bounds.max.subtract(bounds.min);\n        this.voxelGridSize = Math.max(size.x, size.y, size.z);\n        if (this._shadowCastingMeshes.length === 0 || !isFinite(this.voxelGridSize) || this.voxelGridSize === 0) {\n            Logger.Warn(\"IBL Shadows: Scene size is invalid. Can't update bounds.\");\n            this.voxelGridSize = 1.0;\n            return;\n        }\n        const halfSize = this.voxelGridSize / 2.0;\n        const centre = bounds.max.add(bounds.min).multiplyByFloats(-0.5, -0.5, -0.5);\n        const invWorldScaleMatrix = Matrix.Compose(new Vector3(1.0 / halfSize, 1.0 / halfSize, 1.0 / halfSize), new Quaternion(), new Vector3(0, 0, 0));\n        const invTranslationMatrix = Matrix.Compose(new Vector3(1.0, 1.0, 1.0), new Quaternion(), centre);\n        invTranslationMatrix.multiplyToRef(invWorldScaleMatrix, invWorldScaleMatrix);\n        this._voxelTracingPass.setWorldScaleMatrix(invWorldScaleMatrix);\n        this._voxelRenderer.setWorldScaleMatrix(invWorldScaleMatrix);\n        // Set world scale for spatial blur.\n        this._spatialBlurPass.setWorldScale(halfSize * 2.0);\n        this._updateSsShadowParams();\n    }\n    /**\n     * @param name The rendering pipeline name\n     * @param scene The scene linked to this pipeline\n     * @param options Options to configure the pipeline\n     * @param cameras Cameras to apply the pipeline to.\n     */\n    constructor(name, scene, options = {}, cameras) {\n        super(scene.getEngine(), name);\n        this._allowDebugPasses = false;\n        this._debugPasses = [];\n        this._shadowCastingMeshes = [];\n        this._shadowOpacity = 0.8;\n        this._enabled = true;\n        this._coloredShadows = false;\n        this._materialsWithRenderPlugin = [];\n        /**\n         * Observable that triggers when the shadow renderer is ready\n         */\n        this.onShadowTextureReadyObservable = new Observable();\n        /**\n         * Observable that triggers when a new IBL is set and the importance sampling is ready\n         */\n        this.onNewIblReadyObservable = new Observable();\n        /**\n         * Observable that triggers when the voxelization is complete\n         */\n        this.onVoxelizationCompleteObservable = new Observable();\n        /**\n         * The current world-space size of that the voxel grid covers in the scene.\n         */\n        this.voxelGridSize = 1.0;\n        this._renderSizeFactor = 1.0;\n        this._gbufferDebugEnabled = false;\n        this._gBufferDebugSizeParams = new Vector4(0.0, 0.0, 0.0, 0.0);\n        this.scene = scene;\n        this._cameras = cameras || [scene.activeCamera];\n        // Create the dummy textures to be used when the pipeline is not ready\n        const blackPixels = new Uint8Array([0, 0, 0, 255]);\n        this._dummyTexture2d = new RawTexture(blackPixels, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false);\n        this._dummyTexture3d = new RawTexture3D(blackPixels, 1, 1, 1, Engine.TEXTUREFORMAT_RGBA, scene, false);\n        // Setup the geometry buffer target formats\n        const textureTypesAndFormats = {};\n        textureTypesAndFormats[GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE] = { textureFormat: Constants.TEXTUREFORMAT_R, textureType: Constants.TEXTURETYPE_FLOAT };\n        textureTypesAndFormats[GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE] = { textureFormat: Constants.TEXTUREFORMAT_RG, textureType: Constants.TEXTURETYPE_HALF_FLOAT };\n        textureTypesAndFormats[GeometryBufferRenderer.POSITION_TEXTURE_TYPE] = { textureFormat: Constants.TEXTUREFORMAT_RGBA, textureType: Constants.TEXTURETYPE_HALF_FLOAT };\n        textureTypesAndFormats[GeometryBufferRenderer.NORMAL_TEXTURE_TYPE] = { textureFormat: Constants.TEXTUREFORMAT_RGBA, textureType: Constants.TEXTURETYPE_HALF_FLOAT };\n        const geometryBufferRenderer = scene.enableGeometryBufferRenderer(undefined, Constants.TEXTUREFORMAT_DEPTH32_FLOAT, textureTypesAndFormats);\n        if (!geometryBufferRenderer) {\n            Logger.Error(\"Geometry buffer renderer is required for IBL shadows to work.\");\n            return;\n        }\n        this._geometryBufferRenderer = geometryBufferRenderer;\n        this._geometryBufferRenderer.enableScreenspaceDepth = true;\n        this._geometryBufferRenderer.enableVelocityLinear = true;\n        this._geometryBufferRenderer.enablePosition = true;\n        this._geometryBufferRenderer.enableNormal = true;\n        this._geometryBufferRenderer.generateNormalsInWorldSpace = true;\n        this.scene.enableIblCdfGenerator();\n        this.shadowOpacity = options.shadowOpacity || 0.8;\n        this._voxelRenderer = new _IblShadowsVoxelRenderer(this.scene, this, options ? options.resolutionExp : 6, options.triPlanarVoxelization !== undefined ? options.triPlanarVoxelization : true);\n        this._voxelTracingPass = new _IblShadowsVoxelTracingPass(this.scene, this);\n        this._spatialBlurPass = new _IblShadowsSpatialBlurPass(this.scene, this);\n        this._accumulationPass = new _IblShadowsAccumulationPass(this.scene, this);\n        this._accumulationPass.onReadyObservable.addOnce(() => {\n            this.onShadowTextureReadyObservable.notifyObservers();\n        });\n        this.sampleDirections = options.sampleDirections || 2;\n        this.voxelShadowOpacity = options.voxelShadowOpacity ?? 1.0;\n        this.envRotation = options.envRotation ?? 0.0;\n        this.shadowRenderSizeFactor = options.shadowRenderSizeFactor || 1.0;\n        this.ssShadowOpacity = options.ssShadowsEnabled === undefined || options.ssShadowsEnabled ? 1.0 : 0.0;\n        this.ssShadowDistanceScale = options.ssShadowDistanceScale || 1.25;\n        this.ssShadowSampleCount = options.ssShadowSampleCount || 16;\n        this.ssShadowStride = options.ssShadowStride || 8;\n        this.ssShadowThicknessScale = options.ssShadowThicknessScale || 1.0;\n        this.shadowRemanence = options.shadowRemanence ?? 0.75;\n        this._noiseTexture = new Texture(Tools.GetAssetUrl(\"https://assets.babylonjs.com/core/blue_noise/blue_noise_rgb.png\"), this.scene, false, true, Constants.TEXTURE_NEAREST_SAMPLINGMODE);\n        scene.postProcessRenderPipelineManager.addPipeline(this);\n        this.scene.onActiveCameraChanged.add(this._listenForCameraChanges.bind(this));\n        this.scene.onBeforeRenderObservable.add(this._updateBeforeRender.bind(this));\n        this._listenForCameraChanges();\n        this.scene.getEngine().onResizeObservable.add(this._handleResize.bind(this));\n        // Assigning the shadow texture to the materials needs to be done after the RT's are created.\n        if (this.scene.iblCdfGenerator) {\n            this.scene.iblCdfGenerator.onGeneratedObservable.add(() => {\n                this._setPluginParameters();\n                this.onNewIblReadyObservable.notifyObservers();\n            });\n        }\n    }\n    _handleResize() {\n        this._voxelRenderer.resize();\n        this._voxelTracingPass.resize(this.shadowRenderSizeFactor);\n        this._spatialBlurPass.resize(this.shadowRenderSizeFactor);\n        this._accumulationPass.resize(this.shadowRenderSizeFactor);\n        this._setPluginParameters();\n    }\n    _getGBufferDebugPass() {\n        if (this._gbufferDebugPass) {\n            return this._gbufferDebugPass;\n        }\n        const isWebGPU = this.engine.isWebGPU;\n        const textureNames = [\"depthSampler\", \"normalSampler\", \"positionSampler\", \"velocitySampler\"];\n        const options = {\n            width: this.scene.getEngine().getRenderWidth(),\n            height: this.scene.getEngine().getRenderHeight(),\n            samplingMode: Constants.TEXTURE_NEAREST_SAMPLINGMODE,\n            engine: this.scene.getEngine(),\n            textureType: Constants.TEXTURETYPE_UNSIGNED_BYTE,\n            textureFormat: Constants.TEXTUREFORMAT_RGBA,\n            uniforms: [\"sizeParams\"],\n            samplers: textureNames,\n            reusable: false,\n            shaderLanguage: isWebGPU ? 1 /* ShaderLanguage.WGSL */ : 0 /* ShaderLanguage.GLSL */,\n            extraInitializations: (useWebGPU, list) => {\n                if (useWebGPU) {\n                    list.push(import(\"../../ShadersWGSL/iblShadowGBufferDebug.fragment\"));\n                }\n                else {\n                    list.push(import(\"../../Shaders/iblShadowGBufferDebug.fragment\"));\n                }\n            },\n        };\n        this._gbufferDebugPass = new PostProcess(\"iblShadowGBufferDebug\", \"iblShadowGBufferDebug\", options);\n        if (this.engine.isWebGPU) {\n            this._gbufferDebugPass.samples = this.engine.currentSampleCount ?? 1;\n        }\n        this._gbufferDebugPass.autoClear = false;\n        this._gbufferDebugPass.onApplyObservable.add((effect) => {\n            const depthIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.SCREENSPACE_DEPTH_TEXTURE_TYPE);\n            effect.setTexture(\"depthSampler\", this._geometryBufferRenderer.getGBuffer().textures[depthIndex]);\n            const normalIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.NORMAL_TEXTURE_TYPE);\n            effect.setTexture(\"normalSampler\", this._geometryBufferRenderer.getGBuffer().textures[normalIndex]);\n            const positionIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.POSITION_TEXTURE_TYPE);\n            effect.setTexture(\"positionSampler\", this._geometryBufferRenderer.getGBuffer().textures[positionIndex]);\n            const velocityIndex = this._geometryBufferRenderer.getTextureIndex(GeometryBufferRenderer.VELOCITY_LINEAR_TEXTURE_TYPE);\n            effect.setTexture(\"velocitySampler\", this._geometryBufferRenderer.getGBuffer().textures[velocityIndex]);\n            effect.setVector4(\"sizeParams\", this._gBufferDebugSizeParams);\n            if (this.scene.activeCamera) {\n                effect.setFloat(\"maxDepth\", this.scene.activeCamera.maxZ);\n            }\n        });\n        return this._gbufferDebugPass;\n    }\n    _createDebugPasses() {\n        if (this.scene.iblCdfGenerator) {\n            this._debugPasses = [{ pass: this.scene.iblCdfGenerator.getDebugPassPP(), enabled: this.cdfDebugEnabled }];\n        }\n        else {\n            this._debugPasses = [];\n        }\n        this._debugPasses.push({ pass: this._voxelRenderer.getDebugPassPP(), enabled: this.voxelDebugEnabled }, { pass: this._voxelTracingPass.getDebugPassPP(), enabled: this.voxelTracingDebugEnabled }, { pass: this._spatialBlurPass.getDebugPassPP(), enabled: this.spatialBlurPassDebugEnabled }, { pass: this._accumulationPass.getDebugPassPP(), enabled: this.accumulationPassDebugEnabled }, { pass: this._getGBufferDebugPass(), enabled: this.gbufferDebugEnabled });\n        for (let i = 0; i < this._debugPasses.length; i++) {\n            if (!this._debugPasses[i].pass) {\n                continue;\n            }\n            this.addEffect(new PostProcessRenderEffect(this.scene.getEngine(), this._debugPasses[i].pass.name, () => {\n                return this._debugPasses[i].pass;\n            }, true));\n        }\n        const cameras = this.cameras.slice();\n        this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name, this.cameras);\n        this.scene.postProcessRenderPipelineManager.attachCamerasToRenderPipeline(this.name, cameras);\n        for (let i = 0; i < this._debugPasses.length; i++) {\n            if (!this._debugPasses[i].pass) {\n                continue;\n            }\n            if (this._debugPasses[i].enabled) {\n                this._enableEffect(this._debugPasses[i].pass.name, this.cameras);\n            }\n            else {\n                this._disableEffect(this._debugPasses[i].pass.name, this.cameras);\n            }\n        }\n    }\n    _disposeEffectPasses() {\n        this.scene.postProcessRenderPipelineManager.detachCamerasFromRenderPipeline(this.name, this.cameras);\n        this._disposeDebugPasses();\n        this._reset();\n    }\n    _disposeDebugPasses() {\n        for (let i = 0; i < this._debugPasses.length; i++) {\n            this._disableEffect(this._debugPasses[i].pass.name, this.cameras);\n            this._debugPasses[i].pass.dispose();\n        }\n        this._debugPasses = [];\n    }\n    _updateDebugPasses() {\n        let count = 0;\n        if (this._gbufferDebugEnabled) {\n            count++;\n        }\n        if (this.cdfDebugEnabled) {\n            count++;\n        }\n        if (this.voxelDebugEnabled) {\n            count++;\n        }\n        if (this.voxelTracingDebugEnabled) {\n            count++;\n        }\n        if (this.spatialBlurPassDebugEnabled) {\n            count++;\n        }\n        if (this.accumulationPassDebugEnabled) {\n            count++;\n        }\n        const rows = Math.ceil(Math.sqrt(count));\n        const cols = Math.ceil(count / rows);\n        const width = 1.0 / cols;\n        const height = 1.0 / rows;\n        let x = 0;\n        let y = 0;\n        if (this.gbufferDebugEnabled) {\n            this._gBufferDebugSizeParams.set(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.cdfDebugEnabled && this.scene.iblCdfGenerator) {\n            this.scene.iblCdfGenerator.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.voxelDebugEnabled) {\n            this._voxelRenderer.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.voxelTracingDebugEnabled) {\n            this._voxelTracingPass.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.spatialBlurPassDebugEnabled) {\n            this._spatialBlurPass.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n        if (this.accumulationPassDebugEnabled) {\n            this._accumulationPass.setDebugDisplayParams(x, y, cols, rows);\n            x -= width;\n            if (x <= -1) {\n                x = 0;\n                y -= height;\n            }\n        }\n    }\n    /**\n     * Update the SS shadow max distance and thickness based on the voxel grid size and resolution.\n     * The max distance should be just a little larger than the world size of a single voxel.\n     */\n    _updateSsShadowParams() {\n        this._voxelTracingPass.sssMaxDist = (this._sssMaxDistScale * this.voxelGridSize) / (1 << this.resolutionExp);\n        this._voxelTracingPass.sssThickness = this._sssThicknessScale * 0.005 * this.voxelGridSize;\n    }\n    /**\n     * Apply the shadows to a material or array of materials. If no material is provided, all\n     * materials in the scene will be added.\n     * @param material Material that will be affected by the shadows. If not provided, all materials of the scene will be affected.\n     */\n    addShadowReceivingMaterial(material) {\n        if (material) {\n            if (Array.isArray(material)) {\n                for (const m of material) {\n                    this._addShadowSupportToMaterial(m);\n                }\n            }\n            else {\n                this._addShadowSupportToMaterial(material);\n            }\n        }\n        else {\n            for (const mat of this.scene.materials) {\n                this._addShadowSupportToMaterial(mat);\n            }\n        }\n    }\n    /**\n     * Remove a material from the list of materials that receive shadows. If no material\n     * is provided, all materials in the scene will be removed.\n     * @param material The material or array of materials that will no longer receive shadows\n     */\n    removeShadowReceivingMaterial(material) {\n        if (Array.isArray(material)) {\n            for (const m of material) {\n                const matIndex = this._materialsWithRenderPlugin.indexOf(m);\n                if (matIndex !== -1) {\n                    this._materialsWithRenderPlugin.splice(matIndex, 1);\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-asserted-optional-chain\n                    const plugin = m.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);\n                    plugin.isEnabled = false;\n                }\n            }\n        }\n        else {\n            const matIndex = this._materialsWithRenderPlugin.indexOf(material);\n            if (matIndex !== -1) {\n                this._materialsWithRenderPlugin.splice(matIndex, 1);\n                const plugin = material.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);\n                plugin.isEnabled = false;\n            }\n        }\n    }\n    /**\n     * Clear the list of materials that receive shadows. This will remove all materials from the list\n     */\n    clearShadowReceivingMaterials() {\n        for (const mat of this._materialsWithRenderPlugin) {\n            const plugin = mat.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);\n            if (plugin) {\n                plugin.isEnabled = false;\n            }\n        }\n        this._materialsWithRenderPlugin.length = 0;\n    }\n    _addShadowSupportToMaterial(material) {\n        if (!(material instanceof PBRBaseMaterial) && !(material instanceof StandardMaterial) && !(material instanceof OpenPBRMaterial)) {\n            return;\n        }\n        let plugin = material.pluginManager?.getPlugin(IBLShadowsPluginMaterial.Name);\n        if (!plugin) {\n            plugin = new IBLShadowsPluginMaterial(material);\n        }\n        if (this._materialsWithRenderPlugin.indexOf(material) !== -1) {\n            return;\n        }\n        if (this._enabled) {\n            plugin.iblShadowsTexture = this._getAccumulatedTexture().getInternalTexture();\n            plugin.shadowOpacity = this.shadowOpacity;\n        }\n        plugin.isEnabled = this._enabled;\n        plugin.isColored = this._coloredShadows;\n        this._materialsWithRenderPlugin.push(material);\n    }\n    _setPluginParameters() {\n        if (!this._enabled) {\n            return;\n        }\n        for (const mat of this._materialsWithRenderPlugin) {\n            if (mat.pluginManager) {\n                const plugin = mat.pluginManager.getPlugin(IBLShadowsPluginMaterial.Name);\n                plugin.iblShadowsTexture = this._getAccumulatedTexture().getInternalTexture();\n                plugin.shadowOpacity = this.shadowOpacity;\n                plugin.isColored = this._coloredShadows;\n            }\n        }\n    }\n    _updateBeforeRender() {\n        this._updateDebugPasses();\n    }\n    _listenForCameraChanges() {\n        // We want to listen for camera changes and change settings while the camera is moving.\n        this.scene.activeCamera?.onViewMatrixChangedObservable.add(() => {\n            this._accumulationPass.isMoving = true;\n        });\n    }\n    /**\n     * Checks if the IBL shadow pipeline is ready to render shadows\n     * @returns true if the IBL shadow pipeline is ready to render the shadows\n     */\n    isReady() {\n        return (this._noiseTexture.isReady() &&\n            this._voxelRenderer.isReady() &&\n            this.scene.iblCdfGenerator &&\n            this.scene.iblCdfGenerator.isReady() &&\n            (!this._voxelTracingPass || this._voxelTracingPass.isReady()) &&\n            (!this._spatialBlurPass || this._spatialBlurPass.isReady()) &&\n            (!this._accumulationPass || this._accumulationPass.isReady()));\n    }\n    /**\n     * Get the class name\n     * @returns \"IBLShadowsRenderPipeline\"\n     */\n    getClassName() {\n        return \"IBLShadowsRenderPipeline\";\n    }\n    /**\n     * Disposes the IBL shadow pipeline and associated resources\n     */\n    dispose() {\n        const materials = this._materialsWithRenderPlugin.splice(0);\n        for (const mat of materials) {\n            this.removeShadowReceivingMaterial(mat);\n        }\n        this._disposeEffectPasses();\n        this._noiseTexture.dispose();\n        this._voxelRenderer.dispose();\n        this._voxelTracingPass.dispose();\n        this._spatialBlurPass.dispose();\n        this._accumulationPass.dispose();\n        this._dummyTexture2d.dispose();\n        this._dummyTexture3d.dispose();\n        this.onNewIblReadyObservable.clear();\n        this.onShadowTextureReadyObservable.clear();\n        this.onVoxelizationCompleteObservable.clear();\n        super.dispose();\n    }\n}\n//# sourceMappingURL=iblShadowsRenderPipeline.js.map"],"names":["_IblShadowsVoxelRenderer","getVoxelGrid","this","_engine","isWebGPU","_voxelGrid","_triPlanarVoxelization","_combinedVoxelGridPT","_voxelGridZaxis","getDebugPassPP","_voxelDebugPass","_createDebugPass","triPlanarVoxelization","enabled","_disposeVoxelTextures","_createTextures","setWorldScaleMatrix","matrix","_invWorldScaleMatrix","isVoxelizationInProgress","_voxelizationInProgress","voxelResolutionExp","_voxelResolutionExp","resolutionExp","Math","round","min","max","_voxelResolution","pow","voxelDebugAxis","axis","_voxelDebugAxis","setDebugDisplayParams","x","y","widthScale","heightScale","_debugSizeParams","set","setDebugMipNumber","mipNum","_debugMipNumber","debugPassName","_debugPassName","voxelDebugEnabled","_voxelDebugEnabled","_voxelSlabDebugRT","RenderTargetTexture","width","getRenderWidth","height","getRenderHeight","_scene","generateDepthBuffer","generateMipMaps","type","Constants","TEXTURETYPE_UNSIGNED_BYTE","format","TEXTUREFORMAT_RGBA","samplingMode","TEXTURE_NEAREST_SAMPLINGMODE","noPrePassRenderer","_removeVoxelRTs","_addRTsForRender","_includedMeshes","_setDebugBindingsBound","_setDebugBindings","bind","onBeforeRenderObservable","add","removeCallback","debugOptions","textureFormat","textureType","uniforms","samplers","engine","reusable","shaderLanguage","extraInitializations","useWebGPU","list","push","import","PostProcess","onApplyObservable","effect","setTexture","_voxelGridXaxis","_voxelGridYaxis","setVector4","setFloat","constructor","scene","iblShadowsRenderPipeline","_voxelMrtsXaxis","_voxelMrtsYaxis","_voxelMrtsZaxis","_voxelClearColor","Color4","onVoxelizationCompleteObservable","Observable","_renderTargets","Matrix","Identity","_mipArray","Vector4","getEngine","getCaps","drawBuffersExtension","Logger","Error","_maxDrawBuffers","maxDrawBuffers","_copyMipEffectRenderer","EffectRenderer","_copyMipEffectWrapper","EffectWrapper","fragmentShader","useShaderStore","uniformNames","samplerNames","extraInitializationsAsync","async","_generateMipMaps","iterations","ceil","log2","i","_generateMipMap","lodLevel","mipTarget","render","_copyMipMaps","_copyMipMap","voxelGrid","rt","renderTarget","_rtWrapper","saveStates","bindSize","getSize","layer","bindFramebuffer","applyEffectWrapper","setInt","draw","unBindFramebuffer","restoreStates","_computeNumberOfSlabs","size","depth","voxelAxisOptions","numSlabs","voxelCombinedOptions","TEXTUREFORMAT_R","TEXTURE_NEAREST_NEAREST_MIPNEAREST","creationFlags","TEXTURE_CREATIONFLAG_STORAGE","_voxelGridRT","_createVoxelMRTs","ProceduralTexture","proceduralTextures","splice","indexOf","autoClear","wrapU","Texture","CLAMP_ADDRESSMODE","wrapV","generateVoxelMipOptions","Array","mipIdx","length","mipDim","mipSize","_createVoxelMaterials","name","voxelRT","mrtArray","targetTypes","fill","TEXTURE_3D","mrtIndex","layerIndices","map","value","index","textureNames","mrt","MultiRenderTarget","types","samplingModes","TEXTURE_TRILINEAR_SAMPLINGMODE","formats","faceIndex","layerIndex","layerCounts","generateStencilBuffer","clearColor","setInternalTexture","getInternalTexture","_stopVoxelization","dispose","mip","_voxelMaterial","_voxelSlabDebugMaterial","ShaderMaterial","defines","Promise","all","cullBackFaces","backFaceCulling","depthFunction","Engine","ALWAYS","setMatrix","activeCamera","getProjectionMatrix","getViewMatrix","isReady","allReady","mipReady","rts","rtIdx","findIndex","customRenderTargets","updateVoxelGrid","includedMeshes","renderList","_renderVoxelGridBound","_renderVoxelGrid","onAfterRenderObservable","rttReady","isReadyForRendering","undefined","clear","whenCompiledAsync","then","notifyObservers","mrts","shaderType","continuousRender","slabSize","voxelMaterial","nearPlane","farPlane","stepSize","cameraPosition","Vector3","targetPosition","upDirection","LookAtLH","useVertexPulling","mesh","subMeshes","setMaterialForRendering","meshes","getChildMeshes","childMesh","concat","resize","_IblShadowsVoxelTracingPass","voxelShadowOpacity","_voxelShadowOpacity","ssShadowOpacity","_ssShadowOpacity","sssSamples","_sssSamples","sssStride","_sssStride","sssMaxDist","_sssMaxDist","sssThickness","_sssThickness","voxelNormalBias","_voxelNormalBias","voxelDirectionBias","_voxelDirectionBias","sampleDirections","_sampleDirections","envRotation","_envRotation","getOutputTexture","_outputTexture","_debugPassPP","coloredShadows","_coloredShadows","_cameraInvView","_cameraInvProj","_frameId","_shadowParameters","_sssParameters","_opacityParameters","_voxelBiasParameters","debugEnabled","_debugVoxelMarchEnabled","_renderWhenGBufferReady","_renderPipeline","_createDefines","textureOptions","refreshRate","_setBindings","_render","addOnce","geometryBufferRenderer","getGBuffer","useRightHandedSystem","camera","invertToRef","rotation","environmentTexture","rotationY","PI","_getVoxelGridTexture","highestMip","floor","_getNoiseTexture","cdfGenerator","iblCdfGenerator","Warn","getIcdfTexture","depthIndex","getTextureIndex","GeometryBufferRenderer","SCREENSPACE_DEPTH_TEXTURE_TYPE","textures","wnormalIndex","NORMAL_TEXTURE_TYPE","getEffect","scaleFactor","newSize","_IblShadowsSpatialBlurPass","setWorldScale","scale","_worldScale","_blurParameters","_getVoxelTracingTexture","_IblShadowsAccumulationPass","remanence","_remanence","reset","_reset","isMoving","_isMoving","_accumulationParams","onReadyObservable","outputTextureOptions","TEXTURETYPE_HALF_FLOAT","onGeneratedObservable","_setOutputTextureBindings","accumulationOptions","_oldAccumulationCopy","onBeforeGenerationObservable","_setAccumulationCopyBindings","localPositionOptions","_oldPositionCopy","_updatePositionCopy","voxelGridSize","_getSpatialBlurTexture","_dummyTexture2d","velocityIndex","VELOCITY_LINEAR_TEXTURE_TYPE","wPositionIndex","POSITION_TEXTURE_TYPE","_disposeTextures","RawTexture3D","_texture","data","invertY","TRILINEAR_SAMPLINGMODE","super","createRawTexture3D","is3D","update","_getEngine","updateRawTexture3D","MaterialIBLShadowsRenderDefines","MaterialDefines","arguments","RENDER_WITH_IBL_SHADOWS","COLORED_IBL_SHADOWS","IBLShadowsPluginMaterial","MaterialPluginBase","isColored","_isColored","_markAllSubMeshesAsTexturesDirty","_enable","_isEnabled","_internalMarkAllSubMeshesAsTexturesDirty","isCompatible","material","Name","shadowOpacity","isEnabled","_dirtyCallbacks","MATERIAL_TextureDirtyFlag","prepareDefines","getClassName","getUniforms","ubo","fragment","getSamplers","bindForSubMesh","uniformBuffer","bindTexture","iblShadowsTexture","updateFloat2","_material","getScene","updateFloat","getCustomCode","frag","CUSTOM_FRAGMENT_DEFINITIONS","PBRBaseMaterial","OpenPBRMaterial","__decorate","serialize","prototype","expandToProperty","RegisterClass","IblShadowsRenderPipeline","PostProcessRenderPipeline","resetAccumulation","_accumulationPass","_shadowOpacity","_setPluginParameters","_voxelTracingPass","shadowRenderSizeFactor","_renderSizeFactor","_spatialBlurPass","ssShadowSampleCount","ssShadowStride","ssShadowDistanceScale","_sssMaxDistScale","_updateSsShadowParams","ssShadowThicknessScale","_sssThicknessScale","tex","_voxelRenderer","_dummyTexture3d","_noiseTexture","_getAccumulatedTexture","gbufferDebugEnabled","_gbufferDebugEnabled","allowDebugPasses","_enableEffect","_getGBufferDebugPass","cameras","_disableEffect","cdfDebugEnabled","axisNum","voxelDebugDisplayMip","voxelTracingDebugEnabled","spatialBlurPassDebugEnabled","accumulationPassDebugEnabled","addShadowCastingMesh","isArray","m","_shadowCastingMeshes","removeShadowCastingMesh","clearShadowCastingMeshes","newResolution","shadowRemanence","_allowDebugPasses","_createDebugPasses","_disposeDebugPasses","IsSupported","EngineStore","LastCreatedEngine","_features","supportIBLShadows","toggleShadow","_enabled","mat","_materialsWithRenderPlugin","pluginManager","getPlugin","updateVoxelization","updateSceneBounds","bounds","Number","MAX_VALUE","localBounds","getHierarchyBoundingVectors","Minimize","Maximize","subtract","z","isFinite","halfSize","centre","multiplyByFloats","invWorldScaleMatrix","Compose","Quaternion","multiplyToRef","options","_debugPasses","onShadowTextureReadyObservable","onNewIblReadyObservable","_gBufferDebugSizeParams","_cameras","blackPixels","Uint8Array","RawTexture","textureTypesAndFormats","TEXTURETYPE_FLOAT","TEXTUREFORMAT_RG","enableGeometryBufferRenderer","TEXTUREFORMAT_DEPTH32_FLOAT","_geometryBufferRenderer","enableScreenspaceDepth","enableVelocityLinear","enablePosition","enableNormal","generateNormalsInWorldSpace","enableIblCdfGenerator","ssShadowsEnabled","Tools","GetAssetUrl","postProcessRenderPipelineManager","addPipeline","onActiveCameraChanged","_listenForCameraChanges","_updateBeforeRender","onResizeObservable","_handleResize","_gbufferDebugPass","samples","currentSampleCount","normalIndex","positionIndex","maxZ","pass","addEffect","PostProcessRenderEffect","slice","detachCamerasFromRenderPipeline","attachCamerasToRenderPipeline","_disposeEffectPasses","_updateDebugPasses","count","rows","sqrt","cols","addShadowReceivingMaterial","_addShadowSupportToMaterial","materials","removeShadowReceivingMaterial","matIndex","plugin","clearShadowReceivingMaterials","StandardMaterial","onViewMatrixChangedObservable"],"mappings":"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"}