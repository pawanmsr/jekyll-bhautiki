import{ca as t,x as e,q as s,J as n,aL as r}from"./index-C7lpuH7l.esm.min.js";import{A as i}from"./assetContainer-BpinJ-Pb.esm.min.js";import"./standardMaterial-BeALqQl2.esm.min.js";class a{constructor(){this.solidPattern=/solid (\S*)([\S\s]*?)endsolid[ ]*(\S*)/g,this.facetsPattern=/facet([\s\S]*?)endfacet/g,this.normalPattern=/normal[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g,this.vertexPattern=/vertex[\s]+([-+]?[0-9]+\.?[0-9]*([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+[\s]+([-+]?[0-9]*\.?[0-9]+([eE][-+]?[0-9]+)?)+/g,this.name=t.name,this.extensions=t.extensions}importMesh(t,n,r,i,a){let o;if("string"!=typeof r){if(this._isBinary(r)){const t=new e("stlmesh",n);return this._parseBinary(t,r),a&&a.push(t),!0}r=(new TextDecoder).decode(new Uint8Array(r))}for(;o=this.solidPattern.exec(r);){let r=o[1];const i=o[3];if(i&&r!=i)return s.Error("Error in STL, solid name != endsolid name"),!1;if(t&&r)if(t instanceof Array){if(!t.indexOf(r))continue}else if(r!==t)continue;r=r||"stlmesh";const l=new e(r,n);this._parseASCII(l,o[2]),a&&a.push(l)}return!0}load(t,e,s){return this.importMesh(null,t,e,s,null)}loadAssetContainer(t,e,s){const n=new i(t);return t._blockEntityCollection=!0,this.importMesh(null,t,e,s,n.meshes),t._blockEntityCollection=!1,n}_isBinary(t){const e=new DataView(t);if(e.byteLength<=80)return!1;if(84+50*e.getUint32(80,!0)===e.byteLength)return!0;const s=[115,111,108,105,100];for(let t=0;t<5;t++)if(e.getUint8(t)!==s[t])return!0;return!1}_parseBinary(t,e){const s=new DataView(e),r=s.getUint32(80,!0);let i=0;const o=new Float32Array(3*r*3),l=new Float32Array(3*r*3),c=new Uint32Array(3*r);let m=0;for(let t=0;t<r;t++){const e=84+50*t,n=s.getFloat32(e,!0),r=s.getFloat32(e+4,!0),u=s.getFloat32(e+8,!0);for(let t=1;t<=3;t++){const c=e+12*t;o[i]=s.getFloat32(c,!0),l[i]=n,a.DO_NOT_ALTER_FILE_COORDINATES?(o[i+1]=s.getFloat32(c+4,!0),o[i+2]=s.getFloat32(c+8,!0),l[i+1]=r,l[i+2]=u):(o[i+2]=s.getFloat32(c+4,!0),o[i+1]=s.getFloat32(c+8,!0),l[i+2]=r,l[i+1]=u),i+=3}a.DO_NOT_ALTER_FILE_COORDINATES?(c[m]=m,c[m+1]=m+2,c[m+2]=m+1,m+=3):(c[m]=m++,c[m]=m++,c[m]=m++)}t.setVerticesData(n.PositionKind,o),t.setVerticesData(n.NormalKind,l),t.setIndices(c),t.computeWorldMatrix(!0)}_parseASCII(t,e){const s=[],r=[],i=[];let o,l=0;for(;o=this.facetsPattern.exec(e);){const t=o[1],e=this.normalPattern.exec(t);if(this.normalPattern.lastIndex=0,!e)continue;const n=[Number(e[1]),Number(e[5]),Number(e[3])];let c;for(;c=this.vertexPattern.exec(t);)a.DO_NOT_ALTER_FILE_COORDINATES?(s.push(Number(c[1]),Number(c[3]),Number(c[5])),r.push(n[0],n[2],n[1])):(s.push(Number(c[1]),Number(c[5]),Number(c[3])),r.push(n[0],n[1],n[2]));a.DO_NOT_ALTER_FILE_COORDINATES?(i.push(l,l+2,l+1),l+=3):i.push(l++,l++,l++),this.vertexPattern.lastIndex=0}this.facetsPattern.lastIndex=0,t.setVerticesData(n.PositionKind,s),t.setVerticesData(n.NormalKind,r),t.setIndices(i),t.computeWorldMatrix(!0)}}a.DO_NOT_ALTER_FILE_COORDINATES=!1,r(new a);export{a as STLFileLoader};
//# sourceMappingURL=stlFileLoader-WbHVuseT.esm.min.js.map
