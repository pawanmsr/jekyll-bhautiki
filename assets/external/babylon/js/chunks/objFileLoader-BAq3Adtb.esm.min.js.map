{"version":3,"file":"objFileLoader-BAq3Adtb.esm.min.js","sources":["../../../../../dev/loaders/dist/OBJ/mtlFileLoader.js","../../../../../dev/loaders/dist/OBJ/solidParser.js","../../../../../dev/loaders/dist/OBJ/objFileLoader.js"],"sourcesContent":["import { Color3 } from \"core/Maths/math.color\";\nimport { Texture } from \"core/Materials/Textures/texture\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\n/**\n * Class reading and parsing the MTL file bundled with the obj file.\n */\nexport class MTLFileLoader {\n    constructor() {\n        /**\n         * All material loaded from the mtl will be set here\n         */\n        this.materials = [];\n    }\n    /**\n     * This function will read the mtl file and create each material described inside\n     * This function could be improve by adding :\n     * -some component missing (Ni, Tf...)\n     * -including the specific options available\n     *\n     * @param scene defines the scene the material will be created in\n     * @param data defines the mtl data to parse\n     * @param rootUrl defines the rooturl to use in order to load relative dependencies\n     * @param assetContainer defines the asset container to store the material in (can be null)\n     */\n    parseMTL(scene, data, rootUrl, assetContainer) {\n        if (data instanceof ArrayBuffer) {\n            return;\n        }\n        //Split the lines from the file\n        const lines = data.split(\"\\n\");\n        // whitespace char ie: [ \\t\\r\\n\\f]\n        const delimiterPattern = /\\s+/;\n        //Array with RGB colors\n        let color;\n        //New material\n        let material = null;\n        //Look at each line\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trim();\n            // Blank line or comment\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            //Get the first parameter (keyword)\n            const pos = line.indexOf(\" \");\n            let key = pos >= 0 ? line.substring(0, pos) : line;\n            key = key.toLowerCase();\n            //Get the data following the key\n            const value = pos >= 0 ? line.substring(pos + 1).trim() : \"\";\n            //This mtl keyword will create the new material\n            if (key === \"newmtl\") {\n                //Check if it is the first material.\n                // Materials specifications are described after this keyword.\n                if (material) {\n                    //Add the previous material in the material array.\n                    this.materials.push(material);\n                }\n                //Create a new material.\n                // value is the name of the material read in the mtl file\n                scene._blockEntityCollection = !!assetContainer;\n                material = new StandardMaterial(value, scene);\n                material._parentContainer = assetContainer;\n                scene._blockEntityCollection = false;\n            }\n            else if (key === \"kd\" && material) {\n                // Diffuse color (color under white light) using RGB values\n                //value  = \"r g b\"\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.diffuseColor = Color3.FromArray(color);\n            }\n            else if (key === \"ka\" && material) {\n                // Ambient color (color under shadow) using RGB values\n                //value = \"r g b\"\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set tghe color into the material\n                material.ambientColor = Color3.FromArray(color);\n            }\n            else if (key === \"ks\" && material) {\n                // Specular color (color when light is reflected from shiny surface) using RGB values\n                //value = \"r g b\"\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                //color = [r,g,b]\n                //Set the color into the material\n                material.specularColor = Color3.FromArray(color);\n            }\n            else if (key === \"ke\" && material) {\n                // Emissive color using RGB values\n                color = value.split(delimiterPattern, 3).map(parseFloat);\n                material.emissiveColor = Color3.FromArray(color);\n            }\n            else if (key === \"ns\" && material) {\n                //value = \"Integer\"\n                material.specularPower = parseFloat(value);\n            }\n            else if (key === \"d\" && material) {\n                //d is dissolve for current material. It mean alpha for BABYLON\n                material.alpha = parseFloat(value);\n                //Texture\n                //This part can be improved by adding the possible options of texture\n            }\n            else if (key === \"map_ka\" && material) {\n                // ambient texture map with a loaded image\n                //We must first get the folder of the image\n                material.ambientTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_kd\" && material) {\n                // Diffuse texture map with a loaded image\n                material.diffuseTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_ks\" && material) {\n                // Specular texture map with a loaded image\n                //We must first get the folder of the image\n                material.specularTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n            }\n            else if (key === \"map_ns\") {\n                //Specular\n                //Specular highlight component\n                //We must first get the folder of the image\n                //\n                //Not supported by BABYLON\n                //\n                //    continue;\n            }\n            else if (key === \"map_bump\" && material) {\n                //The bump texture\n                const values = value.split(delimiterPattern);\n                const bumpMultiplierIndex = values.indexOf(\"-bm\");\n                let bumpMultiplier = null;\n                if (bumpMultiplierIndex >= 0) {\n                    bumpMultiplier = values[bumpMultiplierIndex + 1];\n                    values.splice(bumpMultiplierIndex, 2); // remove\n                }\n                material.bumpTexture = MTLFileLoader._GetTexture(rootUrl, values.join(\" \"), scene);\n                if (material.bumpTexture && bumpMultiplier !== null) {\n                    material.bumpTexture.level = parseFloat(bumpMultiplier);\n                }\n            }\n            else if (key === \"map_d\" && material) {\n                // The dissolve of the material\n                material.opacityTexture = MTLFileLoader._GetTexture(rootUrl, value, scene);\n                //Options for illumination\n            }\n            else if (key === \"illum\") {\n                //Illumination\n                if (value === \"0\") {\n                    //That mean Kd == Kd\n                }\n                else if (value === \"1\") {\n                    //Color on and Ambient on\n                }\n                else if (value === \"2\") {\n                    //Highlight on\n                }\n                else if (value === \"3\") {\n                    //Reflection on and Ray trace on\n                }\n                else if (value === \"4\") {\n                    //Transparency: Glass on, Reflection: Ray trace on\n                }\n                else if (value === \"5\") {\n                    //Reflection: Fresnel on and Ray trace on\n                }\n                else if (value === \"6\") {\n                    //Transparency: Refraction on, Reflection: Fresnel off and Ray trace on\n                }\n                else if (value === \"7\") {\n                    //Transparency: Refraction on, Reflection: Fresnel on and Ray trace on\n                }\n                else if (value === \"8\") {\n                    //Reflection on and Ray trace off\n                }\n                else if (value === \"9\") {\n                    //Transparency: Glass on, Reflection: Ray trace off\n                }\n                else if (value === \"10\") {\n                    //Casts shadows onto invisible surfaces\n                }\n            }\n            else {\n                // console.log(\"Unhandled expression at line : \" + i +'\\n' + \"with value : \" + line);\n            }\n        }\n        //At the end of the file, add the last material\n        if (material) {\n            this.materials.push(material);\n        }\n    }\n    /**\n     * Gets the texture for the material.\n     *\n     * If the material is imported from input file,\n     * We sanitize the url to ensure it takes the texture from aside the material.\n     *\n     * @param rootUrl The root url to load from\n     * @param value The value stored in the mtl\n     * @param scene\n     * @returns The Texture\n     */\n    static _GetTexture(rootUrl, value, scene) {\n        if (!value) {\n            return null;\n        }\n        let url = rootUrl;\n        // Load from input file.\n        if (rootUrl === \"file:\") {\n            let lastDelimiter = value.lastIndexOf(\"\\\\\");\n            if (lastDelimiter === -1) {\n                lastDelimiter = value.lastIndexOf(\"/\");\n            }\n            if (lastDelimiter > -1) {\n                url += value.substring(lastDelimiter + 1);\n            }\n            else {\n                url += value;\n            }\n        }\n        // Not from input file.\n        else {\n            url += value;\n        }\n        return new Texture(url, scene, false, MTLFileLoader.INVERT_TEXTURE_Y);\n    }\n}\n/**\n * Invert Y-Axis of referenced textures on load\n */\nMTLFileLoader.INVERT_TEXTURE_Y = true;\n//# sourceMappingURL=mtlFileLoader.js.map","import { VertexBuffer } from \"core/Buffers/buffer\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\nimport { Color3, Color4 } from \"core/Maths/math.color\";\nimport { Vector2, Vector3 } from \"core/Maths/math.vector\";\nimport { Geometry } from \"core/Meshes/geometry\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { VertexData } from \"core/Meshes/mesh.vertexData\";\nimport { Logger } from \"core/Misc/logger\";\n/**\n * Class used to load mesh data from OBJ content\n */\nexport class SolidParser {\n    /**\n     * Creates a new SolidParser\n     * @param materialToUse defines the array to fill with the list of materials to use (it will be filled by the parse function)\n     * @param babylonMeshesArray defines the array to fill with the list of loaded meshes (it will be filled by the parse function)\n     * @param loadingOptions defines the loading options to use\n     */\n    constructor(materialToUse, babylonMeshesArray, loadingOptions) {\n        this._positions = []; //values for the positions of vertices\n        this._normals = []; //Values for the normals\n        this._uvs = []; //Values for the textures\n        this._colors = [];\n        this._extColors = []; //Extension color\n        this._meshesFromObj = []; //[mesh] Contains all the obj meshes\n        this._indicesForBabylon = []; //The list of indices for VertexData\n        this._wrappedPositionForBabylon = []; //The list of position in vectors\n        this._wrappedUvsForBabylon = []; //Array with all value of uvs to match with the indices\n        this._wrappedColorsForBabylon = []; // Array with all color values to match with the indices\n        this._wrappedNormalsForBabylon = []; //Array with all value of normals to match with the indices\n        this._tuplePosNorm = []; //Create a tuple with indice of Position, Normal, UV  [pos, norm, uvs]\n        this._curPositionInIndices = 0;\n        this._hasMeshes = false; //Meshes are defined in the file\n        this._unwrappedPositionsForBabylon = []; //Value of positionForBabylon w/o Vector3() [x,y,z]\n        this._unwrappedColorsForBabylon = []; // Value of colorForBabylon w/o Color4() [r,g,b,a]\n        this._unwrappedNormalsForBabylon = []; //Value of normalsForBabylon w/o Vector3()  [x,y,z]\n        this._unwrappedUVForBabylon = []; //Value of uvsForBabylon w/o Vector3()      [x,y,z]\n        this._triangles = []; //Indices from new triangles coming from polygons\n        this._materialNameFromObj = \"\"; //The name of the current material\n        this._objMeshName = \"\"; //The name of the current obj mesh\n        this._increment = 1; //Id for meshes created by the multimaterial\n        this._isFirstMaterial = true;\n        this._grayColor = new Color4(0.5, 0.5, 0.5, 1);\n        this._hasLineData = false; //If this mesh has line segment(l) data\n        this._materialToUse = materialToUse;\n        this._babylonMeshesArray = babylonMeshesArray;\n        this._loadingOptions = loadingOptions;\n    }\n    /**\n     * Search for obj in the given array.\n     * This function is called to check if a couple of data already exists in an array.\n     *\n     * If found, returns the index of the founded tuple index. Returns -1 if not found\n     * @param arr Array<{ normals: Array<number>, idx: Array<number> }>\n     * @param obj Array<number>\n     * @returns {boolean}\n     */\n    _isInArray(arr, obj) {\n        if (!arr[obj[0]]) {\n            arr[obj[0]] = { normals: [], idx: [] };\n        }\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\n        return idx === -1 ? -1 : arr[obj[0]].idx[idx];\n    }\n    _isInArrayUV(arr, obj) {\n        if (!arr[obj[0]]) {\n            arr[obj[0]] = { normals: [], idx: [], uv: [] };\n        }\n        const idx = arr[obj[0]].normals.indexOf(obj[1]);\n        if (idx != 1 && obj[2] === arr[obj[0]].uv[idx]) {\n            return arr[obj[0]].idx[idx];\n        }\n        return -1;\n    }\n    /**\n     * This function set the data for each triangle.\n     * Data are position, normals and uvs\n     * If a tuple of (position, normal) is not set, add the data into the corresponding array\n     * If the tuple already exist, add only their indice\n     *\n     * @param data The vertex's data\n     * * indicesPositionFromObj: The index in positions array\n     * * indicesUvsFromObj: The index in uvs array\n     * * indicesNormalFromObj: The index in normals array\n     * * positionVectorFromOBJ: The value of position at index objIndice\n     * * textureVectorFromOBJ: The value of uvs\n     * * normalsVectorFromOBJ: The value of normals at index objNormale\n     * * positionColorsFromOBJ: The value of color at index objIndice\n     */\n    _setData(data) {\n        //Use default values if undefined\n        data.indiceUvsFromObj ??= -1;\n        data.indiceNormalFromObj ??= -1;\n        //Check if this tuple already exists in the list of tuples\n        let _index;\n        if (this._loadingOptions.optimizeWithUV) {\n            _index = this._isInArrayUV(this._tuplePosNorm, [data.indicePositionFromObj, data.indiceNormalFromObj, data.indiceUvsFromObj]);\n        }\n        else {\n            _index = this._isInArray(this._tuplePosNorm, [data.indicePositionFromObj, data.indiceNormalFromObj]);\n        }\n        //If it not exists\n        if (_index === -1) {\n            //Add an new indice.\n            //The array of indices is only an array with his length equal to the number of triangles - 1.\n            //We add vertices data in this order\n            this._indicesForBabylon.push(this._wrappedPositionForBabylon.length);\n            //Push the position of vertice for Babylon\n            //Each element is a Vector3(x,y,z)\n            this._wrappedPositionForBabylon.push(data.positionVectorFromOBJ);\n            if (data.textureVectorFromOBJ !== undefined) {\n                //Push the uvs for Babylon\n                //Each element is a Vector2(u,v)\n                this._wrappedUvsForBabylon.push(data.textureVectorFromOBJ);\n            }\n            if (data.normalsVectorFromOBJ !== undefined) {\n                //Push the normals for Babylon\n                //Each element is a Vector3(x,y,z)\n                this._wrappedNormalsForBabylon.push(data.normalsVectorFromOBJ);\n            }\n            if (data.positionColorsFromOBJ !== undefined) {\n                //Push the colors for Babylon\n                //Each element is a BABYLON.Color4(r,g,b,a)\n                this._wrappedColorsForBabylon.push(data.positionColorsFromOBJ);\n            }\n            //Add the tuple in the comparison list\n            this._tuplePosNorm[data.indicePositionFromObj].normals.push(data.indiceNormalFromObj);\n            this._tuplePosNorm[data.indicePositionFromObj].idx.push(this._curPositionInIndices++);\n            if (this._loadingOptions.optimizeWithUV) {\n                this._tuplePosNorm[data.indicePositionFromObj].uv.push(data.indiceUvsFromObj);\n            }\n        }\n        else {\n            //The tuple already exists\n            //Add the index of the already existing tuple\n            //At this index we can get the value of position, normal, color and uvs of vertex\n            this._indicesForBabylon.push(_index);\n        }\n    }\n    /**\n     * Transform Vector() and BABYLON.Color() objects into numbers in an array\n     */\n    _unwrapData() {\n        try {\n            //Every array has the same length\n            for (let l = 0; l < this._wrappedPositionForBabylon.length; l++) {\n                //Push the x, y, z values of each element in the unwrapped array\n                this._unwrappedPositionsForBabylon.push(this._wrappedPositionForBabylon[l].x * this._handednessSign, this._wrappedPositionForBabylon[l].y, this._wrappedPositionForBabylon[l].z);\n                if (this._wrappedNormalsForBabylon.length) {\n                    this._unwrappedNormalsForBabylon.push(this._wrappedNormalsForBabylon[l].x * this._handednessSign, this._wrappedNormalsForBabylon[l].y, this._wrappedNormalsForBabylon[l].z);\n                }\n                if (this._wrappedUvsForBabylon.length) {\n                    this._unwrappedUVForBabylon.push(this._wrappedUvsForBabylon[l].x, this._wrappedUvsForBabylon[l].y); //z is an optional value not supported by BABYLON\n                }\n                if (this._unwrappedColorsForBabylon.length) {\n                    //Push the r, g, b, a values of each element in the unwrapped array\n                    this._unwrappedColorsForBabylon.push(this._wrappedColorsForBabylon[l].r, this._wrappedColorsForBabylon[l].g, this._wrappedColorsForBabylon[l].b, this._wrappedColorsForBabylon[l].a);\n                }\n            }\n            // Reset arrays for the next new meshes\n            this._wrappedPositionForBabylon.length = 0;\n            this._wrappedNormalsForBabylon.length = 0;\n            this._wrappedUvsForBabylon.length = 0;\n            this._wrappedColorsForBabylon.length = 0;\n            this._tuplePosNorm.length = 0;\n            this._curPositionInIndices = 0;\n        }\n        catch (e) {\n            throw new Error(\"Unable to unwrap data while parsing OBJ data.\");\n        }\n    }\n    /**\n     * Create triangles from polygons\n     * It is important to notice that a triangle is a polygon\n     * We get 5 patterns of face defined in OBJ File :\n     * facePattern1 = [\"1\",\"2\",\"3\",\"4\",\"5\",\"6\"]\n     * facePattern2 = [\"1/1\",\"2/2\",\"3/3\",\"4/4\",\"5/5\",\"6/6\"]\n     * facePattern3 = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"4/4/4\",\"5/5/5\",\"6/6/6\"]\n     * facePattern4 = [\"1//1\",\"2//2\",\"3//3\",\"4//4\",\"5//5\",\"6//6\"]\n     * facePattern5 = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-4/-4/-4\",\"-5/-5/-5\",\"-6/-6/-6\"]\n     * Each pattern is divided by the same method\n     * @param faces Array[String] The indices of elements\n     * @param v Integer The variable to increment\n     */\n    _getTriangles(faces, v) {\n        //Work for each element of the array\n        for (let faceIndex = v; faceIndex < faces.length - 1; faceIndex++) {\n            //Add on the triangle variable the indexes to obtain triangles\n            this._pushTriangle(faces, faceIndex);\n        }\n        //Result obtained after 2 iterations:\n        //Pattern1 => triangle = [\"1\",\"2\",\"3\",\"1\",\"3\",\"4\"];\n        //Pattern2 => triangle = [\"1/1\",\"2/2\",\"3/3\",\"1/1\",\"3/3\",\"4/4\"];\n        //Pattern3 => triangle = [\"1/1/1\",\"2/2/2\",\"3/3/3\",\"1/1/1\",\"3/3/3\",\"4/4/4\"];\n        //Pattern4 => triangle = [\"1//1\",\"2//2\",\"3//3\",\"1//1\",\"3//3\",\"4//4\"];\n        //Pattern5 => triangle = [\"-1/-1/-1\",\"-2/-2/-2\",\"-3/-3/-3\",\"-1/-1/-1\",\"-3/-3/-3\",\"-4/-4/-4\"];\n    }\n    /**\n     * To get color between color and extension color\n     * @param index Integer The index of the element in the array\n     * @returns value of target color\n     */\n    _getColor(index) {\n        if (this._loadingOptions.importVertexColors) {\n            return this._extColors[index] ?? this._colors[index];\n        }\n        else {\n            return undefined;\n        }\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 1\n     * In this pattern we get vertice positions\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern1(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        //For each element in the triangles array.\n        //This var could contains 1 to an infinity of triangles\n        for (let k = 0; k < this._triangles.length; k++) {\n            // Set position indice\n            const indicePositionFromObj = parseInt(this._triangles[k]) - 1;\n            this._setData({\n                indicePositionFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 2\n     * In this pattern we get vertice positions and uvs\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern2(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1/1\"\n            //Split the data for getting position and uv\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\"]\n            //Set position indice\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            //Set uv indice\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\n            this._setData({\n                indicePositionFromObj,\n                indiceUvsFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 3\n     * In this pattern we get vertice positions, uvs and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern3(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1/1/1\"\n            //Split the data for getting position, uv, and normals\n            const point = this._triangles[k].split(\"/\"); // [\"1\", \"1\", \"1\"]\n            // Set position indice\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            // Set uv indice\n            const indiceUvsFromObj = parseInt(point[1]) - 1;\n            // Set normal indice\n            const indiceNormalFromObj = parseInt(point[2]) - 1;\n            this._setData({\n                indicePositionFromObj,\n                indiceUvsFromObj,\n                indiceNormalFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /**\n     * Create triangles and push the data for each polygon for the pattern 4\n     * In this pattern we get vertice positions and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern4(face, v) {\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"1//1\"\n            //Split the data for getting position and normals\n            const point = this._triangles[k].split(\"//\"); // [\"1\", \"1\"]\n            // We check indices, and normals\n            const indicePositionFromObj = parseInt(point[0]) - 1;\n            const indiceNormalFromObj = parseInt(point[1]) - 1;\n            this._setData({\n                indicePositionFromObj,\n                indiceNormalFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    /*\n     * Create triangles and push the data for each polygon for the pattern 3\n     * In this pattern we get vertice positions, uvs and normals\n     * @param face\n     * @param v\n     */\n    _setDataForCurrentFaceWithPattern5(face, v) {\n        //Get the indices of triangles for each polygon\n        this._getTriangles(face, v);\n        for (let k = 0; k < this._triangles.length; k++) {\n            //triangle[k] = \"-1/-1/-1\"\n            //Split the data for getting position, uv, and normals\n            const point = this._triangles[k].split(\"/\"); // [\"-1\", \"-1\", \"-1\"]\n            // Set position indice\n            const indicePositionFromObj = this._positions.length + parseInt(point[0]);\n            // Set uv indice\n            const indiceUvsFromObj = this._uvs.length + parseInt(point[1]);\n            // Set normal indice\n            const indiceNormalFromObj = this._normals.length + parseInt(point[2]);\n            this._setData({\n                indicePositionFromObj,\n                indiceUvsFromObj,\n                indiceNormalFromObj,\n                positionVectorFromOBJ: this._positions[indicePositionFromObj],\n                textureVectorFromOBJ: this._uvs[indiceUvsFromObj],\n                normalsVectorFromOBJ: this._normals[indiceNormalFromObj],\n                positionColorsFromOBJ: this._getColor(indicePositionFromObj),\n            });\n        }\n        //Reset variable for the next line\n        this._triangles.length = 0;\n    }\n    _addPreviousObjMesh() {\n        //Check if it is not the first mesh. Otherwise we don't have data.\n        if (this._meshesFromObj.length > 0) {\n            //Get the previous mesh for applying the data about the faces\n            //=> in obj file, faces definition append after the name of the mesh\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n            //Set the data into Array for the mesh\n            this._unwrapData();\n            if (this._loadingOptions.useLegacyBehavior) {\n                // Reverse tab. Otherwise face are displayed in the wrong sens\n                this._indicesForBabylon.reverse();\n            }\n            //Set the information for the mesh\n            //Slice the array to avoid rewriting because of the fact this is the same var which be rewrited\n            this._handledMesh.indices = this._indicesForBabylon.slice();\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon.slice();\n            if (this._unwrappedNormalsForBabylon.length) {\n                this._handledMesh.normals = this._unwrappedNormalsForBabylon.slice();\n            }\n            if (this._unwrappedUVForBabylon.length) {\n                this._handledMesh.uvs = this._unwrappedUVForBabylon.slice();\n            }\n            if (this._unwrappedColorsForBabylon.length) {\n                this._handledMesh.colors = this._unwrappedColorsForBabylon.slice();\n            }\n            this._handledMesh.hasLines = this._hasLineData;\n            //Reset the array for the next mesh\n            this._indicesForBabylon.length = 0;\n            this._unwrappedPositionsForBabylon.length = 0;\n            this._unwrappedColorsForBabylon.length = 0;\n            this._unwrappedNormalsForBabylon.length = 0;\n            this._unwrappedUVForBabylon.length = 0;\n            this._hasLineData = false;\n        }\n    }\n    _optimizeNormals(mesh) {\n        const positions = mesh.getVerticesData(VertexBuffer.PositionKind);\n        const normals = mesh.getVerticesData(VertexBuffer.NormalKind);\n        const mapVertices = {};\n        if (!positions || !normals) {\n            return;\n        }\n        for (let i = 0; i < positions.length / 3; i++) {\n            const x = positions[i * 3 + 0];\n            const y = positions[i * 3 + 1];\n            const z = positions[i * 3 + 2];\n            const key = x + \"_\" + y + \"_\" + z;\n            let lst = mapVertices[key];\n            if (!lst) {\n                lst = [];\n                mapVertices[key] = lst;\n            }\n            lst.push(i);\n        }\n        const normal = new Vector3();\n        for (const key in mapVertices) {\n            const lst = mapVertices[key];\n            if (lst.length < 2) {\n                continue;\n            }\n            const v0Idx = lst[0];\n            for (let i = 1; i < lst.length; ++i) {\n                const vIdx = lst[i];\n                normals[v0Idx * 3 + 0] += normals[vIdx * 3 + 0];\n                normals[v0Idx * 3 + 1] += normals[vIdx * 3 + 1];\n                normals[v0Idx * 3 + 2] += normals[vIdx * 3 + 2];\n            }\n            normal.copyFromFloats(normals[v0Idx * 3 + 0], normals[v0Idx * 3 + 1], normals[v0Idx * 3 + 2]);\n            normal.normalize();\n            for (let i = 0; i < lst.length; ++i) {\n                const vIdx = lst[i];\n                normals[vIdx * 3 + 0] = normal.x;\n                normals[vIdx * 3 + 1] = normal.y;\n                normals[vIdx * 3 + 2] = normal.z;\n            }\n        }\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n    }\n    static _IsLineElement(line) {\n        return line.startsWith(\"l\");\n    }\n    static _IsObjectElement(line) {\n        return line.startsWith(\"o\");\n    }\n    static _IsGroupElement(line) {\n        return line.startsWith(\"g\");\n    }\n    static _GetZbrushMRGB(line, notParse) {\n        if (!line.startsWith(\"mrgb\")) {\n            return null;\n        }\n        line = line.replace(\"mrgb\", \"\").trim();\n        // if include vertex color , not load mrgb anymore\n        if (notParse) {\n            return [];\n        }\n        const regex = /[a-z0-9]/g;\n        const regArray = line.match(regex);\n        if (!regArray || regArray.length % 8 !== 0) {\n            return [];\n        }\n        const array = [];\n        for (let regIndex = 0; regIndex < regArray.length / 8; regIndex++) {\n            //each item is MMRRGGBB, m is material index\n            // const m = regArray[regIndex * 8 + 0] + regArray[regIndex * 8 + 1];\n            const r = regArray[regIndex * 8 + 2] + regArray[regIndex * 8 + 3];\n            const g = regArray[regIndex * 8 + 4] + regArray[regIndex * 8 + 5];\n            const b = regArray[regIndex * 8 + 6] + regArray[regIndex * 8 + 7];\n            array.push(new Color4(parseInt(r, 16) / 255, parseInt(g, 16) / 255, parseInt(b, 16) / 255, 1));\n        }\n        return array;\n    }\n    /**\n     * Function used to parse an OBJ string\n     * @param meshesNames defines the list of meshes to load (all if not defined)\n     * @param data defines the OBJ string\n     * @param scene defines the hosting scene\n     * @param assetContainer defines the asset container to load data in\n     * @param onFileToLoadFound defines a callback that will be called if a MTL file is found\n     */\n    parse(meshesNames, data, scene, assetContainer, onFileToLoadFound) {\n        //Move Santitize here to forbid delete zbrush data\n        // Sanitize data\n        data = data.replace(/#MRGB/g, \"mrgb\");\n        data = data.replace(/#.*$/gm, \"\").trim();\n        if (this._loadingOptions.useLegacyBehavior) {\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n            this._handednessSign = 1;\n        }\n        else if (scene.useRightHandedSystem) {\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex + 1], faces[faceIndex]);\n            this._handednessSign = 1;\n        }\n        else {\n            this._pushTriangle = (faces, faceIndex) => this._triangles.push(faces[0], faces[faceIndex], faces[faceIndex + 1]);\n            this._handednessSign = -1;\n        }\n        // Split the file into lines\n        // Preprocess line data\n        const linesOBJ = data.split(\"\\n\");\n        const lineLines = [];\n        let currentGroup = [];\n        lineLines.push(currentGroup);\n        for (let i = 0; i < linesOBJ.length; i++) {\n            const line = linesOBJ[i].trim().replace(/\\s\\s/g, \" \");\n            // Comment or newLine\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            if (SolidParser._IsGroupElement(line) || SolidParser._IsObjectElement(line)) {\n                currentGroup = [];\n                lineLines.push(currentGroup);\n            }\n            if (SolidParser._IsLineElement(line)) {\n                const lineValues = line.split(\" \");\n                // create line elements with two vertices only\n                for (let i = 1; i < lineValues.length - 1; i++) {\n                    currentGroup.push(`l ${lineValues[i]} ${lineValues[i + 1]}`);\n                }\n            }\n            else {\n                currentGroup.push(line);\n            }\n        }\n        const lines = lineLines.flat();\n        // Look at each line\n        for (let i = 0; i < lines.length; i++) {\n            const line = lines[i].trim().replace(/\\s\\s/g, \" \");\n            let result;\n            // Comment or newLine\n            if (line.length === 0 || line.charAt(0) === \"#\") {\n                continue;\n            }\n            else if (SolidParser.VertexPattern.test(line)) {\n                //Get information about one position possible for the vertices\n                result = line.match(/[^ ]+/g); // match will return non-null due to passing regex pattern\n                // Value of result with line: \"v 1.0 2.0 3.0\"\n                // [\"v\", \"1.0\", \"2.0\", \"3.0\"]\n                // Create a Vector3 with the position x, y, z\n                this._positions.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n                if (this._loadingOptions.importVertexColors) {\n                    if (result.length >= 7) {\n                        const r = parseFloat(result[4]);\n                        const g = parseFloat(result[5]);\n                        const b = parseFloat(result[6]);\n                        this._colors.push(new Color4(r > 1 ? r / 255 : r, g > 1 ? g / 255 : g, b > 1 ? b / 255 : b, result.length === 7 || result[7] === undefined ? 1 : parseFloat(result[7])));\n                    }\n                    else {\n                        // TODO: maybe push NULL and if all are NULL to skip (and remove grayColor var).\n                        this._colors.push(this._grayColor);\n                    }\n                }\n            }\n            else if ((result = SolidParser.NormalPattern.exec(line)) !== null) {\n                //Create a Vector3 with the normals x, y, z\n                //Value of result\n                // [\"vn 1.0 2.0 3.0\", \"1.0\", \"2.0\", \"3.0\"]\n                //Add the Vector in the list of normals\n                this._normals.push(new Vector3(parseFloat(result[1]), parseFloat(result[2]), parseFloat(result[3])));\n            }\n            else if ((result = SolidParser.UVPattern.exec(line)) !== null) {\n                //Create a Vector2 with the normals u, v\n                //Value of result\n                // [\"vt 0.1 0.2 0.3\", \"0.1\", \"0.2\"]\n                //Add the Vector in the list of uvs\n                this._uvs.push(new Vector2(parseFloat(result[1]) * this._loadingOptions.UVScaling.x, parseFloat(result[2]) * this._loadingOptions.UVScaling.y));\n                //Identify patterns of faces\n                //Face could be defined in different type of pattern\n            }\n            else if ((result = SolidParser.FacePattern3.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1/1 2/2/2 3/3/3\", \"1/1/1 2/2/2 3/3/3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\", \"3/3/3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern4.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1//1 2//2 3//3\", \"1//1 2//2 3//3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern4(result[1].trim().split(\" \"), // [\"1//1\", \"2//2\", \"3//3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern5.exec(line)) !== null) {\n                //Value of result:\n                //[\"f -1/-1/-1 -2/-2/-2 -3/-3/-3\", \"-1/-1/-1 -2/-2/-2 -3/-3/-3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern5(result[1].trim().split(\" \"), // [\"-1/-1/-1\", \"-2/-2/-2\", \"-3/-3/-3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern2.exec(line)) !== null) {\n                //Value of result:\n                //[\"f 1/1 2/2 3/3\", \"1/1 2/2 3/3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"), // [\"1/1\", \"2/2\", \"3/3\"]\n                1);\n            }\n            else if ((result = SolidParser.FacePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"f 1 2 3\", \"1 2 3\"...]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"), // [\"1\", \"2\", \"3\"]\n                1);\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if ((result = SolidParser.LinePattern1.exec(line)) !== null) {\n                //Value of result\n                //[\"l 1 2\"]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern1(result[1].trim().split(\" \"), // [\"1\", \"2\"]\n                0);\n                this._hasLineData = true;\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if ((result = SolidParser.LinePattern2.exec(line)) !== null) {\n                //Value of result\n                //[\"l 1/1 2/2\"]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern2(result[1].trim().split(\" \"), // [\"1/1\", \"2/2\"]\n                0);\n                this._hasLineData = true;\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if ((result = SolidParser._GetZbrushMRGB(line, !this._loadingOptions.importVertexColors))) {\n                for (const element of result) {\n                    this._extColors.push(element);\n                }\n            }\n            else if ((result = SolidParser.LinePattern3.exec(line)) !== null) {\n                //Value of result\n                //[\"l 1/1/1 2/2/2\"]\n                //Set the data for this face\n                this._setDataForCurrentFaceWithPattern3(result[1].trim().split(\" \"), // [\"1/1/1\", \"2/2/2\"]\n                0);\n                this._hasLineData = true;\n                // Define a mesh or an object\n                // Each time this keyword is analyzed, create a new Object with all data for creating a babylonMesh\n            }\n            else if (SolidParser.GroupDescriptor.test(line) || SolidParser.ObjectDescriptor.test(line)) {\n                // Create a new mesh corresponding to the name of the group.\n                // Definition of the mesh\n                const objMesh = {\n                    name: line.substring(2).trim(), //Set the name of the current obj mesh\n                    indices: null,\n                    positions: null,\n                    normals: null,\n                    uvs: null,\n                    colors: null,\n                    materialName: this._materialNameFromObj,\n                    isObject: SolidParser.ObjectDescriptor.test(line),\n                };\n                this._addPreviousObjMesh();\n                //Push the last mesh created with only the name\n                this._meshesFromObj.push(objMesh);\n                //Set this variable to indicate that now meshesFromObj has objects defined inside\n                this._hasMeshes = true;\n                this._isFirstMaterial = true;\n                this._increment = 1;\n                //Keyword for applying a material\n            }\n            else if (SolidParser.UseMtlDescriptor.test(line)) {\n                //Get the name of the material\n                this._materialNameFromObj = line.substring(7).trim();\n                //If this new material is in the same mesh\n                if (!this._isFirstMaterial || !this._hasMeshes) {\n                    //Set the data for the previous mesh\n                    this._addPreviousObjMesh();\n                    //Create a new mesh\n                    const objMesh = \n                    //Set the name of the current obj mesh\n                    {\n                        name: (this._objMeshName || \"mesh\") + \"_mm\" + this._increment.toString(), //Set the name of the current obj mesh\n                        indices: null,\n                        positions: null,\n                        normals: null,\n                        uvs: null,\n                        colors: null,\n                        materialName: this._materialNameFromObj,\n                        isObject: false,\n                    };\n                    this._increment++;\n                    //If meshes are already defined\n                    this._meshesFromObj.push(objMesh);\n                    this._hasMeshes = true;\n                }\n                //Set the material name if the previous line define a mesh\n                if (this._hasMeshes && this._isFirstMaterial) {\n                    //Set the material name to the previous mesh (1 material per mesh)\n                    this._meshesFromObj[this._meshesFromObj.length - 1].materialName = this._materialNameFromObj;\n                    this._isFirstMaterial = false;\n                }\n                // Keyword for loading the mtl file\n            }\n            else if (SolidParser.MtlLibGroupDescriptor.test(line)) {\n                // Get the name of mtl file\n                onFileToLoadFound(line.substring(7).trim());\n                // Apply smoothing\n            }\n            else if (SolidParser.SmoothDescriptor.test(line)) {\n                // smooth shading => apply smoothing\n                // Today I don't know it work with babylon and with obj.\n                // With the obj file  an integer is set\n            }\n            else {\n                //If there is another possibility\n                Logger.Log(\"Unhandled expression at line : \" + line);\n            }\n        }\n        // At the end of the file, add the last mesh into the meshesFromObj array\n        if (this._hasMeshes) {\n            // Set the data for the last mesh\n            this._handledMesh = this._meshesFromObj[this._meshesFromObj.length - 1];\n            if (this._loadingOptions.useLegacyBehavior) {\n                //Reverse indices for displaying faces in the good sense\n                this._indicesForBabylon.reverse();\n            }\n            //Get the good array\n            this._unwrapData();\n            //Set array\n            this._handledMesh.indices = this._indicesForBabylon;\n            this._handledMesh.positions = this._unwrappedPositionsForBabylon;\n            if (this._unwrappedNormalsForBabylon.length) {\n                this._handledMesh.normals = this._unwrappedNormalsForBabylon;\n            }\n            if (this._unwrappedUVForBabylon.length) {\n                this._handledMesh.uvs = this._unwrappedUVForBabylon;\n            }\n            if (this._unwrappedColorsForBabylon.length) {\n                this._handledMesh.colors = this._unwrappedColorsForBabylon;\n            }\n            this._handledMesh.hasLines = this._hasLineData;\n        }\n        // If any o or g keyword not found, create a mesh with a random id\n        if (!this._hasMeshes) {\n            let newMaterial = null;\n            if (this._indicesForBabylon.length) {\n                if (this._loadingOptions.useLegacyBehavior) {\n                    // reverse tab of indices\n                    this._indicesForBabylon.reverse();\n                }\n                //Get positions normals uvs\n                this._unwrapData();\n            }\n            else {\n                // There is no indices in the file. We will have to switch to point cloud rendering\n                for (const pos of this._positions) {\n                    this._unwrappedPositionsForBabylon.push(pos.x, pos.y, pos.z);\n                }\n                if (this._normals.length) {\n                    for (const normal of this._normals) {\n                        this._unwrappedNormalsForBabylon.push(normal.x, normal.y, normal.z);\n                    }\n                }\n                if (this._uvs.length) {\n                    for (const uv of this._uvs) {\n                        this._unwrappedUVForBabylon.push(uv.x, uv.y);\n                    }\n                }\n                if (this._extColors.length) {\n                    for (const color of this._extColors) {\n                        this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\n                    }\n                }\n                else {\n                    if (this._colors.length) {\n                        for (const color of this._colors) {\n                            this._unwrappedColorsForBabylon.push(color.r, color.g, color.b, color.a);\n                        }\n                    }\n                }\n                if (!this._materialNameFromObj) {\n                    // Create a material with point cloud on\n                    newMaterial = new StandardMaterial(Geometry.RandomId(), scene);\n                    newMaterial.pointsCloud = true;\n                    this._materialNameFromObj = newMaterial.name;\n                    if (!this._normals.length) {\n                        newMaterial.disableLighting = true;\n                        newMaterial.emissiveColor = Color3.White();\n                    }\n                }\n            }\n            //Set data for one mesh\n            this._meshesFromObj.push({\n                name: Geometry.RandomId(),\n                indices: this._indicesForBabylon,\n                positions: this._unwrappedPositionsForBabylon,\n                colors: this._unwrappedColorsForBabylon,\n                normals: this._unwrappedNormalsForBabylon,\n                uvs: this._unwrappedUVForBabylon,\n                materialName: this._materialNameFromObj,\n                directMaterial: newMaterial,\n                isObject: true,\n                hasLines: this._hasLineData,\n            });\n        }\n        //Set data for each mesh\n        for (let j = 0; j < this._meshesFromObj.length; j++) {\n            //check meshesNames (stlFileLoader)\n            if (meshesNames && this._meshesFromObj[j].name) {\n                if (meshesNames instanceof Array) {\n                    if (meshesNames.indexOf(this._meshesFromObj[j].name) === -1) {\n                        continue;\n                    }\n                }\n                else {\n                    if (this._meshesFromObj[j].name !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n            //Get the current mesh\n            //Set the data with VertexBuffer for each mesh\n            this._handledMesh = this._meshesFromObj[j];\n            //Create a Mesh with the name of the obj mesh\n            scene._blockEntityCollection = !!assetContainer;\n            const babylonMesh = new Mesh(this._meshesFromObj[j].name, scene);\n            babylonMesh._parentContainer = assetContainer;\n            scene._blockEntityCollection = false;\n            this._handledMesh._babylonMesh = babylonMesh;\n            // If this is a group mesh, it should have an object mesh as a parent. So look for the first object mesh that appears before it.\n            if (!this._handledMesh.isObject) {\n                for (let k = j - 1; k >= 0; --k) {\n                    if (this._meshesFromObj[k].isObject && this._meshesFromObj[k]._babylonMesh) {\n                        babylonMesh.parent = this._meshesFromObj[k]._babylonMesh;\n                        break;\n                    }\n                }\n            }\n            //Push the name of the material to an array\n            //This is indispensable for the importMesh function\n            this._materialToUse.push(this._meshesFromObj[j].materialName);\n            //If the mesh is a line mesh\n            if (this._handledMesh.hasLines) {\n                babylonMesh._internalMetadata ??= {};\n                babylonMesh._internalMetadata[\"_isLine\"] = true; //this is a line mesh\n            }\n            if (this._handledMesh.positions?.length === 0) {\n                //Push the mesh into an array\n                this._babylonMeshesArray.push(babylonMesh);\n                continue;\n            }\n            const vertexData = new VertexData(); //The container for the values\n            //Set the data for the babylonMesh\n            vertexData.indices = this._handledMesh.indices;\n            vertexData.positions = this._handledMesh.positions;\n            if (this._loadingOptions.computeNormals || !this._handledMesh.normals) {\n                // Compute normals if requested or if normals are not defined\n                const normals = new Array();\n                VertexData.ComputeNormals(this._handledMesh.positions, this._handledMesh.indices, normals);\n                vertexData.normals = normals;\n            }\n            else {\n                vertexData.normals = this._handledMesh.normals;\n            }\n            if (this._handledMesh.uvs) {\n                vertexData.uvs = this._handledMesh.uvs;\n            }\n            if (this._handledMesh.colors) {\n                vertexData.colors = this._handledMesh.colors;\n            }\n            //Set the data from the VertexBuffer to the current Mesh\n            vertexData.applyToMesh(babylonMesh);\n            if (this._loadingOptions.invertY) {\n                babylonMesh.scaling.y *= -1;\n            }\n            if (this._loadingOptions.optimizeNormals) {\n                this._optimizeNormals(babylonMesh);\n            }\n            //Push the mesh into an array\n            this._babylonMeshesArray.push(babylonMesh);\n            if (this._handledMesh.directMaterial) {\n                babylonMesh.material = this._handledMesh.directMaterial;\n            }\n        }\n    }\n}\n// Descriptor\n/** Object descriptor */\nSolidParser.ObjectDescriptor = /^o/;\n/** Group descriptor */\nSolidParser.GroupDescriptor = /^g/;\n/** Material lib descriptor */\nSolidParser.MtlLibGroupDescriptor = /^mtllib /;\n/** Use a material descriptor */\nSolidParser.UseMtlDescriptor = /^usemtl /;\n/** Smooth descriptor */\nSolidParser.SmoothDescriptor = /^s /;\n// Patterns\n/** Pattern used to detect a vertex */\nSolidParser.VertexPattern = /^v(\\s+[\\d|.|+|\\-|e|E]+){3,7}/;\n/** Pattern used to detect a normal */\nSolidParser.NormalPattern = /^vn(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a UV set */\nSolidParser.UVPattern = /^vt(\\s+[\\d|.|+|\\-|e|E]+)( +[\\d|.|+|\\-|e|E]+)/;\n/** Pattern used to detect a first kind of face (f vertex vertex vertex) */\nSolidParser.FacePattern1 = /^f\\s+(([\\d]{1,}[\\s]?){3,})+/;\n/** Pattern used to detect a second kind of face (f vertex/uvs vertex/uvs vertex/uvs) */\nSolidParser.FacePattern2 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a third kind of face (f vertex/uvs/normal vertex/uvs/normal vertex/uvs/normal) */\nSolidParser.FacePattern3 = /^f\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fourth kind of face (f vertex//normal vertex//normal vertex//normal)*/\nSolidParser.FacePattern4 = /^f\\s+((([\\d]{1,}\\/\\/[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a fifth kind of face (f -vertex/-uvs/-normal -vertex/-uvs/-normal -vertex/-uvs/-normal) */\nSolidParser.FacePattern5 = /^f\\s+(((-[\\d]{1,}\\/-[\\d]{1,}\\/-[\\d]{1,}[\\s]?){3,})+)/;\n/** Pattern used to detect a line(l vertex vertex) */\nSolidParser.LinePattern1 = /^l\\s+(([\\d]{1,}[\\s]?){2,})+/;\n/** Pattern used to detect a second kind of line (l vertex/uvs vertex/uvs) */\nSolidParser.LinePattern2 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\n/** Pattern used to detect a third kind of line (l vertex/uvs/normal vertex/uvs/normal) */\nSolidParser.LinePattern3 = /^l\\s+((([\\d]{1,}\\/[\\d]{1,}\\/[\\d]{1,}[\\s]?){2,})+)/;\n//# sourceMappingURL=solidParser.js.map","import { Vector2 } from \"core/Maths/math.vector\";\nimport { Tools } from \"core/Misc/tools\";\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\nimport { AssetContainer } from \"core/assetContainer\";\nimport { OBJFileLoaderMetadata } from \"./objFileLoader.metadata\";\nimport { MTLFileLoader } from \"./mtlFileLoader\";\nimport { SolidParser } from \"./solidParser\";\nimport { StandardMaterial } from \"core/Materials/standardMaterial\";\n/**\n * OBJ file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class OBJFileLoader {\n    /**\n     * Invert Y-Axis of referenced textures on load\n     */\n    static get INVERT_TEXTURE_Y() {\n        return MTLFileLoader.INVERT_TEXTURE_Y;\n    }\n    static set INVERT_TEXTURE_Y(value) {\n        MTLFileLoader.INVERT_TEXTURE_Y = value;\n    }\n    /**\n     * Creates loader for .OBJ files\n     *\n     * @param loadingOptions options for loading and parsing OBJ/MTL files.\n     */\n    constructor(loadingOptions) {\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = OBJFileLoaderMetadata.name;\n        /**\n         * Defines the extension the plugin is able to load.\n         */\n        this.extensions = OBJFileLoaderMetadata.extensions;\n        this._assetContainer = null;\n        this._loadingOptions = { ...OBJFileLoader._DefaultLoadingOptions, ...(loadingOptions ?? {}) };\n    }\n    static get _DefaultLoadingOptions() {\n        return {\n            computeNormals: OBJFileLoader.COMPUTE_NORMALS,\n            optimizeNormals: OBJFileLoader.OPTIMIZE_NORMALS,\n            importVertexColors: OBJFileLoader.IMPORT_VERTEX_COLORS,\n            invertY: OBJFileLoader.INVERT_Y,\n            invertTextureY: OBJFileLoader.INVERT_TEXTURE_Y,\n            // eslint-disable-next-line @typescript-eslint/naming-convention\n            UVScaling: OBJFileLoader.UV_SCALING,\n            materialLoadingFailsSilently: OBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY,\n            optimizeWithUV: OBJFileLoader.OPTIMIZE_WITH_UV,\n            skipMaterials: OBJFileLoader.SKIP_MATERIALS,\n            useLegacyBehavior: OBJFileLoader.USE_LEGACY_BEHAVIOR,\n        };\n    }\n    /**\n     * Calls synchronously the MTL file attached to this obj.\n     * Load function or importMesh function don't enable to load 2 files in the same time asynchronously.\n     * Without this function materials are not displayed in the first frame (but displayed after).\n     * In consequence it is impossible to get material information in your HTML file\n     *\n     * @param url The URL of the MTL file\n     * @param rootUrl defines where to load data from\n     * @param onSuccess Callback function to be called when the MTL file is loaded\n     * @param onFailure\n     */\n    _loadMTL(url, rootUrl, onSuccess, onFailure) {\n        //The complete path to the mtl file\n        const pathOfFile = rootUrl + url;\n        // Loads through the babylon tools to allow fileInput search.\n        Tools.LoadFile(pathOfFile, onSuccess, undefined, undefined, false, (request, exception) => {\n            onFailure(pathOfFile, exception);\n        });\n    }\n    /** @internal */\n    createPlugin(options) {\n        return new OBJFileLoader(options[OBJFileLoaderMetadata.name]);\n    }\n    /**\n     * If the data string can be loaded directly.\n     * @returns if the data can be loaded directly\n     */\n    canDirectLoad() {\n        return false;\n    }\n    /**\n     * Imports one or more meshes from the loaded OBJ data and adds them to the scene\n     * @param meshesNames a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene the scene the meshes should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise containing the loaded meshes, particles, skeletons and animations\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    importMeshAsync(meshesNames, scene, data, rootUrl) {\n        //get the meshes from OBJ file\n        // eslint-disable-next-line github/no-then\n        return this._parseSolidAsync(meshesNames, scene, data, rootUrl).then((meshes) => {\n            return {\n                meshes: meshes,\n                particleSystems: [],\n                skeletons: [],\n                animationGroups: [],\n                transformNodes: [],\n                geometries: [],\n                lights: [],\n                spriteManagers: [],\n            };\n        });\n    }\n    /**\n     * Imports all objects from the loaded OBJ data and adds them to the scene\n     * @param scene the scene the objects should be added to\n     * @param data the OBJ data to load\n     * @param rootUrl root url to load from\n     * @returns a promise which completes when objects have been loaded to the scene\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadAsync(scene, data, rootUrl) {\n        //Get the 3D model\n        // eslint-disable-next-line github/no-then\n        return this.importMeshAsync(null, scene, data, rootUrl).then(() => {\n            // return void\n        });\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    loadAssetContainerAsync(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        this._assetContainer = container;\n        return (this.importMeshAsync(null, scene, data, rootUrl)\n            // eslint-disable-next-line github/no-then\n            .then((result) => {\n            result.meshes.forEach((mesh) => container.meshes.push(mesh));\n            result.meshes.forEach((mesh) => {\n                const material = mesh.material;\n                if (material) {\n                    // Materials\n                    if (container.materials.indexOf(material) == -1) {\n                        container.materials.push(material);\n                        // Textures\n                        const textures = material.getActiveTextures();\n                        textures.forEach((t) => {\n                            if (container.textures.indexOf(t) == -1) {\n                                container.textures.push(t);\n                            }\n                        });\n                    }\n                }\n            });\n            this._assetContainer = null;\n            return container;\n        })\n            // eslint-disable-next-line github/no-then\n            .catch((ex) => {\n            this._assetContainer = null;\n            throw ex;\n        }));\n    }\n    /**\n     * Read the OBJ file and create an Array of meshes.\n     * Each mesh contains all information given by the OBJ and the MTL file.\n     * i.e. vertices positions and indices, optional normals values, optional UV values, optional material\n     * @param meshesNames defines a string or array of strings of the mesh names that should be loaded from the file\n     * @param scene defines the scene where are displayed the data\n     * @param data defines the content of the obj file\n     * @param rootUrl defines the path to the folder\n     * @returns the list of loaded meshes\n     */\n    // eslint-disable-next-line @typescript-eslint/promise-function-async, no-restricted-syntax\n    _parseSolidAsync(meshesNames, scene, data, rootUrl) {\n        let fileToLoad = \"\"; //The name of the mtlFile to load\n        const materialsFromMTLFile = new MTLFileLoader();\n        const materialToUse = [];\n        const babylonMeshesArray = []; //The mesh for babylon\n        // Sanitize data\n        data = data.replace(/#.*$/gm, \"\").trim();\n        // Main function\n        const solidParser = new SolidParser(materialToUse, babylonMeshesArray, this._loadingOptions);\n        solidParser.parse(meshesNames, data, scene, this._assetContainer, (fileName) => {\n            fileToLoad = fileName;\n        });\n        // load the materials\n        const mtlPromises = [];\n        // Check if we have a file to load\n        if (fileToLoad !== \"\" && !this._loadingOptions.skipMaterials) {\n            //Load the file synchronously\n            mtlPromises.push(new Promise((resolve, reject) => {\n                this._loadMTL(fileToLoad, rootUrl, (dataLoaded) => {\n                    try {\n                        //Create materials thanks MTLLoader function\n                        materialsFromMTLFile.parseMTL(scene, dataLoaded, rootUrl, this._assetContainer);\n                        //Look at each material loaded in the mtl file\n                        for (let n = 0; n < materialsFromMTLFile.materials.length; n++) {\n                            //Three variables to get all meshes with the same material\n                            let startIndex = 0;\n                            const _indices = [];\n                            let _index;\n                            //The material from MTL file is used in the meshes loaded\n                            //Push the indice in an array\n                            //Check if the material is not used for another mesh\n                            while ((_index = materialToUse.indexOf(materialsFromMTLFile.materials[n].name, startIndex)) > -1) {\n                                _indices.push(_index);\n                                startIndex = _index + 1;\n                            }\n                            //If the material is not used dispose it\n                            if (_index === -1 && _indices.length === 0) {\n                                //If the material is not needed, remove it\n                                materialsFromMTLFile.materials[n].dispose();\n                            }\n                            else {\n                                for (let o = 0; o < _indices.length; o++) {\n                                    //Apply the material to the Mesh for each mesh with the material\n                                    const mesh = babylonMeshesArray[_indices[o]];\n                                    const material = materialsFromMTLFile.materials[n];\n                                    mesh.material = material;\n                                    if (!mesh.getTotalIndices()) {\n                                        // No indices, we need to turn on point cloud\n                                        material.pointsCloud = true;\n                                    }\n                                }\n                            }\n                        }\n                        resolve();\n                    }\n                    catch (e) {\n                        Tools.Warn(`Error processing MTL file: '${fileToLoad}'`);\n                        if (this._loadingOptions.materialLoadingFailsSilently) {\n                            resolve();\n                        }\n                        else {\n                            // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                            reject(e);\n                        }\n                    }\n                }, (pathOfFile, exception) => {\n                    Tools.Warn(`Error downloading MTL file: '${fileToLoad}'`);\n                    if (this._loadingOptions.materialLoadingFailsSilently) {\n                        resolve();\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(exception);\n                    }\n                });\n            }));\n        }\n        //Return an array with all Mesh\n        // eslint-disable-next-line github/no-then\n        return Promise.all(mtlPromises).then(() => {\n            const isLine = (mesh) => Boolean(mesh._internalMetadata?.[\"_isLine\"] ?? false);\n            // Iterate over the mesh, determine if it is a line mesh, clone or modify the material to line rendering.\n            babylonMeshesArray.forEach((mesh) => {\n                if (isLine(mesh)) {\n                    let mat = mesh.material ?? new StandardMaterial(mesh.name + \"_line\", scene);\n                    // If another mesh is using this material and it is not a line then we need to clone it.\n                    const needClone = mat.getBindedMeshes().filter((e) => !isLine(e)).length > 0;\n                    if (needClone) {\n                        mat = mat.clone(mat.name + \"_line\") ?? mat;\n                    }\n                    mat.wireframe = true;\n                    mesh.material = mat;\n                    if (mesh._internalMetadata) {\n                        mesh._internalMetadata[\"_isLine\"] = undefined;\n                    }\n                }\n            });\n            return babylonMeshesArray;\n        });\n    }\n}\n/**\n * Defines if UVs are optimized by default during load.\n */\nOBJFileLoader.OPTIMIZE_WITH_UV = true;\n/**\n * Invert model on y-axis (does a model scaling inversion)\n */\nOBJFileLoader.INVERT_Y = false;\n/**\n * Include in meshes the vertex colors available in some OBJ files.  This is not part of OBJ standard.\n */\nOBJFileLoader.IMPORT_VERTEX_COLORS = false;\n/**\n * Compute the normals for the model, even if normals are present in the file.\n */\nOBJFileLoader.COMPUTE_NORMALS = false;\n/**\n * Optimize the normals for the model. Lighting can be uneven if you use OptimizeWithUV = true because new vertices can be created for the same location if they pertain to different faces.\n * Using OptimizehNormals = true will help smoothing the lighting by averaging the normals of those vertices.\n */\nOBJFileLoader.OPTIMIZE_NORMALS = false;\n/**\n * Defines custom scaling of UV coordinates of loaded meshes.\n */\nOBJFileLoader.UV_SCALING = new Vector2(1, 1);\n/**\n * Skip loading the materials even if defined in the OBJ file (materials are ignored).\n */\nOBJFileLoader.SKIP_MATERIALS = false;\n/**\n * When a material fails to load OBJ loader will silently fail and onSuccess() callback will be triggered.\n *\n * Defaults to true for backwards compatibility.\n */\nOBJFileLoader.MATERIAL_LOADING_FAILS_SILENTLY = true;\n/**\n * Loads assets without handedness conversions. This flag is for compatibility. Use it only if absolutely required. Defaults to false.\n */\nOBJFileLoader.USE_LEGACY_BEHAVIOR = false;\n//Add this loader into the register plugin\nRegisterSceneLoaderPlugin(new OBJFileLoader());\n//# sourceMappingURL=objFileLoader.js.map"],"names":["MTLFileLoader","constructor","this","materials","parseMTL","scene","data","rootUrl","assetContainer","ArrayBuffer","lines","split","delimiterPattern","color","material","i","length","line","trim","charAt","pos","indexOf","key","substring","toLowerCase","value","push","_blockEntityCollection","StandardMaterial","_parentContainer","map","parseFloat","diffuseColor","Color3","FromArray","ambientColor","specularColor","emissiveColor","specularPower","alpha","ambientTexture","_GetTexture","diffuseTexture","specularTexture","values","bumpMultiplierIndex","bumpMultiplier","splice","bumpTexture","join","level","opacityTexture","url","lastDelimiter","lastIndexOf","Texture","INVERT_TEXTURE_Y","SolidParser","materialToUse","babylonMeshesArray","loadingOptions","_positions","_normals","_uvs","_colors","_extColors","_meshesFromObj","_indicesForBabylon","_wrappedPositionForBabylon","_wrappedUvsForBabylon","_wrappedColorsForBabylon","_wrappedNormalsForBabylon","_tuplePosNorm","_curPositionInIndices","_hasMeshes","_unwrappedPositionsForBabylon","_unwrappedColorsForBabylon","_unwrappedNormalsForBabylon","_unwrappedUVForBabylon","_triangles","_materialNameFromObj","_objMeshName","_increment","_isFirstMaterial","_grayColor","Color4","_hasLineData","_materialToUse","_babylonMeshesArray","_loadingOptions","_isInArray","arr","obj","normals","idx","_isInArrayUV","uv","_setData","_index","indiceUvsFromObj","indiceNormalFromObj","optimizeWithUV","indicePositionFromObj","positionVectorFromOBJ","undefined","textureVectorFromOBJ","normalsVectorFromOBJ","positionColorsFromOBJ","_unwrapData","l","x","_handednessSign","y","z","r","g","b","a","e","Error","_getTriangles","faces","v","faceIndex","_pushTriangle","_getColor","index","importVertexColors","_setDataForCurrentFaceWithPattern1","face","k","parseInt","_setDataForCurrentFaceWithPattern2","point","_setDataForCurrentFaceWithPattern3","_setDataForCurrentFaceWithPattern4","_setDataForCurrentFaceWithPattern5","_addPreviousObjMesh","_handledMesh","useLegacyBehavior","reverse","indices","slice","positions","uvs","colors","hasLines","_optimizeNormals","mesh","getVerticesData","VertexBuffer","PositionKind","NormalKind","mapVertices","lst","normal","Vector3","v0Idx","vIdx","copyFromFloats","normalize","setVerticesData","_IsLineElement","startsWith","_IsObjectElement","_IsGroupElement","_GetZbrushMRGB","notParse","replace","regArray","match","array","regIndex","parse","meshesNames","onFileToLoadFound","useRightHandedSystem","linesOBJ","lineLines","currentGroup","lineValues","flat","result","VertexPattern","test","NormalPattern","exec","UVPattern","Vector2","UVScaling","FacePattern3","FacePattern4","FacePattern5","FacePattern2","FacePattern1","LinePattern1","LinePattern2","element","LinePattern3","GroupDescriptor","ObjectDescriptor","objMesh","name","materialName","isObject","UseMtlDescriptor","toString","MtlLibGroupDescriptor","SmoothDescriptor","Logger","Log","newMaterial","Geometry","RandomId","pointsCloud","disableLighting","White","directMaterial","j","Array","babylonMesh","Mesh","_babylonMesh","parent","_internalMetadata","vertexData","VertexData","computeNormals","ComputeNormals","applyToMesh","invertY","scaling","optimizeNormals","OBJFileLoader","OBJFileLoaderMetadata","extensions","_assetContainer","_DefaultLoadingOptions","COMPUTE_NORMALS","OPTIMIZE_NORMALS","IMPORT_VERTEX_COLORS","INVERT_Y","invertTextureY","UV_SCALING","materialLoadingFailsSilently","MATERIAL_LOADING_FAILS_SILENTLY","OPTIMIZE_WITH_UV","skipMaterials","SKIP_MATERIALS","USE_LEGACY_BEHAVIOR","_loadMTL","onSuccess","onFailure","pathOfFile","Tools","LoadFile","request","exception","createPlugin","options","canDirectLoad","importMeshAsync","_parseSolidAsync","then","meshes","particleSystems","skeletons","animationGroups","transformNodes","geometries","lights","spriteManagers","loadAsync","loadAssetContainerAsync","container","AssetContainer","forEach","getActiveTextures","t","textures","catch","ex","fileToLoad","materialsFromMTLFile","fileName","mtlPromises","Promise","resolve","reject","dataLoaded","n","startIndex","_indices","dispose","o","getTotalIndices","Warn","all","isLine","Boolean","mat","getBindedMeshes","filter","clone","wireframe","RegisterSceneLoaderPlugin"],"mappings":"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"}