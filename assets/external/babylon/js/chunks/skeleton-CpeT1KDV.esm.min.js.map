{"version":3,"file":"skeleton-CpeT1KDV.esm.min.js","sources":["../../../../../dev/core/dist/Bones/skeleton.js"],"sourcesContent":["import { Bone } from \"./bone\";\nimport { Observable } from \"../Misc/observable\";\nimport { Vector3, Matrix, TmpVectors } from \"../Maths/math.vector\";\nimport { RawTexture } from \"../Materials/Textures/rawTexture\";\nimport { Animation } from \"../Animations/animation\";\nimport { AnimationRange } from \"../Animations/animationRange\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Constants } from \"../Engines/constants\";\nimport { Logger } from \"../Misc/logger\";\nimport { DeepCopier } from \"../Misc/deepCopier\";\n/**\n * Class used to handle skinning animations\n * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/bonesSkeletons\n */\nexport class Skeleton {\n    /**\n     * Gets or sets a boolean indicating that bone matrices should be stored as a texture instead of using shader uniforms (default is true).\n     * Please note that this option is not available if the hardware does not support it\n     */\n    get useTextureToStoreBoneMatrices() {\n        return this._useTextureToStoreBoneMatrices;\n    }\n    set useTextureToStoreBoneMatrices(value) {\n        this._useTextureToStoreBoneMatrices = value;\n        this._markAsDirty();\n    }\n    /**\n     * Gets or sets the animation properties override\n     */\n    get animationPropertiesOverride() {\n        if (!this._animationPropertiesOverride) {\n            return this._scene.animationPropertiesOverride;\n        }\n        return this._animationPropertiesOverride;\n    }\n    set animationPropertiesOverride(value) {\n        this._animationPropertiesOverride = value;\n    }\n    /**\n     * Gets a boolean indicating that the skeleton effectively stores matrices into a texture\n     */\n    get isUsingTextureForMatrices() {\n        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;\n    }\n    /**\n     * Gets the unique ID of this skeleton\n     */\n    get uniqueId() {\n        return this._uniqueId;\n    }\n    /**\n     * Creates a new skeleton\n     * @param name defines the skeleton name\n     * @param id defines the skeleton Id\n     * @param scene defines the hosting scene\n     */\n    constructor(\n    /** defines the skeleton name */\n    name, \n    /** defines the skeleton Id */\n    id, scene) {\n        this.name = name;\n        this.id = id;\n        /**\n         * Defines the list of child bones\n         */\n        this.bones = [];\n        /**\n         * Defines a boolean indicating if the root matrix is provided by meshes or by the current skeleton (this is the default value)\n         */\n        this.needInitialSkinMatrix = false;\n        this._isDirty = true;\n        this._meshesWithPoseMatrix = new Array();\n        this._identity = Matrix.Identity();\n        this._currentRenderId = -1;\n        this._ranges = {};\n        this._absoluteTransformIsDirty = true;\n        this._canUseTextureForBones = false;\n        this._uniqueId = 0;\n        /** @internal */\n        this._numBonesWithLinkedTransformNode = 0;\n        /** @internal */\n        this._hasWaitingData = null;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * Specifies if the skeleton should be serialized\n         */\n        this.doNotSerialize = false;\n        this._useTextureToStoreBoneMatrices = true;\n        this._animationPropertiesOverride = null;\n        // Events\n        /**\n         * An observable triggered before computing the skeleton's matrices\n         */\n        this.onBeforeComputeObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the skeleton\n         */\n        this.metadata = null;\n        this.bones = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._uniqueId = this._scene.getUniqueId();\n        this._scene.addSkeleton(this);\n        //make sure it will recalculate the matrix next time prepare is called.\n        this._isDirty = true;\n        const engineCaps = this._scene.getEngine().getCaps();\n        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;\n    }\n    /**\n     * Gets the current object class name.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"Skeleton\";\n    }\n    /**\n     * Returns an array containing the root bones\n     * @returns an array containing the root bones\n     */\n    getChildren() {\n        return this.bones.filter((b) => !b.getParent());\n    }\n    // Members\n    /**\n     * Gets the list of transform matrices to send to shaders (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a Float32Array containing matrices data\n     */\n    getTransformMatrices(mesh) {\n        if (this.needInitialSkinMatrix) {\n            if (!mesh) {\n                throw new Error(\"getTransformMatrices: When using the needInitialSkinMatrix flag, a mesh must be provided\");\n            }\n            if (!mesh._bonesTransformMatrices) {\n                this.prepare(true);\n            }\n            return mesh._bonesTransformMatrices;\n        }\n        if (!this._transformMatrices || this._isDirty) {\n            this.prepare(!this._transformMatrices);\n        }\n        return this._transformMatrices;\n    }\n    /**\n     * Gets the list of transform matrices to send to shaders inside a texture (one matrix per bone)\n     * @param mesh defines the mesh to use to get the root matrix (if needInitialSkinMatrix === true)\n     * @returns a raw texture containing the data\n     */\n    getTransformMatrixTexture(mesh) {\n        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {\n            return mesh._transformMatrixTexture;\n        }\n        return this._transformMatrixTexture;\n    }\n    /**\n     * Gets the current hosting scene\n     * @returns a scene object\n     */\n    getScene() {\n        return this._scene;\n    }\n    // Methods\n    /**\n     * Gets a string representing the current skeleton data\n     * @param fullDetails defines a boolean indicating if we want a verbose version\n     * @returns a string representing the current skeleton data\n     */\n    toString(fullDetails) {\n        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;\n        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : \"none\"}`;\n        if (fullDetails) {\n            ret += \", Ranges: {\";\n            let first = true;\n            for (const name in this._ranges) {\n                if (first) {\n                    ret += \", \";\n                    first = false;\n                }\n                ret += name;\n            }\n            ret += \"}\";\n        }\n        return ret;\n    }\n    /**\n     * Get bone's index searching by name\n     * @param name defines bone's name to search for\n     * @returns the indice of the bone. Returns -1 if not found\n     */\n    getBoneIndexByName(name) {\n        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {\n            if (this.bones[boneIndex].name === name) {\n                return boneIndex;\n            }\n        }\n        return -1;\n    }\n    /**\n     * Finds a bone in a skeleton that is linked to the given transform node.\n     * @param transformNode The transform node to find the bone for\n     * @returns The bone linked to the transform node, or null if not found\n     */\n    findBoneFromLinkedTransformNode(transformNode) {\n        for (const bone of this.bones) {\n            if (bone._linkedTransformNode === transformNode) {\n                return bone;\n            }\n        }\n        return null;\n    }\n    /**\n     * Finds a bone in a skeleton by the name of its linked transform node.\n     * @param name The name of the linked transform node\n     * @returns The bone linked to the transform node with the given name, or null if not found\n     */\n    findBoneFromLinkedTransformNodeName(name) {\n        for (const bone of this.bones) {\n            if (bone._linkedTransformNode && bone._linkedTransformNode.name === name) {\n                return bone;\n            }\n        }\n        return null;\n    }\n    /**\n     * Create a new animation range\n     * @param name defines the name of the range\n     * @param from defines the start key\n     * @param to defines the end key\n     */\n    createAnimationRange(name, from, to) {\n        // check name not already in use\n        if (!this._ranges[name]) {\n            this._ranges[name] = new AnimationRange(name, from, to);\n            for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n                if (this.bones[i].animations[0]) {\n                    this.bones[i].animations[0].createRange(name, from, to);\n                }\n            }\n        }\n    }\n    /**\n     * Delete a specific animation range\n     * @param name defines the name of the range\n     * @param deleteFrames defines if frames must be removed as well\n     */\n    deleteAnimationRange(name, deleteFrames = true) {\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                this.bones[i].animations[0].deleteRange(name, deleteFrames);\n            }\n        }\n        this._ranges[name] = null; // said much faster than 'delete this._range[name]'\n    }\n    /**\n     * Gets a specific animation range\n     * @param name defines the name of the range to look for\n     * @returns the requested animation range or null if not found\n     */\n    getAnimationRange(name) {\n        return this._ranges[name] || null;\n    }\n    /**\n     * Gets the list of all animation ranges defined on this skeleton\n     * @returns an array\n     */\n    getAnimationRanges() {\n        const animationRanges = [];\n        let name;\n        for (name in this._ranges) {\n            animationRanges.push(this._ranges[name]);\n        }\n        return animationRanges;\n    }\n    /**\n     * Copy animation range from a source skeleton.\n     * This is not for a complete retargeting, only between very similar skeleton's with only possible bone length differences\n     * @param source defines the source skeleton\n     * @param name defines the name of the range to copy\n     * @param rescaleAsRequired defines if rescaling must be applied if required\n     * @returns true if operation was successful\n     */\n    copyAnimationRange(source, name, rescaleAsRequired = false) {\n        if (this._ranges[name] || !source.getAnimationRange(name)) {\n            return false;\n        }\n        let ret = true;\n        const frameOffset = this._getHighestAnimationFrame() + 1;\n        // make a dictionary of source skeleton's bones, so exact same order or doubly nested loop is not required\n        const boneDict = {};\n        const sourceBones = source.bones;\n        let nBones;\n        let i;\n        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {\n            boneDict[sourceBones[i].name] = sourceBones[i];\n        }\n        if (this.bones.length !== sourceBones.length) {\n            Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);\n            ret = false;\n        }\n        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;\n        for (i = 0, nBones = this.bones.length; i < nBones; i++) {\n            const boneName = this.bones[i].name;\n            const sourceBone = boneDict[boneName];\n            if (sourceBone) {\n                ret = ret && this.bones[i].copyAnimationRange(sourceBone, name, frameOffset, rescaleAsRequired, skelDimensionsRatio);\n            }\n            else {\n                Logger.Warn(\"copyAnimationRange: not same rig, missing source bone \" + boneName);\n                ret = false;\n            }\n        }\n        // do not call createAnimationRange(), since it also is done to bones, which was already done\n        const range = source.getAnimationRange(name);\n        if (range) {\n            this._ranges[name] = new AnimationRange(name, range.from + frameOffset, range.to + frameOffset);\n        }\n        return ret;\n    }\n    /**\n     * Forces the skeleton to go to rest pose\n     */\n    returnToRest() {\n        for (const bone of this.bones) {\n            if (bone._index !== -1) {\n                bone.returnToRest();\n            }\n        }\n    }\n    _getHighestAnimationFrame() {\n        let ret = 0;\n        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {\n            if (this.bones[i].animations[0]) {\n                const highest = this.bones[i].animations[0].getHighestFrame();\n                if (ret < highest) {\n                    ret = highest;\n                }\n            }\n        }\n        return ret;\n    }\n    /**\n     * Begin a specific animation range\n     * @param name defines the name of the range to start\n     * @param loop defines if looping must be turned on (false by default)\n     * @param speedRatio defines the speed ratio to apply (1 by default)\n     * @param onAnimationEnd defines a callback which will be called when animation will end\n     * @returns a new animatable\n     */\n    beginAnimation(name, loop, speedRatio, onAnimationEnd) {\n        const range = this.getAnimationRange(name);\n        if (!range) {\n            return null;\n        }\n        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);\n    }\n    /**\n     * Convert the keyframes for a range of animation on a skeleton to be relative to a given reference frame.\n     * @param skeleton defines the Skeleton containing the animation range to convert\n     * @param referenceFrame defines the frame that keyframes in the range will be relative to\n     * @param range defines the name of the AnimationRange belonging to the Skeleton to convert\n     * @returns the original skeleton\n     */\n    static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {\n        const rangeValue = skeleton.getAnimationRange(range);\n        // We can't make a range additive if it doesn't exist\n        if (!rangeValue) {\n            return null;\n        }\n        // Find any current scene-level animatable belonging to the target that matches the range\n        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);\n        let rangeAnimatable = null;\n        for (let index = 0; index < sceneAnimatables.length; index++) {\n            const sceneAnimatable = sceneAnimatables[index];\n            if (sceneAnimatable.fromFrame === rangeValue?.from && sceneAnimatable.toFrame === rangeValue?.to) {\n                rangeAnimatable = sceneAnimatable;\n                break;\n            }\n        }\n        // Convert the animations belonging to the skeleton to additive keyframes\n        const animatables = skeleton.getAnimatables();\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            const animations = animatable.animations;\n            if (!animations) {\n                continue;\n            }\n            for (let animIndex = 0; animIndex < animations.length; animIndex++) {\n                Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);\n            }\n        }\n        // Mark the scene-level animatable as additive\n        if (rangeAnimatable) {\n            rangeAnimatable.isAdditive = true;\n        }\n        return skeleton;\n    }\n    /** @internal */\n    _markAsDirty() {\n        this._isDirty = true;\n        this._absoluteTransformIsDirty = true;\n    }\n    /**\n     * @internal\n     */\n    _registerMeshWithPoseMatrix(mesh) {\n        this._meshesWithPoseMatrix.push(mesh);\n    }\n    /**\n     * @internal\n     */\n    _unregisterMeshWithPoseMatrix(mesh) {\n        const index = this._meshesWithPoseMatrix.indexOf(mesh);\n        if (index > -1) {\n            this._meshesWithPoseMatrix.splice(index, 1);\n        }\n    }\n    _computeTransformMatrices(targetMatrix, initialSkinMatrix) {\n        this.onBeforeComputeObservable.notifyObservers(this);\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            bone._childUpdateId++;\n            const parentBone = bone.getParent();\n            if (parentBone) {\n                bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());\n            }\n            else {\n                if (initialSkinMatrix) {\n                    bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());\n                }\n                else {\n                    bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());\n                }\n            }\n            if (bone._index !== -1) {\n                const mappedIndex = bone._index === null ? index : bone._index;\n                bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);\n            }\n        }\n        this._identity.copyToArray(targetMatrix, this.bones.length * 16);\n    }\n    /**\n     * Build all resources required to render a skeleton\n     * @param dontCheckFrameId defines a boolean indicating if prepare should be run without checking first the current frame id (default: false)\n     */\n    prepare(dontCheckFrameId = false) {\n        if (!dontCheckFrameId) {\n            const currentRenderId = this.getScene().getRenderId();\n            if (this._currentRenderId === currentRenderId) {\n                return;\n            }\n            this._currentRenderId = currentRenderId;\n        }\n        // Update the local matrix of bones with linked transform nodes.\n        if (this._numBonesWithLinkedTransformNode > 0) {\n            for (const bone of this.bones) {\n                if (bone._linkedTransformNode) {\n                    const node = bone._linkedTransformNode;\n                    bone.position = node.position;\n                    if (node.rotationQuaternion) {\n                        bone.rotationQuaternion = node.rotationQuaternion;\n                    }\n                    else {\n                        bone.rotation = node.rotation;\n                    }\n                    bone.scaling = node.scaling;\n                }\n            }\n        }\n        if (this.needInitialSkinMatrix) {\n            for (const mesh of this._meshesWithPoseMatrix) {\n                const poseMatrix = mesh.getPoseMatrix();\n                let needsUpdate = this._isDirty;\n                if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {\n                    mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                    needsUpdate = true;\n                }\n                if (!needsUpdate) {\n                    continue;\n                }\n                if (this._synchronizedWithMesh !== mesh) {\n                    this._synchronizedWithMesh = mesh;\n                    // Prepare bones\n                    for (const bone of this.bones) {\n                        if (!bone.getParent()) {\n                            const matrix = bone.getBindMatrix();\n                            matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);\n                            bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);\n                        }\n                    }\n                    if (this.isUsingTextureForMatrices) {\n                        const textureWidth = (this.bones.length + 1) * 4;\n                        if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {\n                            if (mesh._transformMatrixTexture) {\n                                mesh._transformMatrixTexture.dispose();\n                            }\n                            mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n                        }\n                    }\n                }\n                this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);\n                if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {\n                    mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);\n                }\n            }\n        }\n        else {\n            if (!this._isDirty) {\n                return;\n            }\n            if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {\n                this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));\n                if (this.isUsingTextureForMatrices) {\n                    if (this._transformMatrixTexture) {\n                        this._transformMatrixTexture.dispose();\n                    }\n                    this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, Constants.TEXTURE_NEAREST_SAMPLINGMODE, Constants.TEXTURETYPE_FLOAT);\n                }\n            }\n            this._computeTransformMatrices(this._transformMatrices, null);\n            if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {\n                this._transformMatrixTexture.update(this._transformMatrices);\n            }\n        }\n        this._isDirty = false;\n    }\n    /**\n     * Gets the list of animatables currently running for this skeleton\n     * @returns an array of animatables\n     */\n    getAnimatables() {\n        if (!this._animatables || this._animatables.length !== this.bones.length) {\n            this._animatables = [];\n            for (let index = 0; index < this.bones.length; index++) {\n                this._animatables.push(this.bones[index]);\n            }\n        }\n        return this._animatables;\n    }\n    /**\n     * Clone the current skeleton\n     * @param name defines the name of the new skeleton\n     * @param id defines the id of the new skeleton\n     * @returns the new skeleton\n     */\n    clone(name, id) {\n        const result = new Skeleton(name, id || name, this._scene);\n        result.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        result.metadata = this.metadata;\n        for (let index = 0; index < this.bones.length; index++) {\n            const source = this.bones[index];\n            let parentBone = null;\n            const parent = source.getParent();\n            if (parent) {\n                const parentIndex = this.bones.indexOf(parent);\n                parentBone = result.bones[parentIndex];\n            }\n            const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());\n            bone._index = source._index;\n            if (source._linkedTransformNode) {\n                bone.linkTransformNode(source._linkedTransformNode);\n            }\n            DeepCopier.DeepCopy(source.animations, bone.animations);\n        }\n        if (this._ranges) {\n            result._ranges = {};\n            for (const rangeName in this._ranges) {\n                const range = this._ranges[rangeName];\n                if (range) {\n                    result._ranges[rangeName] = range.clone();\n                }\n            }\n        }\n        this._isDirty = true;\n        result.prepare(true);\n        return result;\n    }\n    /**\n     * Enable animation blending for this skeleton\n     * @param blendingSpeed defines the blending speed to apply\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    enableBlending(blendingSpeed = 0.01) {\n        for (const bone of this.bones) {\n            for (const animation of bone.animations) {\n                animation.enableBlending = true;\n                animation.blendingSpeed = blendingSpeed;\n            }\n        }\n    }\n    /**\n     * Releases all resources associated with the current skeleton\n     */\n    dispose() {\n        this._meshesWithPoseMatrix.length = 0;\n        this.metadata = null;\n        // Animations\n        this.getScene().stopAnimation(this);\n        // Remove from scene\n        this.getScene().removeSkeleton(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.skeletons.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.skeletons.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        if (this._transformMatrixTexture) {\n            this._transformMatrixTexture.dispose();\n            this._transformMatrixTexture = null;\n        }\n    }\n    /**\n     * Serialize the skeleton in a JSON object\n     * @returns a JSON object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.id = this.id;\n        serializationObject.uniqueId = this.uniqueId;\n        if (this.dimensionsAtRest) {\n            serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();\n        }\n        serializationObject.bones = [];\n        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        for (let index = 0; index < this.bones.length; index++) {\n            const bone = this.bones[index];\n            const parent = bone.getParent();\n            const serializedBone = {\n                parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,\n                index: bone.getIndex(),\n                name: bone.name,\n                id: bone.id,\n                uniqueId: bone.uniqueId,\n                matrix: bone.getBindMatrix().asArray(),\n                rest: bone.getRestMatrix().asArray(),\n                linkedTransformNodeId: bone.getTransformNode()?.id,\n                linkedTransformNodeUniqueId: bone.getTransformNode()?.uniqueId,\n            };\n            serializationObject.bones.push(serializedBone);\n            if (bone.length) {\n                serializedBone.length = bone.length;\n            }\n            if (bone.metadata) {\n                serializedBone.metadata = bone.metadata;\n            }\n            if (bone.animations && bone.animations.length > 0) {\n                serializedBone.animation = bone.animations[0].serialize();\n            }\n            serializationObject.ranges = [];\n            for (const name in this._ranges) {\n                const source = this._ranges[name];\n                if (!source) {\n                    continue;\n                }\n                const range = {};\n                range.name = name;\n                range.from = source.from;\n                range.to = source.to;\n                serializationObject.ranges.push(range);\n            }\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a new skeleton from serialized data\n     * @param parsedSkeleton defines the serialized data\n     * @param scene defines the hosting scene\n     * @returns a new skeleton\n     */\n    static Parse(parsedSkeleton, scene) {\n        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);\n        if (parsedSkeleton.dimensionsAtRest) {\n            skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);\n        }\n        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;\n        if (parsedSkeleton.metadata) {\n            skeleton.metadata = parsedSkeleton.metadata;\n        }\n        let index;\n        for (index = 0; index < parsedSkeleton.bones.length; index++) {\n            const parsedBone = parsedSkeleton.bones[index];\n            const parsedBoneIndex = parsedSkeleton.bones[index].index;\n            let parentBone = null;\n            if (parsedBone.parentBoneIndex > -1) {\n                parentBone = skeleton.bones[parsedBone.parentBoneIndex];\n            }\n            const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;\n            const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);\n            if (parsedBone.id !== undefined && parsedBone.id !== null) {\n                bone.id = parsedBone.id;\n            }\n            if (parsedBone.length) {\n                bone.length = parsedBone.length;\n            }\n            if (parsedBone.metadata) {\n                bone.metadata = parsedBone.metadata;\n            }\n            if (parsedBone.animation) {\n                bone.animations.push(Animation.Parse(parsedBone.animation));\n            }\n            if (parsedBone.linkedTransformNodeId !== undefined && parsedBone.linkedTransformNodeId !== null) {\n                skeleton._hasWaitingData = true;\n                bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;\n            }\n            if (parsedBone.linkedTransformNodeUniqueId !== undefined && parsedBone.linkedTransformNodeUniqueId !== null) {\n                skeleton._hasWaitingData = true;\n                bone._waitingTransformNodeUniqueId = parsedBone.linkedTransformNodeUniqueId;\n            }\n        }\n        // placed after bones, so createAnimationRange can cascade down\n        if (parsedSkeleton.ranges) {\n            for (index = 0; index < parsedSkeleton.ranges.length; index++) {\n                const data = parsedSkeleton.ranges[index];\n                skeleton.createAnimationRange(data.name, data.from, data.to);\n            }\n        }\n        return skeleton;\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     */\n    computeAbsoluteMatrices(forceUpdate = false) {\n        if (this._absoluteTransformIsDirty || forceUpdate) {\n            this.bones[0].computeAbsoluteMatrices();\n            this._absoluteTransformIsDirty = false;\n        }\n    }\n    /**\n     * Compute all node absolute matrices\n     * @param forceUpdate defines if computation must be done even if cache is up to date\n     * @deprecated Please use computeAbsoluteMatrices instead\n     */\n    computeAbsoluteTransforms(forceUpdate = false) {\n        this.computeAbsoluteMatrices(forceUpdate);\n    }\n    /**\n     * Gets the root pose matrix\n     * @returns a matrix\n     */\n    getPoseMatrix() {\n        let poseMatrix = null;\n        if (this._meshesWithPoseMatrix.length > 0) {\n            poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();\n        }\n        return poseMatrix;\n    }\n    /**\n     * Sorts bones per internal index\n     */\n    sortBones() {\n        const bones = [];\n        const visited = new Array(this.bones.length);\n        for (let index = 0; index < this.bones.length; index++) {\n            this._sortBones(index, bones, visited);\n        }\n        this.bones = bones;\n    }\n    _sortBones(index, bones, visited) {\n        if (visited[index]) {\n            return;\n        }\n        visited[index] = true;\n        const bone = this.bones[index];\n        if (!bone) {\n            return;\n        }\n        if (bone._index === undefined) {\n            bone._index = index;\n        }\n        const parentBone = bone.getParent();\n        if (parentBone) {\n            this._sortBones(this.bones.indexOf(parentBone), bones, visited);\n        }\n        bones.push(bone);\n    }\n    /**\n     * Set the current local matrix as the restPose for all bones in the skeleton.\n     */\n    setCurrentPoseAsRest() {\n        for (const b of this.bones) {\n            b.setCurrentPoseAsRest();\n        }\n    }\n}\n//# sourceMappingURL=skeleton.js.map"],"names":["Skeleton","useTextureToStoreBoneMatrices","this","_useTextureToStoreBoneMatrices","value","_markAsDirty","animationPropertiesOverride","_animationPropertiesOverride","_scene","isUsingTextureForMatrices","_canUseTextureForBones","uniqueId","_uniqueId","constructor","name","id","scene","bones","needInitialSkinMatrix","_isDirty","_meshesWithPoseMatrix","Array","_identity","Matrix","Identity","_currentRenderId","_ranges","_absoluteTransformIsDirty","_numBonesWithLinkedTransformNode","_hasWaitingData","_parentContainer","doNotSerialize","onBeforeComputeObservable","Observable","metadata","EngineStore","LastCreatedScene","getUniqueId","addSkeleton","engineCaps","getEngine","getCaps","textureFloat","maxVertexTextureImageUnits","getClassName","getChildren","filter","b","getParent","getTransformMatrices","mesh","Error","_bonesTransformMatrices","prepare","_transformMatrices","getTransformMatrixTexture","_transformMatrixTexture","getScene","toString","fullDetails","ret","length","Object","keys","first","getBoneIndexByName","boneIndex","cache","findBoneFromLinkedTransformNode","transformNode","bone","_linkedTransformNode","findBoneFromLinkedTransformNodeName","createAnimationRange","from","to","AnimationRange","i","nBones","animations","createRange","deleteAnimationRange","deleteFrames","deleteRange","getAnimationRange","getAnimationRanges","animationRanges","push","copyAnimationRange","source","rescaleAsRequired","frameOffset","_getHighestAnimationFrame","boneDict","sourceBones","Logger","Warn","skelDimensionsRatio","dimensionsAtRest","divide","boneName","sourceBone","range","returnToRest","_index","highest","getHighestFrame","beginAnimation","loop","speedRatio","onAnimationEnd","MakeAnimationAdditive","skeleton","referenceFrame","rangeValue","sceneAnimatables","getAllAnimatablesByTarget","rangeAnimatable","index","sceneAnimatable","fromFrame","toFrame","animatables","getAnimatables","animIndex","Animation","isAdditive","_registerMeshWithPoseMatrix","_unregisterMeshWithPoseMatrix","indexOf","splice","_computeTransformMatrices","targetMatrix","initialSkinMatrix","notifyObservers","_childUpdateId","parentBone","getLocalMatrix","multiplyToRef","getFinalMatrix","copyFrom","mappedIndex","getAbsoluteInverseBindMatrix","multiplyToArray","copyToArray","dontCheckFrameId","currentRenderId","getRenderId","node","position","rotationQuaternion","rotation","scaling","poseMatrix","getPoseMatrix","needsUpdate","Float32Array","_synchronizedWithMesh","getBindMatrix","TmpVectors","_updateAbsoluteBindMatrices","textureWidth","getSize","width","dispose","RawTexture","CreateRGBATexture","Constants","TEXTURE_NEAREST_SAMPLINGMODE","TEXTURETYPE_FLOAT","update","_animatables","clone","result","parent","parentIndex","Bone","getRestMatrix","linkTransformNode","DeepCopier","DeepCopy","rangeName","enableBlending","blendingSpeed","animation","stopAnimation","removeSkeleton","skeletons","serialize","serializationObject","asArray","serializedBone","parentBoneIndex","getIndex","matrix","rest","linkedTransformNodeId","getTransformNode","linkedTransformNodeUniqueId","ranges","Parse","parsedSkeleton","Vector3","FromArray","parsedBone","parsedBoneIndex","undefined","_waitingTransformNodeId","_waitingTransformNodeUniqueId","data","computeAbsoluteMatrices","forceUpdate","computeAbsoluteTransforms","sortBones","visited","_sortBones","setCurrentPoseAsRest"],"mappings":"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"}