{"version":3,"file":"cubeTexture-CU8CkahI.esm.min.js","sources":["../../../../../dev/core/dist/Materials/Textures/cubeTexture.js"],"sourcesContent":["import { __decorate } from \"tslib\";\nimport { serialize, serializeAsMatrix, serializeAsVector3 } from \"../../Misc/decorators\";\nimport { Tools } from \"../../Misc/tools\";\nimport { Matrix, TmpVectors, Vector3 } from \"../../Maths/math.vector\";\nimport { BaseTexture } from \"../../Materials/Textures/baseTexture\";\nimport { Texture } from \"../../Materials/Textures/texture\";\nimport { Constants } from \"../../Engines/constants\";\nimport { GetClass, RegisterClass } from \"../../Misc/typeStore\";\nimport { Observable } from \"../../Misc/observable\";\nimport { SerializationHelper } from \"../../Misc/decorators.serialization\";\nimport \"../../Engines/AbstractEngine/abstractEngine.cubeTexture\";\n// The default scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\nconst DefaultLodScale = 0.8;\n/**\n * Class for creating a cube texture\n */\nexport class CubeTexture extends BaseTexture {\n    /**\n     * Gets or sets the size of the bounding box associated with the cube texture\n     * When defined, the cubemap will switch to local mode\n     * @see https://community.arm.com/graphics/b/blog/posts/reflections-based-on-local-cubemaps-in-unity\n     * @example https://www.babylonjs-playground.com/#RNASML\n     */\n    set boundingBoxSize(value) {\n        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {\n            return;\n        }\n        this._boundingBoxSize = value;\n        const scene = this.getScene();\n        if (scene) {\n            scene.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\n        }\n    }\n    /**\n     * Returns the bounding box size\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\n     */\n    get boundingBoxSize() {\n        return this._boundingBoxSize;\n    }\n    /**\n     * Sets texture matrix rotation angle around Y axis in radians.\n     */\n    set rotationY(value) {\n        this._rotationY = value;\n        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));\n    }\n    /**\n     * Gets texture matrix rotation angle around Y axis radians.\n     */\n    get rotationY() {\n        return this._rotationY;\n    }\n    /**\n     * Are mip maps generated for this texture or not.\n     */\n    get noMipmap() {\n        return this._noMipmap;\n    }\n    /**\n     * Gets the forced extension (if any)\n     */\n    get forcedExtension() {\n        return this._forcedExtension;\n    }\n    /**\n     * Creates a cube texture from an array of image urls\n     * @param files defines an array of image urls\n     * @param scene defines the hosting scene\n     * @param noMipmap specifies if mip maps are not used\n     * @returns a cube texture\n     */\n    static CreateFromImages(files, scene, noMipmap) {\n        let rootUrlKey = \"\";\n        for (const url of files) {\n            rootUrlKey += url;\n        }\n        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);\n    }\n    /**\n     * Creates and return a texture created from prefilterd data by tools like IBL Baker or Lys.\n     * @param url defines the url of the prefiltered texture\n     * @param scene defines the scene the texture is attached to\n     * @param forcedExtension defines the extension of the file if different from the url\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n     * @returns the prefiltered texture\n     */\n    static CreateFromPrefilteredData(url, scene, forcedExtension = null, createPolynomials = true) {\n        const oldValue = scene.useDelayedTextureLoading;\n        scene.useDelayedTextureLoading = false;\n        const result = new CubeTexture(url, scene, null, false, null, null, null, undefined, true, forcedExtension, createPolynomials);\n        scene.useDelayedTextureLoading = oldValue;\n        return result;\n    }\n    /**\n     * Creates a cube texture to use with reflection for instance. It can be based upon dds or six images as well\n     * as prefiltered data.\n     * @param rootUrl defines the url of the texture or the root name of the six images\n     * @param sceneOrEngine defines the scene or engine the texture is attached to\n     * @param extensionsOrOptions defines the suffixes add to the picture name in case six images are in use like _px.jpg or set of all options to create the cube texture\n     * @param noMipmap defines if mipmaps should be created or not\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n     * @param onLoad defines a callback triggered at the end of the file load if no errors occurred\n     * @param onError defines a callback triggered in case of error during load\n     * @param format defines the internal format to use for the texture once loaded\n     * @param prefiltered defines whether or not the texture is created from prefiltered data\n     * @param forcedExtension defines the extensions to use (force a special type of file to load) in case it is different from the file name\n     * @param createPolynomials defines whether or not to create polynomial harmonics from the texture data if necessary\n     * @param lodScale defines the scale applied to environment texture. This manages the range of LOD level used for IBL according to the roughness\n     * @param lodOffset defines the offset applied to environment texture. This manages first LOD level used for IBL according to the roughness\n     * @param loaderOptions options to be passed to the loader\n     * @param useSRGBBuffer Defines if the texture must be loaded in a sRGB GPU buffer (if supported by the GPU) (default: false)\n     * @returns the cube texture\n     */\n    constructor(rootUrl, sceneOrEngine, extensionsOrOptions = null, noMipmap = false, files = null, onLoad = null, onError = null, format = Constants.TEXTUREFORMAT_RGBA, prefiltered = false, forcedExtension = null, createPolynomials = false, lodScale = DefaultLodScale, lodOffset = 0, loaderOptions, useSRGBBuffer) {\n        super(sceneOrEngine);\n        /**\n         * Observable triggered once the texture has been loaded.\n         */\n        this.onLoadObservable = new Observable();\n        /**\n         * Gets or sets the center of the bounding box associated with the cube texture.\n         * It must define where the camera used to render the texture was set\n         * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/using/reflectionTexture#using-local-cubemap-mode\n         */\n        this.boundingBoxPosition = Vector3.Zero();\n        this._rotationY = 0;\n        /** @internal */\n        this._files = null;\n        this._forcedExtension = null;\n        this._extensions = null;\n        this._textureMatrixRefraction = new Matrix();\n        this._buffer = null;\n        this.name = rootUrl;\n        this.url = rootUrl;\n        this._noMipmap = noMipmap;\n        this.hasAlpha = false;\n        this.isCube = true;\n        this._textureMatrix = Matrix.Identity();\n        this.coordinatesMode = Texture.CUBIC_MODE;\n        let extensions = null;\n        let buffer = null;\n        if (extensionsOrOptions !== null && !Array.isArray(extensionsOrOptions)) {\n            extensions = extensionsOrOptions.extensions ?? null;\n            this._noMipmap = extensionsOrOptions.noMipmap ?? false;\n            files = extensionsOrOptions.files ?? null;\n            buffer = extensionsOrOptions.buffer ?? null;\n            this._format = extensionsOrOptions.format ?? Constants.TEXTUREFORMAT_RGBA;\n            prefiltered = extensionsOrOptions.prefiltered ?? false;\n            forcedExtension = extensionsOrOptions.forcedExtension ?? null;\n            this._createPolynomials = extensionsOrOptions.createPolynomials ?? false;\n            this._lodScale = extensionsOrOptions.lodScale ?? DefaultLodScale;\n            this._lodOffset = extensionsOrOptions.lodOffset ?? 0;\n            this._loaderOptions = extensionsOrOptions.loaderOptions;\n            this._useSRGBBuffer = extensionsOrOptions.useSRGBBuffer;\n            onLoad = extensionsOrOptions.onLoad ?? null;\n            onError = extensionsOrOptions.onError ?? null;\n        }\n        else {\n            this._noMipmap = noMipmap;\n            this._format = format;\n            this._createPolynomials = createPolynomials;\n            extensions = extensionsOrOptions;\n            this._loaderOptions = loaderOptions;\n            this._useSRGBBuffer = useSRGBBuffer;\n            this._lodScale = lodScale;\n            this._lodOffset = lodOffset;\n        }\n        if (!rootUrl && !files) {\n            return;\n        }\n        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, this.getScene()?.useDelayedTextureLoading, files, buffer);\n    }\n    /**\n     * Get the current class name of the texture useful for serialization or dynamic coding.\n     * @returns \"CubeTexture\"\n     */\n    getClassName() {\n        return \"CubeTexture\";\n    }\n    /**\n     * Update the url (and optional buffer) of this texture if url was null during construction.\n     * @param url the url of the texture\n     * @param forcedExtension defines the extension to use\n     * @param onLoad callback called when the texture is loaded  (defaults to null)\n     * @param prefiltered Defines whether the updated texture is prefiltered or not\n     * @param onError callback called if there was an error during the loading process (defaults to null)\n     * @param extensions defines the suffixes add to the picture name in case six images are in use like _px.jpg...\n     * @param delayLoad defines if the texture should be loaded now (false by default)\n     * @param files defines the six files to load for the different faces in that order: px, py, pz, nx, ny, nz\n     * @param buffer the buffer to use instead of loading from the url\n     */\n    updateURL(url, forcedExtension = null, onLoad = null, prefiltered = false, onError = null, extensions = null, delayLoad = false, files = null, buffer = null) {\n        if (!this.name || this.name.startsWith(\"data:\")) {\n            this.name = url;\n        }\n        this.url = url;\n        if (forcedExtension) {\n            this._forcedExtension = forcedExtension;\n        }\n        const lastDot = url.lastIndexOf(\".\");\n        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : \"\";\n        const isDDS = extension.indexOf(\".dds\") === 0;\n        const isEnv = extension.indexOf(\".env\") === 0;\n        const isBasis = extension.indexOf(\".basis\") === 0;\n        if (isEnv) {\n            this.gammaSpace = false;\n            this._prefiltered = false;\n            this.anisotropicFilteringLevel = 1;\n        }\n        else {\n            this._prefiltered = prefiltered;\n            if (prefiltered) {\n                this.gammaSpace = false;\n                this.anisotropicFilteringLevel = 1;\n            }\n        }\n        if (files) {\n            this._files = files;\n        }\n        else {\n            if (!isBasis && !isEnv && !isDDS && !extensions) {\n                extensions = [\"_px.jpg\", \"_py.jpg\", \"_pz.jpg\", \"_nx.jpg\", \"_ny.jpg\", \"_nz.jpg\"];\n            }\n            this._files = this._files || [];\n            this._files.length = 0;\n            if (extensions) {\n                for (let index = 0; index < extensions.length; index++) {\n                    this._files.push(url + extensions[index]);\n                }\n                this._extensions = extensions;\n            }\n        }\n        this._buffer = buffer;\n        if (delayLoad) {\n            this.delayLoadState = Constants.DELAYLOADSTATE_NOTLOADED;\n            this._delayedOnLoad = onLoad;\n            this._delayedOnError = onError;\n        }\n        else {\n            this._loadTexture(onLoad, onError);\n        }\n    }\n    /**\n     * Delays loading of the cube texture\n     * @param forcedExtension defines the extension to use\n     */\n    delayLoad(forcedExtension) {\n        if (this.delayLoadState !== Constants.DELAYLOADSTATE_NOTLOADED) {\n            return;\n        }\n        if (forcedExtension) {\n            this._forcedExtension = forcedExtension;\n        }\n        this.delayLoadState = Constants.DELAYLOADSTATE_LOADED;\n        this._loadTexture(this._delayedOnLoad, this._delayedOnError);\n    }\n    /**\n     * Returns the reflection texture matrix\n     * @returns the reflection texture matrix\n     */\n    getReflectionTextureMatrix() {\n        return this._textureMatrix;\n    }\n    /**\n     * Sets the reflection texture matrix\n     * @param value Reflection texture matrix\n     */\n    setReflectionTextureMatrix(value) {\n        if (value.updateFlag === this._textureMatrix.updateFlag) {\n            return;\n        }\n        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {\n            this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag, (mat) => mat.getActiveTextures().indexOf(this) !== -1);\n        }\n        this._textureMatrix = value;\n        if (!this.getScene()?.useRightHandedSystem) {\n            return;\n        }\n        const scale = TmpVectors.Vector3[0];\n        const quat = TmpVectors.Quaternion[0];\n        const trans = TmpVectors.Vector3[1];\n        this._textureMatrix.decompose(scale, quat, trans);\n        quat.z *= -1; // these two operations correspond to negating the x and y euler angles\n        quat.w *= -1;\n        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);\n    }\n    /**\n     * Gets a suitable rotate/transform matrix when the texture is used for refraction.\n     * There's a separate function from getReflectionTextureMatrix because refraction requires a special configuration of the matrix in right-handed mode.\n     * @returns The refraction matrix\n     */\n    getRefractionTextureMatrix() {\n        return this.getScene()?.useRightHandedSystem ? this._textureMatrixRefraction : this._textureMatrix;\n    }\n    _loadTexture(onLoad = null, onError = null) {\n        const scene = this.getScene();\n        const oldTexture = this._texture;\n        this._texture = this._getFromCache(this.url, this._noMipmap, undefined, undefined, this._useSRGBBuffer, this.isCube);\n        const onLoadProcessing = () => {\n            this.onLoadObservable.notifyObservers(this);\n            if (oldTexture) {\n                oldTexture.dispose();\n                this.getScene()?.markAllMaterialsAsDirty(Constants.MATERIAL_TextureDirtyFlag);\n            }\n            if (onLoad) {\n                onLoad();\n            }\n        };\n        const errorHandler = (message, exception) => {\n            this._loadingError = true;\n            this._errorObject = { message, exception };\n            if (onError) {\n                onError(message, exception);\n            }\n            Texture.OnTextureLoadErrorObservable.notifyObservers(this);\n        };\n        if (!this._texture) {\n            if (this._prefiltered) {\n                this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);\n            }\n            else {\n                this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer, this._buffer);\n            }\n            this._texture?.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));\n        }\n        else {\n            if (this._texture.isReady) {\n                Tools.SetImmediate(() => onLoadProcessing());\n            }\n            else {\n                this._texture.onLoadedObservable.add(() => onLoadProcessing());\n            }\n        }\n    }\n    /**\n     * Parses text to create a cube texture\n     * @param parsedTexture define the serialized text to read from\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root url of the cube texture\n     * @returns a cube texture\n     */\n    static Parse(parsedTexture, scene, rootUrl) {\n        const texture = SerializationHelper.Parse(() => {\n            let prefiltered = false;\n            if (parsedTexture.prefiltered) {\n                prefiltered = parsedTexture.prefiltered;\n            }\n            return new CubeTexture(rootUrl + (parsedTexture.url ?? parsedTexture.name), scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, undefined, prefiltered, parsedTexture.forcedExtension);\n        }, parsedTexture, scene);\n        // Local Cubemaps\n        if (parsedTexture.boundingBoxPosition) {\n            texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);\n        }\n        if (parsedTexture.boundingBoxSize) {\n            texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);\n        }\n        // Animations\n        if (parsedTexture.animations) {\n            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {\n                const parsedAnimation = parsedTexture.animations[animationIndex];\n                const internalClass = GetClass(\"BABYLON.Animation\");\n                if (internalClass) {\n                    texture.animations.push(internalClass.Parse(parsedAnimation));\n                }\n            }\n        }\n        return texture;\n    }\n    /**\n     * Makes a clone, or deep copy, of the cube texture\n     * @returns a new cube texture\n     */\n    clone() {\n        let uniqueId = 0;\n        const newCubeTexture = SerializationHelper.Clone(() => {\n            const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);\n            uniqueId = cubeTexture.uniqueId;\n            return cubeTexture;\n        }, this);\n        newCubeTexture.uniqueId = uniqueId;\n        return newCubeTexture;\n    }\n}\n__decorate([\n    serialize()\n], CubeTexture.prototype, \"url\", void 0);\n__decorate([\n    serializeAsVector3()\n], CubeTexture.prototype, \"boundingBoxPosition\", void 0);\n__decorate([\n    serializeAsVector3()\n], CubeTexture.prototype, \"boundingBoxSize\", null);\n__decorate([\n    serialize(\"rotationY\")\n], CubeTexture.prototype, \"rotationY\", null);\n__decorate([\n    serialize(\"files\")\n], CubeTexture.prototype, \"_files\", void 0);\n__decorate([\n    serialize(\"forcedExtension\")\n], CubeTexture.prototype, \"_forcedExtension\", void 0);\n__decorate([\n    serialize(\"extensions\")\n], CubeTexture.prototype, \"_extensions\", void 0);\n__decorate([\n    serializeAsMatrix(\"textureMatrix\")\n], CubeTexture.prototype, \"_textureMatrix\", void 0);\n__decorate([\n    serializeAsMatrix(\"textureMatrixRefraction\")\n], CubeTexture.prototype, \"_textureMatrixRefraction\", void 0);\nTexture._CubeTextureParser = CubeTexture.Parse;\n// Some exporters relies on Tools.Instantiate\nRegisterClass(\"BABYLON.CubeTexture\", CubeTexture);\n//# sourceMappingURL=cubeTexture.js.map"],"names":["CubeTexture","BaseTexture","boundingBoxSize","value","this","_boundingBoxSize","equals","scene","getScene","markAllMaterialsAsDirty","Constants","MATERIAL_TextureDirtyFlag","rotationY","_rotationY","setReflectionTextureMatrix","Matrix","RotationY","noMipmap","_noMipmap","forcedExtension","_forcedExtension","CreateFromImages","files","rootUrlKey","url","CreateFromPrefilteredData","createPolynomials","oldValue","useDelayedTextureLoading","result","undefined","constructor","rootUrl","sceneOrEngine","extensionsOrOptions","onLoad","onError","format","TEXTUREFORMAT_RGBA","prefiltered","lodScale","lodOffset","loaderOptions","useSRGBBuffer","super","onLoadObservable","Observable","boundingBoxPosition","Vector3","Zero","_files","_extensions","_textureMatrixRefraction","_buffer","name","hasAlpha","isCube","_textureMatrix","Identity","coordinatesMode","Texture","CUBIC_MODE","extensions","buffer","Array","isArray","_format","_createPolynomials","_loaderOptions","_useSRGBBuffer","_lodScale","_lodOffset","updateURL","getClassName","delayLoad","startsWith","lastDot","lastIndexOf","extension","substring","toLowerCase","isDDS","indexOf","isEnv","isBasis","gammaSpace","_prefiltered","anisotropicFilteringLevel","length","index","push","delayLoadState","DELAYLOADSTATE_NOTLOADED","_delayedOnLoad","_delayedOnError","_loadTexture","DELAYLOADSTATE_LOADED","getReflectionTextureMatrix","updateFlag","isIdentity","mat","getActiveTextures","useRightHandedSystem","scale","TmpVectors","quat","Quaternion","trans","decompose","z","w","ComposeToRef","getRefractionTextureMatrix","oldTexture","_texture","_getFromCache","onLoadProcessing","notifyObservers","dispose","errorHandler","message","exception","_loadingError","_errorObject","OnTextureLoadErrorObservable","isReady","Tools","SetImmediate","onLoadedObservable","add","_getEngine","createPrefilteredCubeTexture","createCubeTexture","Parse","parsedTexture","texture","SerializationHelper","FromArray","animations","animationIndex","parsedAnimation","internalClass","GetClass","clone","uniqueId","newCubeTexture","Clone","cubeTexture","__decorate","serialize","prototype","serializeAsVector3","serializeAsMatrix","_CubeTextureParser","RegisterClass"],"mappings":"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"}