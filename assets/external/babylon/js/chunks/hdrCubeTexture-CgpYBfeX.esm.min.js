import{C as e,n as t,b as i,E as r,o as n,B as s,p as a,O as o,T as h,q as l,r as _,t as d,u as c,v as u,g as f}from"./index-C7lpuH7l.esm.min.js";import{I as p}from"./iblCdfGenerator-DvytZHDN.esm.min.js";import{G as g}from"./hdr-Br-IdqQ0.esm.min.js";import"./rawTexture-GcKYJ37d.esm.min.js";class m{constructor(t,i={}){this._lodGenerationOffset=0,this._lodGenerationScale=.8,this.quality=e.TEXTURE_FILTERING_QUALITY_OFFLINE,this.hdrScale=1,this._engine=t,this.hdrScale=i.hdrScale||this.hdrScale,this.quality=i.quality||this.quality}_createRenderTarget(t){let i=e.TEXTURETYPE_UNSIGNED_BYTE;this._engine.getCaps().textureHalfFloatRender?i=e.TEXTURETYPE_HALF_FLOAT:this._engine.getCaps().textureFloatRender&&(i=e.TEXTURETYPE_FLOAT);const r=this._engine.createRenderTargetCubeTexture(t,{format:e.TEXTUREFORMAT_RGBA,type:i,createMipMaps:!0,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:e.TEXTURE_NEAREST_SAMPLINGMODE,label:"HDR_Radiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(r.texture,e.TEXTURE_CLAMP_ADDRESSMODE,e.TEXTURE_CLAMP_ADDRESSMODE,e.TEXTURE_CLAMP_ADDRESSMODE),this._engine.updateTextureSamplingMode(e.TEXTURE_TRILINEAR_SAMPLINGMODE,r.texture,!0),r}_prefilterInternal(r){const n=r.getSize().width,s=t(n)+1,a=this._effectWrapper.effect,o=this._createRenderTarget(n);this._effectRenderer.saveStates(),this._effectRenderer.setViewport();const h=r.getInternalTexture();h&&this._engine.updateTextureSamplingMode(e.TEXTURE_TRILINEAR_SAMPLINGMODE,h,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const l=[[new i(0,0,-1),new i(0,-1,0),new i(1,0,0)],[new i(0,0,1),new i(0,-1,0),new i(-1,0,0)],[new i(1,0,0),new i(0,0,1),new i(0,1,0)],[new i(1,0,0),new i(0,0,-1),new i(0,-1,0)],[new i(1,0,0),new i(0,-1,0),new i(0,0,1)],[new i(-1,0,0),new i(0,-1,0),new i(0,0,-1)]];a.setFloat("hdrScale",this.hdrScale),a.setFloat2("vFilteringInfo",r.getSize().width,s),a.setTexture("inputTexture",r);for(let e=0;e<6;e++){a.setVector3("up",l[e][0]),a.setVector3("right",l[e][1]),a.setVector3("front",l[e][2]);for(let t=0;t<s;t++){this._engine.bindFramebuffer(o,e,void 0,void 0,!0,t),this._effectRenderer.applyEffectWrapper(this._effectWrapper);let i=Math.pow(2,(t-this._lodGenerationOffset)/this._lodGenerationScale)/n;0===t&&(i=0),a.setFloat("alphaG",i),this._effectRenderer.draw()}}this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),this._engine._releaseTexture(r._texture);const _=o.texture.type,d=o.texture.format;return o._swapAndDie(r._texture),r._texture.type=_,r._texture.format=d,r.gammaSpace=!1,r.lodGenerationOffset=this._lodGenerationOffset,r.lodGenerationScale=this._lodGenerationScale,r._prefiltered=!0,r}_createEffect(e,t){const i=[];e.gammaSpace&&i.push("#define GAMMA_INPUT"),i.push("#define NUM_SAMPLES "+this.quality+"u");const n=this._engine.isWebGPU;return new r({engine:this._engine,name:"hdrFiltering",vertexShader:"hdrFiltering",fragmentShader:"hdrFiltering",samplerNames:["inputTexture"],uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale","alphaG"],useShaderStore:!0,defines:i,onCompiled:t,shaderLanguage:n?1:0,extraInitializationsAsync:async()=>{n?await Promise.all([import("./hdrFiltering.vertex-BuceXbEv.esm.min.js"),import("./hdrFiltering.fragment-B5dovPWY.esm.min.js")]):await Promise.all([import("./hdrFiltering.vertex-CBSp4s5x.esm.min.js"),import("./hdrFiltering.fragment-u78XLTd0.esm.min.js")])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this._effectRenderer=new n(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync(),this._prefilterInternal(e),this._effectRenderer.dispose(),this._effectWrapper.dispose()}}class T{constructor(t,i={}){this.quality=e.TEXTURE_FILTERING_QUALITY_OFFLINE,this.hdrScale=1,this.useCdf=!1,this._engine=t,this.hdrScale=i.hdrScale||this.hdrScale,this.quality=i.quality||this.quality,this.useCdf=i.useCdf||this.useCdf}_createRenderTarget(t){let i=e.TEXTURETYPE_UNSIGNED_BYTE;this._engine.getCaps().textureHalfFloatRender?i=e.TEXTURETYPE_HALF_FLOAT:this._engine.getCaps().textureFloatRender&&(i=e.TEXTURETYPE_FLOAT);const r=this._engine.createRenderTargetCubeTexture(t,{format:e.TEXTUREFORMAT_RGBA,type:i,createMipMaps:!1,generateMipMaps:!1,generateDepthBuffer:!1,generateStencilBuffer:!1,samplingMode:e.TEXTURE_BILINEAR_SAMPLINGMODE,label:"HDR_Irradiance_Filtering_Target"});return this._engine.updateTextureWrappingMode(r.texture,e.TEXTURE_CLAMP_ADDRESSMODE,e.TEXTURE_CLAMP_ADDRESSMODE,e.TEXTURE_CLAMP_ADDRESSMODE),r}_prefilterInternal(e){const r=e.getSize().width,n=t(r),a=this._effectWrapper.effect,o=Math.max(32,1<<t(r>>3)),h=this._createRenderTarget(o);this._effectRenderer.saveStates(),this._effectRenderer.setViewport(),this._effectRenderer.applyEffectWrapper(this._effectWrapper);const l=[[new i(0,0,-1),new i(0,-1,0),new i(1,0,0)],[new i(0,0,1),new i(0,-1,0),new i(-1,0,0)],[new i(1,0,0),new i(0,0,1),new i(0,1,0)],[new i(1,0,0),new i(0,0,-1),new i(0,-1,0)],[new i(1,0,0),new i(0,-1,0),new i(0,0,1)],[new i(-1,0,0),new i(0,-1,0),new i(0,0,-1)]];a.setFloat("hdrScale",this.hdrScale),a.setFloat2("vFilteringInfo",e.getSize().width,n),a.setTexture("inputTexture",e),this._cdfGenerator&&a.setTexture("icdfTexture",this._cdfGenerator.getIcdfTexture());for(let e=0;e<6;e++)a.setVector3("up",l[e][0]),a.setVector3("right",l[e][1]),a.setVector3("front",l[e][2]),this._engine.bindFramebuffer(h,e,void 0,void 0,!0),this._effectRenderer.applyEffectWrapper(this._effectWrapper),this._effectRenderer.draw();this._effectRenderer.restoreStates(),this._engine.restoreDefaultFramebuffer(),a.setTexture("inputTexture",null),a.setTexture("icdfTexture",null);const _=new s(e.getScene(),h.texture);return _.name=e.name+"_irradiance",_.displayName=e.name+"_irradiance",_.gammaSpace=!1,_}_createEffect(e,t){const i=[];e.gammaSpace&&i.push("#define GAMMA_INPUT"),i.push("#define NUM_SAMPLES "+this.quality+"u");const n=this._engine.isWebGPU,s=["inputTexture"];this._cdfGenerator&&(s.push("icdfTexture"),i.push("#define IBL_CDF_FILTERING"));return new r({engine:this._engine,name:"HDRIrradianceFiltering",vertexShader:"hdrIrradianceFiltering",fragmentShader:"hdrIrradianceFiltering",samplerNames:s,uniformNames:["vSampleDirections","vWeights","up","right","front","vFilteringInfo","hdrScale"],useShaderStore:!0,defines:i,onCompiled:t,shaderLanguage:n?1:0,extraInitializationsAsync:async()=>{n?await Promise.all([import("./hdrIrradianceFiltering.vertex-Xy7UIgai.esm.min.js"),import("./hdrIrradianceFiltering.fragment-CloDSKrP.esm.min.js")]):await Promise.all([import("./hdrIrradianceFiltering.vertex-DrY6bJcn.esm.min.js"),import("./hdrIrradianceFiltering.fragment-DW5jZTzE.esm.min.js")])}})}isReady(e){return e.isReady()&&this._effectWrapper.effect.isReady()}async prefilter(e){if(!this._engine._features.allowTexturePrefiltering)throw new Error("HDR prefiltering is not available in WebGL 1., you can use real time filtering instead.");this.useCdf&&(this._cdfGenerator=new p(this._engine),this._cdfGenerator.iblSource=e,await this._cdfGenerator.renderWhenReady()),this._effectRenderer=new n(this._engine),this._effectWrapper=this._createEffect(e),await this._effectWrapper.effect.whenCompiledAsync();const t=this._prefilterInternal(e);return this.useCdf&&await this._cdfGenerator.findDominantDirection().then((e=>{t._dominantDirection=e})),this._effectRenderer.dispose(),this._effectWrapper.dispose(),this._cdfGenerator?.dispose(),t}}class E extends s{set isBlocking(e){this._isBlocking=e}get isBlocking(){return this._isBlocking}set rotationY(e){this._rotationY=e,this.setReflectionTextureMatrix(a.RotationY(this._rotationY))}get rotationY(){return this._rotationY}set boundingBoxSize(t){if(this._boundingBoxSize&&this._boundingBoxSize.equals(t))return;this._boundingBoxSize=t;const i=this.getScene();i&&i.markAllMaterialsAsDirty(e.MATERIAL_TextureDirtyFlag)}get boundingBoxSize(){return this._boundingBoxSize}constructor(t,r,n,s=!1,_=!0,d=!1,c=!1,u=null,f=null,p=!1,g=!1,m=!1){super(r),this._generateHarmonics=!0,this._onError=null,this._isBlocking=!0,this._rotationY=0,this.boundingBoxPosition=i.Zero(),this.onLoadObservable=new o,t&&(this._coordinatesMode=h.CUBIC_MODE,this.name=t,this.url=t,this.hasAlpha=!1,this.isCube=!0,this._textureMatrix=a.Identity(),this._prefilterOnLoad=c,this._prefilterIrradianceOnLoad=g,this._prefilterUsingCdf=m,this._onLoad=()=>{this.onLoadObservable.notifyObservers(this),u&&u()},this._onError=f,this.gammaSpace=d,this._noMipmap=s,this._size=n,this._supersample=p||m,this._generateHarmonics=_,this._texture=this._getFromCache(t,this._noMipmap,void 0,void 0,void 0,this.isCube),this._texture?this._texture.isReady?l.SetImmediate((()=>this._onLoad())):this._texture.onLoadedObservable.add(this._onLoad):this.getScene()?.useDelayedTextureLoading?this.delayLoadState=e.DELAYLOADSTATE_NOTLOADED:this._loadTexture())}getClassName(){return"EnvCubeTexture"}_loadTexture(){const t=this._getEngine(),i=t.getCaps();let r=e.TEXTURETYPE_UNSIGNED_BYTE;i.textureFloat&&i.textureFloatLinearFiltering?r=e.TEXTURETYPE_FLOAT:i.textureHalfFloat&&i.textureHalfFloatLinearFiltering&&(r=e.TEXTURETYPE_HALF_FLOAT);if(t._features.allowTexturePrefiltering&&(this._prefilterOnLoad||this._prefilterIrradianceOnLoad)){const i=this._onLoad,r=new m(t);this._onLoad=()=>{let n=Promise.resolve(null),s=Promise.resolve();if(this._prefilterIrradianceOnLoad){n=new T(t,{useCdf:this._prefilterUsingCdf}).prefilter(this)}this._prefilterOnLoad&&(s=r.prefilter(this)),Promise.all([n,s]).then((t=>{const r=t[0];if(this._prefilterIrradianceOnLoad&&r){this.irradianceTexture=r;const t=this.getScene();t&&t.markAllMaterialsAsDirty(e.MATERIAL_TextureDirtyFlag)}i&&i()}))}}this._texture=t.createRawCubeTextureFromUrl(this.url,this.getScene(),this._size,e.TEXTUREFORMAT_RGB,r,this._noMipmap,(async t=>{this.lodGenerationOffset=0,this.lodGenerationScale=.8;const i=await this._getCubeMapTextureDataAsync(t,this._size,this._supersample);if(this._generateHarmonics){const e=d.ConvertCubeMapToSphericalPolynomial(i);this.sphericalPolynomial=e}const n=[];let s=null,a=null;for(let t=0;t<6;t++){r===e.TEXTURETYPE_HALF_FLOAT?a=new Uint16Array(this._size*this._size*3):r===e.TEXTURETYPE_UNSIGNED_BYTE&&(s=new Uint8Array(this._size*this._size*3));const o=i[E._FacesMapping[t]];if(this.gammaSpace||a||s)for(let e=0;e<this._size*this._size;e++)if(this.gammaSpace&&(o[3*e+0]=Math.pow(o[3*e+0],c),o[3*e+1]=Math.pow(o[3*e+1],c),o[3*e+2]=Math.pow(o[3*e+2],c)),a&&(a[3*e+0]=u(o[3*e+0]),a[3*e+1]=u(o[3*e+1]),a[3*e+2]=u(o[3*e+2])),s){let t=Math.max(255*o[3*e+0],0),i=Math.max(255*o[3*e+1],0),r=Math.max(255*o[3*e+2],0);const n=Math.max(Math.max(t,i),r);if(n>255){const e=255/n;t*=e,i*=e,r*=e}s[3*e+0]=t,s[3*e+1]=i,s[3*e+2]=r}a?n.push(a):s?n.push(s):n.push(o)}return n}),null,this._onLoad,this._onError),this._generateHarmonics||this._texture._sphericalPolynomial||(this._texture._sphericalPolynomial=new _)}delayLoad(){this.delayLoadState===e.DELAYLOADSTATE_NOTLOADED&&(this.delayLoadState=e.DELAYLOADSTATE_LOADED,this._texture=this._getFromCache(this.url,this._noMipmap),this._texture||this._loadTexture())}getReflectionTextureMatrix(){return this._textureMatrix}setReflectionTextureMatrix(t){this._textureMatrix=t,t.updateFlag!==this._textureMatrix.updateFlag&&t.isIdentity()!==this._textureMatrix.isIdentity()&&this.getScene()?.markAllMaterialsAsDirty(e.MATERIAL_TextureDirtyFlag,(e=>-1!==e.getActiveTextures().indexOf(this)))}dispose(){this.onLoadObservable.clear(),super.dispose()}serialize(){if(!this.name)return null;const e={};return e.name=this.name,e.hasAlpha=this.hasAlpha,e.isCube=!0,e.level=this.level,e.size=this._size,e.coordinatesMode=this.coordinatesMode,e.useInGammaSpace=this.gammaSpace,e.generateHarmonics=this._generateHarmonics,e.noMipmap=this._noMipmap,e.isBlocking=this._isBlocking,e.rotationY=this._rotationY,e}clone(){const e=this._instantiateClone();return e.level=this.level,e.wrapU=this.wrapU,e.wrapV=this.wrapV,e.coordinatesIndex=this.coordinatesIndex,e.coordinatesMode=this.coordinatesMode,e}static _Parse(e,t){t.name=e.name,t.hasAlpha=e.hasAlpha,t.level=e.level,t.coordinatesMode=e.coordinatesMode,t.isBlocking=e.isBlocking,e.boundingBoxPosition&&(t.boundingBoxPosition=i.FromArray(e.boundingBoxPosition)),e.boundingBoxSize&&(t.boundingBoxSize=i.FromArray(e.boundingBoxSize)),e.rotationY&&(t.rotationY=e.rotationY)}}E._FacesMapping=["right","left","up","down","front","back"];class x extends E{constructor(e,t,i,r=!1,n=!0,s=!1,a=!1,o=null,h=null,l=!1,_=!1,d=!1){super(e,t,i,r,n,s,a,o,h,l,_,d)}getClassName(){return"HDRCubeTexture"}async _getCubeMapTextureDataAsync(e,t,i){return g(e,t,i)}_instantiateClone(){return new x(this.url,this.getScene()||this._getEngine(),this._size,this._noMipmap,this._generateHarmonics,this.gammaSpace)}serialize(){const e=super.serialize();return e?(e.customType="BABYLON.HDRCubeTexture",e):null}static Parse(e,t,i){if(!e.name||e.isRenderTarget)return null;const r=new x(i+e.name,t,e.size,e.noMipmap,e.generateHarmonics,e.useInGammaSpace);return this._Parse(e,r),r}}f("BABYLON.HDRCubeTexture",x);export{x as HDRCubeTexture};
//# sourceMappingURL=hdrCubeTexture-CgpYBfeX.esm.min.js.map
