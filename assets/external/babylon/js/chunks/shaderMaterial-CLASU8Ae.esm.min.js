import{aZ as t,p as s,J as e,W as r,N as i,a0 as n,X as o,l as a,Y as h,a4 as c,Z as f,a_ as u,a$ as _,$ as l,S as x,T as p,Q as d,b0 as m,e as y,a3 as A,C as g,g as v}from"./index-C7lpuH7l.esm.min.js";const T=new WeakMap;const M={effect:null,subMesh:null};class b extends t{constructor(t,e,r,i={},n=!0){super(t,e,n),this._textures={},this._internalTextures={},this._textureArrays={},this._externalTextures={},this._floats={},this._ints={},this._uints={},this._floatsArrays={},this._colors3={},this._colors3Arrays={},this._colors4={},this._colors4Arrays={},this._vectors2={},this._vectors3={},this._vectors4={},this._quaternions={},this._quaternionsArrays={},this._matrices={},this._matrixArrays={},this._matrices3x3={},this._matrices2x2={},this._vectors2Arrays={},this._vectors3Arrays={},this._vectors4Arrays={},this._uniformBuffers={},this._textureSamplers={},this._storageBuffers={},this._cachedWorldViewMatrix=new s,this._cachedWorldViewProjectionMatrix=new s,this._multiview=!1,this._vertexPullingMetadata=null,this._materialHelperNeedsPreviousMatrices=!1,this._shaderPath=r,this._options={needAlphaBlending:!1,needAlphaTesting:!1,attributes:["position","normal","uv"],uniforms:["worldViewProjection"],uniformBuffers:[],samplers:[],externalTextures:[],samplerObjects:[],storageBuffers:[],defines:[],useClipPlane:!1,...i}}get shaderPath(){return this._shaderPath}set shaderPath(t){this._shaderPath=t}get options(){return this._options}get isMultiview(){return this._multiview}getClassName(){return"ShaderMaterial"}needAlphaBlending(){return this.alpha<1||this._options.needAlphaBlending}needAlphaTesting(){return this._options.needAlphaTesting}_checkUniform(t){-1===this._options.uniforms.indexOf(t)&&this._options.uniforms.push(t)}setTexture(t,s){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._textures[t]=s,this}setInternalTexture(t,s){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._internalTextures[t]=s,this}removeTexture(t){delete this._textures[t]}setTextureArray(t,s){return-1===this._options.samplers.indexOf(t)&&this._options.samplers.push(t),this._checkUniform(t),this._textureArrays[t]=s,this}setExternalTexture(t,s){return-1===this._options.externalTextures.indexOf(t)&&this._options.externalTextures.push(t),this._externalTextures[t]=s,this}setFloat(t,s){return this._checkUniform(t),this._floats[t]=s,this}setInt(t,s){return this._checkUniform(t),this._ints[t]=s,this}setUInt(t,s){return this._checkUniform(t),this._uints[t]=s,this}setFloats(t,s){return this._checkUniform(t),this._floatsArrays[t]=s,this}setColor3(t,s){return this._checkUniform(t),this._colors3[t]=s,this}setColor3Array(t,s){return this._checkUniform(t),this._colors3Arrays[t]=s.reduce(((t,s)=>(t.push(s.r,s.g,s.b),t)),[]),this}setColor4(t,s){return this._checkUniform(t),this._colors4[t]=s,this}setColor4Array(t,s){return this._checkUniform(t),this._colors4Arrays[t]=s.reduce(((t,s)=>(t.push(s.r,s.g,s.b,s.a),t)),[]),this}setVector2(t,s){return this._checkUniform(t),this._vectors2[t]=s,this}setVector3(t,s){return this._checkUniform(t),this._vectors3[t]=s,this}setVector4(t,s){return this._checkUniform(t),this._vectors4[t]=s,this}setQuaternion(t,s){return this._checkUniform(t),this._quaternions[t]=s,this}setQuaternionArray(t,s){return this._checkUniform(t),this._quaternionsArrays[t]=s.reduce(((t,s)=>(s.toArray(t,t.length),t)),[]),this}setMatrix(t,s){return this._checkUniform(t),this._matrices[t]=s,this}setMatrices(t,s){this._checkUniform(t);const e=new Float32Array(16*s.length);for(let t=0;t<s.length;t++){s[t].copyToArray(e,16*t)}return this._matrixArrays[t]=e,this}setMatrix3x3(t,s){return this._checkUniform(t),this._matrices3x3[t]=s,this}setMatrix2x2(t,s){return this._checkUniform(t),this._matrices2x2[t]=s,this}setArray2(t,s){return this._checkUniform(t),this._vectors2Arrays[t]=s,this}setArray3(t,s){return this._checkUniform(t),this._vectors3Arrays[t]=s,this}setArray4(t,s){return this._checkUniform(t),this._vectors4Arrays[t]=s,this}setUniformBuffer(t,s){return-1===this._options.uniformBuffers.indexOf(t)&&this._options.uniformBuffers.push(t),this._uniformBuffers[t]=s,this}setTextureSampler(t,s){return-1===this._options.samplerObjects.indexOf(t)&&this._options.samplerObjects.push(t),this._textureSamplers[t]=s,this}setStorageBuffer(t,s){return-1===this._options.storageBuffers.indexOf(t)&&this._options.storageBuffers.push(t),this._storageBuffers[t]=s,this}setDefine(t,s){const e=t.trimEnd()+" ",r=this.options.defines.findIndex((s=>s===t||s.startsWith(e)));return r>=0&&this.options.defines.splice(r,1),("boolean"!=typeof s||s)&&this.options.defines.push(e+s),this}isReadyForSubMesh(t,s,e){return this.isReady(t,e,s)}isReady(t,s,h){const c=h&&this._storeEffectOnSubMeshes;if(this.isFrozen){const t=c?h._drawWrapper:this._drawWrapper;if(t.effect&&t._wasPreviouslyReady&&t._wasPreviouslyUsingInstances===s)return!0}const f=this.getScene(),u=f.getEngine(),_=[],l=[];let x=null,p=this._shaderPath,d=this._options.uniforms,m=this._options.uniformBuffers,y=this._options.samplers;u.getCaps().multiview&&f.activeCamera&&f.activeCamera.outputRenderTarget&&f.activeCamera.outputRenderTarget.getViewCount()>1&&(this._multiview=!0,_.push("#define MULTIVIEW"),-1!==d.indexOf("viewProjection")&&-1===d.indexOf("viewProjectionR")&&d.push("viewProjectionR"));for(let t=0;t<this._options.defines.length;t++){const s=0===this._options.defines[t].indexOf("#define")?this._options.defines[t]:`#define ${this._options.defines[t]}`;_.push(s)}for(let t=0;t<this._options.attributes.length;t++)l.push(this._options.attributes[t]);if(t&&t.isVerticesDataPresent(e.ColorKind)&&(-1===l.indexOf(e.ColorKind)&&l.push(e.ColorKind),_.push("#define VERTEXCOLOR")),s&&(_.push("#define INSTANCES"),r(l,this._materialHelperNeedsPreviousMatrices),t?.hasThinInstances&&(_.push("#define THIN_INSTANCES"),t&&t.isVerticesDataPresent(e.ColorInstanceKind)&&(l.push(e.ColorInstanceKind),_.push("#define INSTANCESCOLOR")))),t&&t.useBones&&t.computeBonesUsingShaders&&t.skeleton){l.push(e.MatricesIndicesKind),l.push(e.MatricesWeightsKind),t.numBoneInfluencers>4&&(l.push(e.MatricesIndicesExtraKind),l.push(e.MatricesWeightsExtraKind));const s=t.skeleton;_.push("#define NUM_BONE_INFLUENCERS "+t.numBoneInfluencers),x=new A,x.addCPUSkinningFallback(0,t),s.isUsingTextureForMatrices?(_.push("#define BONETEXTURE"),-1===d.indexOf("boneTextureWidth")&&d.push("boneTextureWidth"),-1===this._options.samplers.indexOf("boneSampler")&&this._options.samplers.push("boneSampler")):(_.push("#define BonesPerMesh "+(s.bones.length+1)),-1===d.indexOf("mBones")&&d.push("mBones"))}else _.push("#define NUM_BONE_INFLUENCERS 0");let g=0;const v=t?t.morphTargetManager:null;if(v){const s=-1!==_.indexOf("#define UV1"),e=-1!==_.indexOf("#define UV2"),r=-1!==_.indexOf("#define TANGENT"),n=-1!==_.indexOf("#define NORMAL"),o=-1!==_.indexOf("#define VERTEXCOLOR");g=i(v,_,l,t,!0,n,r,s,e,o),v.isUsingTextureForTargets&&(-1===d.indexOf("morphTargetTextureIndices")&&d.push("morphTargetTextureIndices"),-1===this._options.samplers.indexOf("morphTargets")&&this._options.samplers.push("morphTargets")),g>0&&(d=d.slice(),d.push("morphTargetInfluences"),d.push("morphTargetCount"),d.push("morphTargetTextureInfo"),d.push("morphTargetTextureIndices"))}else _.push("#define NUM_MORPH_INFLUENCERS 0");if(t){const e=t.bakedVertexAnimationManager;e&&e.isEnabled&&(_.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),-1===d.indexOf("bakedVertexAnimationSettings")&&d.push("bakedVertexAnimationSettings"),-1===d.indexOf("bakedVertexAnimationTextureSizeInverted")&&d.push("bakedVertexAnimationTextureSizeInverted"),-1===d.indexOf("bakedVertexAnimationTime")&&d.push("bakedVertexAnimationTime"),-1===this._options.samplers.indexOf("bakedVertexAnimationTexture")&&this._options.samplers.push("bakedVertexAnimationTexture"),s&&l.push("bakedVertexAnimationSettingsInstanced"))}for(const t in this._textures)if(!this._textures[t].isReady())return!1;for(const t in this._internalTextures)if(!this._internalTextures[t].isReady)return!1;t&&this.needAlphaTestingForMesh(t)&&_.push("#define ALPHATEST"),!1!==this._options.useClipPlane&&(n(d),o(this,f,_)),f.fogEnabled&&t?.applyFog&&f.fogMode!==a.FOGMODE_NONE&&(_.push("#define FOG"),-1===d.indexOf("view")&&d.push("view"),-1===d.indexOf("vFogInfos")&&d.push("vFogInfos"),-1===d.indexOf("vFogColor")&&d.push("vFogColor")),this._useLogarithmicDepth&&(_.push("#define LOGARITHMICDEPTH"),-1===d.indexOf("logarithmicDepthConstant")&&d.push("logarithmicDepthConstant"));const b=h?h.getRenderingMesh():t;if(b&&this.useVertexPulling){const t=b.geometry;t&&(this._vertexPullingMetadata=function(t){const s=t.getVertexBuffers();if(!s)return null;let e=T.get(t);if(e){let t=!1;for(const r in s)if(!e.has(r)){t=!0;break}if(!t)return e}else e=new Map,T.set(t,e);for(const t in s){const r=s[t];if(r){const s=r.byteOffset,i=r.byteStride,n=r.type;e.set(t,{offset:s,stride:i,type:n})}}return e}(t),this._vertexPullingMetadata&&this._vertexPullingMetadata.forEach(((t,s)=>{d.push(`vp_${s}_info`)}))),_.push("#define USE_VERTEX_PULLING");const s=b.geometry?.getIndexBuffer();s&&!b.isUnIndexed&&(_.push("#define VERTEX_PULLING_USE_INDEX_BUFFER"),s.is32Bits&&_.push("#define VERTEX_PULLING_INDEX_BUFFER_32BITS"))}this.customShaderNameResolve&&(d=d.slice(),m=m.slice(),y=y.slice(),p=this.customShaderNameResolve(this.name,d,m,y,_,l));const O=c?h._getDrawWrapper(void 0,!0):this._drawWrapper,E=O?.effect??null,S=O?.defines??null,w=_.join("\n");let P=E;return S!==w&&(P=u.createEffect(p,{attributes:l,uniformsNames:d,uniformBuffersNames:m,samplers:y,defines:w,fallbacks:x,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{maxSimultaneousMorphTargets:g},shaderLanguage:this._options.shaderLanguage,extraInitializationsAsync:this._options.extraInitializationsAsync},u),c?h.setEffect(P,w,this._materialContext):O&&O.setEffect(P,w),this._onEffectCreatedObservable&&(M.effect=P,M.subMesh=h??t?.subMeshes[0]??null,this._onEffectCreatedObservable.notifyObservers(M))),O._wasPreviouslyUsingInstances=!!s,!!P?.isReady()&&(E!==P&&f.resetCachedMaterial(),O._wasPreviouslyReady=!0,!0)}bindOnlyWorldMatrix(t,s){const e=s??this.getEffect();if(!e)return;const r=this._options.uniforms;-1!==r.indexOf("world")&&e.setMatrix("world",t);const i=this.getScene();-1!==r.indexOf("worldView")&&(t.multiplyToRef(i.getViewMatrix(),this._cachedWorldViewMatrix),e.setMatrix("worldView",this._cachedWorldViewMatrix)),-1!==r.indexOf("worldViewProjection")&&(t.multiplyToRef(i.getTransformMatrix(),this._cachedWorldViewProjectionMatrix),e.setMatrix("worldViewProjection",this._cachedWorldViewProjectionMatrix)),-1!==r.indexOf("view")&&e.setMatrix("view",i.getViewMatrix())}bindForSubMesh(t,s,e){this.bind(t,s,e._drawWrapperOverride?.effect,e)}bind(t,s,e,r){const i=r&&this._storeEffectOnSubMeshes,n=e??(i?r.effect:this.getEffect());if(!n)return;const o=this.getScene();this._activeEffect=n,this.bindOnlyWorldMatrix(t,e);const a=this._options.uniformBuffers;let x=!1;if(n&&a&&a.length>0&&o.getEngine().supportsUniformBuffers)for(let e=0;e<a.length;++e){switch(a[e]){case"Mesh":s&&(s.getMeshUniformBuffer().bindToEffect(n,"Mesh"),s.transferToEffect(t));break;case"Scene":h(n,o.getSceneUniformBuffer()),o.finalizeSceneUbo(),x=!0}}const p=s&&i?this._mustRebind(o,n,r,s.visibility):o.getCachedMaterial()!==this;if(n&&p){let t;for(t in x||-1===this._options.uniforms.indexOf("view")||n.setMatrix("view",o.getViewMatrix()),x||-1===this._options.uniforms.indexOf("projection")||n.setMatrix("projection",o.getProjectionMatrix()),x||-1===this._options.uniforms.indexOf("viewProjection")||(n.setMatrix("viewProjection",o.getTransformMatrix()),this._multiview&&n.setMatrix("viewProjectionR",o._transformMatrixR)),o.activeCamera&&-1!==this._options.uniforms.indexOf("cameraPosition")&&n.setVector3("cameraPosition",o.activeCamera.globalPosition),c(s,n),f(n,this,o),this._vertexPullingMetadata&&function(t,s){s.forEach(((s,e)=>{const r=`vp_${e}_info`;t.setFloat3(r,s.offset,s.stride,s.type)}))}(n,this._vertexPullingMetadata),this._useLogarithmicDepth&&u(i?r.materialDefines:n.defines,n,o),s&&_(o,s,n),this._textures)n.setTexture(t,this._textures[t]);for(t in this._internalTextures)n._bindTexture(t,this._internalTextures[t]);for(t in this._textureArrays)n.setTextureArray(t,this._textureArrays[t]);for(t in this._ints)n.setInt(t,this._ints[t]);for(t in this._uints)n.setUInt(t,this._uints[t]);for(t in this._floats)n.setFloat(t,this._floats[t]);for(t in this._floatsArrays)n.setArray(t,this._floatsArrays[t]);for(t in this._colors3)n.setColor3(t,this._colors3[t]);for(t in this._colors3Arrays)n.setArray3(t,this._colors3Arrays[t]);for(t in this._colors4){const s=this._colors4[t];n.setFloat4(t,s.r,s.g,s.b,s.a)}for(t in this._colors4Arrays)n.setArray4(t,this._colors4Arrays[t]);for(t in this._vectors2)n.setVector2(t,this._vectors2[t]);for(t in this._vectors3)n.setVector3(t,this._vectors3[t]);for(t in this._vectors4)n.setVector4(t,this._vectors4[t]);for(t in this._quaternions)n.setQuaternion(t,this._quaternions[t]);for(t in this._matrices)n.setMatrix(t,this._matrices[t]);for(t in this._matrixArrays)n.setMatrices(t,this._matrixArrays[t]);for(t in this._matrices3x3)n.setMatrix3x3(t,this._matrices3x3[t]);for(t in this._matrices2x2)n.setMatrix2x2(t,this._matrices2x2[t]);for(t in this._vectors2Arrays)n.setArray2(t,this._vectors2Arrays[t]);for(t in this._vectors3Arrays)n.setArray3(t,this._vectors3Arrays[t]);for(t in this._vectors4Arrays)n.setArray4(t,this._vectors4Arrays[t]);for(t in this._quaternionsArrays)n.setArray4(t,this._quaternionsArrays[t]);for(t in this._uniformBuffers){const s=this._uniformBuffers[t].getBuffer();s&&n.bindUniformBuffer(s,t)}const e=o.getEngine(),a=e.setExternalTexture;if(a)for(t in this._externalTextures)a.call(e,t,this._externalTextures[t]);const h=e.setTextureSampler;if(h)for(t in this._textureSamplers)h.call(e,t,this._textureSamplers[t]);const l=e.setStorageBuffer;if(l)for(t in this._storageBuffers)l.call(e,t,this._storageBuffers[t])}if(n&&s&&(p||!this.isFrozen)){l(s,n),s.morphTargetManager&&s.morphTargetManager.isUsingTextureForTargets&&s.morphTargetManager._bind(n);const t=s.bakedVertexAnimationManager;if(t&&t.isEnabled){const t=i?r._drawWrapper:this._drawWrapper;s.bakedVertexAnimationManager?.bind(n,!!t._wasPreviouslyUsingInstances)}}this._afterBind(s,n,r)}getActiveTextures(){const t=super.getActiveTextures();for(const s in this._textures)t.push(this._textures[s]);for(const s in this._textureArrays){const e=this._textureArrays[s];for(let s=0;s<e.length;s++)t.push(e[s])}return t}hasTexture(t){if(super.hasTexture(t))return!0;for(const s in this._textures)if(this._textures[s]===t)return!0;const s=t.getInternalTexture();for(const t in this._internalTextures)if(this._internalTextures[t]===s)return!0;for(const s in this._textureArrays){const e=this._textureArrays[s];for(let s=0;s<e.length;s++)if(e[s]===t)return!0}return!1}clone(t){const s=x.Clone((()=>new b(t,this.getScene(),this._shaderPath,this._options,this._storeEffectOnSubMeshes)),this);s.name=t,s.id=t,"object"==typeof s._shaderPath&&(s._shaderPath={...s._shaderPath}),this._options={...this._options};const e=Object.keys(this._options);for(const t of e){const s=this._options[t];Array.isArray(s)&&(this._options[t]=s.slice(0))}this.stencil.copyTo(s.stencil);for(const t in this._textures)s.setTexture(t,this._textures[t]);for(const t in this._internalTextures)s.setInternalTexture(t,this._internalTextures[t]);for(const t in this._textureArrays)s.setTextureArray(t,this._textureArrays[t]);for(const t in this._externalTextures)s.setExternalTexture(t,this._externalTextures[t]);for(const t in this._ints)s.setInt(t,this._ints[t]);for(const t in this._uints)s.setUInt(t,this._uints[t]);for(const t in this._floats)s.setFloat(t,this._floats[t]);for(const t in this._floatsArrays)s.setFloats(t,this._floatsArrays[t]);for(const t in this._colors3)s.setColor3(t,this._colors3[t]);for(const t in this._colors3Arrays)s._colors3Arrays[t]=this._colors3Arrays[t];for(const t in this._colors4)s.setColor4(t,this._colors4[t]);for(const t in this._colors4Arrays)s._colors4Arrays[t]=this._colors4Arrays[t];for(const t in this._vectors2)s.setVector2(t,this._vectors2[t]);for(const t in this._vectors3)s.setVector3(t,this._vectors3[t]);for(const t in this._vectors4)s.setVector4(t,this._vectors4[t]);for(const t in this._quaternions)s.setQuaternion(t,this._quaternions[t]);for(const t in this._quaternionsArrays)s._quaternionsArrays[t]=this._quaternionsArrays[t];for(const t in this._matrices)s.setMatrix(t,this._matrices[t]);for(const t in this._matrixArrays)s._matrixArrays[t]=this._matrixArrays[t].slice();for(const t in this._matrices3x3)s.setMatrix3x3(t,this._matrices3x3[t]);for(const t in this._matrices2x2)s.setMatrix2x2(t,this._matrices2x2[t]);for(const t in this._vectors2Arrays)s.setArray2(t,this._vectors2Arrays[t]);for(const t in this._vectors3Arrays)s.setArray3(t,this._vectors3Arrays[t]);for(const t in this._vectors4Arrays)s.setArray4(t,this._vectors4Arrays[t]);for(const t in this._uniformBuffers)s.setUniformBuffer(t,this._uniformBuffers[t]);for(const t in this._textureSamplers)s.setTextureSampler(t,this._textureSamplers[t]);for(const t in this._storageBuffers)s.setStorageBuffer(t,this._storageBuffers[t]);return s}dispose(t,s,e){if(s){let t;for(t in this._textures)this._textures[t].dispose();for(t in this._internalTextures)this._internalTextures[t].dispose();for(t in this._textureArrays){const s=this._textureArrays[t];for(let t=0;t<s.length;t++)s[t].dispose()}}this._textures={},this._internalTextures={},super.dispose(t,s,e)}serialize(){const t=x.Serialize(this);let s;for(s in t.customType="BABYLON.ShaderMaterial",t.uniqueId=this.uniqueId,t.options=this._options,t.shaderPath=this._shaderPath,t.storeEffectOnSubMeshes=this._storeEffectOnSubMeshes,t.stencil=this.stencil.serialize(),t.textures={},this._textures)t.textures[s]=this._textures[s].serialize();for(s in t.textureArrays={},this._textureArrays){t.textureArrays[s]=[];const e=this._textureArrays[s];for(let r=0;r<e.length;r++)t.textureArrays[s].push(e[r].serialize())}for(s in t.ints={},this._ints)t.ints[s]=this._ints[s];for(s in t.uints={},this._uints)t.uints[s]=this._uints[s];for(s in t.floats={},this._floats)t.floats[s]=this._floats[s];for(s in t.floatsArrays={},this._floatsArrays)t.floatsArrays[s]=this._floatsArrays[s];for(s in t.colors3={},this._colors3){const e=this._colors3[s];t.colors3[s]=[e.r,e.g,e.b]}for(s in t.colors3Arrays={},this._colors3Arrays)t.colors3Arrays[s]=this._colors3Arrays[s];for(s in t.colors4={},this._colors4){const e=this._colors4[s];t.colors4[s]=[e.r,e.g,e.b,e.a]}for(s in t.colors4Arrays={},this._colors4Arrays)t.colors4Arrays[s]=this._colors4Arrays[s];for(s in t.vectors2={},this._vectors2){const e=this._vectors2[s];t.vectors2[s]=[e.x,e.y]}for(s in t.vectors3={},this._vectors3){const e=this._vectors3[s];t.vectors3[s]=[e.x,e.y,e.z]}for(s in t.vectors4={},this._vectors4){const e=this._vectors4[s];t.vectors4[s]=[e.x,e.y,e.z,e.w]}for(s in t.quaternions={},this._quaternions)t.quaternions[s]=this._quaternions[s].asArray();for(s in t.matrices={},this._matrices)t.matrices[s]=this._matrices[s].asArray();for(s in t.matrixArray={},this._matrixArrays)t.matrixArray[s]=this._matrixArrays[s];for(s in t.matrices3x3={},this._matrices3x3)t.matrices3x3[s]=this._matrices3x3[s];for(s in t.matrices2x2={},this._matrices2x2)t.matrices2x2[s]=this._matrices2x2[s];for(s in t.vectors2Arrays={},this._vectors2Arrays)t.vectors2Arrays[s]=this._vectors2Arrays[s];for(s in t.vectors3Arrays={},this._vectors3Arrays)t.vectors3Arrays[s]=this._vectors3Arrays[s];for(s in t.vectors4Arrays={},this._vectors4Arrays)t.vectors4Arrays[s]=this._vectors4Arrays[s];for(s in t.quaternionsArrays={},this._quaternionsArrays)t.quaternionsArrays[s]=this._quaternionsArrays[s];return t}static Parse(t,e,r){const i=x.Parse((()=>new b(t.name,e,t.shaderPath,t.options,t.storeEffectOnSubMeshes)),t,e,r);let n;for(n in t.stencil&&i.stencil.parse(t.stencil,e,r),t.textures)i.setTexture(n,p.Parse(t.textures[n],e,r));for(n in t.textureArrays){const s=t.textureArrays[n],o=[];for(let t=0;t<s.length;t++)o.push(p.Parse(s[t],e,r));i.setTextureArray(n,o)}for(n in t.ints)i.setInt(n,t.ints[n]);for(n in t.uints)i.setUInt(n,t.uints[n]);for(n in t.floats)i.setFloat(n,t.floats[n]);for(n in t.floatsArrays)i.setFloats(n,t.floatsArrays[n]);for(n in t.colors3){const s=t.colors3[n];i.setColor3(n,{r:s[0],g:s[1],b:s[2]})}for(n in t.colors3Arrays){const s=t.colors3Arrays[n].reduce(((t,s,e)=>(e%3==0?t.push([s]):t[t.length-1].push(s),t)),[]).map((t=>({r:t[0],g:t[1],b:t[2]})));i.setColor3Array(n,s)}for(n in t.colors4){const s=t.colors4[n];i.setColor4(n,{r:s[0],g:s[1],b:s[2],a:s[3]})}for(n in t.colors4Arrays){const s=t.colors4Arrays[n].reduce(((t,s,e)=>(e%4==0?t.push([s]):t[t.length-1].push(s),t)),[]).map((t=>({r:t[0],g:t[1],b:t[2],a:t[3]})));i.setColor4Array(n,s)}for(n in t.vectors2){const s=t.vectors2[n];i.setVector2(n,{x:s[0],y:s[1]})}for(n in t.vectors3){const s=t.vectors3[n];i.setVector3(n,{x:s[0],y:s[1],z:s[2]})}for(n in t.vectors4){const s=t.vectors4[n];i.setVector4(n,{x:s[0],y:s[1],z:s[2],w:s[3]})}for(n in t.quaternions)i.setQuaternion(n,d.FromArray(t.quaternions[n]));for(n in t.matrices)i.setMatrix(n,s.FromArray(t.matrices[n]));for(n in t.matrixArray)i._matrixArrays[n]=new Float32Array(t.matrixArray[n]);for(n in t.matrices3x3)i.setMatrix3x3(n,t.matrices3x3[n]);for(n in t.matrices2x2)i.setMatrix2x2(n,t.matrices2x2[n]);for(n in t.vectors2Arrays)i.setArray2(n,t.vectors2Arrays[n]);for(n in t.vectors3Arrays)i.setArray3(n,t.vectors3Arrays[n]);for(n in t.vectors4Arrays)i.setArray4(n,t.vectors4Arrays[n]);for(n in t.quaternionsArrays)i.setArray4(n,t.quaternionsArrays[n]);return i}static async ParseFromFileAsync(t,s,e,r=""){return await new Promise(((i,n)=>{const o=new m;o.addEventListener("readystatechange",(()=>{if(4==o.readyState)if(200==o.status){const s=JSON.parse(o.responseText),n=this.Parse(s,e||y.LastCreatedScene,r);t&&(n.name=t),i(n)}else n("Unable to load the ShaderMaterial")})),o.open("GET",s),o.send()}))}static async ParseFromSnippetAsync(t,s,e=""){return await new Promise(((r,i)=>{const n=new m;n.addEventListener("readystatechange",(()=>{if(4==n.readyState)if(200==n.status){const i=JSON.parse(JSON.parse(n.responseText).jsonPayload),o=JSON.parse(i.shaderMaterial),a=this.Parse(o,s||y.LastCreatedScene,e);a.snippetId=t,r(a)}else i("Unable to load the snippet "+t)})),n.open("GET",this.SnippetUrl+"/"+t.replace(/#/g,"/")),n.send()}))}}b.SnippetUrl=g.SnippetUrl,b.CreateFromSnippetAsync=b.ParseFromSnippetAsync,v("BABYLON.ShaderMaterial",b);export{b as ShaderMaterial};
//# sourceMappingURL=shaderMaterial-CLASU8Ae.esm.min.js.map
