{"version":3,"file":"abstractSoundInstance-sVqCQsb0.esm.min.js","sources":["../../../../../dev/core/dist/AudioV2/abstractAudio/abstractSound.js","../../../../../dev/core/dist/AudioV2/abstractAudio/abstractSoundInstance.js"],"sourcesContent":["import { Observable } from \"../../Misc/observable\";\nimport { AbstractSoundSource } from \"./abstractSoundSource\";\n/**\n * Abstract class representing a sound in the audio engine.\n */\nexport class AbstractSound extends AbstractSoundSource {\n    constructor(name, engine, options) {\n        super(name, engine, options, 3 /* AudioNodeType.HAS_INPUTS_AND_OUTPUTS */); // Inputs are for instances.\n        this._newestInstance = null;\n        this._privateInstances = new Set();\n        this._state = 1 /* SoundState.Stopped */;\n        this._instances = this._privateInstances;\n        /**\n         * Observable for when the sound stops playing.\n         */\n        this.onEndedObservable = new Observable();\n        this._onInstanceEnded = (instance) => {\n            if (this._newestInstance === instance) {\n                this._newestInstance = null;\n            }\n            this._privateInstances.delete(instance);\n            if (this._instances.size === 0) {\n                this._state = 1 /* SoundState.Stopped */;\n                this.onEndedObservable.notifyObservers(this);\n            }\n            instance.dispose();\n        };\n    }\n    /**\n     * The number of active instances of the sound that are currently playing.\n     */\n    get activeInstancesCount() {\n        return this._instances.size;\n    }\n    /**\n     * Whether the sound should start playing automatically. Defaults to `false`.\n     */\n    get autoplay() {\n        return this._options.autoplay;\n    }\n    /**\n     * The current playback time of the sound, in seconds.\n     */\n    get currentTime() {\n        const instance = this._getNewestInstance();\n        return instance ? instance.currentTime : 0;\n    }\n    set currentTime(value) {\n        this.startOffset = value;\n        const instance = this._getNewestInstance();\n        if (instance) {\n            instance.currentTime = value;\n        }\n    }\n    /**\n     * Whether the sound should loop. Defaults to `false`.\n     */\n    get loop() {\n        return this._options.loop;\n    }\n    set loop(value) {\n        this._options.loop = value;\n    }\n    /**\n     * The maximum number of instances that can play at the same time. Defaults to `Infinity`.\n     */\n    get maxInstances() {\n        return this._options.maxInstances;\n    }\n    set maxInstances(value) {\n        this._options.maxInstances = value;\n    }\n    /**\n     * The time within the sound buffer to start playing at, in seconds. Defaults to `0`.\n     */\n    get startOffset() {\n        return this._options.startOffset;\n    }\n    set startOffset(value) {\n        this._options.startOffset = value;\n    }\n    /**\n     * The state of the sound.\n     */\n    get state() {\n        return this._state;\n    }\n    /**\n     * Releases associated resources.\n     */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this._newestInstance = null;\n        this._privateInstances.clear();\n        this.onEndedObservable.clear();\n    }\n    /**\n     * Pauses the sound.\n     */\n    pause() {\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.pause();\n        }\n        this._state = 5 /* SoundState.Paused */;\n    }\n    /**\n     * Resumes the sound.\n     */\n    resume() {\n        if (this._state !== 5 /* SoundState.Paused */) {\n            return;\n        }\n        const it = this._instances.values();\n        for (let next = it.next(); !next.done; next = it.next()) {\n            next.value.resume();\n        }\n        this._state = 3 /* SoundState.Started */;\n    }\n    _beforePlay(instance) {\n        if (this.state === 5 /* SoundState.Paused */ && this._instances.size > 0) {\n            this.resume();\n            return;\n        }\n        instance.onEndedObservable.addOnce(this._onInstanceEnded);\n        this._privateInstances.add(instance);\n        this._newestInstance = instance;\n    }\n    _afterPlay(instance) {\n        this._state = instance.state;\n    }\n    _getNewestInstance() {\n        if (this._instances.size === 0) {\n            return null;\n        }\n        if (!this._newestInstance) {\n            const it = this._instances.values();\n            for (let next = it.next(); !next.done; next = it.next()) {\n                this._newestInstance = next.value;\n            }\n        }\n        return this._newestInstance;\n    }\n    _setState(state) {\n        this._state = state;\n    }\n    _stopExcessInstances() {\n        if (this.maxInstances < Infinity) {\n            const numberOfInstancesToStop = Array.from(this._instances).filter((instance) => instance.state === 3 /* SoundState.Started */).length - this.maxInstances;\n            const it = this._instances.values();\n            for (let i = 0; i < numberOfInstancesToStop; i++) {\n                const instance = it.next().value;\n                instance.stop();\n            }\n        }\n    }\n}\n//# sourceMappingURL=abstractSound.js.map","import { Observable } from \"../../Misc/observable\";\nimport { AbstractAudioNode } from \"./abstractAudioNode\";\n/** @internal */\nexport class _AbstractSoundInstance extends AbstractAudioNode {\n    constructor(sound) {\n        super(sound.engine, 2 /* AudioNodeType.HAS_OUTPUTS */);\n        this._state = 1 /* SoundState.Stopped */;\n        /** Observable triggered when the sound instance's playback ends */\n        this.onEndedObservable = new Observable();\n        /** Observable triggered if the sound instance encounters an error and can not be played */\n        this.onErrorObservable = new Observable();\n        /** Observable triggered when the sound instance's state changes */\n        this.onStateChangedObservable = new Observable();\n        this._sound = sound;\n    }\n    /** The playback state of the sound instance */\n    get state() {\n        return this._state;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this.stop();\n        this.onEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n    _setState(value) {\n        if (this._state === value) {\n            return;\n        }\n        this._state = value;\n        this.onStateChangedObservable.notifyObservers(this);\n        if (this._state === 1 /* SoundState.Stopped */) {\n            this.onEndedObservable.notifyObservers(this);\n        }\n    }\n}\n//# sourceMappingURL=abstractSoundInstance.js.map"],"names":["AbstractSound","AbstractSoundSource","constructor","name","engine","options","super","this","_newestInstance","_privateInstances","Set","_state","_instances","onEndedObservable","Observable","_onInstanceEnded","instance","delete","size","notifyObservers","dispose","activeInstancesCount","autoplay","_options","currentTime","_getNewestInstance","value","startOffset","loop","maxInstances","state","stop","clear","pause","it","values","next","done","resume","_beforePlay","addOnce","add","_afterPlay","_setState","_stopExcessInstances","Infinity","numberOfInstancesToStop","Array","from","filter","length","i","_AbstractSoundInstance","AbstractAudioNode","sound","onErrorObservable","onStateChangedObservable","_sound"],"mappings":"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"}