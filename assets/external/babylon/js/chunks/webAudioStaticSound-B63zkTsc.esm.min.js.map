{"version":3,"file":"webAudioStaticSound-B63zkTsc.esm.min.js","sources":["../../../../../dev/core/dist/AudioV2/abstractAudio/staticSound.js","../../../../../dev/core/dist/AudioV2/abstractAudio/staticSoundBuffer.js","../../../../../dev/core/dist/AudioV2/abstractAudio/staticSoundInstance.js","../../../../../dev/core/dist/AudioV2/webAudio/webAudioStaticSound.js"],"sourcesContent":["import { AbstractSound } from \"./abstractSound\";\n/**\n * Abstract class representing a static sound.\n *\n * A static sound has a sound buffer that is loaded into memory all at once. This allows it to have more capabilities\n * than a streaming sound, such as loop points and playback rate changes, but it also means that the sound must be\n * fully downloaded and decoded before it can be played, which may take a long time for sounds with long durations.\n *\n * To prevent downloading and decoding a sound multiple times, a sound's buffer can be shared with other sounds.\n * See {@link CreateSoundBufferAsync}, {@link StaticSoundBuffer} and {@link StaticSound.buffer} for more information.\n *\n * Static sounds are created by the {@link CreateSoundAsync} function.\n */\nexport class StaticSound extends AbstractSound {\n    constructor(name, engine, options) {\n        super(name, engine, options);\n    }\n    /**\n     * The amount of time to play the sound for, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the sound plays for its full duration.\n     */\n    get duration() {\n        return this._options.duration;\n    }\n    set duration(value) {\n        this._options.duration = value;\n    }\n    /**\n     * The start of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop starts at the beginning of the sound.\n     */\n    get loopStart() {\n        return this._options.loopStart;\n    }\n    set loopStart(value) {\n        this._options.loopStart = value;\n    }\n    /**\n     * The end of the loop range, in seconds. Defaults to `0`.\n     * - If less than or equal to `0`, the loop plays for the sound's full duration.\n     */\n    get loopEnd() {\n        return this._options.loopEnd;\n    }\n    set loopEnd(value) {\n        this._options.loopEnd = value;\n    }\n    /**\n     * The pitch of the sound, in cents. Defaults to `0`.\n     * - Gets combined with {@link playbackRate} to determine the final pitch.\n     */\n    get pitch() {\n        return this._options.pitch;\n    }\n    set pitch(value) {\n        this._options.pitch = value;\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.pitch = value;\n        }\n    }\n    /**\n     * The playback rate of the sound. Defaults to `1`.\n     * - Gets combined with {@link pitch} to determine the final playback rate.\n     */\n    get playbackRate() {\n        return this._options.playbackRate;\n    }\n    set playbackRate(value) {\n        this._options.playbackRate = value;\n        const it = this._instances.values();\n        for (let instance = it.next(); !instance.done; instance = it.next()) {\n            instance.value.playbackRate = value;\n        }\n    }\n    /**\n     * Plays the sound.\n     * - Triggers `onEndedObservable` if played for the full duration and the `loop` option is not set.\n     * @param options The options to use when playing the sound. Options set here override the sound's options.\n     */\n    play(options = {}) {\n        if (this.state === 5 /* SoundState.Paused */) {\n            this.resume();\n            return;\n        }\n        options.duration ??= this.duration;\n        options.loop ??= this.loop;\n        options.loopStart ??= this.loopStart;\n        options.loopEnd ??= this.loopEnd;\n        options.startOffset ??= this.startOffset;\n        options.volume ??= 1;\n        options.waitTime ??= 0;\n        const instance = this._createInstance();\n        this._beforePlay(instance);\n        instance.play(options);\n        this._afterPlay(instance);\n        this._stopExcessInstances();\n    }\n    /**\n     * Stops the sound.\n     * - Triggers `onEndedObservable` if the sound is playing.\n     * @param options - The options to use when stopping the sound.\n     */\n    stop(options = {}) {\n        if (options.waitTime && 0 < options.waitTime) {\n            this._setState(0 /* SoundState.Stopping */);\n        }\n        else {\n            this._setState(1 /* SoundState.Stopped */);\n        }\n        if (!this._instances) {\n            return;\n        }\n        for (const instance of Array.from(this._instances)) {\n            instance.stop(options);\n        }\n    }\n}\n//# sourceMappingURL=staticSound.js.map","let StaticSoundBufferId = 1;\n/**\n * Abstract class representing a static sound buffer.\n *\n * A static sound buffer is a fully downloaded and decoded array of audio data that is ready to be played.\n *\n * Static sound buffers can be reused multiple times by different {@link StaticSound} instances.\n *\n * Static sound buffers are created by the {@link CreateSoundBufferAsync} function.\n *\n * @see {@link StaticSound.buffer}\n */\nexport class StaticSoundBuffer {\n    constructor(engine) {\n        /**\n         * The name of the sound buffer.\n         */\n        this.name = `StaticSoundBuffer #${StaticSoundBufferId++}`;\n        this.engine = engine;\n    }\n}\n//# sourceMappingURL=staticSoundBuffer.js.map","import { _AbstractSoundInstance } from \"./abstractSoundInstance\";\n/** @internal */\nexport class _StaticSoundInstance extends _AbstractSoundInstance {\n}\n//# sourceMappingURL=staticSoundInstance.js.map","import { StaticSound } from \"../abstractAudio/staticSound\";\nimport { StaticSoundBuffer } from \"../abstractAudio/staticSoundBuffer\";\nimport { _StaticSoundInstance } from \"../abstractAudio/staticSoundInstance\";\nimport { _HasSpatialAudioOptions } from \"../abstractAudio/subProperties/abstractSpatialAudio\";\nimport { _StereoAudio } from \"../abstractAudio/subProperties/stereoAudio\";\nimport { _CleanUrl, _FileExtensionRegex } from \"../audioUtils\";\nimport { _WebAudioParameterComponent } from \"./components/webAudioParameterComponent\";\nimport { _WebAudioBusAndSoundSubGraph } from \"./subNodes/webAudioBusAndSoundSubGraph\";\nimport { _SpatialWebAudio } from \"./subProperties/spatialWebAudio\";\n/** @internal */\nexport class _WebAudioStaticSound extends StaticSound {\n    /** @internal */\n    constructor(name, engine, options) {\n        super(name, engine, options);\n        this._stereo = null;\n        this._options = {\n            autoplay: options.autoplay ?? false,\n            duration: options.duration ?? 0,\n            loop: options.loop ?? false,\n            loopEnd: options.loopEnd ?? 0,\n            loopStart: options.loopStart ?? 0,\n            maxInstances: options.maxInstances ?? Infinity,\n            pitch: options.pitch ?? 0,\n            playbackRate: options.playbackRate ?? 1,\n            startOffset: options.startOffset ?? 0,\n        };\n        this._subGraph = new _WebAudioStaticSound._SubGraph(this);\n    }\n    /** @internal */\n    async _initAsync(source, options) {\n        this._audioContext = this.engine._audioContext;\n        if (source instanceof _WebAudioStaticSoundBuffer) {\n            this._buffer = source;\n        }\n        else if (typeof source === \"string\" || Array.isArray(source) || source instanceof ArrayBuffer || source instanceof AudioBuffer) {\n            this._buffer = (await this.engine.createSoundBufferAsync(source, options));\n        }\n        if (options.outBus) {\n            this.outBus = options.outBus;\n        }\n        else if (options.outBusAutoDefault !== false) {\n            await this.engine.isReadyPromise;\n            this.outBus = this.engine.defaultMainBus;\n        }\n        await this._subGraph.initAsync(options);\n        if (_HasSpatialAudioOptions(options)) {\n            this._initSpatialProperty();\n        }\n        if (options.autoplay) {\n            this.play();\n        }\n        this.engine._addSound(this);\n    }\n    /** @internal */\n    get buffer() {\n        return this._buffer;\n    }\n    /** @internal */\n    get _inNode() {\n        return this._subGraph._inNode;\n    }\n    /** @internal */\n    get _outNode() {\n        return this._subGraph._outNode;\n    }\n    /** @internal */\n    get stereo() {\n        return this._stereo ?? (this._stereo = new _StereoAudio(this._subGraph));\n    }\n    /** @internal */\n    async cloneAsync(options = null) {\n        const clone = await this.engine.createSoundAsync(this.name, options?.cloneBuffer ? this.buffer.clone() : this.buffer, this._options);\n        clone.outBus = options?.outBus ? options.outBus : this.outBus;\n        return clone;\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._stereo = null;\n        this._subGraph.dispose();\n        this.engine._removeSound(this);\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStaticSound\";\n    }\n    _createInstance() {\n        return new _WebAudioStaticSoundInstance(this, this._options);\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the subgraph.\n        if (node._inNode) {\n            this._outNode?.connect(node._inNode);\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n        }\n        return true;\n    }\n    _createSpatialProperty(autoUpdate, minUpdateTime) {\n        return new _SpatialWebAudio(this._subGraph, autoUpdate, minUpdateTime);\n    }\n    _getOptions() {\n        return this._options;\n    }\n}\n_WebAudioStaticSound._SubGraph = class extends _WebAudioBusAndSoundSubGraph {\n    get _downstreamNodes() {\n        return this._owner._downstreamNodes ?? null;\n    }\n    get _upstreamNodes() {\n        return this._owner._upstreamNodes ?? null;\n    }\n};\n/** @internal */\nexport class _WebAudioStaticSoundBuffer extends StaticSoundBuffer {\n    /** @internal */\n    constructor(engine) {\n        super(engine);\n    }\n    async _initAsync(source, options) {\n        if (source instanceof AudioBuffer) {\n            this._audioBuffer = source;\n        }\n        else if (typeof source === \"string\") {\n            await this._initFromUrlAsync(source);\n        }\n        else if (Array.isArray(source)) {\n            await this._initFromUrlsAsync(source, options.skipCodecCheck ?? false);\n        }\n        else if (source instanceof ArrayBuffer) {\n            await this._initFromArrayBufferAsync(source);\n        }\n    }\n    /** @internal */\n    get channelCount() {\n        return this._audioBuffer.numberOfChannels;\n    }\n    /** @internal */\n    get duration() {\n        return this._audioBuffer.duration;\n    }\n    /** @internal */\n    get length() {\n        return this._audioBuffer.length;\n    }\n    /** @internal */\n    get sampleRate() {\n        return this._audioBuffer.sampleRate;\n    }\n    /** @internal */\n    clone(options = null) {\n        const audioBuffer = new AudioBuffer({\n            length: this._audioBuffer.length,\n            numberOfChannels: this._audioBuffer.numberOfChannels,\n            sampleRate: this._audioBuffer.sampleRate,\n        });\n        for (let i = 0; i < this._audioBuffer.numberOfChannels; i++) {\n            audioBuffer.copyToChannel(this._audioBuffer.getChannelData(i), i);\n        }\n        const buffer = new _WebAudioStaticSoundBuffer(this.engine);\n        buffer._audioBuffer = audioBuffer;\n        buffer.name = options?.name ? options.name : this.name;\n        return buffer;\n    }\n    async _initFromArrayBufferAsync(arrayBuffer) {\n        this._audioBuffer = await this.engine._audioContext.decodeAudioData(arrayBuffer);\n    }\n    async _initFromUrlAsync(url) {\n        url = _CleanUrl(url);\n        await this._initFromArrayBufferAsync(await (await fetch(url)).arrayBuffer());\n    }\n    async _initFromUrlsAsync(urls, skipCodecCheck) {\n        for (const url of urls) {\n            if (skipCodecCheck) {\n                // eslint-disable-next-line no-await-in-loop\n                await this._initFromUrlAsync(url);\n            }\n            else {\n                const matches = url.match(_FileExtensionRegex);\n                const format = matches?.at(1);\n                if (format && this.engine.isFormatValid(format)) {\n                    try {\n                        // eslint-disable-next-line no-await-in-loop\n                        await this._initFromUrlAsync(url);\n                    }\n                    catch {\n                        if (format && 0 < format.length) {\n                            this.engine.flagInvalidFormat(format);\n                        }\n                    }\n                }\n            }\n            if (this._audioBuffer) {\n                break;\n            }\n        }\n    }\n}\n/** @internal */\nclass _WebAudioStaticSoundInstance extends _StaticSoundInstance {\n    constructor(sound, options) {\n        super(sound);\n        this._enginePlayTime = 0;\n        this._enginePauseTime = 0;\n        this._isConnected = false;\n        this._pitch = null;\n        this._playbackRate = null;\n        this._sourceNode = null;\n        this._onEnded = () => {\n            this._enginePlayTime = 0;\n            if (this._state !== 5 /* SoundState.Paused */) {\n                this.onEndedObservable.notifyObservers(this);\n            }\n            this._deinitSourceNode();\n        };\n        this._onEngineStateChanged = () => {\n            if (this.engine.state !== \"running\") {\n                return;\n            }\n            if (this._options.loop && this.state === 2 /* SoundState.Starting */) {\n                this.play();\n            }\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        };\n        this._options = options;\n        this._volumeNode = new GainNode(sound._audioContext);\n        this._initSourceNode();\n    }\n    /** @internal */\n    dispose() {\n        super.dispose();\n        this._pitch?.dispose();\n        this._playbackRate?.dispose();\n        this._sourceNode = null;\n        this.stop();\n        this._deinitSourceNode();\n        this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n    }\n    /** @internal */\n    get currentTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        const timeSinceLastStart = this._state === 5 /* SoundState.Paused */ ? 0 : this.engine.currentTime - this._enginePlayTime;\n        return this._enginePauseTime + timeSinceLastStart + this._options.startOffset;\n    }\n    set currentTime(value) {\n        const restart = this._state === 2 /* SoundState.Starting */ || this._state === 3 /* SoundState.Started */;\n        if (restart) {\n            // Stop source node without sending `onEndedObservable` so instance's `dispose` function is not called.\n            const sourceNode = this._sourceNode;\n            this._deinitSourceNode();\n            sourceNode?.stop();\n            this._state = 1 /* SoundState.Stopped */;\n        }\n        if (this.state === 5 /* SoundState.Paused */) {\n            this._enginePauseTime = 0;\n        }\n        this._options.startOffset = value;\n        if (restart) {\n            this.play();\n        }\n    }\n    get _outNode() {\n        return this._volumeNode;\n    }\n    /** @internal */\n    set pitch(value) {\n        this._pitch?.setTargetValue(value);\n    }\n    /** @internal */\n    set playbackRate(value) {\n        this._playbackRate?.setTargetValue(value);\n    }\n    /** @internal */\n    get startTime() {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return 0;\n        }\n        return this._enginePlayTime;\n    }\n    /** @internal */\n    getClassName() {\n        return \"_WebAudioStaticSoundInstance\";\n    }\n    /** @internal */\n    play(options = {}) {\n        if (this._state === 3 /* SoundState.Started */) {\n            return;\n        }\n        if (options.duration !== undefined) {\n            this._options.duration = options.duration;\n        }\n        if (options.loop !== undefined) {\n            this._options.loop = options.loop;\n        }\n        if (options.loopStart !== undefined) {\n            this._options.loopStart = options.loopStart;\n        }\n        if (options.loopEnd !== undefined) {\n            this._options.loopEnd = options.loopEnd;\n        }\n        if (options.startOffset !== undefined) {\n            this._options.startOffset = options.startOffset;\n        }\n        let startOffset = this._options.startOffset;\n        if (this._state === 5 /* SoundState.Paused */) {\n            startOffset += this._enginePauseTime;\n            startOffset %= this._sound.buffer.duration;\n        }\n        this._enginePlayTime = this.engine.currentTime + (options.waitTime ?? 0);\n        this._volumeNode.gain.value = options.volume ?? 1;\n        this._initSourceNode();\n        if (this.engine.state === \"running\") {\n            this._setState(3 /* SoundState.Started */);\n            this._sourceNode?.start(this._enginePlayTime, startOffset, this._options.duration > 0 ? this._options.duration : undefined);\n        }\n        else if (this._options.loop) {\n            this._setState(2 /* SoundState.Starting */);\n            this.engine.stateChangedObservable.add(this._onEngineStateChanged);\n        }\n    }\n    /** @internal */\n    pause() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            return;\n        }\n        this._setState(5 /* SoundState.Paused */);\n        this._enginePauseTime += this.engine.currentTime - this._enginePlayTime;\n        if (this._state === 3 /* SoundState.Started */) {\n            this._sourceNode?.stop();\n        }\n        else {\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        }\n        this._deinitSourceNode();\n    }\n    /** @internal */\n    resume() {\n        if (this._state === 5 /* SoundState.Paused */) {\n            this.play();\n        }\n    }\n    /** @internal */\n    stop(options = {}) {\n        if (this._state === 1 /* SoundState.Stopped */) {\n            return;\n        }\n        if (this._state === 3 /* SoundState.Started */) {\n            const engineStopTime = this.engine.currentTime + (options.waitTime ?? 0);\n            this._sourceNode?.stop(engineStopTime);\n        }\n        if (options.waitTime === undefined || options.waitTime <= 0) {\n            this._setState(1 /* SoundState.Stopped */);\n            this.engine.stateChangedObservable.removeCallback(this._onEngineStateChanged);\n        }\n    }\n    _connect(node) {\n        const connected = super._connect(node);\n        if (!connected) {\n            return false;\n        }\n        // If the wrapped node is not available now, it will be connected later by the sound's subgraph.\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.connect(node._inNode);\n            this._isConnected = true;\n        }\n        return true;\n    }\n    _disconnect(node) {\n        const disconnected = super._disconnect(node);\n        if (!disconnected) {\n            return false;\n        }\n        if (node instanceof _WebAudioStaticSound && node._inNode) {\n            this._outNode?.disconnect(node._inNode);\n            this._isConnected = false;\n        }\n        return true;\n    }\n    _deinitSourceNode() {\n        if (!this._sourceNode) {\n            return;\n        }\n        if (this._isConnected && !this._disconnect(this._sound)) {\n            throw new Error(\"Disconnect failed\");\n        }\n        this._sourceNode.disconnect(this._volumeNode);\n        this._sourceNode.removeEventListener(\"ended\", this._onEnded);\n        this._sourceNode = null;\n    }\n    _initSourceNode() {\n        if (!this._sourceNode) {\n            this._sourceNode = new AudioBufferSourceNode(this._sound._audioContext, { buffer: this._sound.buffer._audioBuffer });\n            this._sourceNode.addEventListener(\"ended\", this._onEnded, { once: true });\n            this._sourceNode.connect(this._volumeNode);\n            if (!this._connect(this._sound)) {\n                throw new Error(\"Connect failed\");\n            }\n            this._pitch = new _WebAudioParameterComponent(this.engine, this._sourceNode.detune);\n            this._playbackRate = new _WebAudioParameterComponent(this.engine, this._sourceNode.playbackRate);\n        }\n        const node = this._sourceNode;\n        node.detune.value = this._sound.pitch;\n        node.loop = this._options.loop;\n        node.loopEnd = this._options.loopEnd;\n        node.loopStart = this._options.loopStart;\n        node.playbackRate.value = this._sound.playbackRate;\n    }\n}\n//# sourceMappingURL=webAudioStaticSound.js.map"],"names":["StaticSound","AbstractSound","constructor","name","engine","options","super","duration","this","_options","value","loopStart","loopEnd","pitch","it","_instances","values","instance","next","done","playbackRate","play","state","resume","loop","startOffset","volume","waitTime","_createInstance","_beforePlay","_afterPlay","_stopExcessInstances","stop","_setState","Array","from","StaticSoundBufferId","StaticSoundBuffer","_StaticSoundInstance","_AbstractSoundInstance","_WebAudioStaticSound","_stereo","autoplay","maxInstances","Infinity","_subGraph","_SubGraph","_initAsync","source","_audioContext","_WebAudioStaticSoundBuffer","_buffer","isArray","ArrayBuffer","AudioBuffer","createSoundBufferAsync","outBus","outBusAutoDefault","isReadyPromise","defaultMainBus","initAsync","_HasSpatialAudioOptions","_initSpatialProperty","_addSound","buffer","_inNode","_outNode","stereo","_StereoAudio","cloneAsync","clone","createSoundAsync","cloneBuffer","dispose","_removeSound","getClassName","_WebAudioStaticSoundInstance","_connect","node","connect","_disconnect","disconnect","_createSpatialProperty","autoUpdate","minUpdateTime","_SpatialWebAudio","_getOptions","_WebAudioBusAndSoundSubGraph","_downstreamNodes","_owner","_upstreamNodes","_audioBuffer","_initFromUrlAsync","_initFromUrlsAsync","skipCodecCheck","_initFromArrayBufferAsync","channelCount","numberOfChannels","length","sampleRate","audioBuffer","i","copyToChannel","getChannelData","arrayBuffer","decodeAudioData","url","_CleanUrl","fetch","urls","matches","match","_FileExtensionRegex","format","at","isFormatValid","flagInvalidFormat","sound","_enginePlayTime","_enginePauseTime","_isConnected","_pitch","_playbackRate","_sourceNode","_onEnded","_state","onEndedObservable","notifyObservers","_deinitSourceNode","_onEngineStateChanged","stateChangedObservable","removeCallback","_volumeNode","GainNode","_initSourceNode","currentTime","timeSinceLastStart","restart","sourceNode","setTargetValue","startTime","undefined","_sound","gain","start","add","pause","engineStopTime","Error","removeEventListener","AudioBufferSourceNode","addEventListener","once","_WebAudioParameterComponent","detune"],"mappings":"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"}