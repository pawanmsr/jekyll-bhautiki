import{e,a1 as t,aQ as s,aF as n,H as r,aZ as a,bc as i,bd as o,be as l,bh as c,bl as h,a0 as u,a as p,Z as d,a$ as f,a_ as _,S as m,i as x,F as v,J as g,g as S,c2 as y,c3 as w,x as T,a6 as M,aY as E,b as I,w as C,p as A,V as b,c4 as D,d as P,L as R,c5 as O,c6 as z,c7 as U,v as H,C as k,c8 as V,Q as F,h as N,b1 as B,z as L,R as W,B as G,c9 as X,q as j,aL as Z}from"./index-C7lpuH7l.esm.min.js";import{ShaderMaterial as Y}from"./shaderMaterial-CLASU8Ae.esm.min.js";import"./clipPlaneFragment-tBT19CLp.esm.min.js";import"./logDepthDeclaration-MBSE1j-w.esm.min.js";import"./fogFragment-BksZoFzo.esm.min.js";import"./sceneUboDeclaration-C0IDfgqW.esm.min.js";import"./meshUboDeclaration-Bs0hD4wN.esm.min.js";import"./clipPlaneVertex-C37mL-i1.esm.min.js";import"./logDepthVertex-DRVUhdU2.esm.min.js";import"./helperFunctions-Bt-rj6dw.esm.min.js";import"./clipPlaneFragment-0scumDcy.esm.min.js";import"./logDepthDeclaration-fnCxpoUt.esm.min.js";import"./fogFragment-DI3lczAW.esm.min.js";import"./sceneUboDeclaration-CUhiaE1_.esm.min.js";import"./meshUboDeclaration-CU-5WBoM.esm.min.js";import"./helperFunctions-BkIwyaq_.esm.min.js";import"./clipPlaneVertex-BASI4ROo.esm.min.js";import"./logDepthVertex-BqJGeSwB.esm.min.js";import{R as q}from"./rawTexture-GcKYJ37d.esm.min.js";import"./thinInstanceMesh-BRurJ3_A.esm.min.js";import{A as K}from"./assetContainer-BpinJ-Pb.esm.min.js";import{Ray as $}from"./ray-LKgv-qoC.esm.min.js";import{S as Q}from"./standardMaterial-BeALqQl2.esm.min.js";class J{constructor(){this.mm=new Map}get(e,t){const s=this.mm.get(e);if(void 0!==s)return s.get(t)}set(e,t,s){let n=this.mm.get(e);void 0===n&&this.mm.set(e,n=new Map),n.set(t,s)}}class ee{get standalone(){return this._options?.standalone??!1}get baseMaterial(){return this._baseMaterial}get doNotInjectCode(){return this._options?.doNotInjectCode??!1}constructor(t,s,n){this._baseMaterial=t,this._scene=s??e.LastCreatedScene,this._options=n,this._subMeshToEffect=new Map,this._subMeshToDepthWrapper=new J,this._meshes=new Map,this._onEffectCreatedObserver=this._baseMaterial.onEffectCreatedObservable.add((e=>{const t=e.subMesh?.getMesh();t&&!this._meshes.has(t)&&this._meshes.set(t,t.onDisposeObservable.add((e=>{const t=this._subMeshToEffect.keys();for(let s=t.next();!0!==s.done;s=t.next()){const t=s.value;t?.getMesh()===e&&(this._subMeshToEffect.delete(t),this._deleteDepthWrapperEffect(t))}}))),this._subMeshToEffect.get(e.subMesh)?.[0]!==e.effect&&(this._subMeshToEffect.set(e.subMesh,[e.effect,this._scene.getEngine().currentRenderPassId]),this._deleteDepthWrapperEffect(e.subMesh))}))}_deleteDepthWrapperEffect(e){const t=this._subMeshToDepthWrapper.mm.get(e);t&&(t.forEach((e=>{e.mainDrawWrapper.effect?.dispose()})),this._subMeshToDepthWrapper.mm.delete(e))}getEffect(e,s,n){const r=this._subMeshToDepthWrapper.mm.get(e)?.get(s);if(!r)return null;let a=r.drawWrapper[n];return a||(a=r.drawWrapper[n]=new t(this._scene.getEngine()),a.setEffect(r.mainDrawWrapper.effect,r.mainDrawWrapper.defines)),a}isReadyForSubMesh(e,t,s,n,r){return!(this.standalone&&!this._baseMaterial.isReadyForSubMesh(e.getMesh(),e,n))&&(this._makeEffect(e,t,s,r)?.isReady()??!1)}dispose(){this._baseMaterial.onEffectCreatedObservable.remove(this._onEffectCreatedObserver),this._onEffectCreatedObserver=null;const e=this._meshes.entries();for(let t=e.next();!0!==t.done;t=e.next()){const[e,s]=t.value;e.onDisposeObservable.remove(s)}}_makeEffect(e,r,a,i){const o=this._scene.getEngine(),l=this._subMeshToEffect.get(e);if(!l)return null;const[c,h]=l;if(!c.isReady())return null;let u=this._subMeshToDepthWrapper.get(e,a);if(!u){const n=new t(o);n.defines=e._getDrawWrapper(h)?.defines??null,u={drawWrapper:[],mainDrawWrapper:n,depthDefines:"",token:s()},u.drawWrapper[i]=n,this._subMeshToDepthWrapper.set(e,a,u)}const p=r.join("\n");if(u.mainDrawWrapper.effect&&p===u.depthDefines)return u.mainDrawWrapper.effect;u.depthDefines=p;const d=c.getUniformNames().slice();let f=c.vertexSourceCodeBeforeMigration,_=c.fragmentSourceCodeBeforeMigration;if(!f&&!_)return null;if(!this.doNotInjectCode){const e=this._options&&this._options.remappedVariables?`#include<shadowMapVertexNormalBias>(${this._options.remappedVariables.join(",")})`:"#include<shadowMapVertexNormalBias>",t=this._options&&this._options.remappedVariables?`#include<shadowMapVertexMetric>(${this._options.remappedVariables.join(",")})`:"#include<shadowMapVertexMetric>",s=this._options&&this._options.remappedVariables?`#include<shadowMapFragmentSoftTransparentShadow>(${this._options.remappedVariables.join(",")})`:"#include<shadowMapFragmentSoftTransparentShadow>",r="#include<shadowMapFragment>",a="#include<shadowMapVertexExtraDeclaration>";f=0===c.shaderLanguage?f.replace(/void\s+?main/g,`\n${a}\nvoid main`):f.replace(/@vertex/g,`\n${a}\n@vertex`),f=f.replace(/#define SHADOWDEPTH_NORMALBIAS|#define CUSTOM_VERTEX_UPDATE_WORLDPOS/g,e),f=-1!==f.indexOf("#define SHADOWDEPTH_METRIC")?f.replace(/#define SHADOWDEPTH_METRIC/g,t):f.replace(/}\s*$/g,t+"\n}"),f=f.replace(/#define SHADER_NAME.*?\n|out vec4 glFragColor;\n/g,"");const i=_.indexOf("#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW")>=0||_.indexOf("#define CUSTOM_FRAGMENT_BEFORE_FOG")>=0,o=-1!==_.indexOf("#define SHADOWDEPTH_FRAGMENT");let l="";i?_=_.replace(/#define SHADOWDEPTH_SOFTTRANSPARENTSHADOW|#define CUSTOM_FRAGMENT_BEFORE_FOG/g,s):l=s+"\n",_=_.replace(/void\s+?main/g,n.IncludesShadersStore.shadowMapFragmentExtraDeclaration+"\nvoid main"),o?_=_.replace(/#define SHADOWDEPTH_FRAGMENT/g,r):l+=r+"\n",l&&(_=_.replace(/}\s*$/g,l+"}")),d.push("biasAndScaleSM","depthValuesSM","lightDataSM","softTransparentShadowSM")}u.mainDrawWrapper.effect=o.createEffect({vertexSource:f,fragmentSource:_,vertexToken:u.token,fragmentToken:u.token},{attributes:c.getAttributesNames(),uniformsNames:d,uniformBuffersNames:c.getUniformBuffersNames(),samplers:c.getSamplers(),defines:p+"\n"+c.defines.replace("#define SHADOWS","").replace(/#define SHADOW\d/g,""),indexParameters:c.getIndexParameters(),shaderLanguage:c.shaderLanguage},o);for(let e=0;e<u.drawWrapper.length;++e)e!==i&&u.drawWrapper[e]?.setEffect(u.mainDrawWrapper.effect,u.mainDrawWrapper.defines);return u.mainDrawWrapper.effect}}const te="gaussianSplattingFragmentDeclaration";r.IncludesShadersStore[te]||(r.IncludesShadersStore[te]="vec4 gaussianColor(vec4 inColor)\n{float A=-dot(vPosition,vPosition);if (A<-4.0) discard;float B=exp(A)*inColor.a;\n#include<logDepthFragment>\nvec3 color=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4(color,B);}\n");const se="gaussianSplattingPixelShader",ne="#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vec4 vColor;varying vec2 vPosition;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<gaussianSplattingFragmentDeclaration>\nvoid main () {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvec4 finalColor=gaussianColor(vColor);\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\ngl_FragColor=finalColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n";r.ShadersStore[se]||(r.ShadersStore[se]=ne);const re={name:se,shader:ne};var ae=Object.freeze({__proto__:null,gaussianSplattingPixelShader:re});const ie="gaussianSplattingVertexDeclaration";r.IncludesShadersStore[ie]||(r.IncludesShadersStore[ie]="attribute vec3 position;attribute vec4 splatIndex0;attribute vec4 splatIndex1;attribute vec4 splatIndex2;attribute vec4 splatIndex3;uniform mat4 view;uniform mat4 projection;uniform mat4 world;uniform vec4 vEyePosition;");const oe="gaussianSplattingUboDeclaration";r.IncludesShadersStore[oe]||(r.IncludesShadersStore[oe]="#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute vec3 position;attribute vec4 splatIndex0;attribute vec4 splatIndex1;attribute vec4 splatIndex2;attribute vec4 splatIndex3;\n");const le="gaussianSplatting";r.IncludesShadersStore[le]||(r.IncludesShadersStore[le]="#if !defined(WEBGL2) && !defined(WEBGPU) && !defined(NATIVE)\nmat3 transpose(mat3 matrix) {return mat3(matrix[0][0],matrix[1][0],matrix[2][0],\nmatrix[0][1],matrix[1][1],matrix[2][1],\nmatrix[0][2],matrix[1][2],matrix[2][2]);}\n#endif\nvec2 getDataUV(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return vec2((x+0.5)/textureSize.x,(y+0.5)/textureSize.y);}\n#if SH_DEGREE>0 || IS_COMPOUND\nivec2 getDataUVint(float index,vec2 textureSize) {float y=floor(index/textureSize.x);float x=index-y*textureSize.x;return ivec2(uint(x+0.5),uint(y+0.5));}\n#endif\nstruct Splat {vec4 center;vec4 color;vec4 covA;vec4 covB;\n#if SH_DEGREE>0\nuvec4 sh0; \n#endif\n#if SH_DEGREE>1\nuvec4 sh1;\n#endif\n#if SH_DEGREE>2\nuvec4 sh2;\n#endif\n#if IS_COMPOUND\nuint partIndex;\n#endif\n};float getSplatIndex(int localIndex)\n{float splatIndex;switch (localIndex)\n{case 0: splatIndex=splatIndex0.x; break;case 1: splatIndex=splatIndex0.y; break;case 2: splatIndex=splatIndex0.z; break;case 3: splatIndex=splatIndex0.w; break;case 4: splatIndex=splatIndex1.x; break;case 5: splatIndex=splatIndex1.y; break;case 6: splatIndex=splatIndex1.z; break;case 7: splatIndex=splatIndex1.w; break;case 8: splatIndex=splatIndex2.x; break;case 9: splatIndex=splatIndex2.y; break;case 10: splatIndex=splatIndex2.z; break;case 11: splatIndex=splatIndex2.w; break;case 12: splatIndex=splatIndex3.x; break;case 13: splatIndex=splatIndex3.y; break;case 14: splatIndex=splatIndex3.z; break;case 15: splatIndex=splatIndex3.w; break;}\nreturn splatIndex;}\nSplat readSplat(float splatIndex)\n{Splat splat;vec2 splatUV=getDataUV(splatIndex,dataTextureSize);splat.center=texture2D(centersTexture,splatUV);splat.color=texture2D(colorsTexture,splatUV);splat.covA=texture2D(covariancesATexture,splatUV)*splat.center.w;splat.covB=texture2D(covariancesBTexture,splatUV)*splat.center.w;\n#if SH_DEGREE>0 || IS_COMPOUND\nivec2 splatUVint=getDataUVint(splatIndex,dataTextureSize);\n#endif\n#if SH_DEGREE>0\nsplat.sh0=texelFetch(shTexture0,splatUVint,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=texelFetch(shTexture1,splatUVint,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=texelFetch(shTexture2,splatUVint,0);\n#endif\n#if IS_COMPOUND\nsplat.partIndex=uint(texture2D(partIndicesTexture,splatUV).r*255.0+0.5);\n#endif\nreturn splat;}\n#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)\nvec3 computeColorFromSHDegree(vec3 dir,const vec3 sh[16])\n{const float SH_C0=0.28209479;const float SH_C1=0.48860251;float SH_C2[5];SH_C2[0]=1.092548430;SH_C2[1]=-1.09254843;SH_C2[2]=0.315391565;SH_C2[3]=-1.09254843;SH_C2[4]=0.546274215;float SH_C3[7];SH_C3[0]=-0.59004358;SH_C3[1]=2.890611442;SH_C3[2]=-0.45704579;SH_C3[3]=0.373176332;SH_C3[4]=-0.45704579;SH_C3[5]=1.445305721;SH_C3[6]=-0.59004358;vec3 result=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nfloat x=dir.x;float y=dir.y;float z=dir.z;result+=- SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nfloat xx=x*x,yy=y*y,zz=z*z;float xy=x*y,yz=y*z,xz=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0*zz-3.0*xx-3.0*yy)*sh[12] +\nSH_C3[4]*x*(4.0*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nvec4 decompose(uint value)\n{vec4 components=vec4(\nfloat((value ) & 255u),\nfloat((value>>uint( 8)) & 255u),\nfloat((value>>uint(16)) & 255u),\nfloat((value>>uint(24)) & 255u));return components*vec4(2./255.)-vec4(1.);}\nvec3 computeSH(Splat splat,vec3 dir)\n{vec3 sh[16];sh[0]=vec3(0.,0.,0.);\n#if SH_DEGREE>0\nvec4 sh00=decompose(splat.sh0.x);vec4 sh01=decompose(splat.sh0.y);vec4 sh02=decompose(splat.sh0.z);sh[1]=vec3(sh00.x,sh00.y,sh00.z);sh[2]=vec3(sh00.w,sh01.x,sh01.y);sh[3]=vec3(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nvec4 sh03=decompose(splat.sh0.w);vec4 sh04=decompose(splat.sh1.x);vec4 sh05=decompose(splat.sh1.y);sh[4]=vec3(sh02.y,sh02.z,sh02.w);sh[5]=vec3(sh03.x,sh03.y,sh03.z);sh[6]=vec3(sh03.w,sh04.x,sh04.y);sh[7]=vec3(sh04.z,sh04.w,sh05.x);sh[8]=vec3(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nvec4 sh06=decompose(splat.sh1.z);vec4 sh07=decompose(splat.sh1.w);vec4 sh08=decompose(splat.sh2.x);vec4 sh09=decompose(splat.sh2.y);vec4 sh10=decompose(splat.sh2.z);vec4 sh11=decompose(splat.sh2.w);sh[9]=vec3(sh06.x,sh06.y,sh06.z);sh[10]=vec3(sh06.w,sh07.x,sh07.y);sh[11]=vec3(sh07.z,sh07.w,sh08.x);sh[12]=vec3(sh08.y,sh08.z,sh08.w);sh[13]=vec3(sh09.x,sh09.y,sh09.z);sh[14]=vec3(sh09.w,sh10.x,sh10.y);sh[15]=vec3(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\n#else\nvec3 computeSH(Splat splat,vec3 dir)\n{return vec3(0.,0.,0.);}\n#endif\nvec4 gaussianSplatting(vec2 meshPos,vec3 worldPos,vec2 scale,vec3 covA,vec3 covB,mat4 worldMatrix,mat4 viewMatrix,mat4 projectionMatrix)\n{mat4 modelView=viewMatrix*worldMatrix;vec4 camspace=viewMatrix*vec4(worldPos,1.);vec4 pos2d=projectionMatrix*camspace;float bounds=1.2*pos2d.w;if (pos2d.z<-pos2d.w || pos2d.x<-bounds || pos2d.x>bounds\n|| pos2d.y<-bounds || pos2d.y>bounds) {return vec4(0.0,0.0,2.0,1.0);}\nmat3 Vrk=mat3(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);bool isOrtho=abs(projectionMatrix[3][3]-1.0)<0.001;mat3 J;if (isOrtho) {J=mat3(\nfocal.x,0.,0.,\n0.,focal.y,0.,\n0.,0.,0.\n);} else {J=mat3(\nfocal.x/camspace.z,0.,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.,0.,0.\n);}\nmat3 T=transpose(mat3(modelView))*J;mat3 cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nfloat c00=cov2d[0][0];float c11=cov2d[1][1];float c01=cov2d[0][1];float detOrig=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nvec3 c2d=vec3(cov2d[0][0],c01,cov2d[1][1]);float detBlur=c2d.x*c2d.z-c2d.y*c2d.y;float compensation=sqrt(max(0.,detOrig/detBlur));vColor.w*=compensation;\n#endif\nfloat mid=(cov2d[0][0]+cov2d[1][1])/2.0;float radius=length(vec2((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));float epsilon=0.0001;float lambda1=mid+radius+epsilon,lambda2=mid-radius+epsilon;if (lambda2<0.0)\n{return vec4(0.0,0.0,2.0,1.0);}\nvec2 diagonalVector=normalize(vec2(cov2d[0][1],lambda1-cov2d[0][0]));vec2 majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;vec2 minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2(diagonalVector.y,-diagonalVector.x);vec2 vCenter=vec2(pos2d);float scaleFactor=isOrtho ? 1.0 : pos2d.w;return vec4(\nvCenter \n+ ((meshPos.x*majorAxis\n+ meshPos.y*minorAxis)*invViewport*scaleFactor)*scale,pos2d.zw);}\n#if IS_COMPOUND\nmat4 getPartWorld(uint partIndex) {return partWorld[partIndex];}\n#endif\n");const ce="gaussianSplattingVertexShader",he="#include<__decl__gaussianSplattingVertex>\n#ifdef LOGARITHMICDEPTH\n#extension GL_EXT_frag_depth : enable\n#endif\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\n#include<helperFunctions>\nuniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform vec3 eyePosition;uniform float alpha;\n#if IS_COMPOUND\nuniform mat4 partWorld[MAX_PART_COUNT];uniform float partVisibility[MAX_PART_COUNT];\n#endif\nuniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;\n#if SH_DEGREE>0\nuniform highp usampler2D shTexture0;\n#endif\n#if SH_DEGREE>1\nuniform highp usampler2D shTexture1;\n#endif\n#if SH_DEGREE>2\nuniform highp usampler2D shTexture2;\n#endif\n#if IS_COMPOUND\nuniform sampler2D partIndicesTexture;\n#endif\nvarying vec4 vColor;varying vec2 vPosition;\n#define CUSTOM_VERTEX_DEFINITIONS\n#include<gaussianSplatting>\nvoid main () {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nfloat splatIndex=getSplatIndex(int(position.z+0.5));Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);\n#if IS_COMPOUND\nmat4 splatWorld=getPartWorld(splat.partIndex);\n#else\nmat4 splatWorld=world;\n#endif\nvec4 worldPos=splatWorld*vec4(splat.center.xyz,1.0);vColor=splat.color;vPosition=position.xy;\n#if SH_DEGREE>0\nmat3 worldRot=mat3(splatWorld);mat3 normWorldRot=inverseMat3(worldRot);vec3 eyeToSplatLocalSpace=normalize(normWorldRot*(worldPos.xyz-eyePosition));vColor.xyz=splat.color.xyz+computeSH(splat,eyeToSplatLocalSpace);\n#endif\nvColor.w*=alpha;\n#if IS_COMPOUND\nvColor.w*=partVisibility[splat.partIndex];\n#endif\nvec2 scale=vec2(1.,1.);\n#define CUSTOM_VERTEX_UPDATE\ngl_Position=gaussianSplatting(position.xy,worldPos.xyz,scale,covA,covB,splatWorld,view,projection);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n";r.ShadersStore[ce]||(r.ShadersStore[ce]=he);const ue={name:ce,shader:he};var pe=Object.freeze({__proto__:null,gaussianSplattingVertexShader:ue});const de="gaussianSplattingFragmentDeclaration";r.IncludesShadersStoreWGSL[de]||(r.IncludesShadersStoreWGSL[de]="fn gaussianColor(inColor: vec4f,inPosition: vec2f)->vec4f\n{var A : f32=-dot(inPosition,inPosition);if (A>-4.0)\n{var B: f32=exp(A)*inColor.a;\n#include<logDepthFragment>\nvar color: vec3f=inColor.rgb;\n#ifdef FOG\n#include<fogFragment>\n#endif\nreturn vec4f(color,B);} else {return vec4f(0.0);}}\n");const fe="gaussianSplattingPixelShader",_e="#include<clipPlaneFragmentDeclaration>\n#include<logDepthDeclaration>\n#include<fogFragmentDeclaration>\nvarying vColor: vec4f;varying vPosition: vec2f;\n#define CUSTOM_FRAGMENT_DEFINITIONS\n#include<gaussianSplattingFragmentDeclaration>\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {\n#define CUSTOM_FRAGMENT_MAIN_BEGIN\n#include<clipPlaneFragment>\nvar finalColor: vec4f=gaussianColor(input.vColor,input.vPosition);\n#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR\nfragmentOutputs.color=finalColor;\n#define CUSTOM_FRAGMENT_MAIN_END\n}\n";r.ShadersStoreWGSL[fe]||(r.ShadersStoreWGSL[fe]=_e);const me={name:fe,shader:_e};var xe=Object.freeze({__proto__:null,gaussianSplattingPixelShaderWGSL:me});const ve="gaussianSplatting";r.IncludesShadersStoreWGSL[ve]||(r.IncludesShadersStoreWGSL[ve]="fn getDataUV(index: f32,dataTextureSize: vec2f)->vec2<f32> {let y: f32=floor(index/dataTextureSize.x);let x: f32=index-y*dataTextureSize.x;return vec2f((x+0.5),(y+0.5));}\nstruct Splat {center: vec4f,\ncolor: vec4f,\ncovA: vec4f,\ncovB: vec4f,\n#if SH_DEGREE>0\nsh0: vec4<u32>,\n#endif\n#if SH_DEGREE>1\nsh1: vec4<u32>,\n#endif\n#if SH_DEGREE>2\nsh2: vec4<u32>,\n#endif\n#if IS_COMPOUND\npartIndex: u32,\n#endif\n};fn getSplatIndex(localIndex: i32,splatIndex0: vec4f,splatIndex1: vec4f,splatIndex2: vec4f,splatIndex3: vec4f)->f32 {var splatIndex: f32;switch (localIndex)\n{case 0:\n{splatIndex=splatIndex0.x;break;}\ncase 1:\n{splatIndex=splatIndex0.y;break;}\ncase 2:\n{splatIndex=splatIndex0.z;break;}\ncase 3:\n{splatIndex=splatIndex0.w;break;}\ncase 4:\n{splatIndex=splatIndex1.x;break;}\ncase 5:\n{splatIndex=splatIndex1.y;break;}\ncase 6:\n{splatIndex=splatIndex1.z;break;}\ncase 7:\n{splatIndex=splatIndex1.w;break;}\ncase 8:\n{splatIndex=splatIndex2.x;break;}\ncase 9:\n{splatIndex=splatIndex2.y;break;}\ncase 10:\n{splatIndex=splatIndex2.z;break;}\ncase 11:\n{splatIndex=splatIndex2.w;break;}\ncase 12:\n{splatIndex=splatIndex3.x;break;}\ncase 13:\n{splatIndex=splatIndex3.y;break;}\ncase 14:\n{splatIndex=splatIndex3.z;break;}\ndefault:\n{splatIndex=splatIndex3.w;break;}}\nreturn splatIndex;}\nfn readSplat(splatIndex: f32,dataTextureSize: vec2f)->Splat {var splat: Splat;let splatUV=getDataUV(splatIndex,dataTextureSize);let splatUVi32=vec2<i32>(i32(splatUV.x),i32(splatUV.y));splat.center=textureLoad(centersTexture,splatUVi32,0);splat.color=textureLoad(colorsTexture,splatUVi32,0);splat.covA=textureLoad(covariancesATexture,splatUVi32,0)*splat.center.w;splat.covB=textureLoad(covariancesBTexture,splatUVi32,0)*splat.center.w;\n#if SH_DEGREE>0\nsplat.sh0=textureLoad(shTexture0,splatUVi32,0);\n#endif\n#if SH_DEGREE>1\nsplat.sh1=textureLoad(shTexture1,splatUVi32,0);\n#endif\n#if SH_DEGREE>2\nsplat.sh2=textureLoad(shTexture2,splatUVi32,0);\n#endif\n#if IS_COMPOUND\nsplat.partIndex=u32(textureLoad(partIndicesTexture,splatUVi32,0).r*255.0+0.5);\n#endif\nreturn splat;}\nfn computeColorFromSHDegree(dir: vec3f,sh: array<vec3<f32>,16>)->vec3f\n{let SH_C0: f32=0.28209479;let SH_C1: f32=0.48860251;var SH_C2: array<f32,5>=array<f32,5>(\n1.092548430,\n-1.09254843,\n0.315391565,\n-1.09254843,\n0.546274215\n);var SH_C3: array<f32,7>=array<f32,7>(\n-0.59004358,\n2.890611442,\n-0.45704579,\n0.373176332,\n-0.45704579,\n1.445305721,\n-0.59004358\n);var result: vec3f=/*SH_C0**/sh[0];\n#if SH_DEGREE>0\nlet x: f32=dir.x;let y: f32=dir.y;let z: f32=dir.z;result+=-SH_C1*y*sh[1]+SH_C1*z*sh[2]-SH_C1*x*sh[3];\n#if SH_DEGREE>1\nlet xx: f32=x*x;let yy: f32=y*y;let zz: f32=z*z;let xy: f32=x*y;let yz: f32=y*z;let xz: f32=x*z;result+=\nSH_C2[0]*xy*sh[4] +\nSH_C2[1]*yz*sh[5] +\nSH_C2[2]*(2.0f*zz-xx-yy)*sh[6] +\nSH_C2[3]*xz*sh[7] +\nSH_C2[4]*(xx-yy)*sh[8];\n#if SH_DEGREE>2\nresult+=\nSH_C3[0]*y*(3.0f*xx-yy)*sh[9] +\nSH_C3[1]*xy*z*sh[10] +\nSH_C3[2]*y*(4.0f*zz-xx-yy)*sh[11] +\nSH_C3[3]*z*(2.0f*zz-3.0f*xx-3.0f*yy)*sh[12] +\nSH_C3[4]*x*(4.0f*zz-xx-yy)*sh[13] +\nSH_C3[5]*z*(xx-yy)*sh[14] +\nSH_C3[6]*x*(xx-3.0f*yy)*sh[15];\n#endif\n#endif\n#endif\nreturn result;}\nfn decompose(value: u32)->vec4f\n{let components : vec4f=vec4f(\nf32((value ) & 255u),\nf32((value>>u32( 8)) & 255u),\nf32((value>>u32(16)) & 255u),\nf32((value>>u32(24)) & 255u));return components*vec4f(2./255.)-vec4f(1.);}\nfn computeSH(splat: Splat,dir: vec3f)->vec3f\n{var sh: array<vec3<f32>,16>;sh[0]=vec3f(0.,0.,0.);\n#if SH_DEGREE>0\nlet sh00: vec4f=decompose(splat.sh0.x);let sh01: vec4f=decompose(splat.sh0.y);let sh02: vec4f=decompose(splat.sh0.z);sh[1]=vec3f(sh00.x,sh00.y,sh00.z);sh[2]=vec3f(sh00.w,sh01.x,sh01.y);sh[3]=vec3f(sh01.z,sh01.w,sh02.x);\n#endif\n#if SH_DEGREE>1\nlet sh03: vec4f=decompose(splat.sh0.w);let sh04: vec4f=decompose(splat.sh1.x);let sh05: vec4f=decompose(splat.sh1.y);sh[4]=vec3f(sh02.y,sh02.z,sh02.w);sh[5]=vec3f(sh03.x,sh03.y,sh03.z);sh[6]=vec3f(sh03.w,sh04.x,sh04.y);sh[7]=vec3f(sh04.z,sh04.w,sh05.x);sh[8]=vec3f(sh05.y,sh05.z,sh05.w);\n#endif\n#if SH_DEGREE>2\nlet sh06: vec4f=decompose(splat.sh1.z);let sh07: vec4f=decompose(splat.sh1.w);let sh08: vec4f=decompose(splat.sh2.x);let sh09: vec4f=decompose(splat.sh2.y);let sh10: vec4f=decompose(splat.sh2.z);let sh11: vec4f=decompose(splat.sh2.w);sh[9]=vec3f(sh06.x,sh06.y,sh06.z);sh[10]=vec3f(sh06.w,sh07.x,sh07.y);sh[11]=vec3f(sh07.z,sh07.w,sh08.x);sh[12]=vec3f(sh08.y,sh08.z,sh08.w);sh[13]=vec3f(sh09.x,sh09.y,sh09.z);sh[14]=vec3f(sh09.w,sh10.x,sh10.y);sh[15]=vec3f(sh10.z,sh10.w,sh11.x); \n#endif\nreturn computeColorFromSHDegree(dir,sh);}\nfn gaussianSplatting(\nmeshPos: vec2<f32>,\nworldPos: vec3<f32>,\nscale: vec2<f32>,\ncovA: vec3<f32>,\ncovB: vec3<f32>,\nworldMatrix: mat4x4<f32>,\nviewMatrix: mat4x4<f32>,\nprojectionMatrix: mat4x4<f32>,\nfocal: vec2f,\ninvViewport: vec2f,\nkernelSize: f32\n)->vec4f {let modelView=viewMatrix*worldMatrix;let camspace=viewMatrix*vec4f(worldPos,1.0);let pos2d=projectionMatrix*camspace;let bounds=1.2*pos2d.w;if (pos2d.z<0. || pos2d.x<-bounds || pos2d.x>bounds || pos2d.y<-bounds || pos2d.y>bounds) {return vec4f(0.0,0.0,2.0,1.0);}\nlet Vrk=mat3x3<f32>(\ncovA.x,covA.y,covA.z,\ncovA.y,covB.x,covB.y,\ncovA.z,covB.y,covB.z\n);let isOrtho=abs(projectionMatrix[3][3]-1.0)<0.001;var J: mat3x3<f32>;if (isOrtho) {J=mat3x3<f32>(\nfocal.x,0.0,0.0,\n0.0,focal.y,0.0,\n0.0,0.0,0.0\n);} else {J=mat3x3<f32>(\nfocal.x/camspace.z,0.0,-(focal.x*camspace.x)/(camspace.z*camspace.z),\n0.0,focal.y/camspace.z,-(focal.y*camspace.y)/(camspace.z*camspace.z),\n0.0,0.0,0.0\n);}\nlet T=transpose(mat3x3<f32>(\nmodelView[0].xyz,\nmodelView[1].xyz,\nmodelView[2].xyz))*J;var cov2d=transpose(T)*Vrk*T;\n#if COMPENSATION\nlet c00: f32=cov2d[0][0];let c11: f32=cov2d[1][1];let c01: f32=cov2d[0][1];let detOrig: f32=c00*c11-c01*c01;\n#endif\ncov2d[0][0]+=kernelSize;cov2d[1][1]+=kernelSize;\n#if COMPENSATION\nlet c2d: vec3f=vec3f(cov2d[0][0],c01,cov2d[1][1]);let detBlur: f32=c2d.x*c2d.z-c2d.y*c2d.y;let compensation: f32=sqrt(max(0.,detOrig/detBlur));vertexOutputs.vColor.w*=compensation;\n#endif\nlet mid=(cov2d[0][0]+cov2d[1][1])/2.0;let radius=length(vec2<f32>((cov2d[0][0]-cov2d[1][1])/2.0,cov2d[0][1]));let lambda1=mid+radius;let lambda2=mid-radius;if (lambda2<0.0) {return vec4f(0.0,0.0,2.0,1.0);}\nlet diagonalVector=normalize(vec2<f32>(cov2d[0][1],lambda1-cov2d[0][0]));let majorAxis=min(sqrt(2.0*lambda1),1024.0)*diagonalVector;let minorAxis=min(sqrt(2.0*lambda2),1024.0)*vec2<f32>(diagonalVector.y,-diagonalVector.x);let vCenter=vec2<f32>(pos2d.x,pos2d.y);let scaleFactor=select(pos2d.w,1.0,isOrtho);return vec4f(\nvCenter+((meshPos.x*majorAxis+meshPos.y*minorAxis)*invViewport*scaleFactor)*scale,\npos2d.z,\npos2d.w\n);}\n#if IS_COMPOUND\nfn getPartWorld(partIndex: u32)->mat4x4<f32> {return uniforms.partWorld[partIndex];}\n#endif\n");const ge="gaussianSplattingVertexShader",Se="#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\n#include<helperFunctions>\n#include<clipPlaneVertexDeclaration>\n#include<fogVertexDeclaration>\n#include<logDepthDeclaration>\nattribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;attribute position: vec3f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;uniform eyePosition: vec3f;uniform alpha: f32;\n#if IS_COMPOUND\nuniform partWorld: array<mat4x4<f32>,MAX_PART_COUNT>;uniform partVisibility: array<f32,MAX_PART_COUNT>;\n#endif\nvar covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if SH_DEGREE>0\nvar shTexture0: texture_2d<u32>;\n#endif\n#if SH_DEGREE>1\nvar shTexture1: texture_2d<u32>;\n#endif\n#if SH_DEGREE>2\nvar shTexture2: texture_2d<u32>;\n#endif\n#if IS_COMPOUND\nvar partIndicesTexture: texture_2d<f32>;\n#endif\nvarying vColor: vec4f;varying vPosition: vec2f;\n#define CUSTOM_VERTEX_DEFINITIONS\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {\n#define CUSTOM_VERTEX_MAIN_BEGIN\nlet splatIndex: f32=getSplatIndex(i32(input.position.z+0.5),input.splatIndex0,input.splatIndex1,input.splatIndex2,input.splatIndex3);var splat: Splat=readSplat(splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);\n#if IS_COMPOUND\nlet splatWorld: mat4x4f=getPartWorld(splat.partIndex);\n#else\nlet splatWorld: mat4x4f=mesh.world;\n#endif\nlet worldPos: vec4f=splatWorld*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position.xy;\n#if SH_DEGREE>0\nlet worldRot: mat3x3f= mat3x3f(splatWorld[0].xyz,splatWorld[1].xyz,splatWorld[2].xyz);let normWorldRot: mat3x3f=inverseMat3(worldRot);var eyeToSplatLocalSpace: vec3f=normalize(normWorldRot*(worldPos.xyz-uniforms.eyePosition.xyz));vertexOutputs.vColor=vec4f(splat.color.xyz+computeSH(splat,eyeToSplatLocalSpace),splat.color.w*uniforms.alpha);\n#else\nvertexOutputs.vColor=vec4f(splat.color.xyz,splat.color.w*uniforms.alpha);\n#endif\n#if IS_COMPOUND\nvertexOutputs.vColor.w*=uniforms.partVisibility[splat.partIndex];\n#endif\nlet scale: vec2f=vec2f(1.,1.);\n#define CUSTOM_VERTEX_UPDATE\nvertexOutputs.position=gaussianSplatting(input.position.xy,worldPos.xyz,scale,covA,covB,splatWorld,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);\n#include<clipPlaneVertex>\n#include<fogVertex>\n#include<logDepthVertex>\n#define CUSTOM_VERTEX_MAIN_END\n}\n";r.ShadersStoreWGSL[ge]||(r.ShadersStoreWGSL[ge]=Se);const ye={name:ge,shader:Se};var we=Object.freeze({__proto__:null,gaussianSplattingVertexShaderWGSL:ye});const Te="gaussianSplattingDepthPixelShader";r.ShadersStore[Te]||(r.ShadersStore[Te]="precision highp float;varying vec2 vPosition;varying vec4 vColor;\n#ifdef DEPTH_RENDER\nvarying float vDepthMetric;\n#endif\nvoid main(void) {float A=-dot(vPosition,vPosition);\n#if (defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1) || (defined(DEPTH_RENDER) && defined(ALPHA_BLENDED_DEPTH))\nfloat alpha=exp(A)*vColor.a;if (A<-4.)\ndiscard;\n#else\nif (A<-vColor.a)\ndiscard;\n#endif\n#ifdef DEPTH_RENDER\nfloat opacity=1.0;\n#ifdef ALPHA_BLENDED_DEPTH\nopacity=alpha;\n#endif\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,opacity);\n#endif\n}");const Me="gaussianSplattingDepthVertexShader";r.ShadersStore[Me]||(r.ShadersStore[Me]="#include<__decl__gaussianSplattingVertex>\nuniform vec2 invViewport;uniform vec2 dataTextureSize;uniform vec2 focal;uniform float kernelSize;uniform float alpha;uniform sampler2D covariancesATexture;uniform sampler2D covariancesBTexture;uniform sampler2D centersTexture;uniform sampler2D colorsTexture;\n#if IS_COMPOUND\nuniform mat4 partWorld[MAX_PART_COUNT];uniform float partVisibility[MAX_PART_COUNT];uniform sampler2D partIndicesTexture;\n#endif\nvarying vec2 vPosition;varying vec4 vColor;\n#include<gaussianSplatting>\n#ifdef DEPTH_RENDER\nuniform vec2 depthValues;varying float vDepthMetric;\n#endif\nvoid main(void) {float splatIndex=getSplatIndex(int(position.z+0.5));Splat splat=readSplat(splatIndex);vec3 covA=splat.covA.xyz;vec3 covB=vec3(splat.covA.w,splat.covB.xy);\n#if IS_COMPOUND\nmat4 splatWorld=getPartWorld(splat.partIndex);\n#else\nmat4 splatWorld=world;\n#endif\nvec4 worldPosGS=splatWorld*vec4(splat.center.xyz,1.0);vPosition=position.xy;vColor=splat.color;vColor.w*=alpha;\n#if IS_COMPOUND\nvColor.w*=partVisibility[splat.partIndex];\n#endif\ngl_Position=gaussianSplatting(position.xy,worldPosGS.xyz,vec2(1.,1.),covA,covB,splatWorld,view,projection);\n#ifdef DEPTH_RENDER\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#endif\n}");const Ee="gaussianSplattingDepthPixelShader";r.ShadersStoreWGSL[Ee]||(r.ShadersStoreWGSL[Ee]="#include<gaussianSplattingFragmentDeclaration>\nvarying vPosition: vec2f;varying vColor: vec4f;\n#ifdef DEPTH_RENDER\nvarying vDepthMetric: f32;\n#endif\nfn checkDiscard(inPosition: vec2f,inColor: vec4f)->vec4f {var A : f32=-dot(inPosition,inPosition);var alpha : f32=exp(A)*inColor.a;\n#if (defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1) || (defined(DEPTH_RENDER) && defined(ALPHA_BLENDED_DEPTH))\nif (A<-4.) {discard;}\n#else\nif (A<-inColor.a) {discard;}\n#endif\n#ifdef DEPTH_RENDER\nvar opacity : f32=1.0;\n#ifdef ALPHA_BLENDED_DEPTH\nopacity=alpha;\n#endif\nreturn vec4f(fragmentInputs.vDepthMetric,0.0,0.0,opacity);\n#else\nreturn vec4f(inColor.rgb,alpha);\n#endif\n}\n#define CUSTOM_FRAGMENT_DEFINITIONS\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=checkDiscard(fragmentInputs.vPosition,fragmentInputs.vColor);\n#if (defined(SM_SOFTTRANSPARENTSHADOW) && SM_SOFTTRANSPARENTSHADOW==1) || (defined(DEPTH_RENDER) && defined(ALPHA_BLENDED_DEPTH))\nvar alpha : f32=fragmentOutputs.color.a;\n#endif\n}\n");const Ie="gaussianSplattingDepthVertexShader";r.ShadersStoreWGSL[Ie]||(r.ShadersStoreWGSL[Ie]="#include<sceneUboDeclaration>\n#include<meshUboDeclaration>\nattribute splatIndex0: vec4f;attribute splatIndex1: vec4f;attribute splatIndex2: vec4f;attribute splatIndex3: vec4f;attribute position: vec3f;uniform invViewport: vec2f;uniform dataTextureSize: vec2f;uniform focal: vec2f;uniform kernelSize: f32;uniform alpha: f32;var covariancesATexture: texture_2d<f32>;var covariancesBTexture: texture_2d<f32>;var centersTexture: texture_2d<f32>;var colorsTexture: texture_2d<f32>;\n#if IS_COMPOUND\nuniform partWorld: array<mat4x4<f32>,MAX_PART_COUNT>;uniform partVisibility: array<f32,MAX_PART_COUNT>;var partIndicesTexture: texture_2d<f32>;\n#endif\nvarying vPosition: vec2f;varying vColor: vec4f;\n#ifdef DEPTH_RENDER\nuniform depthValues: vec2f;varying vDepthMetric: f32;\n#endif\n#include<gaussianSplatting>\n@vertex\nfn main(input : VertexInputs)->FragmentInputs {let splatIndex: f32=getSplatIndex(i32(input.position.z+0.5),input.splatIndex0,input.splatIndex1,input.splatIndex2,input.splatIndex3);var splat: Splat=readSplat(splatIndex,uniforms.dataTextureSize);var covA: vec3f=splat.covA.xyz;var covB: vec3f=vec3f(splat.covA.w,splat.covB.xy);\n#if IS_COMPOUND\nlet splatWorld: mat4x4f=getPartWorld(splat.partIndex);\n#else\nlet splatWorld: mat4x4f=mesh.world;\n#endif\nlet worldPos: vec4f=splatWorld*vec4f(splat.center.xyz,1.0);vertexOutputs.vPosition=input.position.xy;vertexOutputs.vColor=splat.color;vertexOutputs.vColor.w*=uniforms.alpha;\n#if IS_COMPOUND\nvertexOutputs.vColor.w*=uniforms.partVisibility[splat.partIndex];\n#endif\nvertexOutputs.position=gaussianSplatting(input.position.xy,worldPos.xyz,vec2f(1.0,1.0),covA,covB,splatWorld,scene.view,scene.projection,uniforms.focal,uniforms.invViewport,uniforms.kernelSize);\n#ifdef DEPTH_RENDER\n#ifdef USE_REVERSE_DEPTHBUFFER\nvertexOutputs.vDepthMetric=((-vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#else\nvertexOutputs.vDepthMetric=((vertexOutputs.position.z+uniforms.depthValues.x)/(uniforms.depthValues.y));\n#endif\n#endif\n}");const Ce=128;class Ae extends v{constructor(e){super(e),this.FOG=!1,this.THIN_INSTANCES=!0,this.LOGARITHMICDEPTH=!1,this.CLIPPLANE=!1,this.CLIPPLANE2=!1,this.CLIPPLANE3=!1,this.CLIPPLANE4=!1,this.CLIPPLANE5=!1,this.CLIPPLANE6=!1,this.SH_DEGREE=0,this.COMPENSATION=!1,this.IS_COMPOUND=!1,this.MAX_PART_COUNT=Ce,this.rebuild()}}class be extends a{constructor(e,t){super(e,t),this.kernelSize=be.KernelSize,this._compensation=be.Compensation,this._isDirty=!1,this._sourceMesh=null,this.backFaceCulling=!1,this.shadowDepthWrapper=be._MakeGaussianSplattingShadowDepthWrapper(t,this.shaderLanguage)}set compensation(e){this._isDirty=this._isDirty!=e,this._compensation=e}get compensation(){return this._compensation}get hasRenderTargetTextures(){return!1}needAlphaTesting(){return!1}needAlphaBlending(){return!0}isReadyForSubMesh(e,t){const s=!0,n=t._drawWrapper;let r=t.materialDefines;if(r&&this._isDirty&&r.markAsUnprocessed(),n.effect&&this.isFrozen&&n._wasPreviouslyReady&&n._wasPreviouslyUsingInstances===s)return!0;t.materialDefines||(this._callbackPluginEventGeneric(4,this._eventInfo),r=t.materialDefines=new Ae(this._eventInfo.defineNames));const a=this.getScene();if(this._isReadyForSubMesh(t))return!0;if(this._eventInfo.isReadyForSubMesh=!0,this._eventInfo.defines=r,this._eventInfo.subMesh=t,this._callbackPluginEventIsReadyForSubMesh(this._eventInfo),!this._eventInfo.isReadyForSubMesh)return!1;if(!this._sourceMesh)return!1;const p=a.getEngine(),d=this._sourceMesh;i(e,a,this._useLogarithmicDepth,this.pointsCloud,this.fogEnabled,!1,r,void 0,void 0,void 0,this._isVertexOutputInvariant),o(a,p,this,r,s,null,!0),l(e,r,!1,!1),(p.version>1||p.isWebGPU)&&(r.SH_DEGREE=d.shDegree),r.IS_COMPOUND=d.isCompound;const f=d.material;if(r.COMPENSATION=f&&f.compensation?f.compensation:be.Compensation,r.isDirty){r.markAsProcessed(),a.resetCachedMaterial(),c(be._Attribs,r);const s=be._Attribs.slice(),n=be._Uniforms.slice(),i=be._Samplers.slice(),o=be._UniformBuffers.slice();h({uniformsNames:n,uniformBuffersNames:o,samplers:i,defines:r}),u(n),this._uniformBufferLayoutBuilt||this.buildUniformLayout(),this._eventInfo.fallbackRank=0,this._eventInfo.defines=r,this._eventInfo.attributes=s,this._eventInfo.uniforms=n,this._eventInfo.samplers=i,this._eventInfo.uniformBuffersNames=o,this._eventInfo.customCode=void 0,this._eventInfo.mesh=e,this._callbackPluginEventGeneric(128,this._eventInfo);const l=r.toString(),d=a.getEngine().createEffect("gaussianSplatting",{attributes:s,uniformsNames:n,uniformBuffersNames:o,samplers:i,defines:l,onCompiled:this.onCompiled,onError:this.onError,indexParameters:{},processCodeAfterIncludes:this._eventInfo.customCode,shaderLanguage:this._shaderLanguage,extraInitializationsAsync:async()=>{1===this._shaderLanguage?await Promise.all([Promise.resolve().then((function(){return xe})),Promise.resolve().then((function(){return we}))]):await Promise.all([Promise.resolve().then((function(){return ae})),Promise.resolve().then((function(){return pe}))])}},p);t.setEffect(d,r,this._materialContext)}return!(!t.effect||!t.effect.isReady())&&(r._renderId=a.getRenderId(),n._wasPreviouslyReady=!0,n._wasPreviouslyUsingInstances=s,this._isDirty=!1,!0)}setSourceMesh(e){this._sourceMesh=e}static BindEffect(e,t,s){const n=s.getEngine(),r=s.activeCamera,a=n.getRenderWidth()*r.viewport.width,i=n.getRenderHeight()*r.viewport.height,o=e.material;if(!o._sourceMesh)return;const l=o._sourceMesh,c=r?.rigParent?.rigCameras.length||1;t.setFloat2("invViewport",1/(a/c),1/i);let h=1e3;if(r){const e=r.getProjectionMatrix().m[5];h=r.fovMode==p.FOVMODE_VERTICAL_FIXED?i*e/2:a*e/2}if(t.setFloat2("focal",h,h),t.setFloat("kernelSize",o&&o.kernelSize?o.kernelSize:be.KernelSize),t.setFloat("alpha",o.alpha),s.bindEyePosition(t,"eyePosition",!0),l.covariancesATexture){const e=l.covariancesATexture.getSize();if(t.setFloat2("dataTextureSize",e.width,e.height),t.setTexture("covariancesATexture",l.covariancesATexture),t.setTexture("covariancesBTexture",l.covariancesBTexture),t.setTexture("centersTexture",l.centersTexture),t.setTexture("colorsTexture",l.colorsTexture),l.shTextures)for(let e=0;e<l.shTextures?.length;e++)t.setTexture(`shTexture${e}`,l.shTextures[e]);if(l.partIndicesTexture){t.setTexture("partIndicesTexture",l.partIndicesTexture);const e=new Float32Array(16*l.partCount);for(let t=0;t<l.partCount;t++)l.getWorldMatrixForPart(t).toArray(e,16*t);t.setMatrices("partWorld",e);const s=[];for(let e=0;e<l.partCount;e++)s.push(l.partVisibility[e]??1);t.setArray("partVisibility",s)}}}bindForSubMesh(e,t,s){const n=this.getScene(),r=s.materialDefines;if(!r)return;const a=s.effect;if(!a)return;this._activeEffect=a,t.getMeshUniformBuffer().bindToEffect(a,"Mesh"),t.transferToEffect(e);this._mustRebind(n,a,s,t.visibility)?(this.bindView(a),this.bindViewProjection(a),be.BindEffect(t,this._activeEffect,n),d(a,this,n)):n.getEngine()._features.needToAlwaysBindUniformBuffers&&(this._needToBindSceneUbo=!0),f(n,t,a),this.useLogarithmicDepth&&_(r,a,n),this._eventInfo.subMesh=s,this._callbackPluginEventBindForSubMesh(this._eventInfo),this._afterBind(t,this._activeEffect,s)}static _BindEffectUniforms(e,t,s,n){const r=n.getEngine(),a=s.getEffect(),i=n.activeCamera;if(!i)return;e.getMeshUniformBuffer().bindToEffect(a,"Mesh"),s.bindView(a),s.bindViewProjection(a);const o=r.getRenderWidth()*i.viewport.width,l=r.getRenderHeight()*i.viewport.height;a.setFloat2("invViewport",1/o,1/l);let c,h,u=1e3;if(i){const e=i.getProjectionMatrix().m[5];u=i.fovMode==p.FOVMODE_VERTICAL_FIXED?l*e/2:o*e/2}a.setFloat2("focal",u,u),a.setFloat("kernelSize",t&&t.kernelSize?t.kernelSize:be.KernelSize),a.setFloat("alpha",t.alpha);if(i.mode===p.ORTHOGRAPHIC_CAMERA?(c=!r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:1,h=r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:1):(c=r.useReverseDepthBuffer&&r.isNDCHalfZRange?i.minZ:r.isNDCHalfZRange?0:i.minZ,h=r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:i.maxZ),a.setFloat2("depthValues",c,c+h),e.covariancesATexture){const t=e.covariancesATexture.getSize();if(a.setFloat2("dataTextureSize",t.width,t.height),a.setTexture("covariancesATexture",e.covariancesATexture),a.setTexture("covariancesBTexture",e.covariancesBTexture),a.setTexture("centersTexture",e.centersTexture),a.setTexture("colorsTexture",e.colorsTexture),e.partIndicesTexture){a.setTexture("partIndicesTexture",e.partIndicesTexture);const t=new Float32Array(16*e.partCount);for(let s=0;s<e.partCount;s++)e.getWorldMatrixForPart(s).toArray(t,16*s);a.setMatrices("partWorld",t);const s=[];for(let t=0;t<e.partCount;t++)s.push(e.partVisibility[t]??1);a.setArray("partVisibility",s)}}}makeDepthRenderingMaterial(e,t,s=!1,n=!1){const r=["#define DEPTH_RENDER"];s&&r.push("#define ALPHA_BLENDED_DEPTH"),n&&(r.push("#define IS_COMPOUND"),r.push("#define MAX_PART_COUNT 128"));const a=new Y("gaussianSplattingDepthRender",e,{vertex:"gaussianSplattingDepth",fragment:"gaussianSplattingDepth"},{attributes:be._Attribs,uniforms:be._Uniforms,samplers:be._Samplers,uniformBuffers:be._UniformBuffers,shaderLanguage:t,defines:r,needAlphaBlending:s});return a.onBindObservable.add((t=>{const s=t.material,n=t;be._BindEffectUniforms(n,s,a,e)})),a}static _MakeGaussianSplattingShadowDepthWrapper(e,t){const s=new Y("gaussianSplattingDepth",e,{vertex:"gaussianSplattingDepth",fragment:"gaussianSplattingDepth"},{attributes:be._Attribs,uniforms:be._Uniforms,samplers:be._Samplers,uniformBuffers:be._UniformBuffers,shaderLanguage:t}),n=new ee(s,e,{standalone:!0});return s.onBindObservable.add((t=>{const n=t.material,r=t;be._BindEffectUniforms(r,n,s,e)})),n}clone(e){const t=m.Clone((()=>new be(e,this.getScene())),this);return t.id=e,t.name=e,this._clonePlugins(t,""),t}serialize(){const e=super.serialize();return e.customType="BABYLON.GaussianSplattingMaterial",e}getClassName(){return"GaussianSplattingMaterial"}static Parse(e,t,s){const n=m.Parse((()=>new be(e.name,t)),e,t,s);return x._ParsePlugins(e,n,t,s),n}}be.KernelSize=.3,be.Compensation=!1,be._Attribs=[g.PositionKind,"splatIndex0","splatIndex1","splatIndex2","splatIndex3"],be._Samplers=["covariancesATexture","covariancesBTexture","centersTexture","colorsTexture","shTexture0","shTexture1","shTexture2","partIndicesTexture"],be._UniformBuffers=["Scene","Mesh"],be._Uniforms=["world","view","projection","vFogInfos","vFogColor","logarithmicDepthConstant","invViewport","dataTextureSize","focal","eyePosition","kernelSize","alpha","depthValues","partWorld","partVisibility"],S("BABYLON.GaussianSplattingMaterial",be);const De=w,Pe={...y,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:De};class Re extends T{get partIndex(){return this._partIndex}constructor(e,t,s,n,r){super(e,t),this.proxiedMesh=n,this._partIndex=r,this.compoundSplatMesh=s,this.updateBoundingInfoFromProxiedMesh(),this.compoundSplatMesh.setWorldMatrixForPart(this.partIndex,this.getWorldMatrix()),this.onAfterWorldMatrixUpdateObservable.add((()=>{this.compoundSplatMesh.setWorldMatrixForPart(this.partIndex,this.getWorldMatrix()),this.updateBoundingInfoFromProxiedMesh()}))}updateBoundingInfoFromProxiedMesh(){const e=this.proxiedMesh.getBoundingInfo();this.setBoundingInfo(new M(e.minimum.clone(),e.maximum.clone()))}getClassName(){return"GaussianSplattingPartProxyMesh"}updatePartIndex(e){this._partIndex=e}get isVisible(){return this.compoundSplatMesh.getPartVisibility(this.partIndex)>0}set isVisible(e){this.compoundSplatMesh.setPartVisibility(this.partIndex,e?1:0)}get visibility(){return this.compoundSplatMesh.getPartVisibility(this.partIndex)}set visibility(e){this.compoundSplatMesh.setPartVisibility(this.partIndex,e)}intersects(e){const t=new E,s=this.getBoundingInfo();return s&&e.intersectsSphere(s.boundingSphere)&&e.intersectsBox(s.boundingBox)?(t.hit=!0,t.pickedMesh=this,t.distance=I.Distance(e.origin,s.boundingSphere.center),t.subMeshId=0,t):t}}const Oe="undefined"!=typeof _native,ze=Oe?_native:null,Ue=(e,t)=>{const s=(1<<t)-1;return(e&s)/s},He=(e,t)=>{t.x=Ue(e>>>21,11),t.y=Ue(e>>>11,10),t.z=Ue(e,11)},ke=(e,t)=>{t[0]=255*Ue(e>>>24,8),t[1]=255*Ue(e>>>16,8),t[2]=255*Ue(e>>>8,8),t[3]=255*Ue(e,8)},Ve=(e,t)=>{const s=1/(.5*Math.sqrt(2)),n=(Ue(e>>>20,10)-.5)*s,r=(Ue(e>>>10,10)-.5)*s,a=(Ue(e,10)-.5)*s,i=Math.sqrt(1-(n*n+r*r+a*a));switch(e>>>30){case 0:t.set(i,n,r,a);break;case 1:t.set(n,i,r,a);break;case 2:t.set(n,r,i,a);break;case 3:t.set(n,r,a,i)}};var Fe,Ne,Be;!function(e){e[e.FLOAT=0]="FLOAT",e[e.INT=1]="INT",e[e.UINT=2]="UINT",e[e.DOUBLE=3]="DOUBLE",e[e.UCHAR=4]="UCHAR",e[e.UNDEFINED=5]="UNDEFINED"}(Fe||(Fe={})),function(e){e[e.MIN_X=0]="MIN_X",e[e.MIN_Y=1]="MIN_Y",e[e.MIN_Z=2]="MIN_Z",e[e.MAX_X=3]="MAX_X",e[e.MAX_Y=4]="MAX_Y",e[e.MAX_Z=5]="MAX_Z",e[e.MIN_SCALE_X=6]="MIN_SCALE_X",e[e.MIN_SCALE_Y=7]="MIN_SCALE_Y",e[e.MIN_SCALE_Z=8]="MIN_SCALE_Z",e[e.MAX_SCALE_X=9]="MAX_SCALE_X",e[e.MAX_SCALE_Y=10]="MAX_SCALE_Y",e[e.MAX_SCALE_Z=11]="MAX_SCALE_Z",e[e.PACKED_POSITION=12]="PACKED_POSITION",e[e.PACKED_ROTATION=13]="PACKED_ROTATION",e[e.PACKED_SCALE=14]="PACKED_SCALE",e[e.PACKED_COLOR=15]="PACKED_COLOR",e[e.X=16]="X",e[e.Y=17]="Y",e[e.Z=18]="Z",e[e.SCALE_0=19]="SCALE_0",e[e.SCALE_1=20]="SCALE_1",e[e.SCALE_2=21]="SCALE_2",e[e.DIFFUSE_RED=22]="DIFFUSE_RED",e[e.DIFFUSE_GREEN=23]="DIFFUSE_GREEN",e[e.DIFFUSE_BLUE=24]="DIFFUSE_BLUE",e[e.OPACITY=25]="OPACITY",e[e.F_DC_0=26]="F_DC_0",e[e.F_DC_1=27]="F_DC_1",e[e.F_DC_2=28]="F_DC_2",e[e.F_DC_3=29]="F_DC_3",e[e.ROT_0=30]="ROT_0",e[e.ROT_1=31]="ROT_1",e[e.ROT_2=32]="ROT_2",e[e.ROT_3=33]="ROT_3",e[e.MIN_COLOR_R=34]="MIN_COLOR_R",e[e.MIN_COLOR_G=35]="MIN_COLOR_G",e[e.MIN_COLOR_B=36]="MIN_COLOR_B",e[e.MAX_COLOR_R=37]="MAX_COLOR_R",e[e.MAX_COLOR_G=38]="MAX_COLOR_G",e[e.MAX_COLOR_B=39]="MAX_COLOR_B",e[e.SH_0=40]="SH_0",e[e.SH_1=41]="SH_1",e[e.SH_2=42]="SH_2",e[e.SH_3=43]="SH_3",e[e.SH_4=44]="SH_4",e[e.SH_5=45]="SH_5",e[e.SH_6=46]="SH_6",e[e.SH_7=47]="SH_7",e[e.SH_8=48]="SH_8",e[e.SH_9=49]="SH_9",e[e.SH_10=50]="SH_10",e[e.SH_11=51]="SH_11",e[e.SH_12=52]="SH_12",e[e.SH_13=53]="SH_13",e[e.SH_14=54]="SH_14",e[e.SH_15=55]="SH_15",e[e.SH_16=56]="SH_16",e[e.SH_17=57]="SH_17",e[e.SH_18=58]="SH_18",e[e.SH_19=59]="SH_19",e[e.SH_20=60]="SH_20",e[e.SH_21=61]="SH_21",e[e.SH_22=62]="SH_22",e[e.SH_23=63]="SH_23",e[e.SH_24=64]="SH_24",e[e.SH_25=65]="SH_25",e[e.SH_26=66]="SH_26",e[e.SH_27=67]="SH_27",e[e.SH_28=68]="SH_28",e[e.SH_29=69]="SH_29",e[e.SH_30=70]="SH_30",e[e.SH_31=71]="SH_31",e[e.SH_32=72]="SH_32",e[e.SH_33=73]="SH_33",e[e.SH_34=74]="SH_34",e[e.SH_35=75]="SH_35",e[e.SH_36=76]="SH_36",e[e.SH_37=77]="SH_37",e[e.SH_38=78]="SH_38",e[e.SH_39=79]="SH_39",e[e.SH_40=80]="SH_40",e[e.SH_41=81]="SH_41",e[e.SH_42=82]="SH_42",e[e.SH_43=83]="SH_43",e[e.SH_44=84]="SH_44",e[e.UNDEFINED=85]="UNDEFINED"}(Ne||(Ne={}));class Le extends T{get disableDepthSort(){return this._disableDepthSort}set disableDepthSort(e){!this._disableDepthSort&&e?(this._worker?.terminate(),this._worker=null,this._disableDepthSort=!0):this._disableDepthSort&&!e&&(this._disableDepthSort=!1,this._sortIsDirty=!0,this._instanciateWorker())}get viewDirectionFactor(){return I.OneReadOnly}get shDegree(){return this._shDegree}get splatCount(){return this._splatIndex?.length}get splatsData(){return this._splatsData}get shData(){return this._shData}get isCompound(){return this._partMatrices.length>0}get partIndices(){return this._partIndices}get partIndicesTexture(){return this._partIndicesTexture}get partVisibility(){return this._partVisibility}get covariancesATexture(){return this._covariancesATexture}get covariancesBTexture(){return this._covariancesBTexture}get centersTexture(){return this._centersTexture}get colorsTexture(){return this._colorsTexture}get shTextures(){return this._shTextures}get kernelSize(){return this._material instanceof be?this._material.kernelSize:0}get compensation(){return this._material instanceof be&&this._material.compensation}set material(e){this._material=e,this._material.backFaceCulling=!1,this._material.cullBackFaces=!1,e.resetDrawCache()}get material(){return this._material}static _MakeSplatGeometryForMesh(e){const t=new C,s=[-2,-2,0,2,-2,0,2,2,0,-2,2,0],n=[0,1,2,0,2,3],r=[],a=[];for(let e=0;e<Le._BatchSize;e++){for(let t=0;t<12;t++)2==t||5==t||8==t||11==t?r.push(e):r.push(s[t]);a.push(n.map((t=>t+4*e)))}t.positions=r,t.indices=a.flat(),t.applyToMesh(e)}constructor(e,t=null,s=null,n=!1){super(e,s),this._vertexCount=0,this._worker=null,this._modelViewProjectionMatrix=A.Identity(),this._viewProjectionMatrix=A.Identity(),this._canPostToWorker=!0,this._readyToDisplay=!1,this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._splatPositions=null,this._splatIndex=null,this._shTextures=null,this._splatsData=null,this._shData=null,this._partIndicesTexture=null,this._partIndices=null,this._partMatrices=[],this._partVisibility=[],this._partProxies=new Map,this._textureSize=new b(0,0),this._keepInRam=!1,this._delayedTextureUpdate=null,this._useRGBACovariants=!1,this._material=null,this._tmpCovariances=[0,0,0,0,0,0],this._sortIsDirty=!1,this._shDegree=0,this._cameraViewInfos=new Map,this.viewUpdateThreshold=Le._DefaultViewUpdateThreshold,this._disableDepthSort=!1,this._loadingPromise=null,this.subMeshes=[],new D(0,0,4*Le._BatchSize,0,6*Le._BatchSize,this),this.setEnabled(!1),this._useRGBACovariants=!this.getEngine().isWebGPU&&1===this.getEngine().version,this._keepInRam=n,t&&(this._loadingPromise=this.loadFileAsync(t));const r=new be(this.name+"_material",this._scene);r.setSourceMesh(this),this._material=r,this._scene.onCameraRemovedObservable.add((e=>{const t=e.uniqueId;if(this._cameraViewInfos.has(t)){const e=this._cameraViewInfos.get(t);e?.mesh.dispose(),this._cameraViewInfos.delete(t)}}))}getLoadingPromise(){return this._loadingPromise}getClassName(){return"GaussianSplattingMesh"}getTotalVertices(){return this._vertexCount}isReady(e=!1){return!!super.isReady(e,!0)&&(!!this._readyToDisplay||(this._postToWorker(!0),!1))}_getCameraDirection(e){const t=e.getViewMatrix(),s=e.getProjectionMatrix(),n=P.Matrix[0];t.multiplyToRef(s,n),this._viewProjectionMatrix.copyFrom(n);const r=P.Matrix[1];this.getWorldMatrix().multiplyToRef(t,r),r.multiplyToRef(s,this._modelViewProjectionMatrix);const a=P.Vector3[1];return a.set(r.m[2],r.m[6],r.m[10]),a.normalize(),a}_postToWorker(e=!1){const t=this._scene.getFrameId();let s=!1;this._cameraViewInfos.forEach((e=>{e.frameIdLastUpdate!==t&&(s=!0)}));const n=this._scene.activeCameras?.length?this._scene.activeCameras:[this._scene.activeCamera],r=[];n.forEach((e=>{if(!e)return;const s=e.uniqueId,n=this._cameraViewInfos.get(s);if(n)r.push(n);else{const n=new T(this.name+"_cameraMesh_"+s,this._scene);n.reservedDataStore={hidden:!0},n.setEnabled(!1),n.material=this.material,Le._MakeSplatGeometryForMesh(n);const a={camera:e,cameraDirection:new I(0,0,0),mesh:n,frameIdLastUpdate:t,splatIndexBufferSet:!1};r.push(a),this._cameraViewInfos.set(s,a)}})),r.sort(((e,t)=>e.frameIdLastUpdate-t.frameIdLastUpdate));const a=this._worker||ze?.sortSplats||this._disableDepthSort;(e||s)&&a&&(this._scene.activeCameras?.length||this._scene.activeCamera)&&this._canPostToWorker?r.forEach((s=>{const n=s.camera,r=this._getCameraDirection(n),a=s.cameraDirection,i=I.Dot(r,a);(e||Math.abs(i-1)>=this.viewUpdateThreshold)&&this._canPostToWorker&&(s.cameraDirection.copyFrom(r),s.frameIdLastUpdate=t,this._canPostToWorker=!1,this._worker?this._worker.postMessage({modelViewProjection:this._modelViewProjectionMatrix.m,viewProjection:this._viewProjectionMatrix.m,depthMix:this._depthMix,cameraId:n.uniqueId,depthScale:n.mode===p.ORTHOGRAPHIC_CAMERA?(n.maxZ-n.minZ)/2:1},[this._depthMix.buffer]):ze?.sortSplats&&(ze.sortSplats(this._modelViewProjectionMatrix,this._splatPositions,this._splatIndex,this._scene.useRightHandedSystem),s.splatIndexBufferSet?s.mesh.thinInstanceBufferUpdated("splatIndex"):(s.mesh.thinInstanceSetBuffer("splatIndex",this._splatIndex,16,!1),s.splatIndexBufferSet=!0),this._canPostToWorker=!0,this._readyToDisplay=!0))})):this._disableDepthSort&&(r.forEach((e=>{e.splatIndexBufferSet||(e.mesh.thinInstanceSetBuffer("splatIndex",this._splatIndex,16,!1),e.splatIndexBufferSet=!0)})),this._canPostToWorker=!0,this._readyToDisplay=!0)}render(e,t,s){this._postToWorker(),!this._geometry&&this._cameraViewInfos.size&&(this._geometry=this._cameraViewInfos.values().next().value.mesh.geometry);const n=this._scene.activeCamera.uniqueId,r=this._cameraViewInfos.get(n);if(!r||!r.splatIndexBufferSet)return this;this.onBeforeRenderObservable&&this.onBeforeRenderObservable.notifyObservers(this);const a=r.mesh;a.getWorldMatrix().copyFrom(this.getWorldMatrix());const i=this._scene.getEngine().currentRenderPassId,o=this.getMaterialForRenderPass(i);o&&a.setMaterialForRenderPass(i,o);const l=a.render(e,t,s);return o&&a.setMaterialForRenderPass(i,void 0),this.onAfterRenderObservable&&this.onAfterRenderObservable.notifyObservers(this),l}static _TypeNameToEnum(e){switch(e){case"float":return 0;case"int":return 1;case"uint":return 2;case"double":return 3;case"uchar":return 4}return 5}static _ValueNameToEnum(e){switch(e){case"min_x":return 0;case"min_y":return 1;case"min_z":return 2;case"max_x":return 3;case"max_y":return 4;case"max_z":return 5;case"min_scale_x":return 6;case"min_scale_y":return 7;case"min_scale_z":return 8;case"max_scale_x":return 9;case"max_scale_y":return 10;case"max_scale_z":return 11;case"packed_position":return 12;case"packed_rotation":return 13;case"packed_scale":return 14;case"packed_color":return 15;case"x":return 16;case"y":return 17;case"z":return 18;case"scale_0":return 19;case"scale_1":return 20;case"scale_2":return 21;case"diffuse_red":case"red":return 22;case"diffuse_green":case"green":return 23;case"diffuse_blue":case"blue":return 24;case"f_dc_0":return 26;case"f_dc_1":return 27;case"f_dc_2":return 28;case"f_dc_3":return 29;case"opacity":return 25;case"rot_0":return 30;case"rot_1":return 31;case"rot_2":return 32;case"rot_3":return 33;case"min_r":return 34;case"min_g":return 35;case"min_b":return 36;case"max_r":return 37;case"max_g":return 38;case"max_b":return 39;case"f_rest_0":return 40;case"f_rest_1":return 41;case"f_rest_2":return 42;case"f_rest_3":return 43;case"f_rest_4":return 44;case"f_rest_5":return 45;case"f_rest_6":return 46;case"f_rest_7":return 47;case"f_rest_8":return 48;case"f_rest_9":return 49;case"f_rest_10":return 50;case"f_rest_11":return 51;case"f_rest_12":return 52;case"f_rest_13":return 53;case"f_rest_14":return 54;case"f_rest_15":return 55;case"f_rest_16":return 56;case"f_rest_17":return 57;case"f_rest_18":return 58;case"f_rest_19":return 59;case"f_rest_20":return 60;case"f_rest_21":return 61;case"f_rest_22":return 62;case"f_rest_23":return 63;case"f_rest_24":return 64;case"f_rest_25":return 65;case"f_rest_26":return 66;case"f_rest_27":return 67;case"f_rest_28":return 68;case"f_rest_29":return 69;case"f_rest_30":return 70;case"f_rest_31":return 71;case"f_rest_32":return 72;case"f_rest_33":return 73;case"f_rest_34":return 74;case"f_rest_35":return 75;case"f_rest_36":return 76;case"f_rest_37":return 77;case"f_rest_38":return 78;case"f_rest_39":return 79;case"f_rest_40":return 80;case"f_rest_41":return 81;case"f_rest_42":return 82;case"f_rest_43":return 83;case"f_rest_44":return 84}return 85}static ParseHeader(e){const t=new Uint8Array(e),s=(new TextDecoder).decode(t.slice(0,10240)),n="end_header\n",r=s.indexOf(n);if(r<0||!s)return null;const a=parseInt(/element vertex (\d+)\n/.exec(s)[1]),i=/element chunk (\d+)\n/.exec(s);let o=0;i&&(o=parseInt(i[1]));let l=0,c=0;const h={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0};let u;!function(e){e[e.Vertex=0]="Vertex",e[e.Chunk=1]="Chunk",e[e.SH=2]="SH",e[e.Unused=3]="Unused"}(u||(u={}));let p=1;const d=[],f=[],_=s.slice(0,r).split("\n");let m=0;for(const e of _)if(e.startsWith("property ")){const[,t,s]=e.split(" "),n=Le._ValueNameToEnum(s);85!=n&&(n>=84?m=3:n>=64?m=Math.max(m,2):n>=48&&(m=Math.max(m,1)));const r=Le._TypeNameToEnum(t);1==p?(f.push({value:n,type:r,offset:c}),c+=h[t]):0==p?(d.push({value:n,type:r,offset:l}),l+=h[t]):2==p&&d.push({value:n,type:r,offset:l}),h[t]||R.Warn(`Unsupported property type: ${t}.`)}else if(e.startsWith("element ")){const[,t]=e.split(" ");p="chunk"==t?1:"vertex"==t?0:"sh"==t?2:3}const x=new DataView(e,r+11),v=new ArrayBuffer(Le._RowOutputLength*a);let g=null,S=0;if(m){S=3*((m+1)*(m+1)-1),g=new ArrayBuffer(S*a)}return{vertexCount:a,chunkCount:o,rowVertexLength:l,rowChunkLength:c,vertexProperties:d,chunkProperties:f,dataView:x,buffer:v,shDegree:m,shCoefficientCount:S,shBuffer:g}}static _GetCompressedChunks(e,t){if(!e.chunkCount)return null;const s=e.dataView,n=new Array(e.chunkCount);for(let r=0;r<e.chunkCount;r++){const a={min:new I,max:new I,minScale:new I,maxScale:new I,minColor:new I(0,0,0),maxColor:new I(1,1,1)};n[r]=a;for(let n=0;n<e.chunkProperties.length;n++){const r=e.chunkProperties[n];let i;if(0===r.type)switch(i=s.getFloat32(r.offset+t.value,!0),r.value){case 0:a.min.x=i;break;case 1:a.min.y=i;break;case 2:a.min.z=i;break;case 3:a.max.x=i;break;case 4:a.max.y=i;break;case 5:a.max.z=i;break;case 6:a.minScale.x=i;break;case 7:a.minScale.y=i;break;case 8:a.minScale.z=i;break;case 9:a.maxScale.x=i;break;case 10:a.maxScale.y=i;break;case 11:a.maxScale.z=i;break;case 34:a.minColor.x=i;break;case 35:a.minColor.y=i;break;case 36:a.minColor.z=i;break;case 37:a.maxColor.x=i;break;case 38:a.maxColor.y=i;break;case 39:a.maxColor.z=i}}t.value+=e.rowChunkLength}return n}static _GetSplat(e,t,s,n){const r=P.Quaternion[0],a=P.Vector3[0],i=Le._RowOutputLength,o=e.buffer,l=e.dataView,c=new Float32Array(o,t*i,3),h=new Float32Array(o,t*i+12,3),u=new Uint8ClampedArray(o,t*i+24,4),p=new Uint8ClampedArray(o,t*i+28,4);let d=null;e.shBuffer&&(d=new Uint8ClampedArray(e.shBuffer,t*e.shCoefficientCount,e.shCoefficientCount));const f=t>>8;let _=255,m=0,x=0,v=0;const g=[];for(let i=0;i<e.vertexProperties.length;i++){const o=e.vertexProperties[i];let p;switch(o.type){case 0:p=l.getFloat32(n.value+o.offset,!0);break;case 1:p=l.getInt32(n.value+o.offset,!0);break;case 2:p=l.getUint32(n.value+o.offset,!0);break;case 3:p=l.getFloat64(n.value+o.offset,!0);break;case 4:p=l.getUint8(n.value+o.offset);break;default:continue}switch(o.value){case 12:{const e=s[f];He(p,a),c[0]=Pe.Lerp(e.min.x,e.max.x,a.x),c[1]=Pe.Lerp(e.min.y,e.max.y,a.y),c[2]=Pe.Lerp(e.min.z,e.max.z,a.z)}break;case 13:Ve(p,r),_=r.x,m=r.y,x=r.z,v=r.w;break;case 14:{const e=s[f];He(p,a),h[0]=Math.exp(Pe.Lerp(e.minScale.x,e.maxScale.x,a.x)),h[1]=Math.exp(Pe.Lerp(e.minScale.y,e.maxScale.y,a.y)),h[2]=Math.exp(Pe.Lerp(e.minScale.z,e.maxScale.z,a.z))}break;case 15:{const e=s[f];ke(p,u),u[0]=255*Pe.Lerp(e.minColor.x,e.maxColor.x,u[0]/255),u[1]=255*Pe.Lerp(e.minColor.y,e.maxColor.y,u[1]/255),u[2]=255*Pe.Lerp(e.minColor.z,e.maxColor.z,u[2]/255)}break;case 16:c[0]=p;break;case 17:c[1]=p;break;case 18:c[2]=p;break;case 19:h[0]=Math.exp(p);break;case 20:h[1]=Math.exp(p);break;case 21:h[2]=Math.exp(p);break;case 22:u[0]=p;break;case 23:u[1]=p;break;case 24:u[2]=p;break;case 26:u[0]=255*(.5+Le._SH_C0*p);break;case 27:u[1]=255*(.5+Le._SH_C0*p);break;case 28:u[2]=255*(.5+Le._SH_C0*p);break;case 29:u[3]=255*(.5+Le._SH_C0*p);break;case 25:u[3]=1/(1+Math.exp(-p))*255;break;case 30:_=p;break;case 31:m=p;break;case 32:x=p;break;case 33:v=p}if(d&&o.value>=40&&o.value<=84){const s=o.value-40;if(4==o.type&&e.chunkCount){const n=l.getUint8(e.rowChunkLength*e.chunkCount+e.vertexCount*e.rowVertexLength+t*e.shCoefficientCount+s);g[s]=127.5*(n*(8/255)-4)+127.5}else{const e=Pe.Clamp(127.5*p+127.5,0,255);g[s]=e}}}if(d){const t=1==e.shDegree?3:2==e.shDegree?8:15;for(let e=0;e<t;e++)d[3*e+0]=g[e],d[3*e+1]=g[e+t],d[3*e+2]=g[e+2*t]}r.set(m,x,v,_),r.normalize(),p[0]=127.5*r.w+127.5,p[1]=127.5*r.x+127.5,p[2]=127.5*r.y+127.5,p[3]=127.5*r.z+127.5,n.value+=e.rowVertexLength}static*ConvertPLYWithSHToSplat(t,s=!1){const n=Le.ParseHeader(t);if(!n)return{buffer:t};const r={value:0},a=Le._GetCompressedChunks(n,r);for(let e=0;e<n.vertexCount;e++)Le._GetSplat(n,e,a,r),e%Le._PlyConversionBatchSize===0&&s&&(yield);let i=null;if(n.shDegree&&n.shBuffer){const t=Math.ceil(n.shCoefficientCount/16);let s=0;const r=new Uint8Array(n.shBuffer);i=[];const a=n.vertexCount,o=e.LastCreatedEngine;if(o){const e=o.getCaps().maxTextureSize,l=Math.ceil(a/e);for(let s=0;s<t;s++){const t=new Uint8Array(l*e*4*4);i.push(t)}for(let e=0;e<a;e++)for(let t=0;t<n.shCoefficientCount;t++){const n=r[s++];i[Math.floor(t/16)][t%16+16*e]=n}}}return{buffer:n.buffer,sh:i}}static*ConvertPLYToSplat(e,t=!1){const s=Le.ParseHeader(e);if(!s)return e;const n={value:0},r=Le._GetCompressedChunks(s,n);for(let e=0;e<s.vertexCount;e++)Le._GetSplat(s,e,r,n),e%Le._PlyConversionBatchSize===0&&t&&(yield);return s.buffer}static async ConvertPLYToSplatAsync(e){return await O(Le.ConvertPLYToSplat(e,!0),z())}static async ConvertPLYWithSHToSplatAsync(e){return await O(Le.ConvertPLYWithSHToSplat(e,!0),z())}async loadDataAsync(e){return await this.updateDataAsync(e)}async loadFileAsync(t,s){await U(t,s||e.LastCreatedScene,{pluginOptions:{splat:{gaussianSplattingMesh:this}}})}dispose(e){if(this._covariancesATexture?.dispose(),this._covariancesBTexture?.dispose(),this._centersTexture?.dispose(),this._colorsTexture?.dispose(),this._shTextures)for(const e of this._shTextures)e.dispose();this._partIndicesTexture&&this._partIndicesTexture.dispose(),this._covariancesATexture=null,this._covariancesBTexture=null,this._centersTexture=null,this._colorsTexture=null,this._shTextures=null,this._partIndicesTexture=null,this._partMatrices=[],this._worker?.terminate(),this._worker=null,this._cameraViewInfos.forEach((e=>{e.mesh.dispose()})),this._partProxies.forEach((e=>{e.dispose()})),this._partProxies.clear(),super.dispose(e,!0)}_copyTextures(e){if(this._covariancesATexture=e.covariancesATexture?.clone(),this._covariancesBTexture=e.covariancesBTexture?.clone(),this._centersTexture=e.centersTexture?.clone(),this._colorsTexture=e.colorsTexture?.clone(),this._partIndicesTexture=e._partIndicesTexture?.clone(),e._shTextures){this._shTextures=[];for(const t of e._shTextures)this._shTextures?.push(t.clone())}}clone(e=""){const t=new Le(e,void 0,this.getScene());t._copySource(this),t.makeGeometryUnique(),t._vertexCount=this._vertexCount,t._copyTextures(this),t._modelViewProjectionMatrix=A.Identity(),t._viewProjectionMatrix=A.Identity(),t._splatPositions=this._splatPositions,t._readyToDisplay=!1,t._disableDepthSort=this._disableDepthSort,t._partMatrices=this._partMatrices.map((e=>e.clone())),t._instanciateWorker();const s=this.getBoundingInfo();return t.getBoundingInfo().reConstruct(s.minimum,s.maximum,this.getWorldMatrix()),t.forcedInstanceCount=this.forcedInstanceCount,t.setEnabled(!0),t}_makeEmptySplat(e,t,s,n){const r=this._useRGBACovariants?4:2;this._splatPositions[4*e+0]=0,this._splatPositions[4*e+1]=0,this._splatPositions[4*e+2]=0,t[4*e+0]=H(0),t[4*e+1]=H(0),t[4*e+2]=H(0),t[4*e+3]=H(0),s[e*r+0]=H(0),s[e*r+1]=H(0),n[4*e+3]=0}_makeSplat(e,t,s,n,r,a,i,o,l){const c=P.Matrix[0],h=P.Matrix[1],u=P.Quaternion[0],p=this._useRGBACovariants?4:2,d=t[8*e+0],f=t[8*e+1]*(l.flipY?-1:1),_=t[8*e+2];this._splatPositions[4*e+0]=d,this._splatPositions[4*e+1]=f,this._splatPositions[4*e+2]=_,i.minimizeInPlaceFromFloats(d,f,_),o.maximizeInPlaceFromFloats(d,f,_),u.set((s[32*e+28+1]-127.5)/127.5,(s[32*e+28+2]-127.5)/127.5,(s[32*e+28+3]-127.5)/127.5,-(s[32*e+28+0]-127.5)/127.5),u.normalize(),u.toRotationMatrix(c),A.ScalingToRef(2*t[8*e+3+0],2*t[8*e+3+1],2*t[8*e+3+2],h);const m=c.multiplyToRef(h,P.Matrix[0]).m,x=this._tmpCovariances;x[0]=m[0]*m[0]+m[1]*m[1]+m[2]*m[2],x[1]=m[0]*m[4]+m[1]*m[5]+m[2]*m[6],x[2]=m[0]*m[8]+m[1]*m[9]+m[2]*m[10],x[3]=m[4]*m[4]+m[5]*m[5]+m[6]*m[6],x[4]=m[4]*m[8]+m[5]*m[9]+m[6]*m[10],x[5]=m[8]*m[8]+m[9]*m[9]+m[10]*m[10];let v=-1e4;for(let e=0;e<6;e++)v=Math.max(v,Math.abs(x[e]));this._splatPositions[4*e+3]=v;const g=v;n[4*e+0]=H(x[0]/g),n[4*e+1]=H(x[1]/g),n[4*e+2]=H(x[2]/g),n[4*e+3]=H(x[3]/g),r[e*p+0]=H(x[4]/g),r[e*p+1]=H(x[5]/g),a[4*e+0]=s[32*e+24+0],a[4*e+1]=s[32*e+24+1],a[4*e+2]=s[32*e+24+2],a[4*e+3]=s[32*e+24+3]}_updateTextures(e,t,s,n,r){const a=this._getTextureSize(this._vertexCount),i=(e,t,s,n)=>new q(e,t,s,n,this._scene,!1,!1,k.TEXTURE_BILINEAR_SAMPLINGMODE,k.TEXTURETYPE_FLOAT),o=(e,t,s,n)=>new q(e,t,s,n,this._scene,!1,!1,k.TEXTURE_BILINEAR_SAMPLINGMODE,k.TEXTURETYPE_UNSIGNED_BYTE),l=(e,t,s,n)=>new q(e,t,s,n,this._scene,!1,!1,k.TEXTURE_NEAREST_SAMPLINGMODE,k.TEXTURETYPE_UNSIGNED_INTEGER),c=(e,t,s,n)=>new q(e,t,s,n,this._scene,!1,!1,k.TEXTURE_BILINEAR_SAMPLINGMODE,k.TEXTURETYPE_HALF_FLOAT),h=null===this._covariancesATexture,u=this._textureSize.y!=a.y;if(h||u){if(this._textureSize=a,this._covariancesATexture=c(e,a.x,a.y,k.TEXTUREFORMAT_RGBA),this._covariancesBTexture=c(t,a.x,a.y,this._useRGBACovariants?k.TEXTUREFORMAT_RGBA:k.TEXTUREFORMAT_RG),this._centersTexture=i(this._splatPositions,a.x,a.y,k.TEXTUREFORMAT_RGBA),this._colorsTexture=o(s,a.x,a.y,k.TEXTUREFORMAT_RGBA),n){this._shTextures=[];for(const e of n){const t=l(new Uint32Array(e.buffer),a.x,a.y,k.TEXTUREFORMAT_RGBA_INTEGER);t.wrapU=k.TEXTURE_CLAMP_ADDRESSMODE,t.wrapV=k.TEXTURE_CLAMP_ADDRESSMODE,this._shTextures.push(t)}}if(r){const e=new Uint8Array(r);this._partIndicesTexture=o(e,a.x,a.y,k.TEXTUREFORMAT_RED),this._partIndicesTexture.wrapU=k.TEXTURE_CLAMP_ADDRESSMODE,this._partIndicesTexture.wrapV=k.TEXTURE_CLAMP_ADDRESSMODE}if(h)this._instanciateWorker();else{if(this._worker){const e=Float32Array.from(this._splatPositions),t=this._vertexCount;this._worker.postMessage({positions:e,vertexCount:t},[e.buffer]),this._worker.postMessage({partIndices:r??null})}this._postToWorker(!0)}}else{this._delayedTextureUpdate={covA:e,covB:t,colors:s,centers:this._splatPositions,sh:n,partIndices:r};const i=Float32Array.from(this._splatPositions),c=this._vertexCount;if(this._worker&&this._worker.postMessage({positions:i,vertexCount:c},[i.buffer]),n&&!this._shTextures){this._shTextures=[];for(const e of n){const t=l(new Uint32Array(e.buffer),a.x,a.y,k.TEXTUREFORMAT_RGBA_INTEGER);t.wrapU=k.TEXTURE_CLAMP_ADDRESSMODE,t.wrapV=k.TEXTURE_CLAMP_ADDRESSMODE,this._shTextures.push(t)}}if(r&&!this._partIndicesTexture){const e=new Uint8Array(r);this._partIndicesTexture=o(e,a.x,a.y,k.TEXTUREFORMAT_RED),this._partIndicesTexture.wrapU=k.TEXTURE_CLAMP_ADDRESSMODE,this._partIndicesTexture.wrapV=k.TEXTURE_CLAMP_ADDRESSMODE}this._worker&&this._worker.postMessage({partIndices:r??null}),this._postToWorker(!0)}}*_updateData(e,t,s,n,r={flipY:!1}){this._covariancesATexture||(this._readyToDisplay=!1);const a=new Uint8Array(e),i=new Float32Array(a.buffer);this._keepInRam&&(this._splatsData=e,this._shData=s?s.map((e=>new Uint8Array(e))):null);const o=a.length/Le._RowOutputLength;o!=this._vertexCount&&this._updateSplatIndexBuffer(o),this._vertexCount=o,this._shDegree=s?s.length:0;const l=this._getTextureSize(o),c=l.x*l.y,h=Le.ProgressiveUpdateAmount??l.y,u=l.x*h;this._splatPositions=new Float32Array(4*c);const p=new Uint16Array(4*c),d=new Uint16Array((this._useRGBACovariants?4:2)*c),f=new Uint8Array(4*c);if(n){this._partIndices=new Uint8Array(c),this._partIndices.set(n);let e=-1;for(let t=0;t<n.length;t++)e=Math.max(e,n[t]);this._ensureMinimumPartMatricesLength(e+1)}const _=new I(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),m=new I(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);if(Le.ProgressiveUpdateAmount){this._updateTextures(p,d,f,s,this._partIndices?this._partIndices:void 0),this.setEnabled(!0);const e=Math.ceil(l.y/h);for(let s=0;s<e;s++){const e=s*h,n=e*l.x;for(let e=0;e<u;e++)this._makeSplat(n+e,i,a,p,d,f,_,m,r);this._updateSubTextures(this._splatPositions,p,d,f,e,Math.min(h,l.y-e)),this.getBoundingInfo().reConstruct(_,m,this.getWorldMatrix()),t&&(yield)}const o=Float32Array.from(this._splatPositions),c=this._vertexCount;this._worker&&(this._worker.postMessage({positions:o,vertexCount:c},[o.buffer]),this._worker.postMessage({partIndices:n})),this._sortIsDirty=!0}else{const e=o+15&-16;for(let e=0;e<o;e++)this._makeSplat(e,i,a,p,d,f,_,m,r),t&&e%Le._SplatBatchSize===0&&(yield);for(let t=o;t<e;t++)this._makeEmptySplat(t,p,d,f);this._updateTextures(p,d,f,s,this._partIndices?this._partIndices:void 0),this.getBoundingInfo().reConstruct(_,m,this.getWorldMatrix()),this.setEnabled(!0),this._sortIsDirty=!0}this._postToWorker(!0)}async updateDataAsync(e,t,s){return await O(this._updateData(e,!0,t,s),z())}updateData(e,t,s={flipY:!0},n){V(this._updateData(e,!1,t,n,s))}refreshBoundingInfo(){return this.thinInstanceRefreshBoundingInfo(!1),this}_updateSplatIndexBuffer(e){const t=e+15&-16;if(!this._splatIndex||e!=this._splatIndex.length){this._splatIndex=new Float32Array(t);for(let e=0;e<t;e++)this._splatIndex[e]=e;this._cameraViewInfos.forEach((e=>{e.mesh.thinInstanceSetBuffer("splatIndex",this._splatIndex,16,!1)}))}this._depthMix&&e==this._depthMix.length||Oe||(this._depthMix=new BigInt64Array(t)),this.forcedInstanceCount=Math.max(t>>4,1)}_updateSubTextures(e,t,s,n,r,a,i,o){const l=(e,t,s,n,r)=>{this.getEngine().updateTextureData(e.getInternalTexture(),t,0,n,s,r,0,0,!1)},c=this._getTextureSize(this._vertexCount),h=this._useRGBACovariants?4:2,u=r*c.x,p=a*c.x,d=new Uint16Array(t.buffer,4*u*Uint16Array.BYTES_PER_ELEMENT,4*p),f=new Uint16Array(s.buffer,u*h*Uint16Array.BYTES_PER_ELEMENT,p*h),_=new Uint8Array(n.buffer,4*u,4*p),m=new Float32Array(e.buffer,4*u*Float32Array.BYTES_PER_ELEMENT,4*p);if(l(this._covariancesATexture,d,c.x,r,a),l(this._covariancesBTexture,f,c.x,r,a),l(this._centersTexture,m,c.x,r,a),l(this._colorsTexture,_,c.x,r,a),i)for(let e=0;e<i.length;e++){const t=4,s=new Uint32Array(i[e].buffer,u*t*4,p*t);l(this._shTextures[e],s,c.x,r,a)}if(o&&this._partIndicesTexture){const e=new Uint8Array(o.buffer,u,p);l(this._partIndicesTexture,e,c.x,r,a)}}_instanciateWorker(){if(!this._vertexCount)return;if(this._disableDepthSort)return;if(this._updateSplatIndexBuffer(this._vertexCount),Oe)return;this._worker?.terminate(),this._worker=new Worker(URL.createObjectURL(new Blob(["(",Le._CreateWorker.toString(),")(self)"],{type:"application/javascript"})));const e=Float32Array.from(this._splatPositions),t=this._partIndices?new Uint8Array(this._partIndices):null,s=this._partMatrices.map((e=>new Float32Array(e.m)));this._worker.postMessage({positions:e},[e.buffer]),this._worker.postMessage({partIndices:t}),this._worker.postMessage({partMatrices:s}),this._worker.onmessage=e=>{const t=this._vertexCount+15&-16;if(e.data.depthMix.length!=t)return this._canPostToWorker=!0,this._postToWorker(!0),void(this._sortIsDirty=!1);this._depthMix=e.data.depthMix;const s=e.data.cameraId,n=new Uint32Array(e.data.depthMix.buffer);if(this._splatIndex)for(let e=0;e<t;e++)this._splatIndex[e]=n[2*e];if(this._delayedTextureUpdate){const e=this._getTextureSize(t);this._updateSubTextures(this._delayedTextureUpdate.centers,this._delayedTextureUpdate.covA,this._delayedTextureUpdate.covB,this._delayedTextureUpdate.colors,0,e.y,this._delayedTextureUpdate.sh,this._delayedTextureUpdate.partIndices),this._delayedTextureUpdate=null}const r=this._cameraViewInfos.get(s);r&&(r.splatIndexBufferSet?r.mesh.thinInstanceBufferUpdated("splatIndex"):(r.mesh.thinInstanceSetBuffer("splatIndex",this._splatIndex,16,!1),r.splatIndexBufferSet=!0)),this._canPostToWorker=!0,this._readyToDisplay=!0,this._sortIsDirty&&(this._postToWorker(!0),this._sortIsDirty=!1)}}_getTextureSize(e){const t=this._scene.getEngine(),s=t.getCaps().maxTextureSize;let n=1;if(1!==t.version||t.isWebGPU)n=Math.ceil(e/s);else for(;s*n<e;)n*=2;return n>s&&(R.Error("GaussianSplatting texture size: ("+s+", "+n+"), maxTextureSize: "+s),n=s),new b(s,n)}get partCount(){return this._partMatrices.length}setWorldMatrixForPart(e,t){this._partMatrices[e].copyFrom(t),this._worker&&this._worker.postMessage({partMatrices:this._partMatrices.map((e=>new Float32Array(e.m)))}),this._postToWorker(!0)}getWorldMatrixForPart(e){return this._partMatrices[e]??this.getWorldMatrix()}getPartVisibility(e){return this._partVisibility[e]??1}setPartVisibility(e,t){this._partVisibility[e]=Math.max(0,Math.min(1,t))}_ensureMinimumPartMatricesLength(e){this._partMatrices.length<e&&this._resizePartMatrices(e)}_resizePartMatrices(e){if(this._partMatrices.length!=e){if(this._partMatrices.length>e)this._partMatrices=this._partMatrices.slice(0,e),this._partVisibility=this._partVisibility.slice(0,e);else{this.computeWorldMatrix(!0);const t=this.getWorldMatrix();for(;this._partMatrices.length<e;)this._partMatrices.push(t.clone()),this._partVisibility.push(1)}this._worker&&this._worker.postMessage({partMatrices:this._partMatrices.map((e=>new Float32Array(e.m)))}),this._postToWorker(!0)}}addPart(e,t=!0){if(this.partCount>=Ce)throw new Error("Cannot add part, as the maximum part count (128) has been reached");const s=this._vertexCount,n=0==s?new ArrayBuffer(0):this.splatsData,r=this.shData,a=e._vertexCount,i=e.splatsData,o=e.shData,l=Math.max(r?.length||0,o?.length||0),c=null!==r&&null!==o;if(!n)throw new Error("To call addPart(), the current mesh must be loaded with keepInRam: true");const h=s*Le._RowOutputLength;if(n.byteLength!==h)throw new Error(`splatsDataA size (${n.byteLength}) does not match expected size (${h})`);if(!i)throw new Error("To call addPart(), the other mesh must be loaded with keepInRam: true");const u=a*Le._RowOutputLength;if(i.byteLength!==u)throw new Error(`splatsDataB size (${i.byteLength}) does not match expected size (${u})`);if(e.partIndices)throw new Error("To call addPart(), the other mesh must not be a compound");const p=new Uint8Array(n.byteLength+i.byteLength);let d;if(p.set(new Uint8Array(n),0),p.set(new Uint8Array(i),n.byteLength),c){const e=16,t=s+a;d=[];for(let n=0;n<l;n++){const a=new Uint8Array(t*e);if(n<(r?.length??0)&&a.set(r[n],0),n<(o?.length??0)){const t=e*s;a.set(o[n],t)}d.push(a)}}let f=this.partCount,_=this.partIndices;if(_||(_=new Uint8Array(s),f=s>0?1:0),_.length<s)throw new Error(`partIndices length (${_.length}) should be at least vertexCount (${s}) in the current mesh`);const m=new Uint8Array(a).fill(f),x=new Uint8Array(s+a);x.set(_.slice(0,s),0),x.set(m,s),this.updateData(p.buffer,d,{flipY:!1},x);const v=e.getWorldMatrix();this.setWorldMatrixForPart(f,v);const g=new Re(e.name,this.getScene(),this,e,f);t&&e.dispose();const S=new F;return v.decompose(g.scaling,S,g.position),g.rotationQuaternion=S,g.computeWorldMatrix(!0),this._partProxies.set(f,g),g}removePart(e){if(e<0||e>=this.partCount)throw new Error(`Part index ${e} is out of range [0, ${this.partCount})`);const t=this.splatsData,s=this.shData,n=this.partIndices;if(!t||!n)throw new Error("Cannot remove part from a non-compound mesh or mesh without keepInRam");const r=this._vertexCount,a=Le._RowOutputLength;let i=0;for(let t=0;t<r;t++)n[t]!==e&&i++;const o=new Uint8Array(i*a),l=new Uint8Array(i);let c;if(s){const e=16;c=[];for(let t=0;t<s.length;t++)c.push(new Uint8Array(i*e))}let h=0;for(let i=0;i<r;i++){const r=n[i];if(r===e)continue;const u=i*a,p=h*a;if(o.set(new Uint8Array(t,u,a),p),l[h]=r>e?r-1:r,s&&c){const e=16;for(let t=0;t<s.length;t++){const n=i*e,r=h*e;c[t].set(new Uint8Array(s[t].buffer,n,e),r)}}h++}this._partMatrices.splice(e,1),this._partVisibility.splice(e,1),this._worker&&this._worker.postMessage({partMatrices:this._partMatrices.map((e=>new Float32Array(e.m)))}),this.updateData(o.buffer,c,{flipY:!1},l);const u=this._partProxies.get(e);u&&(u.dispose(),this._partProxies.delete(e));const p=[];this._partProxies.forEach(((t,s)=>{s>e&&p.push([s,t])}));for(const[e,t]of p)this._partProxies.delete(e),t.updatePartIndex(e-1),this._partProxies.set(e-1,t)}bakeTransformIntoVertices(e){const t=this.splatsData;if(!t)return R.Error("Cannot bake transform into vertices if splatsData is not kept in RAM"),this;const s=e.m,n=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]),r=Math.sqrt(s[4]*s[4]+s[5]*s[5]+s[6]*s[6]),a=Math.sqrt(s[8]*s[8]+s[9]*s[9]+s[10]*s[10]);if(Math.abs(n-r)>.001||Math.abs(n-a)>.001)return R.Error("Gaussian Splatting bakeTransformIntoVertices does not support non-uniform scaling"),this;const i=new Uint8Array(t),o=new Float32Array(t),l=P.Vector3[0];let c;const h=P.Quaternion[0],u=P.Quaternion[1];for(e.decompose(l,u,l),c=0;c<this._vertexCount;c++){const t=8*c;I.TransformCoordinatesFromFloatsToRef(o[t],o[t+1],o[t+2],e,l),o[t]=l.x,o[t+1]=l.y,o[t+2]=l.z,o[t+3]*=n,o[t+4]*=n,o[t+5]*=n,h.set((i[32*c+28+1]-127.5)/127.5,(i[32*c+28+2]-127.5)/127.5,(i[32*c+28+3]-127.5)/127.5,(i[32*c+28+0]-127.5)/127.5),h.normalize(),this.scaling.x<0&&(h.x=-h.x,h.w=-h.w),this.scaling.y<0&&(h.y=-h.y,h.w=-h.w),this.scaling.z<0&&(h.z=-h.z,h.w=-h.w),u.multiplyToRef(h,h),h.normalize(),i[32*c+28+0]=Math.round(127.5*h.w+127.5),i[32*c+28+1]=Math.round(127.5*h.x+127.5),i[32*c+28+2]=Math.round(127.5*h.y+127.5),i[32*c+28+3]=Math.round(127.5*h.z+127.5)}return this.updateData(t,this.shData??void 0,{flipY:!1}),this}}Le._RowOutputLength=32,Le._SH_C0=.28209479177387814,Le._SplatBatchSize=327680,Le._PlyConversionBatchSize=32768,Le._BatchSize=16,Le._DefaultViewUpdateThreshold=1e-4,Le.ProgressiveUpdateAmount=0,Le._CreateWorker=function(e){let t,s,n,r,a,i;e.onmessage=o=>{if(o.data.positions)t=o.data.positions;else if(o.data.partMatrices)i=o.data.partMatrices;else if(void 0!==o.data.partIndices)a=o.data.partIndices;else{const l=o.data.cameraId,c=o.data.modelViewProjection,h=o.data.viewProjection,u=t.length/4+15&-16;if(!t||!c)throw new Error("positions or modelViewProjection matrix is not defined!");s=o.data.depthMix,n=new Uint32Array(s.buffer),r=new Float32Array(s.buffer);for(let e=0;e<u;e++)n[2*e]=e;const p=o.data.depthScale;if(i&&a){const e=i.map((e=>function(e,t){const s=new Float32Array(16);for(let n=0;n<4;n++)for(let r=0;r<4;r++)for(let a=0;a<4;a++)s[4*r+n]+=e[4*a+n]*t[4*r+a];return s}(h,e))),s=a.length;for(let n=0;n<u;n++){const i=e[a[Math.min(n,s-1)]];r[2*n+1]=1e4-(i[2]*t[4*n+0]+i[6]*t[4*n+1]+i[10]*t[4*n+2]+i[14])*p}}else{const e=c;for(let s=0;s<u;s++)r[2*s+1]=1e4-(e[2]*t[4*s+0]+e[6]*t[4*s+1]+e[10]*t[4*s+2]+e[14])*p}s.sort(),e.postMessage({depthMix:s,cameraId:l},[s.buffer])}}};class We{constructor(e,t,s,n,r){this.idx=0,this.color=new N(1,1,1,1),this.position=I.Zero(),this.rotation=I.Zero(),this.uv=new b(0,0),this.velocity=I.Zero(),this.pivot=I.Zero(),this.translateFromPivot=!1,this._pos=0,this._ind=0,this.groupId=0,this.idxInGroup=0,this._stillInvisible=!1,this._rotationMatrix=[1,0,0,0,1,0,0,0,1],this.parentId=null,this._globalPosition=I.Zero(),this.idx=e,this._group=t,this.groupId=s,this.idxInGroup=n,this._pcs=r}get size(){return this.size}set size(e){this.size=e}get quaternion(){return this.rotationQuaternion}set quaternion(e){this.rotationQuaternion=e}intersectsMesh(e,t){if(!e.hasBoundingInfo)return!1;if(!this._pcs.mesh)throw new Error("Point Cloud System doesnt contain the Mesh");if(t)return e.getBoundingInfo().boundingSphere.intersectsPoint(this.position.add(this._pcs.mesh.position));const s=e.getBoundingInfo().boundingBox,n=s.maximumWorld.x,r=s.minimumWorld.x,a=s.maximumWorld.y,i=s.minimumWorld.y,o=s.maximumWorld.z,l=s.minimumWorld.z,c=this.position.x+this._pcs.mesh.position.x,h=this.position.y+this._pcs.mesh.position.y,u=this.position.z+this._pcs.mesh.position.z;return r<=c&&c<=n&&i<=h&&h<=a&&l<=u&&u<=o}getRotationMatrix(e){let t;if(this.rotationQuaternion)t=this.rotationQuaternion;else{t=P.Quaternion[0];const e=this.rotation;F.RotationYawPitchRollToRef(e.y,e.x,e.z,t)}t.toRotationMatrix(e)}}class Ge{get groupID(){return this.groupId}set groupID(e){this.groupId=e}constructor(e,t){this.groupId=e,this._positionFunction=t}}!function(e){e[e.Color=2]="Color",e[e.UV=1]="UV",e[e.Random=0]="Random",e[e.Stated=3]="Stated"}(Be||(Be={}));class Xe{get positions(){return this._positions32}get colors(){return this._colors32}get uvs(){return this._uvs32}constructor(t,s,n,r){this.particles=new Array,this.nbParticles=0,this.counter=0,this.vars={},this._promises=[],this._positions=new Array,this._indices=new Array,this._normals=new Array,this._colors=new Array,this._uvs=new Array,this._updatable=!0,this._isVisibilityBoxLocked=!1,this._alwaysVisible=!1,this._groups=new Array,this._groupCounter=0,this._computeParticleColor=!0,this._computeParticleTexture=!0,this._computeParticleRotation=!0,this._computeBoundingBox=!1,this._isReady=!1,this.name=t,this._size=s,this._scene=n||e.LastCreatedScene,r&&void 0!==r.updatable?this._updatable=r.updatable:this._updatable=!0}async buildMeshAsync(e){return await Promise.all(this._promises),this._isReady=!0,await this._buildMeshAsync(e)}async _buildMeshAsync(e){0===this.nbParticles&&this.addPoints(1),this._positions32=new Float32Array(this._positions),this._uvs32=new Float32Array(this._uvs),this._colors32=new Float32Array(this._colors);const t=new C;t.set(this._positions32,g.PositionKind),this._uvs32.length>0&&t.set(this._uvs32,g.UVKind);let s=0;this._colors32.length>0&&(s=1,t.set(this._colors32,g.ColorKind));const n=new T(this.name,this._scene);t.applyToMesh(n,this._updatable),this.mesh=n,this._positions=null,this._uvs=null,this._colors=null,this._updatable||(this.particles.length=0);let r=e;return r||(r=new Q("point cloud material",this._scene),r.emissiveColor=new B(s,s,s),r.disableLighting=!0,r.pointsCloud=!0,r.pointSize=this._size),n.material=r,n}_addParticle(e,t,s,n){const r=new We(e,t,s,n,this);return this.particles.push(r),r}_randomUnitVector(e){e.position=new I(Math.random(),Math.random(),Math.random()),e.color=new N(1,1,1,1)}_getColorIndicesForCoord(e,t,s,n){const r=e._groupImageData,a=s*(4*n)+4*t,i=[a,a+1,a+2,a+3],o=i[1],l=i[2],c=i[3],h=r[i[0]],u=r[o],p=r[l],d=r[c];return new N(h/255,u/255,p/255,d)}_setPointsColorOrUV(e,t,s,n,r,a,i,o){o=o??0,s&&e.updateFacetData();const l=2*e.getBoundingInfo().boundingSphere.radius;let c=e.getVerticesData(g.PositionKind);const h=e.getIndices(),u=e.getVerticesData(g.UVKind+(o?o+1:"")),p=e.getVerticesData(g.ColorKind),d=I.Zero();e.computeWorldMatrix();const f=e.getWorldMatrix();if(!f.isIdentity()){c=c.slice(0);for(let e=0;e<c.length/3;e++)I.TransformCoordinatesFromFloatsToRef(c[3*e],c[3*e+1],c[3*e+2],f,d),c[3*e]=d.x,c[3*e+1]=d.y,c[3*e+2]=d.z}let _=0,m=0,x=0,v=0,S=0,y=0,w=0,T=0,M=0,E=0,C=0,A=0,D=0;const P=I.Zero(),R=I.Zero(),O=I.Zero(),z=I.Zero(),U=I.Zero();let H=0,k=0,V=0,F=0,G=0,X=0;const j=b.Zero(),Z=b.Zero(),Y=b.Zero(),q=b.Zero(),K=b.Zero();let Q=0,J=0,ee=0,te=0,se=0,ne=0,re=0,ae=0,ie=0,oe=0,le=0,ce=0;const he=L.Zero(),ue=L.Zero(),pe=L.Zero(),de=L.Zero(),fe=L.Zero();let _e,me,xe=0,ve=0;i=i||0;let ge=new L(0,0,0,0),Se=I.Zero(),ye=I.Zero(),we=I.Zero(),Te=0,Me=I.Zero(),Ee=0,Ie=0;const Ce=new $(I.Zero(),new I(1,0,0));let Ae,be=I.Zero();for(let o=0;o<h.length/3;o++){let d,f,g,b,L,$,De,Pe;m=h[3*o],x=h[3*o+1],v=h[3*o+2],S=c[3*m],y=c[3*m+1],w=c[3*m+2],T=c[3*x],M=c[3*x+1],E=c[3*x+2],C=c[3*v],A=c[3*v+1],D=c[3*v+2],P.set(S,y,w),R.set(T,M,E),O.set(C,A,D),R.subtractToRef(P,z),O.subtractToRef(R,U),u&&(H=u[2*m],k=u[2*m+1],V=u[2*x],F=u[2*x+1],G=u[2*v],X=u[2*v+1],j.set(H,k),Z.set(V,F),Y.set(G,X),Z.subtractToRef(j,q),Y.subtractToRef(Z,K)),p&&n&&(Q=p[4*m],J=p[4*m+1],ee=p[4*m+2],te=p[4*m+3],se=p[4*x],ne=p[4*x+1],re=p[4*x+2],ae=p[4*x+3],ie=p[4*v],oe=p[4*v+1],le=p[4*v+2],ce=p[4*v+3],he.set(Q,J,ee,te),ue.set(se,ne,re,ae),pe.set(ie,oe,le,ce),ue.subtractToRef(he,de),pe.subtractToRef(ue,fe));const Re=new B(0,0,0),Oe=new B(0,0,0);let ze,Ue;for(let c=0;c<t._groupDensity[o];c++)_=this.particles.length,this._addParticle(_,t,this._groupCounter,o+c),Ue=this.particles[_],xe=Math.sqrt(W(0,1)),ve=W(0,1),_e=P.add(z.scale(xe)).add(U.scale(xe*ve)),s&&(Se=e.getFacetNormal(o).normalize().scale(-1),ye=z.clone().normalize(),we=I.Cross(Se,ye),Te=W(0,2*Math.PI),Me=ye.scale(Math.cos(Te)).add(we.scale(Math.sin(Te))),Te=W(.1,Math.PI/2),be=Me.scale(Math.cos(Te)).add(Se.scale(Math.sin(Te))),Ce.origin=_e.add(be.scale(1e-5)),Ce.direction=be,Ce.length=l,Ae=Ce.intersectsMesh(e),Ae.hit&&(Ie=Ae.pickedPoint.subtract(_e).length(),Ee=W(0,1)*Ie,_e.addInPlace(be.scale(Ee)))),Ue.position=_e.clone(),this._positions.push(Ue.position.x,Ue.position.y,Ue.position.z),void 0!==n?u&&(me=j.add(q.scale(xe)).add(K.scale(xe*ve)),n?r&&null!==t._groupImageData?(d=t._groupImgWidth,f=t._groupImgHeight,ze=this._getColorIndicesForCoord(t,Math.round(me.x*d),Math.round(me.y*f),d),Ue.color=ze,this._colors.push(ze.r,ze.g,ze.b,ze.a)):p?(ge=he.add(de.scale(xe)).add(fe.scale(xe*ve)),Ue.color=new N(ge.x,ge.y,ge.z,ge.w),this._colors.push(ge.x,ge.y,ge.z,ge.w)):(ge=he.set(Math.random(),Math.random(),Math.random(),1),Ue.color=new N(ge.x,ge.y,ge.z,ge.w),this._colors.push(ge.x,ge.y,ge.z,ge.w)):(Ue.uv=me.clone(),this._uvs.push(Ue.uv.x,Ue.uv.y))):(a?(Re.set(a.r,a.g,a.b),g=W(-i,i),b=W(-i,i),Pe=Re.toHSV(),L=Pe.r,$=Pe.g+g,De=Pe.b+b,$<0&&($=0),$>1&&($=1),De<0&&(De=0),De>1&&(De=1),B.HSVtoRGBToRef(L,$,De,Oe),ge.set(Oe.r,Oe.g,Oe.b,1)):ge=he.set(Math.random(),Math.random(),Math.random(),1),Ue.color=new N(ge.x,ge.y,ge.z,ge.w),this._colors.push(ge.x,ge.y,ge.z,ge.w))}}_colorFromTexture(e,t,s){if(null===e.material)return R.Warn(e.name+"has no material."),t._groupImageData=null,void this._setPointsColorOrUV(e,t,s,!0,!1);const n=e.material.getActiveTextures();if(0===n.length)return R.Warn(e.name+"has no usable texture."),t._groupImageData=null,void this._setPointsColorOrUV(e,t,s,!0,!1);const r=e.clone();r.setEnabled(!1),this._promises.push(new Promise((e=>{G.WhenAllReady(n,(()=>{let a=t._textureNb;a<0&&(a=0),a>n.length-1&&(a=n.length-1);const i=()=>{t._groupImgWidth=n[a].getSize().width,t._groupImgHeight=n[a].getSize().height,this._setPointsColorOrUV(r,t,s,!0,!0,void 0,void 0,n[a].coordinatesIndex),r.dispose(),e()};t._groupImageData=null;const o=n[a].readPixels();o?o.then((e=>{t._groupImageData=e,i()})):i()}))})))}_calculateDensity(e,t,s){let n,r,a,i,o,l,c,h,u,p,d,f;const _=I.Zero(),m=I.Zero(),x=I.Zero(),v=I.Zero(),g=I.Zero(),S=I.Zero();let y;const w=[];let T=0;const M=s.length/3;for(let e=0;e<M;e++)n=s[3*e],r=s[3*e+1],a=s[3*e+2],i=t[3*n],o=t[3*n+1],l=t[3*n+2],c=t[3*r],h=t[3*r+1],u=t[3*r+2],p=t[3*a],d=t[3*a+1],f=t[3*a+2],_.set(i,o,l),m.set(c,h,u),x.set(p,d,f),m.subtractToRef(_,v),x.subtractToRef(m,g),I.CrossToRef(v,g,S),y=.5*S.length(),T+=y,w[e]=T;const E=new Array(M);let C=e;for(let e=M-1;e>0;e--){const t=w[e];if(0===t)E[e]=0;else{const s=(t-w[e-1])/t*C,n=Math.floor(s),r=s-n,a=n+Number(Math.random()<r);E[e]=a,C-=a}}return E[0]=C,E}addPoints(e,t=this._randomUnitVector){const s=new Ge(this._groupCounter,t);let n,r=this.nbParticles;for(let t=0;t<e;t++)n=this._addParticle(r,s,this._groupCounter,t),s&&s._positionFunction&&s._positionFunction(n,r,t),this._positions.push(n.position.x,n.position.y,n.position.z),n.color&&this._colors.push(n.color.r,n.color.g,n.color.b,n.color.a),n.uv&&this._uvs.push(n.uv.x,n.uv.y),r++;return this.nbParticles+=e,this._groupCounter++,this._groupCounter}addSurfacePoints(e,t,s,n,r){let a=s||0;(isNaN(a)||a<0||a>3)&&(a=0);const i=e.getVerticesData(g.PositionKind),o=e.getIndices();this._groups.push(this._groupCounter);const l=new Ge(this._groupCounter,null);switch(l._groupDensity=this._calculateDensity(t,i,o),2===a?l._textureNb=n||0:n=n||new N(1,1,1,1),a){case 2:this._colorFromTexture(e,l,!1);break;case 1:this._setPointsColorOrUV(e,l,!1,!1,!1);break;case 0:this._setPointsColorOrUV(e,l,!1);break;case 3:this._setPointsColorOrUV(e,l,!1,void 0,void 0,n,r)}return this.nbParticles+=t,this._groupCounter++,this._groupCounter-1}addVolumePoints(e,t,s,n,r){let a=s||0;(isNaN(a)||a<0||a>3)&&(a=0);const i=e.getVerticesData(g.PositionKind),o=e.getIndices();this._groups.push(this._groupCounter);const l=new Ge(this._groupCounter,null);switch(l._groupDensity=this._calculateDensity(t,i,o),2===a?l._textureNb=n||0:n=n||new N(1,1,1,1),a){case 2:this._colorFromTexture(e,l,!0);break;case 1:this._setPointsColorOrUV(e,l,!0,!1,!1);break;case 0:this._setPointsColorOrUV(e,l,!0);break;case 3:this._setPointsColorOrUV(e,l,!0,void 0,void 0,n,r)}return this.nbParticles+=t,this._groupCounter++,this._groupCounter-1}setParticles(e=0,t=this.nbParticles-1,s=!0){if(!this._updatable||!this._isReady)return this;this.beforeUpdateParticles(e,t,s);const n=P.Matrix[0],r=this.mesh,a=this._colors32,i=this._positions32,o=this._uvs32,l=P.Vector3,c=l[5].copyFromFloats(1,0,0),h=l[6].copyFromFloats(0,1,0),u=l[7].copyFromFloats(0,0,1),p=l[8].setAll(Number.MAX_VALUE),d=l[9].setAll(-Number.MAX_VALUE);A.IdentityToRef(n);let f=0;if(this.mesh?.isFacetDataEnabled&&(this._computeBoundingBox=!0),t=t>=this.nbParticles?this.nbParticles-1:t,this._computeBoundingBox&&(0!=e||t!=this.nbParticles-1)){const e=this.mesh?.getBoundingInfo();e&&(p.copyFrom(e.minimum),d.copyFrom(e.maximum))}f=0;let _=0,m=0,x=0;for(let s=e;s<=t;s++){const e=this.particles[s];f=e.idx,_=3*f,m=4*f,x=2*f,this.updateParticle(e);const t=e._rotationMatrix,r=e.position,a=e._globalPosition;this._computeParticleRotation&&e.getRotationMatrix(n);if(null!==e.parentId){const s=this.particles[e.parentId],i=s._rotationMatrix,o=s._globalPosition,l=r.x*i[1]+r.y*i[4]+r.z*i[7],c=r.x*i[0]+r.y*i[3]+r.z*i[6],h=r.x*i[2]+r.y*i[5]+r.z*i[8];if(a.x=o.x+c,a.y=o.y+l,a.z=o.z+h,this._computeParticleRotation){const e=n.m;t[0]=e[0]*i[0]+e[1]*i[3]+e[2]*i[6],t[1]=e[0]*i[1]+e[1]*i[4]+e[2]*i[7],t[2]=e[0]*i[2]+e[1]*i[5]+e[2]*i[8],t[3]=e[4]*i[0]+e[5]*i[3]+e[6]*i[6],t[4]=e[4]*i[1]+e[5]*i[4]+e[6]*i[7],t[5]=e[4]*i[2]+e[5]*i[5]+e[6]*i[8],t[6]=e[8]*i[0]+e[9]*i[3]+e[10]*i[6],t[7]=e[8]*i[1]+e[9]*i[4]+e[10]*i[7],t[8]=e[8]*i[2]+e[9]*i[5]+e[10]*i[8]}}else if(a.x=0,a.y=0,a.z=0,this._computeParticleRotation){const e=n.m;t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[4],t[4]=e[5],t[5]=e[6],t[6]=e[8],t[7]=e[9],t[8]=e[10]}const o=l[11];e.translateFromPivot?o.setAll(0):o.copyFrom(e.pivot);const v=l[0];v.copyFrom(e.position);const g=v.x-e.pivot.x,S=v.y-e.pivot.y,y=v.z-e.pivot.z;let w=g*t[0]+S*t[3]+y*t[6],T=g*t[1]+S*t[4]+y*t[7],M=g*t[2]+S*t[5]+y*t[8];w+=o.x,T+=o.y,M+=o.z;const E=i[_]=a.x+c.x*w+h.x*T+u.x*M,I=i[_+1]=a.y+c.y*w+h.y*T+u.y*M,C=i[_+2]=a.z+c.z*w+h.z*T+u.z*M;if(this._computeBoundingBox&&(p.minimizeInPlaceFromFloats(E,I,C),d.maximizeInPlaceFromFloats(E,I,C)),this._computeParticleColor&&e.color){const t=e.color,s=this._colors32;s[m]=t.r,s[m+1]=t.g,s[m+2]=t.b,s[m+3]=t.a}if(this._computeParticleTexture&&e.uv){const t=e.uv,s=this._uvs32;s[x]=t.x,s[x+1]=t.y}}return r&&(s&&(this._computeParticleColor&&r.updateVerticesData(g.ColorKind,a,!1,!1),this._computeParticleTexture&&r.updateVerticesData(g.UVKind,o,!1,!1),r.updateVerticesData(g.PositionKind,i,!1,!1)),this._computeBoundingBox&&(r.hasBoundingInfo?r.getBoundingInfo().reConstruct(p,d,r._worldMatrix):r.buildBoundingInfo(p,d,r._worldMatrix))),this.afterUpdateParticles(e,t,s),this}dispose(){this.mesh?.dispose(),this.vars=null,this._positions=null,this._indices=null,this._normals=null,this._uvs=null,this._colors=null,this._indices32=null,this._positions32=null,this._uvs32=null,this._colors32=null}refreshVisibleSize(){return this._isVisibilityBoxLocked||this.mesh?.refreshBoundingInfo(),this}setVisibilityBox(e){if(!this.mesh)return;const t=e/2;this.mesh.buildBoundingInfo(new I(-t,-t,-t),new I(t,t,t))}get isAlwaysVisible(){return this._alwaysVisible}set isAlwaysVisible(e){this.mesh&&(this._alwaysVisible=e,this.mesh.alwaysSelectAsActiveMesh=e)}set computeParticleRotation(e){this._computeParticleRotation=e}set computeParticleColor(e){this._computeParticleColor=e}set computeParticleTexture(e){this._computeParticleTexture=e}get computeParticleColor(){return this._computeParticleColor}get computeParticleTexture(){return this._computeParticleTexture}set computeBoundingBox(e){this._computeBoundingBox=e}get computeBoundingBox(){return this._computeBoundingBox}initParticles(){}recycleParticle(e){return e}updateParticle(e){return e}beforeUpdateParticles(e,t,s){}afterUpdateParticles(e,t,s){}}const je=.28209479177387814;async function Ze(e,t,s){const n=new Promise(((n,r)=>{const a=s.createCanvasImage();if(!a)throw new Error("Failed to create ImageBitmap");let i;if(a.onload=()=>{try{const e=s.createCanvas(a.width,a.height);if(!e)throw new Error("Failed to create canvas");const t=e.getContext("2d");if(!t)throw new Error("Failed to get 2D context");t.drawImage(a,0,0);const r=t.getImageData(0,0,e.width,e.height);n({bits:new Uint8Array(r.data.buffer),width:r.width})}catch(e){r(`Error loading image ${a.src} with exception: ${e}`)}},a.onerror=e=>{r(`Error loading image ${a.src} with exception: ${e}`)},a.crossOrigin="anonymous","string"==typeof e){if(!t)throw new Error("filename is required when using a URL");a.src=e+t}else{const t=new Blob([e],{type:"image/webp"});i=URL.createObjectURL(t),a.src=i}}));return await n}async function Ye(e,t,s){let n,r;if(e instanceof Map){r=e;const t=r.get("meta.json");if(!t)throw new Error("meta.json not found in files Map");n=JSON.parse((new TextDecoder).decode(t))}else n=e;const a=[...n.means.files,...n.scales.files,...n.quats.files,...n.sh0.files];n.shN&&a.push(...n.shN.files);const i=await Promise.all(a.map((async e=>{if(r&&r.has(e)){const t=r.get(e);return await Ze(t,e,s.getEngine())}return await Ze(t,e,s.getEngine())})));return await async function(e,t,s){const n=e.count?e.count:e.means.shape[0],r=new ArrayBuffer(32*n),a=new Float32Array(r),i=new Float32Array(r),o=new Uint8ClampedArray(r),l=new Uint8ClampedArray(r),c=e=>Math.sign(e)*(Math.exp(Math.abs(e))-1),h=t[0].bits,u=t[1].bits;if(!Array.isArray(e.means.mins)||!Array.isArray(e.means.maxs))throw new Error("Missing arrays in SOG data.");for(let t=0;t<n;t++){const s=4*t;for(let n=0;n<3;n++){const r=e.means.mins[n],i=e.means.maxs[n],o=u[s+n]<<8|h[s+n],l=Pe.Lerp(r,i,o/65535);a[8*t+n]=c(l)}}const p=t[2].bits;if(2===e.version){if(!e.scales.codebook)throw new Error("Missing codebook in SOG version 2 scales data.");for(let t=0;t<n;t++){const s=4*t;for(let n=0;n<3;n++){const r=e.scales.codebook[p[s+n]],a=Math.exp(r);i[8*t+3+n]=a}}}else{if(!Array.isArray(e.scales.mins)||!Array.isArray(e.scales.maxs))throw new Error("Missing arrays in SOG scales data.");for(let t=0;t<n;t++){const s=4*t;for(let n=0;n<3;n++){const r=p[s+n],a=Pe.Lerp(e.scales.mins[n],e.scales.maxs[n],r/255),o=Math.exp(a);i[8*t+3+n]=o}}}const d=t[4].bits;if(2===e.version){if(!e.sh0.codebook)throw new Error("Missing codebook in SOG version 2 sh0 data.");for(let t=0;t<n;t++){const s=4*t;for(let n=0;n<3;n++){const r=.5+e.sh0.codebook[d[s+n]]*je;o[32*t+24+n]=Math.max(0,Math.min(255,Math.round(255*r)))}o[32*t+24+3]=d[s+3]}}else{if(!Array.isArray(e.sh0.mins)||!Array.isArray(e.sh0.maxs))throw new Error("Missing arrays in SOG sh0 data.");for(let t=0;t<n;t++){const s=4*t;for(let n=0;n<4;n++){const r=e.sh0.mins[n],a=e.sh0.maxs[n],i=d[s+n],l=Pe.Lerp(r,a,i/255);let c;c=n<3?.5+l*je:1/(1+Math.exp(-l)),o[32*t+24+n]=Math.max(0,Math.min(255,Math.round(255*c)))}}}const f=e=>2*(e/255-.5)/Math.SQRT2,_=t[3].bits;for(let e=0;e<n;e++){const t=_[4*e+0],s=_[4*e+1],n=_[4*e+2],r=_[4*e+3],a=f(t),i=f(s),o=f(n),c=r-252,h=a*a+i*i+o*o,u=Math.sqrt(Math.max(0,1-h));let p;switch(c){case 0:p=[u,a,i,o];break;case 1:p=[a,u,i,o];break;case 2:p=[a,i,u,o];break;case 3:p=[a,i,o,u];break;default:throw new Error("Invalid quaternion mode")}l[32*e+28+0]=127.5*p[0]+127.5,l[32*e+28+1]=127.5*p[1]+127.5,l[32*e+28+2]=127.5*p[2]+127.5,l[32*e+28+3]=127.5*p[3]+127.5}if(e.shN){const a=[0,3,8,15],i=e.shN.bands?a[e.shN.bands]:e.shN.shape[1]/3,o=t[5].bits,l=t[6].bits,c=t[5].width,h=3*i,u=Math.ceil(h/16),p=[],d=s.getEngine().getCaps().maxTextureSize,f=Math.ceil(n/d);for(let e=0;e<u;e++){const e=new Uint8Array(f*d*4*4);p.push(e)}if(2===e.version){if(!e.shN.codebook)throw new Error("Missing codebook in SOG version 2 shN data.");for(let t=0;t<n;t++){const s=l[4*t+0]+(l[4*t+1]<<8),n=s%64*i,r=Math.floor(s/64);for(let s=0;s<i;s++)for(let a=0;a<3;a++){const i=3*s+a,l=Math.floor(i/16),h=p[l],u=i%16,d=16*t,f=127.5*e.shN.codebook[o[4*(n+s)+a+r*c*4]]+127.5;h[u+d]=Math.max(0,Math.min(255,f))}}}else for(let t=0;t<n;t++){const s=l[4*t+0]+(l[4*t+1]<<8),n=s%64*i,r=Math.floor(s/64),a=e.shN.mins,h=e.shN.maxs;for(let e=0;e<3;e++)for(let s=0;s<i/3;s++){const i=3*s+e,l=Math.floor(i/16),u=p[l],d=i%16,f=16*t,_=127.5*Pe.Lerp(a,h,o[4*(n+s)+e+r*c*4]/255)+127.5;u[d+f]=Math.max(0,Math.min(255,_))}}return await new Promise((e=>{e({mode:0,data:r,hasVertexColors:!1,sh:p})}))}return await new Promise((e=>{e({mode:0,data:r,hasVertexColors:!1})}))}(n,i,s)}class qe{constructor(e=qe._DefaultLoadingOptions){this.name=X.name,this._assetContainer=null,this.extensions=X.extensions,this._loadingOptions=e}createPlugin(e){return new qe(e[X.name])}async importMeshAsync(e,t,s,n,r,a){return await this._parseAsync(e,t,s,n).then((e=>({meshes:e,particleSystems:[],skeletons:[],animationGroups:[],transformNodes:[],geometries:[],lights:[],spriteManagers:[]})))}static _BuildPointCloud(e,t){if(!t.byteLength)return!1;const s=new Uint8Array(t),n=new Float32Array(t),r=s.length/32;return e.addPoints(r,(function(e,t){const r=n[8*t+0],a=n[8*t+1],i=n[8*t+2];e.position=new I(r,a,i);const o=s[32*t+24+0]/255,l=s[32*t+24+1]/255,c=s[32*t+24+2]/255;e.color=new N(o,l,c,1)})),!0}static _BuildMesh(e,t){const s=new T("PLYMesh",e),n=new Uint8Array(t.data),r=new Float32Array(t.data),a=n.length/32,i=[],o=new C;for(let e=0;e<a;e++){const t=r[8*e+0],s=r[8*e+1],n=r[8*e+2];i.push(t,s,n)}if(t.hasVertexColors){const e=new Float32Array(4*a);for(let t=0;t<a;t++){const s=n[32*t+24+0]/255,r=n[32*t+24+1]/255,a=n[32*t+24+2]/255;e[4*t+0]=s,e[4*t+1]=r,e[4*t+2]=a,e[4*t+3]=1}o.colors=e}return o.positions=i,o.indices=t.faces,o.applyToMesh(s),s}async _unzipWithFFlateAsync(e){let t=this._loadingOptions.fflate;t||(void 0===window.fflate&&await j.LoadScriptAsync(this._loadingOptions.deflateURL??"https://unpkg.com/fflate/umd/index.js"),t=window.fflate);const{unzipSync:s}=t,n=s(e),r=new Map;for(const[e,t]of Object.entries(n))r.set(e,t);return r}_parseAsync(e,t,s,n){const r=[],a=e=>{t._blockEntityCollection=!!this._assetContainer;const s=this._loadingOptions.gaussianSplattingMesh??new Le("GaussianSplatting",null,t,this._loadingOptions.keepInRam);s._parentContainer=this._assetContainer,r.push(s),s.updateData(e.data,e.sh,{flipY:!1}),s.scaling.y*=-1,s.computeWorldMatrix(!0),t._blockEntityCollection=!1};if("string"==typeof s){const e=JSON.parse(s);if(e&&e.means&&e.scales&&e.quats&&e.sh0)return new Promise((s=>{Ye(e,n,t).then((e=>{a(e),s(r)})).catch((()=>{throw new Error("Failed to parse SOG data.")}))}))}const i=s instanceof ArrayBuffer?new Uint8Array(s):s;if(80===i[0]&&75===i[1])return new Promise((e=>{this._unzipWithFFlateAsync(i).then((s=>{Ye(s,n,t).then((t=>{a(t),e(r)})).catch((()=>{throw new Error("Failed to parse SOG zip data.")}))}))}));const o=new ReadableStream({start(e){e.enqueue(new Uint8Array(s)),e.close()}}),l=new DecompressionStream("gzip"),c=o.pipeThrough(l);return new Promise((e=>{new Response(c).arrayBuffer().then((s=>{(function(e,t){const s=new Uint8Array(e),n=new Uint32Array(e.slice(0,12)),r=n[2],a=s[12],i=s[13],o=s[14],l=s[15],c=n[1];if(l||1347635022!=n[0]||2!=c&&3!=c)return new Promise((e=>{e({mode:3,data:h,hasVertexColors:!1})}));const h=new ArrayBuffer(32*r),u=1/(1<<i),p=new Int32Array(1),d=new Uint8Array(p.buffer),f=function(e,t){return d[0]=e[t+0],d[1]=e[t+1],d[2]=e[t+2],d[3]=128&e[t+2]?255:0,p[0]*u};let _=16;const m=new Float32Array(h),x=new Float32Array(h),v=new Uint8ClampedArray(h),g=new Uint8ClampedArray(h);for(let e=0;e<r;e++)m[8*e+0]=f(s,_+0),m[8*e+1]=f(s,_+3),m[8*e+2]=f(s,_+6),_+=9;for(let e=0;e<r;e++){for(let t=0;t<3;t++){const n=(s[_+r+3*e+t]-127.5)/38.25;v[32*e+24+t]=Pe.Clamp(255*(.5+.282*n),0,255)}v[32*e+24+3]=s[_+e]}_+=4*r;for(let e=0;e<r;e++)x[8*e+3+0]=Math.exp(s[_+0]/16-10),x[8*e+3+1]=Math.exp(s[_+1]/16-10),x[8*e+3+2]=Math.exp(s[_+2]/16-10),_+=3;if(c>=3){const e=Math.SQRT1_2;for(let t=0;t<r;t++){const n=[s[_+0],s[_+1],s[_+2],s[_+3]],r=n[0]+(n[1]<<8)+(n[2]<<16)+(n[3]<<24),a=511,i=[],o=r>>>30;let l=r,c=0;for(let t=3;t>=0;--t)if(t!==o){const s=l&a,n=l>>>9&1;l>>>=10,i[t]=e*(s/a),1===n&&(i[t]=-i[t]),c+=i[t]*i[t]}const h=1-c;i[o]=Math.sqrt(Math.max(h,0));const u=[3,0,1,2];for(let e=0;e<4;e++)g[32*t+28+e]=Math.round(127.5+127.5*i[u[e]]);_+=4}}else for(let e=0;e<r;e++){const t=s[_+0],n=s[_+1],r=s[_+2],a=t/127.5-1,i=n/127.5-1,o=r/127.5-1;g[32*e+28+1]=t,g[32*e+28+2]=n,g[32*e+28+3]=r;const l=1-(a*a+i*i+o*o);g[32*e+28+0]=127.5+127.5*Math.sqrt(l<0?0:l),_+=3}if(a){const e=3*((a+1)*(a+1)-1),n=Math.ceil(e/16);let i=_;const l=[],c=t.getEngine().getCaps().maxTextureSize,u=Math.ceil(r/c);for(let e=0;e<n;e++){const e=new Uint8Array(u*c*4*4);l.push(e)}for(let t=0;t<r;t++)for(let n=0;n<e;n++){const e=s[i++],r=Math.floor(n/16);l[r][n%16+16*t]=e}return new Promise((e=>{e({mode:0,data:h,hasVertexColors:!1,sh:l,trainedWithAntialiasing:!!o})}))}return new Promise((e=>{e({mode:0,data:h,hasVertexColors:!1,trainedWithAntialiasing:!!o})}))})(s,t,this._loadingOptions).then((s=>{t._blockEntityCollection=!!this._assetContainer;const n=this._loadingOptions.gaussianSplattingMesh??new Le("GaussianSplatting",null,t,this._loadingOptions.keepInRam);if(s.trainedWithAntialiasing){const e=n.material;e.kernelSize=.1,e.compensation=!0}n._parentContainer=this._assetContainer,r.push(n),n.updateData(s.data,s.sh,{flipY:!1}),this._loadingOptions.flipY||(n.scaling.y*=-1,n.computeWorldMatrix(!0)),t._blockEntityCollection=!1,this.applyAutoCameraLimits(s,t),e(r)}))})).catch((()=>{qe._ConvertPLYToSplat(s).then((async s=>{switch(t._blockEntityCollection=!!this._assetContainer,s.mode){case 0:{const e=this._loadingOptions.gaussianSplattingMesh??new Le("GaussianSplatting",null,t,this._loadingOptions.keepInRam);switch(e._parentContainer=this._assetContainer,r.push(e),e.updateData(s.data,s.sh,{flipY:!1}),e.scaling.y*=-1,"RightHanded"===s.chirality&&(e.scaling.y*=-1),s.upAxis){case"X":e.rotation=new I(0,0,Math.PI/2);break;case"Y":e.rotation=new I(0,0,Math.PI);break;case"Z":e.rotation=new I(-Math.PI/2,Math.PI,0)}e.computeWorldMatrix(!0)}break;case 1:{const e=new Xe("PointCloud",1,t);qe._BuildPointCloud(e,s.data)?await e.buildMeshAsync().then((e=>{r.push(e)})):e.dispose()}break;case 2:if(!s.faces)throw new Error("PLY mesh doesn't contain face informations.");r.push(qe._BuildMesh(t,s));break;default:throw new Error("Unsupported Splat mode")}t._blockEntityCollection=!1,this.applyAutoCameraLimits(s,t),e(r)}))}))}))}applyAutoCameraLimits(e,t){if(!this._loadingOptions.disableAutoCameraLimits&&(void 0!==e.safeOrbitCameraRadiusMin||void 0!==e.safeOrbitCameraElevationMinMax)&&"ArcRotateCamera"===t.activeCamera?.getClassName()){const s=t.activeCamera;e.safeOrbitCameraElevationMinMax&&(s.lowerBetaLimit=.5*Math.PI-e.safeOrbitCameraElevationMinMax[1],s.upperBetaLimit=.5*Math.PI-e.safeOrbitCameraElevationMinMax[0]),e.safeOrbitCameraRadiusMin&&(s.lowerRadiusLimit=e.safeOrbitCameraRadiusMin)}}loadAssetContainerAsync(e,t,s){const n=new K(e);return this._assetContainer=n,this.importMeshAsync(null,e,t,s).then((e=>{for(const t of e.meshes)n.meshes.push(t);return this._assetContainer=null,n})).catch((e=>{throw this._assetContainer=null,e}))}loadAsync(e,t,s){return this.importMeshAsync(null,e,t,s).then((()=>{}))}static _ConvertPLYToSplat(e){const t=new Uint8Array(e),s=(new TextDecoder).decode(t.slice(0,10240)),n="end_header\n",r=s.indexOf(n);if(r<0||!s)return new Promise((t=>{t({mode:0,data:e,rawSplat:!0})}));const a=parseInt(/element vertex (\d+)\n/.exec(s)[1]),i=/element face (\d+)\n/.exec(s);let o=0;i&&(o=parseInt(i[1]));const l=/element chunk (\d+)\n/.exec(s);let c=0;l&&(c=parseInt(l[1]));let h=0,u=0;const p={double:8,int:4,uint:4,float:4,short:2,ushort:2,uchar:1,list:0},d=0,f=1,_=2,m=3,x=4,v=5;let g=f;const S=[],y=s.slice(0,r).split("\n"),w={};for(const t of y)if(t.startsWith("property ")){const[,s,n]=t.split(" ");if(g==f)u+=p[s];else if(g==d)S.push({name:n,type:s,offset:h}),h+=p[s];else if(g==_)S.push({name:n,type:s,offset:h});else if(g==m){const t=new DataView(e,u,2*p.float);w.safeOrbitCameraElevationMinMax=[t.getFloat32(0,!0),t.getFloat32(4,!0)]}else if(g==x){const t=new DataView(e,u,p.float);w.safeOrbitCameraRadiusMin=t.getFloat32(0,!0)}else if(g==v){const t=new DataView(e,u,p.uchar);"up_axis"==n?w.upAxis=0==t.getUint8(0)?"X":1==t.getUint8(0)?"Y":"Z":"chirality"==n&&(w.chirality=0==t.getUint8(0)?"LeftHanded":"RightHanded")}p[s]||R.Warn(`Unsupported property type: ${s}.`)}else if(t.startsWith("element ")){const[,e]=t.split(" ");"chunk"==e?g=f:"vertex"==e?g=d:"sh"==e?g=_:"safe_orbit_camera_elevation_min_max_radians"==e?g=m:"safe_orbit_camera_radius_min"==e?g=x:"up_axis"!=e&&"chirality"!=e||(g=v)}const T=h,M=u;return Le.ConvertPLYWithSHToSplatAsync(e).then((async t=>{const s=new DataView(e,r+11);let n=M*c+T*a;const i=[];if(o)for(let e=0;e<o;e++){const e=s.getUint8(n);if(3==e){n+=1;for(let t=0;t<e;t++){const e=s.getUint32(n+4*(2-t),!0);i.push(e)}n+=12}}if(c)return await new Promise((e=>{e({mode:0,data:t.buffer,sh:t.sh,faces:i,hasVertexColors:!1,compressed:!0,rawSplat:!1})}));let l=0,h=0;const u=["x","y","z","scale_0","scale_1","scale_2","opacity","rot_0","rot_1","rot_2","rot_3"],p=["red","green","blue","f_dc_0","f_dc_1","f_dc_2"];for(let e=0;e<S.length;e++){const t=S[e];u.includes(t.name)&&l++,p.includes(t.name)&&h++}const d=l==u.length&&3==h,f=o?2:d?0:1;return await new Promise((e=>{e({...w,mode:f,data:t.buffer,sh:t.sh,faces:i,hasVertexColors:!!h,compressed:!1,rawSplat:!1})}))}))}}qe._DefaultLoadingOptions={keepInRam:!1,flipY:!1},Z(new qe);export{qe as SPLATFileLoader};
//# sourceMappingURL=splatFileLoader-j1r3EbNQ.esm.min.js.map
