import{q as t,ac as e,C as i,T as s,L as r,b as o,bD as n,_ as a,s as h,g as _,b1 as u,bA as T,Q as l,bS as d,bR as f}from"./index-C7lpuH7l.esm.min.js";import{R as c}from"./rawTexture-GcKYJ37d.esm.min.js";import{ArrayItem as m,GLTFLoader as p}from"./glTFLoader-Cy3hFpAv.esm.min.js";import"./bone-C8BOn9ne.esm.min.js";import"./skeleton-CpeT1KDV.esm.min.js";import"./assetContainer-BpinJ-Pb.esm.min.js";import"./objectModelMapping-EW6prSP3.esm.min.js";function x(e){const o=e.useDelayedTextureLoading;e.useDelayedTextureLoading=!1;const n=e._blockEntityCollection;e._blockEntityCollection=!1,e._ltcTextures={LTC1:c.CreateRGBATexture(null,64,64,e.getEngine(),!1,!1,i.TEXTURE_LINEAR_LINEAR,i.TEXTURETYPE_HALF_FLOAT,0,!1,!0),LTC2:c.CreateRGBATexture(null,64,64,e.getEngine(),!1,!1,i.TEXTURE_LINEAR_LINEAR,i.TEXTURETYPE_HALF_FLOAT,0,!1,!0)},e._blockEntityCollection=n,e._ltcTextures.LTC1.wrapU=s.CLAMP_ADDRESSMODE,e._ltcTextures.LTC1.wrapV=s.CLAMP_ADDRESSMODE,e._ltcTextures.LTC2.wrapU=s.CLAMP_ADDRESSMODE,e._ltcTextures.LTC2.wrapV=s.CLAMP_ADDRESSMODE,e.useDelayedTextureLoading=o,async function(){const e=new Uint16Array(16384),i=new Uint16Array(16384),s=await t.LoadFileAsync(t.GetAssetUrl("https://assets.babylonjs.com/core/areaLights/areaLightsLTC.bin")),r=new Uint16Array(s),o=r.length/8;for(let t=0;t<o;t++)e[4*t]=r[8*t],e[4*t+1]=r[8*t+1],e[4*t+2]=r[8*t+2],e[4*t+3]=r[8*t+3],i[4*t]=r[8*t+4],i[4*t+1]=r[8*t+5],i[4*t+2]=r[8*t+6],i[4*t+3]=r[8*t+7];return[e,i]}().then((t=>{if(e._ltcTextures){const i=e._ltcTextures?.LTC1;i.update(t[0]);const s=e._ltcTextures?.LTC2;s.update(t[1]),e.onDisposeObservable.addOnce((()=>{e._ltcTextures?.LTC1.dispose(),e._ltcTextures?.LTC2.dispose()}))}})).catch((t=>{r.Error(`Area Light fail to get LTC textures data. Error: ${t}`)}))}class g extends e{constructor(t,e,i,s){super(t,i,s),this.position=e,this._scene._ltcTextures||x(this._scene)}transferTexturesToEffect(t,e){return this._scene._ltcTextures&&(t.setTexture("areaLightsLTC1Sampler",this._scene._ltcTextures.LTC1),t.setTexture("areaLightsLTC2Sampler",this._scene._ltcTextures.LTC2)),this}prepareLightSpecificDefines(t,e){t["AREALIGHT"+e]=!0,t.AREALIGHTUSED=!0}_isReady(){return!!this._scene._ltcTextures&&(this._scene._ltcTextures.LTC1.isReady()&&this._scene._ltcTextures.LTC2.isReady())}}n.AddNodeConstructor("Light_Type_4",((t,e)=>()=>new L(t,o.Zero(),1,1,e)));class L extends g{get emissionTexture(){return this._emissionTextureTexture}set emissionTexture(t){this._emissionTextureTexture!==t&&(this._emissionTextureTexture=t,this._emissionTextureTexture&&(this._emissionTextureTexture.wrapU=i.TEXTURE_CLAMP_ADDRESSMODE,this._emissionTextureTexture.wrapV=i.TEXTURE_CLAMP_ADDRESSMODE),this._emissionTextureTexture&&L._IsTexture(this._emissionTextureTexture)&&this._emissionTextureTexture.onLoadObservable.addOnce((()=>{this._markMeshesAsLightDirty()})))}get width(){return this._width.x}set width(t){this._width.x=t}get height(){return this._height.y}set height(t){this._height.y=t}constructor(t,e,i,s,r,n){super(t,e,r,n),this._emissionTextureTexture=null,this._width=new o(i,0,0),this._height=new o(0,s,0),this._pointTransformedPosition=o.Zero(),this._pointTransformedWidth=o.Zero(),this._pointTransformedHeight=o.Zero()}getClassName(){return"RectAreaLight"}getTypeID(){return e.LIGHTTYPEID_RECT_AREALIGHT}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightWidth",4),this._uniformBuffer.addUniform("vLightHeight",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}_computeTransformedInformation(){return!(!this.parent||!this.parent.getWorldMatrix)&&(o.TransformCoordinatesToRef(this.position,this.parent.getWorldMatrix(),this._pointTransformedPosition),o.TransformNormalToRef(this._width,this.parent.getWorldMatrix(),this._pointTransformedWidth),o.TransformNormalToRef(this._height,this.parent.getWorldMatrix(),this._pointTransformedHeight),!0)}static _IsTexture(t){return void 0!==t.onLoadObservable}transferToEffect(t,e){const i=this._scene.floatingOriginOffset;return this._computeTransformedInformation()?(this._uniformBuffer.updateFloat4("vLightData",this._pointTransformedPosition.x-i.x,this._pointTransformedPosition.y-i.y,this._pointTransformedPosition.z-i.z,0,e),this._uniformBuffer.updateFloat4("vLightWidth",this._pointTransformedWidth.x/2,this._pointTransformedWidth.y/2,this._pointTransformedWidth.z/2,0,e),this._uniformBuffer.updateFloat4("vLightHeight",this._pointTransformedHeight.x/2,this._pointTransformedHeight.y/2,this._pointTransformedHeight.z/2,0,e)):(this._uniformBuffer.updateFloat4("vLightData",this.position.x-i.x,this.position.y-i.y,this.position.z-i.z,0,e),this._uniformBuffer.updateFloat4("vLightWidth",this._width.x/2,this._width.y/2,this._width.z/2,0,e),this._uniformBuffer.updateFloat4("vLightHeight",this._height.x/2,this._height.y/2,this._height.z/2,0,e)),this}transferTexturesToEffect(t,e){return super.transferTexturesToEffect(t,e),this._emissionTextureTexture&&this._emissionTextureTexture.isReady()&&t.setTexture("rectAreaLightEmissionTexture"+e,this._emissionTextureTexture),this}transferToNodeMaterialEffect(t,e){const i=this._scene.floatingOriginOffset;return this._computeTransformedInformation()?t.setFloat3(e,this._pointTransformedPosition.x-i.x,this._pointTransformedPosition.y-i.y,this._pointTransformedPosition.z-i.z):t.setFloat3(e,this.position.x-i.x,this.position.y-i.y,this.position.z-i.z),this}prepareLightSpecificDefines(t,e){super.prepareLightSpecificDefines(t,e),t["RECTAREALIGHTEMISSIONTEXTURE"+e]=!(!this._emissionTextureTexture||!this._emissionTextureTexture.isReady())}}a([h()],L.prototype,"width",null),a([h()],L.prototype,"height",null),_("BABYLON.RectAreaLight",L);const y="EXT_lights_area";class E{constructor(t){this.name=y,this._loader=t,this.enabled=this._loader.isExtensionUsed(y)}dispose(){this._loader=null,delete this._lights}onLoading(){const t=this._loader.gltf.extensions;if(t&&t[this.name]){const e=t[this.name];this._lights=e.lights,m.Assign(this._lights)}}loadNodeAsync(t,i,s){return p.LoadExtensionAsync(t,i,this.name,(async(r,n)=>(this._loader._allMaterialsDirtyRequired=!0,await this._loader.loadNodeAsync(t,i,(t=>{let i;const a=m.Get(r,this._lights,n.light),h=a.name||t.name;this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer;const _=void 0!==a.size?a.size:1;switch(a.type){case"rect":{const t=void 0!==a.rect?.aspect?a.rect.aspect*_:_,e=_;i=new L(h,o.Zero(),t,e,this._loader.babylonScene);break}case"disk":{const t=Math.sqrt(_*_*.25*Math.PI);i=new L(h,o.Zero(),t,t,this._loader.babylonScene);break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${r}: Invalid area light type (${a.type})`)}i._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,a._babylonLight=i,i.falloffType=e.FALLOFF_GLTF,i.diffuse=a.color?u.FromArray(a.color):u.White(),i.intensity=null==a.intensity?1:a.intensity;const d=new T(`${h}_orientation`,this._loader.babylonScene);d.rotationQuaternion=l.RotationAxis(o.Up(),Math.PI),d.parent=t,i.parent=d,this._loader._babylonLights.push(i),p.AddPointerMetadata(i,r),s(t)})))))}}d(y),f(y,!0,(t=>new E(t)));export{E as EXT_lights_area};
//# sourceMappingURL=EXT_lights_area-DllRW_iE.esm.min.js.map
