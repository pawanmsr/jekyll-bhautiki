{"version":3,"file":"flowGraphJsonPointerParserBlock-xkVM0_Ok.esm.min.js","sources":["../../../../../dev/core/dist/FlowGraph/flowGraphPathConverterComponent.js","../../../../../dev/core/dist/FlowGraph/Blocks/Data/Transformers/flowGraphJsonPointerParserBlock.js"],"sourcesContent":["import { FlowGraphInteger } from \"./CustomTypes/flowGraphInteger\";\nimport { RichTypeFlowGraphInteger } from \"./flowGraphRichTypes\";\nconst PathHasTemplatesRegex = new RegExp(/\\/\\{(\\w+)\\}(?=\\/|$)/g);\n/**\n * @experimental\n * A component that converts a path to an object accessor.\n */\nexport class FlowGraphPathConverterComponent {\n    constructor(path, ownerBlock) {\n        this.path = path;\n        this.ownerBlock = ownerBlock;\n        /**\n         * The templated inputs for the provided path.\n         */\n        this.templatedInputs = [];\n        let match = PathHasTemplatesRegex.exec(path);\n        const templateSet = new Set();\n        while (match) {\n            const [, matchGroup] = match;\n            if (templateSet.has(matchGroup)) {\n                throw new Error(\"Duplicate template variable detected.\");\n            }\n            templateSet.add(matchGroup);\n            this.templatedInputs.push(ownerBlock.registerDataInput(matchGroup, RichTypeFlowGraphInteger, new FlowGraphInteger(0)));\n            match = PathHasTemplatesRegex.exec(path);\n        }\n    }\n    /**\n     * Get the accessor for the path.\n     * @param pathConverter the path converter to use to convert the path to an object accessor.\n     * @param context the context to use.\n     * @returns the accessor for the path.\n     * @throws if the value for a templated input is invalid.\n     */\n    getAccessor(pathConverter, context) {\n        let finalPath = this.path;\n        for (const templatedInput of this.templatedInputs) {\n            const valueToReplace = templatedInput.getValue(context).value;\n            if (typeof valueToReplace !== \"number\" || valueToReplace < 0) {\n                throw new Error(\"Invalid value for templated input.\");\n            }\n            finalPath = finalPath.replace(`{${templatedInput.name}}`, valueToReplace.toString());\n        }\n        return pathConverter.convert(finalPath);\n    }\n}\n//# sourceMappingURL=flowGraphPathConverterComponent.js.map","import { FlowGraphPathConverterComponent } from \"core/FlowGraph/flowGraphPathConverterComponent\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { Vector3, Vector4 } from \"core/Maths/math.vector\";\nimport { Color3, Color4 } from \"core/Maths/math.color\";\nimport { FlowGraphCachedOperationBlock } from \"../flowGraphCachedOperationBlock\";\n/**\n * This block will take a JSON pointer and parse it to get the value from the JSON object.\n * The output is an object and a property name.\n * Optionally, the block can also output the value of the property. This is configurable.\n */\nexport class FlowGraphJsonPointerParserBlock extends FlowGraphCachedOperationBlock {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        super(RichTypeAny, config);\n        this.config = config;\n        this.object = this.registerDataOutput(\"object\", RichTypeAny);\n        this.propertyName = this.registerDataOutput(\"propertyName\", RichTypeAny);\n        this.setterFunction = this.registerDataOutput(\"setFunction\", RichTypeAny, this._setPropertyValue.bind(this));\n        this.getterFunction = this.registerDataOutput(\"getFunction\", RichTypeAny, this._getPropertyValue.bind(this));\n        this.generateAnimationsFunction = this.registerDataOutput(\"generateAnimationsFunction\", RichTypeAny, this._getInterpolationAnimationPropertyInfo.bind(this));\n        this.templateComponent = new FlowGraphPathConverterComponent(config.jsonPointer, this);\n    }\n    _doOperation(context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const value = accessorContainer.info.get(accessorContainer.object);\n        const object = accessorContainer.info.getTarget?.(accessorContainer.object);\n        const propertyName = accessorContainer.info.getPropertyName?.[0](accessorContainer.object);\n        if (!object) {\n            throw new Error(\"Object is undefined\");\n        }\n        else {\n            this.object.setValue(object, context);\n            if (propertyName) {\n                this.propertyName.setValue(propertyName, context);\n            }\n        }\n        return value;\n    }\n    _setPropertyValue(_target, _propertyName, value, context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        if (type.startsWith(\"Color\")) {\n            value = ToColor(value, type);\n        }\n        accessorContainer.info.set?.(value, accessorContainer.object);\n    }\n    _getPropertyValue(_target, _propertyName, context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        const type = accessorContainer.info.type;\n        const value = accessorContainer.info.get(accessorContainer.object);\n        if (type.startsWith(\"Color\")) {\n            return FromColor(value);\n        }\n        return value;\n    }\n    _getInterpolationAnimationPropertyInfo(_target, _propertyName, context) {\n        const accessorContainer = this.templateComponent.getAccessor(this.config.pathConverter, context);\n        return (keys, fps, animationType, easingFunction) => {\n            const animations = [];\n            // make sure keys are of the right type (in case of float3 color/vector)\n            const type = accessorContainer.info.type;\n            if (type.startsWith(\"Color\")) {\n                keys = keys.map((key) => {\n                    return {\n                        frame: key.frame,\n                        value: ToColor(key.value, type),\n                    };\n                });\n            }\n            accessorContainer.info.interpolation?.forEach((info, index) => {\n                const name = accessorContainer.info.getPropertyName?.[index](accessorContainer.object) || \"Animation-interpolation-\" + index;\n                // generate the keys based on interpolation info\n                let newKeys = keys;\n                if (animationType !== info.type) {\n                    // convert the keys to the right type\n                    newKeys = keys.map((key) => {\n                        return {\n                            frame: key.frame,\n                            value: info.getValue(undefined, key.value.asArray ? key.value.asArray() : [key.value], 0, 1),\n                        };\n                    });\n                }\n                const animationData = info.buildAnimations(accessorContainer.object, name, 60, newKeys);\n                for (const animation of animationData) {\n                    if (easingFunction) {\n                        animation.babylonAnimation.setEasingFunction(easingFunction);\n                    }\n                    animations.push(animation.babylonAnimation);\n                }\n            });\n            return animations;\n        };\n    }\n    /**\n     * Gets the class name of this block\n     * @returns the class name\n     */\n    getClassName() {\n        return \"FlowGraphJsonPointerParserBlock\" /* FlowGraphBlockNames.JsonPointerParser */;\n    }\n}\nfunction ToColor(value, expectedValue) {\n    if (value.getClassName().startsWith(\"Color\")) {\n        return value;\n    }\n    if (expectedValue === \"Color3\") {\n        return new Color3(value.x, value.y, value.z);\n    }\n    else if (expectedValue === \"Color4\") {\n        return new Color4(value.x, value.y, value.z, value.w);\n    }\n    return value;\n}\nfunction FromColor(value) {\n    if (value instanceof Color3) {\n        return new Vector3(value.r, value.g, value.b);\n    }\n    else if (value instanceof Color4) {\n        return new Vector4(value.r, value.g, value.b, value.a);\n    }\n    throw new Error(\"Invalid color type\");\n}\nRegisterClass(\"FlowGraphJsonPointerParserBlock\" /* FlowGraphBlockNames.JsonPointerParser */, FlowGraphJsonPointerParserBlock);\n//# sourceMappingURL=flowGraphJsonPointerParserBlock.js.map"],"names":["PathHasTemplatesRegex","RegExp","FlowGraphPathConverterComponent","constructor","path","ownerBlock","this","templatedInputs","match","exec","templateSet","Set","matchGroup","has","Error","add","push","registerDataInput","RichTypeFlowGraphInteger","FlowGraphInteger","getAccessor","pathConverter","context","finalPath","templatedInput","valueToReplace","getValue","value","replace","name","toString","convert","FlowGraphJsonPointerParserBlock","FlowGraphCachedOperationBlock","config","super","RichTypeAny","object","registerDataOutput","propertyName","setterFunction","_setPropertyValue","bind","getterFunction","_getPropertyValue","generateAnimationsFunction","_getInterpolationAnimationPropertyInfo","templateComponent","jsonPointer","_doOperation","accessorContainer","info","get","getTarget","getPropertyName","setValue","_target","_propertyName","type","startsWith","ToColor","set","Color3","Vector3","r","g","b","Color4","Vector4","a","FromColor","keys","fps","animationType","easingFunction","animations","map","key","frame","interpolation","forEach","index","newKeys","undefined","asArray","animationData","buildAnimations","animation","babylonAnimation","setEasingFunction","getClassName","expectedValue","x","y","z","w","RegisterClass"],"mappings":"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"}