{"version":3,"file":"flowGraphSetDelayBlock-DO4QYWct.esm.min.js","sources":["../../../../../dev/core/dist/Misc/timer.js","../../../../../dev/core/dist/FlowGraph/Blocks/Execution/ControlFlow/flowGraphSetDelayBlock.js"],"sourcesContent":["import { Observable } from \"../Misc/observable\";\n/**\n * The current state of the timer\n */\nexport var TimerState;\n(function (TimerState) {\n    /**\n     * Timer initialized, not yet started\n     */\n    TimerState[TimerState[\"INIT\"] = 0] = \"INIT\";\n    /**\n     * Timer started and counting\n     */\n    TimerState[TimerState[\"STARTED\"] = 1] = \"STARTED\";\n    /**\n     * Timer ended (whether aborted or time reached)\n     */\n    TimerState[TimerState[\"ENDED\"] = 2] = \"ENDED\";\n})(TimerState || (TimerState = {}));\n/**\n * A simple version of the timer. Will take options and start the timer immediately after calling it\n *\n * @param options options with which to initialize this timer\n * @returns an observer that can be used to stop the timer\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport function setAndStartTimer(options) {\n    let timer = 0;\n    const startTime = Date.now();\n    options.observableParameters = options.observableParameters ?? {};\n    const observer = options.contextObservable.add((payload) => {\n        const now = Date.now();\n        timer = now - startTime;\n        const data = {\n            startTime,\n            currentTime: now,\n            deltaTime: timer,\n            completeRate: timer / options.timeout,\n            payload,\n        };\n        options.onTick && options.onTick(data);\n        if (options.breakCondition && options.breakCondition()) {\n            options.contextObservable.remove(observer);\n            options.onAborted && options.onAborted(data);\n        }\n        if (timer >= options.timeout) {\n            options.contextObservable.remove(observer);\n            options.onEnded && options.onEnded(data);\n        }\n    }, options.observableParameters.mask, options.observableParameters.insertFirst, options.observableParameters.scope);\n    return observer;\n}\n/**\n * An advanced implementation of a timer class\n */\nexport class AdvancedTimer {\n    /**\n     * Will construct a new advanced timer based on the options provided. Timer will not start until start() is called.\n     * @param options construction options for this advanced timer\n     */\n    constructor(options) {\n        /**\n         * Will notify each time the timer calculates the remaining time\n         */\n        this.onEachCountObservable = new Observable();\n        /**\n         * Will trigger when the timer was aborted due to the break condition\n         */\n        this.onTimerAbortedObservable = new Observable();\n        /**\n         * Will trigger when the timer ended successfully\n         */\n        this.onTimerEndedObservable = new Observable();\n        /**\n         * Will trigger when the timer state has changed\n         */\n        this.onStateChangedObservable = new Observable();\n        this._observer = null;\n        this._breakOnNextTick = false;\n        this._tick = (payload) => {\n            const now = Date.now();\n            this._timer = now - this._startTime;\n            const data = {\n                startTime: this._startTime,\n                currentTime: now,\n                deltaTime: this._timer,\n                completeRate: this._timer / this._timeToEnd,\n                payload,\n            };\n            const shouldBreak = this._breakOnNextTick || this._breakCondition(data);\n            if (shouldBreak || this._timer >= this._timeToEnd) {\n                this._stop(data, shouldBreak);\n            }\n            else {\n                this.onEachCountObservable.notifyObservers(data);\n            }\n        };\n        this._setState(0 /* TimerState.INIT */);\n        this._contextObservable = options.contextObservable;\n        this._observableParameters = options.observableParameters ?? {};\n        this._breakCondition = options.breakCondition ?? (() => false);\n        this._timeToEnd = options.timeout;\n        if (options.onEnded) {\n            this.onTimerEndedObservable.add(options.onEnded);\n        }\n        if (options.onTick) {\n            this.onEachCountObservable.add(options.onTick);\n        }\n        if (options.onAborted) {\n            this.onTimerAbortedObservable.add(options.onAborted);\n        }\n    }\n    /**\n     * set a breaking condition for this timer. Default is to never break during count\n     * @param predicate the new break condition. Returns true to break, false otherwise\n     */\n    set breakCondition(predicate) {\n        this._breakCondition = predicate;\n    }\n    /**\n     * Reset ALL associated observables in this advanced timer\n     */\n    clearObservables() {\n        this.onEachCountObservable.clear();\n        this.onTimerAbortedObservable.clear();\n        this.onTimerEndedObservable.clear();\n        this.onStateChangedObservable.clear();\n    }\n    /**\n     * Will start a new iteration of this timer. Only one instance of this timer can run at a time.\n     *\n     * @param timeToEnd how much time to measure until timer ended\n     */\n    start(timeToEnd = this._timeToEnd) {\n        if (this._state === 1 /* TimerState.STARTED */) {\n            throw new Error(\"Timer already started. Please stop it before starting again\");\n        }\n        this._timeToEnd = timeToEnd;\n        this._startTime = Date.now();\n        this._timer = 0;\n        this._observer = this._contextObservable.add(this._tick, this._observableParameters.mask, this._observableParameters.insertFirst, this._observableParameters.scope);\n        this._setState(1 /* TimerState.STARTED */);\n    }\n    /**\n     * Will force a stop on the next tick.\n     */\n    stop() {\n        if (this._state !== 1 /* TimerState.STARTED */) {\n            return;\n        }\n        this._breakOnNextTick = true;\n    }\n    /**\n     * Dispose this timer, clearing all resources\n     */\n    dispose() {\n        if (this._observer) {\n            this._contextObservable.remove(this._observer);\n        }\n        this.clearObservables();\n    }\n    _setState(newState) {\n        this._state = newState;\n        this.onStateChangedObservable.notifyObservers(this._state);\n    }\n    _stop(data, aborted = false) {\n        this._contextObservable.remove(this._observer);\n        this._setState(2 /* TimerState.ENDED */);\n        if (aborted) {\n            this.onTimerAbortedObservable.notifyObservers(data);\n        }\n        else {\n            this.onTimerEndedObservable.notifyObservers(data);\n        }\n    }\n}\n//# sourceMappingURL=timer.js.map","import { FlowGraphAsyncExecutionBlock } from \"../../../flowGraphAsyncExecutionBlock\";\nimport { RichTypeFlowGraphInteger, RichTypeNumber } from \"../../../flowGraphRichTypes\";\nimport { AdvancedTimer } from \"../../../../Misc/timer\";\nimport { Logger } from \"../../../../Misc/logger\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\nimport { FlowGraphInteger } from \"core/FlowGraph/CustomTypes/flowGraphInteger\";\n/**\n * Block that sets a delay in seconds before activating the output signal.\n */\nexport class FlowGraphSetDelayBlock extends FlowGraphAsyncExecutionBlock {\n    constructor(config) {\n        super(config);\n        this.cancel = this._registerSignalInput(\"cancel\");\n        this.duration = this.registerDataInput(\"duration\", RichTypeNumber);\n        this.lastDelayIndex = this.registerDataOutput(\"lastDelayIndex\", RichTypeFlowGraphInteger, new FlowGraphInteger(-1));\n    }\n    _preparePendingTasks(context) {\n        const duration = this.duration.getValue(context);\n        if (duration < 0 || isNaN(duration) || !isFinite(duration)) {\n            return this._reportError(context, \"Invalid duration in SetDelay block\");\n        }\n        // active delays are global to the context\n        const activeDelays = context._getGlobalContextVariable(\"activeDelays\", 0);\n        if (activeDelays >= FlowGraphSetDelayBlock.MaxParallelDelayCount) {\n            return this._reportError(context, \"Max parallel delays reached\");\n        }\n        // get the last global delay index\n        const lastDelayIndex = context._getGlobalContextVariable(\"lastDelayIndex\", -1);\n        // these are block-specific and not global\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        const scene = context.configuration.scene;\n        const timer = new AdvancedTimer({\n            timeout: duration * 1000, // duration is in seconds\n            contextObservable: scene.onBeforeRenderObservable,\n            onEnded: () => this._onEnded(timer, context),\n        });\n        timer.start();\n        const newIndex = lastDelayIndex + 1;\n        this.lastDelayIndex.setValue(new FlowGraphInteger(newIndex), context);\n        context._setGlobalContextVariable(\"lastDelayIndex\", newIndex);\n        timers[newIndex] = timer;\n        context._setExecutionVariable(this, \"pendingDelays\", timers);\n        this._updateGlobalTimers(context);\n    }\n    _cancelPendingTasks(context) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        for (const timer of timers) {\n            timer?.dispose();\n        }\n        context._deleteExecutionVariable(this, \"pendingDelays\");\n        this.lastDelayIndex.setValue(new FlowGraphInteger(-1), context);\n        this._updateGlobalTimers(context);\n    }\n    _execute(context, callingSignal) {\n        if (callingSignal === this.cancel) {\n            this._cancelPendingTasks(context);\n            return;\n        }\n        else {\n            this._preparePendingTasks(context);\n            this.out._activateSignal(context);\n        }\n    }\n    getClassName() {\n        return \"FlowGraphSetDelayBlock\" /* FlowGraphBlockNames.SetDelay */;\n    }\n    _onEnded(timer, context) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        const index = timers.indexOf(timer);\n        if (index !== -1) {\n            timers.splice(index, 1);\n        }\n        else {\n            Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n        }\n        context._removePendingBlock(this);\n        this.done._activateSignal(context);\n        this._updateGlobalTimers(context);\n    }\n    _updateGlobalTimers(context) {\n        const timers = context._getExecutionVariable(this, \"pendingDelays\", []);\n        const globalTimers = context._getGlobalContextVariable(\"pendingDelays\", []);\n        // there should NEVER be the same index in the global and local timers, unless they are equal\n        for (let i = 0; i < timers.length; i++) {\n            if (!timers[i]) {\n                continue;\n            }\n            const timer = timers[i];\n            if (globalTimers[i] && globalTimers[i] !== timer) {\n                Logger.Warn(\"FlowGraphTimerBlock: Timer ended but was not found in the running timers list\");\n            }\n            else {\n                globalTimers[i] = timer;\n            }\n        }\n        context._setGlobalContextVariable(\"pendingDelays\", globalTimers);\n    }\n}\n/**\n * The maximum number of parallel delays that can be set per node.\n */\nFlowGraphSetDelayBlock.MaxParallelDelayCount = 100;\nRegisterClass(\"FlowGraphSetDelayBlock\" /* FlowGraphBlockNames.SetDelay */, FlowGraphSetDelayBlock);\n//# sourceMappingURL=flowGraphSetDelayBlock.js.map"],"names":["TimerState","AdvancedTimer","constructor","options","this","onEachCountObservable","Observable","onTimerAbortedObservable","onTimerEndedObservable","onStateChangedObservable","_observer","_breakOnNextTick","_tick","payload","now","Date","_timer","_startTime","data","startTime","currentTime","deltaTime","completeRate","_timeToEnd","shouldBreak","_breakCondition","_stop","notifyObservers","_setState","_contextObservable","contextObservable","_observableParameters","observableParameters","breakCondition","timeout","onEnded","add","onTick","onAborted","predicate","clearObservables","clear","start","timeToEnd","_state","Error","mask","insertFirst","scope","stop","dispose","remove","newState","aborted","FlowGraphSetDelayBlock","FlowGraphAsyncExecutionBlock","config","super","cancel","_registerSignalInput","duration","registerDataInput","RichTypeNumber","lastDelayIndex","registerDataOutput","RichTypeFlowGraphInteger","FlowGraphInteger","_preparePendingTasks","context","getValue","isNaN","isFinite","_reportError","_getGlobalContextVariable","MaxParallelDelayCount","timers","_getExecutionVariable","scene","configuration","timer","onBeforeRenderObservable","_onEnded","newIndex","setValue","_setGlobalContextVariable","_setExecutionVariable","_updateGlobalTimers","_cancelPendingTasks","_deleteExecutionVariable","_execute","callingSignal","out","_activateSignal","getClassName","index","indexOf","splice","Logger","Warn","_removePendingBlock","done","globalTimers","i","length","RegisterClass"],"mappings":"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"}