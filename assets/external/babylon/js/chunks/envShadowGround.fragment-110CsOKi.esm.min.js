import{H as e}from"./index-C7lpuH7l.esm.min.js";const a="envShadowGroundPixelShader",t="var shadowTextureSampler: sampler;var shadowTexture : texture_2d<f32>;uniform shadowOpacity : f32;uniform renderTargetSize: vec2<f32>;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let uvBasedOpacity=1.0-pow(clamp(length(input.vUV*vec2<f32>(2.0)-vec2<f32>(1.0)),0.0,1.0),2.0);let screenUv=fragmentInputs.position.xy/uniforms.renderTargetSize;let shadowValue=textureSampleLevel(shadowTexture,shadowTextureSampler,screenUv,0.0).rrr;let totalOpacity=uniforms.shadowOpacity*uvBasedOpacity;let finalShadowValue=mix(vec3<f32>(1.0),shadowValue,totalOpacity);let invertedShadowValue=vec3(1.0)-shadowValue;fragmentOutputs.color=vec4f(finalShadowValue,invertedShadowValue.r*totalOpacity);}";e.ShadersStoreWGSL[a]||(e.ShadersStoreWGSL[a]=t);const r={name:a,shader:t};export{r as envShadowGroundPixelShaderWGSL};
//# sourceMappingURL=envShadowGround.fragment-110CsOKi.esm.min.js.map
