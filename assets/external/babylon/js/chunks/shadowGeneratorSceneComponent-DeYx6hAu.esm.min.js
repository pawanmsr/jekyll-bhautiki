import{ShadowGenerator as e}from"./shadowGenerator-DqUBkK9X.esm.min.js";import{H as t,C as s,T as i,h as n,y as r,J as a,a3 as o,N as h,W as d,X as c,a0 as u,a as l,a4 as _,Z as f,$ as m,j as p,E as g,c as x,O as M,a5 as S,f as C,b as E,p as v,L as R,e as T,a6 as A,a7 as b,a8 as D,k as w}from"./index-C7lpuH7l.esm.min.js";import"./clipPlaneFragment-tBT19CLp.esm.min.js";import"./packingFunctions-C4n6ROKL.esm.min.js";import"./bakedVertexAnimation-C1n5K-7S.esm.min.js";import"./morphTargetsVertex-DHnQTyrj.esm.min.js";import"./clipPlaneVertex-C37mL-i1.esm.min.js";import"./instancesDeclaration-C61GJtkH.esm.min.js";import"./pointCloudVertex-CzXSiWdh.esm.min.js";const P="depthPixelShader",F="#ifdef ALPHATEST\nvarying vec2 vUV;uniform sampler2D diffuseSampler;\n#endif\n#include<clipPlaneFragmentDeclaration>\nvarying float vDepthMetric;\n#ifdef PACKED\n#include<packingFunctions>\n#endif\n#ifdef STORE_CAMERASPACE_Z\nvarying vec4 vViewPos;\n#endif\n#define CUSTOM_FRAGMENT_DEFINITIONS\nvoid main(void)\n{\n#include<clipPlaneFragment>\n#ifdef ALPHATEST\nif (texture2D(diffuseSampler,vUV).a<0.4)\ndiscard;\n#endif\n#ifdef STORE_CAMERASPACE_Z\n#ifdef PACKED\ngl_FragColor=pack(vViewPos.z);\n#else\ngl_FragColor=vec4(vViewPos.z,0.0,0.0,1.0);\n#endif\n#else\n#ifdef NONLINEARDEPTH\n#ifdef PACKED\ngl_FragColor=pack(gl_FragCoord.z);\n#else\ngl_FragColor=vec4(gl_FragCoord.z,0.0,0.0,0.0);\n#endif\n#else\n#ifdef PACKED\ngl_FragColor=pack(vDepthMetric);\n#else\ngl_FragColor=vec4(vDepthMetric,0.0,0.0,1.0);\n#endif\n#endif\n#endif\n}";t.ShadersStore[P]||(t.ShadersStore[P]=F);const I={name:P,shader:F};var z=Object.freeze({__proto__:null,depthPixelShader:I});const B="pointCloudVertexDeclaration";t.IncludesShadersStore[B]||(t.IncludesShadersStore[B]="#ifdef POINTSIZE\nuniform float pointSize;\n#endif\n");const L="depthVertexShader",O="attribute vec3 position;\n#include<bonesDeclaration>\n#include<bakedVertexAnimationDeclaration>\n#include<morphTargetsVertexGlobalDeclaration>\n#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]\n#include<clipPlaneVertexDeclaration>\n#include<instancesDeclaration>\nuniform mat4 viewProjection;uniform vec2 depthValues;\n#if defined(ALPHATEST) || defined(NEED_UV)\nvarying vec2 vUV;uniform mat4 diffuseMatrix;\n#ifdef UV1\nattribute vec2 uv;\n#endif\n#ifdef UV2\nattribute vec2 uv2;\n#endif\n#endif\n#ifdef STORE_CAMERASPACE_Z\nuniform mat4 view;varying vec4 vViewPos;\n#endif\n#include<pointCloudVertexDeclaration>\nvarying float vDepthMetric;\n#define CUSTOM_VERTEX_DEFINITIONS\nvoid main(void)\n{vec3 positionUpdated=position;\n#ifdef UV1\nvec2 uvUpdated=uv;\n#endif\n#ifdef UV2\nvec2 uv2Updated=uv2;\n#endif\n#include<morphTargetsVertexGlobal>\n#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]\n#include<instancesVertex>\n#include<bonesVertex>\n#include<bakedVertexAnimation>\nvec4 worldPos=finalWorld*vec4(positionUpdated,1.0);\n#include<clipPlaneVertex>\ngl_Position=viewProjection*worldPos;\n#ifdef STORE_CAMERASPACE_Z\nvViewPos=view*worldPos;\n#else\n#ifdef USE_REVERSE_DEPTHBUFFER\nvDepthMetric=((-gl_Position.z+depthValues.x)/(depthValues.y));\n#else\nvDepthMetric=((gl_Position.z+depthValues.x)/(depthValues.y));\n#endif\n#endif\n#if defined(ALPHATEST) || defined(BASIC_RENDER)\n#ifdef UV1\nvUV=vec2(diffuseMatrix*vec4(uvUpdated,1.0,0.0));\n#endif\n#ifdef UV2\nvUV=vec2(diffuseMatrix*vec4(uv2Updated,1.0,0.0));\n#endif\n#endif\n#include<pointCloudVertex>\n}\n";t.ShadersStore[L]||(t.ShadersStore[L]=O);const U={name:L,shader:O};var N,y=Object.freeze({__proto__:null,depthVertexShader:U});class V{get shaderLanguage(){return this._shaderLanguage}get alphaBlendedDepth(){return this._alphaBlendedDepth}set alphaBlendedDepth(e){this._alphaBlendedDepth!==e&&(this._alphaBlendedDepth=e,this._alphaBlendedDepthMaterialCache.clear())}setMaterialForRendering(e,t){this._depthMap.setMaterialForRendering(e,t)}constructor(e,t=s.TEXTURETYPE_FLOAT,a=null,o=!1,h=i.TRILINEAR_SAMPLINGMODE,d=!1,c,u){this._shaderLanguage=0,this.enabled=!0,this.forceDepthWriteTransparentMeshes=!1,this._alphaBlendedDepth=!1,this._alphaBlendedDepthMaterialCache=new Map,this.useOnlyInActiveCamera=!1,this.reverseCulling=!1,this._shadersLoaded=!1,this._scene=e,this._storeNonLinearDepth=o,this._storeCameraSpaceZ=d,this.isPacked=t===s.TEXTURETYPE_UNSIGNED_BYTE,this.isPacked?this.clearColor=new n(1,1,1,1):this.clearColor=new n(d?0:1,0,0,1),this._initShaderSourceAsync(),V._SceneComponentInitialization(this._scene);const p=e.getEngine();this._camera=a,h!==i.NEAREST_SAMPLINGMODE&&(t!==s.TEXTURETYPE_FLOAT||p._caps.textureFloatLinearFiltering||(h=i.NEAREST_SAMPLINGMODE),t!==s.TEXTURETYPE_HALF_FLOAT||p._caps.textureHalfFloatLinearFiltering||(h=i.NEAREST_SAMPLINGMODE));const g=this.isPacked||!p._features.supportExtendedTextureFormats?s.TEXTUREFORMAT_RGBA:s.TEXTUREFORMAT_R;this._depthMap=u??new r(c??"DepthRenderer",{width:p.getRenderWidth(),height:p.getRenderHeight()},this._scene,!1,!0,t,!1,h,void 0,void 0,void 0,g),this._depthMap.wrapU=i.CLAMP_ADDRESSMODE,this._depthMap.wrapV=i.CLAMP_ADDRESSMODE,this._depthMap.refreshRate=1,this._depthMap.renderParticles=!1,this._depthMap.renderList=null,this._depthMap.noPrePassRenderer=!0,this._depthMap.activeCamera=this._camera,this._depthMap.ignoreCameraViewport=!0,this._depthMap.useCameraPostProcesses=!1,this._depthMap.onClearObservable.add((e=>{e.clear(this.clearColor,!0,!0,!0)})),this._depthMap.onBeforeBindObservable.add((()=>{p._enableGPUDebugMarkers&&(p.restoreDefaultFramebuffer(!0),p._debugPushGroup?.("Depth renderer"))})),this._depthMap.onAfterUnbindObservable.add((()=>{p._enableGPUDebugMarkers&&p._debugPopGroup?.()})),this._depthMap.customIsReadyFunction=(e,t,s)=>{if((s||0===t)&&e.subMeshes)for(let t=0;t<e.subMeshes.length;++t){const s=e.subMeshes[t],i=s.getRenderingMesh(),n=i._getInstancesRenderList(s._id,!!s.getReplacementMesh()),r=p.getCaps().instancedArrays&&(null!==n.visibleInstances[s._id]&&void 0!==n.visibleInstances[s._id]||i.hasThinInstances);if(!this.isReady(s,r))return!1}return!0};const x=e=>{const t=e.getRenderingMesh(),i=e.getEffectiveMesh(),n=this._scene,r=n.getEngine(),a=e.getMaterial();if(i._internalAbstractMeshDataInfo._isActiveIntermediate=!1,!a||i.infiniteDistance||a.disableDepthWrite||0===e.verticesCount||e._renderId===n.getRenderId())return;const o=i._getWorldMatrixDeterminant()<0;let h=a._getEffectiveOrientation(t);o&&(h=h===s.MATERIAL_ClockWiseSideOrientation?s.MATERIAL_CounterClockWiseSideOrientation:s.MATERIAL_ClockWiseSideOrientation);const d=h===s.MATERIAL_ClockWiseSideOrientation;r.setState(a.backFaceCulling,0,!1,d,this.reverseCulling?!a.cullBackFaces:a.cullBackFaces);const c=t._getInstancesRenderList(e._id,!!e.getReplacementMesh());if(c.mustReturn)return;const u=r.getCaps().instancedArrays&&(null!==c.visibleInstances[e._id]&&void 0!==c.visibleInstances[e._id]||t.hasThinInstances),p=this._camera||n.activeCamera;if(this.isReady(e,u)&&p){e._renderId=n.getRenderId();let o=i._internalAbstractMeshDataInfo._materialForRenderPass?.[r.currentRenderPassId];if("GaussianSplattingMesh"===i.getClassName()){const e=this._alphaBlendedDepthMaterialCache.get(i.uniqueId),t=i.isCompound;if(void 0===o||e!==this.alphaBlendedDepth){if(o=i.material.makeDepthRenderingMaterial(this._scene,this._shaderLanguage,this.alphaBlendedDepth,t),this.setMaterialForRendering(i,o),this._alphaBlendedDepthMaterialCache.set(i.uniqueId,this.alphaBlendedDepth),!o.isReady())return}}let h=e._getDrawWrapper();!h&&o&&(h=o._getDrawWrapper());const d=p.mode===l.ORTHOGRAPHIC_CAMERA;if(!h)return;const g=h.effect;let x,M;if(r.enableEffect(h),u||t._bind(e,g,a.fillMode),o?o.bindForSubMesh(i.getWorldMatrix(),i,e):(g.setMatrix("viewProjection",n.getTransformMatrix()),g.setMatrix("world",i.getWorldMatrix()),this._storeCameraSpaceZ&&g.setMatrix("view",n.getViewMatrix())),d?(x=!r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:1,M=r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:1):(x=r.useReverseDepthBuffer&&r.isNDCHalfZRange?p.minZ:r.isNDCHalfZRange?0:p.minZ,M=r.useReverseDepthBuffer&&r.isNDCHalfZRange?0:p.maxZ),g.setFloat2("depthValues",x,x+M),!o){if(a.needAlphaTestingForMesh(i)){const e=a.getAlphaTestTexture();e&&(g.setTexture("diffuseSampler",e),g.setMatrix("diffuseMatrix",e.getTextureMatrix()))}_(t,g),f(g,a,n),m(t,g),t.morphTargetManager&&t.morphTargetManager.isUsingTextureForTargets&&t.morphTargetManager._bind(g);const s=e.getMesh().bakedVertexAnimationManager;s&&s.isEnabled&&s.bind(g,u),a.pointsCloud&&g.setFloat("pointSize",a.pointSize)}this.alphaBlendedDepth&&a.needAlphaBlendingForMesh(i)?r.setAlphaMode(s.ALPHA_COMBINE):r.setAlphaMode(s.ALPHA_DISABLE),t._processRendering(i,e,g,a.fillMode,c,u,((e,t)=>g.setMatrix("world",t)))}};this._depthMap.customRenderFunction=(e,t,s,i)=>{const n=this._scene.getEngine(),r=n.getAlphaMode();let a;if(i.length)for(a=0;a<i.length;a++)x(i.data[a]);for(a=0;a<e.length;a++)x(e.data[a]);for(a=0;a<t.length;a++)x(t.data[a]);if(this.forceDepthWriteTransparentMeshes)for(a=0;a<s.length;a++)x(s.data[a]);else for(a=0;a<s.length;a++)s.data[a].getEffectiveMesh()._internalAbstractMeshDataInfo._isActiveIntermediate=!1;this.alphaBlendedDepth&&n.setAlphaMode(r)}}async _initShaderSourceAsync(e=!1){!this._scene.getEngine().isWebGPU||e||V.ForceGLSL?await Promise.all([Promise.resolve().then((function(){return y})),Promise.resolve().then((function(){return z}))]):(this._shaderLanguage=1,await Promise.all([import("./depth.vertex-D6Jh9KVC.esm.min.js"),import("./depth.fragment-BkGqmD8I.esm.min.js")])),this._shadersLoaded=!0}isReady(e,t){if(!this._shadersLoaded)return!1;const s=this._scene.getEngine(),i=e.getMesh(),n=i.getScene(),r=i._internalAbstractMeshDataInfo._materialForRenderPass?.[s.currentRenderPassId];if(r)return r.isReadyForSubMesh(i,e,t);const l=e.getMaterial();if(!l||l.disableDepthWrite)return!1;const _=[],f=[a.PositionKind];let m=!1,p=!1;l.needAlphaTestingForMesh(i)&&l.getAlphaTestTexture()&&(_.push("#define ALPHATEST"),i.isVerticesDataPresent(a.UVKind)&&(f.push(a.UVKind),_.push("#define UV1"),m=!0),i.isVerticesDataPresent(a.UV2Kind)&&(f.push(a.UV2Kind),_.push("#define UV2"),p=!0));const g=new o;if(i.useBones&&i.computeBonesUsingShaders&&i.skeleton){f.push(a.MatricesIndicesKind),f.push(a.MatricesWeightsKind),i.numBoneInfluencers>4&&(f.push(a.MatricesIndicesExtraKind),f.push(a.MatricesWeightsExtraKind)),_.push("#define NUM_BONE_INFLUENCERS "+i.numBoneInfluencers),i.numBoneInfluencers>0&&g.addCPUSkinningFallback(0,i);const e=i.skeleton;e.isUsingTextureForMatrices?_.push("#define BONETEXTURE"):_.push("#define BonesPerMesh "+(e.bones.length+1))}else _.push("#define NUM_BONE_INFLUENCERS 0");const x=i.morphTargetManager?h(i.morphTargetManager,_,f,i,!0,!1,!1,m,p,!1):0;l.pointsCloud&&_.push("#define POINTSIZE"),t&&(_.push("#define INSTANCES"),d(f),e.getRenderingMesh().hasThinInstances&&_.push("#define THIN_INSTANCES"));const M=i.bakedVertexAnimationManager;M&&M.isEnabled&&(_.push("#define BAKED_VERTEX_ANIMATION_TEXTURE"),t&&f.push("bakedVertexAnimationSettingsInstanced")),this._storeNonLinearDepth&&_.push("#define NONLINEARDEPTH"),this._storeCameraSpaceZ&&_.push("#define STORE_CAMERASPACE_Z"),this.isPacked&&_.push("#define PACKED"),c(l,n,_);const S=e._getDrawWrapper(void 0,!0),C=S.defines,E=_.join("\n");if(C!==E){const e=["world","mBones","boneTextureWidth","pointSize","viewProjection","view","diffuseMatrix","depthValues","morphTargetInfluences","morphTargetCount","morphTargetTextureInfo","morphTargetTextureIndices","bakedVertexAnimationSettings","bakedVertexAnimationTextureSizeInverted","bakedVertexAnimationTime","bakedVertexAnimationTexture"],t=["diffuseSampler","morphTargets","boneSampler","bakedVertexAnimationTexture"];u(e),S.setEffect(s.createEffect("depth",{attributes:f,uniformsNames:e,uniformBuffersNames:[],samplers:t,defines:E,fallbacks:g,onCompiled:null,onError:null,indexParameters:{maxSimultaneousMorphTargets:x},shaderLanguage:this._shaderLanguage},s),E)}return S.effect.isReady()}getDepthMap(){return this._depthMap}dispose(){const e=[];for(const t in this._scene._depthRenderer){this._scene._depthRenderer[t]===this&&e.push(t)}if(e.length>0){this._depthMap.dispose();for(const t of e)delete this._scene._depthRenderer[t]}}}V.ForceGLSL=!1,V._SceneComponentInitialization=e=>{throw p("DepthRendererSceneComponent")},function(e){e[e.NormalizedViewDepth=0]="NormalizedViewDepth",e[e.ViewDepth=1]="ViewDepth",e[e.ScreenDepth=2]="ScreenDepth"}(N||(N={}));class W extends g{_gatherImports(e,t){e?(this._webGPUReady=!0,t.push(Promise.resolve().then((function(){return Q})))):t.push(Promise.resolve().then((function(){return Y})))}constructor(e,t=null,s="",i){super({...i,name:e,engine:t||x.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,fragmentShader:W.FragmentUrl,uniforms:W.Uniforms,defines:s}),this.textureWidth=0,this.textureHeight=0}bind(e=!1){super.bind(e);const t=this.drawWrapper.effect;1===this.textureWidth||1===this.textureHeight?t.setInt2("texSize",this.textureWidth,this.textureHeight):t.setFloat2("texSize",this.textureWidth,this.textureHeight)}}W.FragmentUrl="minmaxRedux",W.Uniforms=["texSize"];const k=new Float32Array(4),H=new Uint8Array(4),Z={min:0,max:0};class G{get depthRedux(){return this._depthRedux}set depthRedux(e){this._depthRedux!==e&&(this._depthRedux=e,this._recreatePostProcesses())}get textureWidth(){return this._textureWidth}get textureHeight(){return this._textureHeight}constructor(e,t=!0){this.onAfterReductionPerformed=new M,this._textureWidth=0,this._textureHeight=0,this._scene=e,this._depthRedux=t,this.reductionSteps=[]}setTextureDimensions(e,t,s=0){return(e!==this._textureWidth||t!==this._textureHeight||s!==this._depthTextureType)&&(this._textureWidth=e,this._textureHeight=t,this._depthTextureType=s,this._recreatePostProcesses(),!0)}readMinMax(e){const t=e.type===x.TEXTURETYPE_FLOAT||e.type===x.TEXTURETYPE_HALF_FLOAT,s=t?k:H;this._scene.getEngine()._readTexturePixels(e,1,1,-1,0,s,!1),Z.min=s[0],Z.max=s[1],t||(Z.min=Z.min/255,Z.max=Z.max/255),Z.min>=Z.max&&(Z.min=0,Z.max=1),this.onAfterReductionPerformed.notifyObservers(Z)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._textureWidth=0,this._textureHeight=0);for(let e=0;e<this.reductionSteps.length;++e)this.reductionSteps[e].dispose();this.reductionSteps.length=0}_recreatePostProcesses(){this.dispose(!1);const e=this._scene;let t=this.textureWidth,s=this.textureHeight;const i=new W("Initial reduction phase",e.getEngine(),"#define INITIAL"+(this._depthRedux?"\n#define DEPTH_REDUX":"")+(1===this._depthTextureType?"\n#define VIEW_DEPTH":""));i.textureWidth=t,i.textureHeight=s,this.reductionSteps.push(i);let n=1;for(;t>1||s>1;){t=Math.max(Math.round(t/2),1),s=Math.max(Math.round(s/2),1);const i=new W("Reduction phase "+n,e.getEngine(),"#define "+(1==t&&1==s?"LAST":1==t||1==s?"ONEBEFORELAST":"MAIN"));i.textureWidth=t,i.textureHeight=s,this.reductionSteps.push(i),n++}}}const X="minmaxReduxPixelShader",j="varying vec2 vUV;uniform sampler2D textureSampler;\n#if defined(INITIAL)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));float f1=texelFetch(textureSampler,coord,0).r;float f2=texelFetch(textureSampler,coord+ivec2(1,0),0).r;float f3=texelFetch(textureSampler,coord+ivec2(1,1),0).r;float f4=texelFetch(textureSampler,coord+ivec2(0,1),0).r;\n#ifdef DEPTH_REDUX\n#ifdef VIEW_DEPTH\nfloat minz=3.4e38;if (f1 != 0.0) { minz=f1; }\nif (f2 != 0.0) { minz=min(minz,f2); }\nif (f3 != 0.0) { minz=min(minz,f3); }\nif (f4 != 0.0) { minz=min(minz,f4); }\nfloat maxz=max(max(max(f1,f2),f3),f4);\n#else\nfloat minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#endif\n#else\nfloat minz=min(min(min(f1,f2),f3),f4);float maxz=max(max(max(f1,f2),f3),f4);\n#endif\nglFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform vec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*(texSize-1.0));vec2 f1=texelFetch(textureSampler,coord,0).rg;vec2 f2=texelFetch(textureSampler,coord+ivec2(1,0),0).rg;vec2 f3=texelFetch(textureSampler,coord+ivec2(1,1),0).rg;vec2 f4=texelFetch(textureSampler,coord+ivec2(0,1),0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform ivec2 texSize;void main(void)\n{ivec2 coord=ivec2(vUV*vec2(texSize-1));vec2 f1=texelFetch(textureSampler,coord % texSize,0).rg;vec2 f2=texelFetch(textureSampler,(coord+ivec2(1,0)) % texSize,0).rg;vec2 f3=texelFetch(textureSampler,(coord+ivec2(1,1)) % texSize,0).rg;vec2 f4=texelFetch(textureSampler,(coord+ivec2(0,1)) % texSize,0).rg;float minz=min(min(min(f1.x,f2.x),f3.x),f4.x);float maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);glFragColor=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\nvoid main(void)\n{glFragColor=vec4(0.);if (true) { \ndiscard;}}\n#endif\n";t.ShadersStore[X]||(t.ShadersStore[X]=j);const K={name:X,shader:j};var Y=Object.freeze({__proto__:null,minmaxReduxPixelShader:K});const $="minmaxReduxPixelShader",q="varying vUV: vec2f;var textureSampler: texture_2d<f32>;\n#if defined(INITIAL)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).r;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).r;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).r;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).r;\n#ifdef DEPTH_REDUX\n#ifdef VIEW_DEPTH\nvar minz=3.4e38;if (f1 != 0.0) { minz=f1; }\nif (f2 != 0.0) { minz=min(minz,f2); }\nif (f3 != 0.0) { minz=min(minz,f3); }\nif (f4 != 0.0) { minz=min(minz,f4); }\nlet maxz=max(max(max(f1,f2),f3),f4);\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(sign(1.0-f1)*f1,sign(1.0-f2)*f2),sign(1.0-f3)*f3),sign(1.0-f4)*f4);\n#endif\n#else\nlet minz=min(min(min(f1,f2),f3),f4);let maxz=max(max(max(f1,f2),f3),f4);\n#endif\nfragmentOutputs.color=vec4f(minz,maxz,0.,0.);}\n#elif defined(MAIN)\nuniform texSize: vec2f;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*(uniforms.texSize-1.0));let f1=textureLoad(textureSampler,coord,0).rg;let f2=textureLoad(textureSampler,coord+vec2i(1,0),0).rg;let f3=textureLoad(textureSampler,coord+vec2i(1,1),0).rg;let f4=textureLoad(textureSampler,coord+vec2i(0,1),0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(ONEBEFORELAST)\nuniform texSize: vec2i;@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {let coord=vec2i(fragmentInputs.vUV*vec2f(uniforms.texSize-1));let f1=textureLoad(textureSampler,coord % uniforms.texSize,0).rg;let f2=textureLoad(textureSampler,(coord+vec2i(1,0)) % uniforms.texSize,0).rg;let f3=textureLoad(textureSampler,(coord+vec2i(1,1)) % uniforms.texSize,0).rg;let f4=textureLoad(textureSampler,(coord+vec2i(0,1)) % uniforms.texSize,0).rg;let minz=min(min(min(f1.x,f2.x),f3.x),f4.x);let maxz=max(max(max(f1.y,f2.y),f3.y),f4.y);fragmentOutputs.color=vec4(minz,maxz,0.,0.);}\n#elif defined(LAST)\n@fragment\nfn main(input: FragmentInputs)->FragmentOutputs {fragmentOutputs.color=vec4f(0.);if (true) { \ndiscard;}}\n#endif\n";t.ShadersStoreWGSL[$]||(t.ShadersStoreWGSL[$]=q);const J={name:$,shader:q};var Q=Object.freeze({__proto__:null,minmaxReduxPixelShaderWGSL:J});class ee{get onAfterReductionPerformed(){return this._thinMinMaxReducer.onAfterReductionPerformed}constructor(e){this._onAfterUnbindObserver=null,this._forceFullscreenViewport=!0,this._activated=!1,this._camera=e,this._postProcessManager=new S(e.getScene()),this._thinMinMaxReducer=new G(e.getScene()),this._reductionSteps=[],this._onContextRestoredObserver=e.getEngine().onContextRestoredObservable.add((()=>{this._postProcessManager._rebuild()}))}get sourceTexture(){return this._sourceTexture}setSourceTexture(e,t,i=s.TEXTURETYPE_HALF_FLOAT,n=!0){if(e!==this._sourceTexture&&(this._thinMinMaxReducer.depthRedux=t,this.deactivate(),this._sourceTexture=e,this._forceFullscreenViewport=n,this._thinMinMaxReducer.setTextureDimensions(e.getRenderWidth(),e.getRenderHeight()))){this._disposePostProcesses();const e=this._thinMinMaxReducer.reductionSteps;for(let t=0;t<e.length;++t){const r=e[t],a=new C(r.name,W.FragmentUrl,{effectWrapper:r,samplingMode:s.TEXTURE_NEAREST_NEAREST,engine:this._camera.getScene().getEngine(),textureType:i,textureFormat:s.TEXTUREFORMAT_RG,size:{width:r.textureWidth,height:r.textureHeight}});this._reductionSteps.push(a),a.autoClear=!1,a.forceFullscreenViewport=n,0===t&&(a.externalTextureSamplerBinding=!0,a.onApplyObservable.add((e=>{e.setTexture("textureSampler",this._sourceTexture)}))),t===e.length-1&&this._reductionSteps[t-1].onAfterRenderObservable.add((()=>{this._thinMinMaxReducer.readMinMax(a.inputTexture.texture)}))}}}get refreshRate(){return this._sourceTexture?this._sourceTexture.refreshRate:-1}set refreshRate(e){this._sourceTexture&&(this._sourceTexture.refreshRate=e)}get activated(){return this._activated}activate(){!this._onAfterUnbindObserver&&this._sourceTexture&&(this._onAfterUnbindObserver=this._sourceTexture.onAfterUnbindObservable.add((()=>{const e=this._camera.getScene().getEngine();e._debugPushGroup?.("min max reduction"),this._reductionSteps[0].activate(this._camera),this._postProcessManager.directRender(this._reductionSteps,this._reductionSteps[0].inputTexture,this._forceFullscreenViewport,0,0,!0,this._reductionSteps.length-1),e.unBindFramebuffer(this._reductionSteps[this._reductionSteps.length-1].inputTexture,!1),e._debugPopGroup?.()})),this._activated=!0)}deactivate(){this._onAfterUnbindObserver&&this._sourceTexture&&(this._sourceTexture.onAfterUnbindObservable.remove(this._onAfterUnbindObserver),this._onAfterUnbindObserver=null,this._activated=!1)}dispose(e=!0){e&&(this.onAfterReductionPerformed.clear(),this._camera.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver),this._onContextRestoredObserver=void 0,this._disposePostProcesses(),this._postProcessManager.dispose(),this._postProcessManager=void 0,this._thinMinMaxReducer.dispose(),this._thinMinMaxReducer=void 0,this._sourceTexture=null)}_disposePostProcesses(){for(let e=0;e<this._reductionSteps.length;++e)this._reductionSteps[e].dispose();this._reductionSteps.length=0}}class te extends ee{get depthRenderer(){return this._depthRenderer}constructor(e){super(e)}setDepthRenderer(e=null,t=s.TEXTURETYPE_HALF_FLOAT,i=!0){const n=this._camera.getScene();this._depthRenderer&&(delete n._depthRenderer[this._depthRendererId],this._depthRenderer.dispose(),this._depthRenderer=null),null===e&&(n._depthRenderer||(n._depthRenderer={}),this._depthRendererId="minmax_"+this._camera.id,(e=this._depthRenderer=new V(n,t,this._camera,!1,s.TEXTURE_NEAREST_SAMPLINGMODE,!1,`DepthRenderer ${this._depthRendererId}`)).enabled=!1,n._depthRenderer[this._depthRendererId]=e),super.setSourceTexture(e.getDepthMap(),!0,t,i)}setSourceTexture(e,t,i=s.TEXTURETYPE_HALF_FLOAT,n=!0){super.setSourceTexture(e,t,i,n)}activate(){this._depthRenderer&&(this._depthRenderer.enabled=!0),super.activate()}deactivate(){super.deactivate(),this._depthRenderer&&(this._depthRenderer.enabled=!1)}dispose(e=!0){super.dispose(e),this._depthRenderer&&e&&(this._depthRenderer.dispose(),this._depthRenderer=null)}}const se=E.Up(),ie=E.Zero(),ne=new E,re=new E,ae=new v;class oe extends e{_validateFilter(t){return t===e.FILTER_NONE||t===e.FILTER_PCF||t===e.FILTER_PCSS?t:(R.Error('Unsupported filter "'+t+'"!'),e.FILTER_NONE)}get numCascades(){return this._numCascades}set numCascades(e){(e=Math.min(Math.max(e,oe.MIN_CASCADES_COUNT),oe.MAX_CASCADES_COUNT))!==this._numCascades&&(this._numCascades=e,this.recreateShadowMap(),this._recreateSceneUBOs())}get freezeShadowCastersBoundingInfo(){return this._freezeShadowCastersBoundingInfo}set freezeShadowCastersBoundingInfo(e){this._freezeShadowCastersBoundingInfoObservable&&e&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._freezeShadowCastersBoundingInfoObservable||e||(this._freezeShadowCastersBoundingInfoObservable=this._scene.onBeforeRenderObservable.add((()=>this._computeShadowCastersBoundingInfo()))),this._freezeShadowCastersBoundingInfo=e,e&&this._computeShadowCastersBoundingInfo()}_computeShadowCastersBoundingInfo(){if(this._scbiMin.copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._scbiMax.copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._shadowMap&&this._shadowMap.renderList){const e=this._shadowMap.renderList;for(let t=0;t<e.length;t++){const s=e[t];if(!s)continue;const i=s.getBoundingInfo().boundingBox;this._scbiMin.minimizeInPlace(i.minimumWorld),this._scbiMax.maximizeInPlace(i.maximumWorld)}}this._shadowCastersBoundingInfo.reConstruct(this._scbiMin,this._scbiMax)}get shadowCastersBoundingInfo(){return this._shadowCastersBoundingInfo}set shadowCastersBoundingInfo(e){this._shadowCastersBoundingInfo=e}setMinMaxDistance(e,t){this._minDistance===e&&this._maxDistance===t||(e>t&&(e=0,t=1),e<0&&(e=0),t>1&&(t=1),this._minDistance=e,this._maxDistance=t,this._breaksAreDirty=!0)}get minDistance(){return this._minDistance}get maxDistance(){return this._maxDistance}getClassName(){return oe.CLASSNAME}getCascadeMinExtents(e){return e>=0&&e<this._numCascades?this._cascadeMinExtents[e]:null}getCascadeMaxExtents(e){return e>=0&&e<this._numCascades?this._cascadeMaxExtents[e]:null}get shadowMaxZ(){return this._getCamera()?this._shadowMaxZ:0}set shadowMaxZ(e){const t=this._getCamera();t?this._shadowMaxZ===e||e<t.minZ||e>t.maxZ&&0!==t.maxZ||(this._shadowMaxZ=e,this._light._markMeshesAsLightDirty(),this._breaksAreDirty=!0):this._shadowMaxZ=e}get debug(){return this._debug}set debug(e){this._debug=e,this._light._markMeshesAsLightDirty()}get depthClamp(){return this._depthClamp}set depthClamp(e){this._depthClamp=e}get cascadeBlendPercentage(){return this._cascadeBlendPercentage}set cascadeBlendPercentage(e){this._cascadeBlendPercentage=e,this._light._markMeshesAsLightDirty()}get lambda(){return this._lambda}set lambda(e){const t=Math.min(Math.max(e,0),1);this._lambda!=t&&(this._lambda=t,this._breaksAreDirty=!0)}getCascadeViewMatrix(e){return e>=0&&e<this._numCascades?this._viewMatrices[e]:null}getCascadeProjectionMatrix(e){return e>=0&&e<this._numCascades?this._projectionMatrices[e]:null}getCascadeTransformMatrix(e){return e>=0&&e<this._numCascades?this._transformMatrices[e]:null}setDepthRenderer(e){this._depthRenderer=e,this._depthReducer&&this._depthReducer.setDepthRenderer(this._depthRenderer)}get autoCalcDepthBounds(){return this._autoCalcDepthBounds}set autoCalcDepthBounds(e){const t=this._getCamera();if(t){if(this._autoCalcDepthBounds=e,!e)return this._depthReducer&&this._depthReducer.deactivate(),void this.setMinMaxDistance(0,1);this._depthReducer||(this._depthReducer=new te(t),this._depthReducer.onAfterReductionPerformed.add((e=>{let t=e.min,s=e.max;t>=s&&(t=0,s=1),t==this._minDistance&&s==this._maxDistance||this.setMinMaxDistance(t,s)})),this._depthReducer.setDepthRenderer(this._depthRenderer)),this._depthReducer.activate()}}get autoCalcDepthBoundsRefreshRate(){return this._depthReducer?.depthRenderer?.getDepthMap().refreshRate??-1}set autoCalcDepthBoundsRefreshRate(e){this._depthReducer?.depthRenderer&&(this._depthReducer.depthRenderer.getDepthMap().refreshRate=e)}splitFrustum(){this._breaksAreDirty=!0}_splitFrustum(){const e=this._getCamera();if(!e)return;const t=e.minZ,s=e.maxZ||this._shadowMaxZ,i=s-t,n=this._minDistance,r=t+n*i,a=t+(this._shadowMaxZ<s&&this._shadowMaxZ>=t?Math.min((this._shadowMaxZ-t)/(s-t),this._maxDistance):this._maxDistance)*i,o=a-r,h=a/r;for(let e=0;e<this._cascades.length;++e){const s=(e+1)/this._numCascades,a=r*h**s,d=r+o*s,c=this._lambda*(a-d)+d;this._cascades[e].prevBreakDistance=0===e?n:this._cascades[e-1].breakDistance,this._cascades[e].breakDistance=(c-t)/i,this._viewSpaceFrustumsZ[e]=c,this._frustumLengths[e]=(this._cascades[e].breakDistance-this._cascades[e].prevBreakDistance)*i}this._breaksAreDirty=!1}_computeMatrices(){const t=this._scene;if(!this._getCamera())return;E.NormalizeToRef(this._light.getShadowDirection(0),this._lightDirection),1===Math.abs(E.Dot(this._lightDirection,E.Up()))&&(this._lightDirection.z=1e-13),this._cachedDirection.copyFrom(this._lightDirection);const s=t.getEngine().useReverseDepthBuffer;for(let i=0;i<this._numCascades;++i){this._computeFrustumInWorldSpace(i),this._computeCascadeFrustum(i),this._cascadeMaxExtents[i].subtractToRef(this._cascadeMinExtents[i],ne),this._frustumCenter[i].addToRef(this._lightDirection.scale(this._cascadeMinExtents[i].z),this._shadowCameraPos[i]),v.LookAtLHToRef(this._shadowCameraPos[i],this._frustumCenter[i],se,this._viewMatrices[i]);let n=0,r=ne.z;const a=this._shadowCastersBoundingInfo;a.update(this._viewMatrices[i]);const o=a.boundingBox.minimumWorld.z,h=a.boundingBox.maximumWorld.z;o>r||(this._depthClamp&&this.filter!==e.FILTER_PCSS?(r=Math.min(r,h),n=Math.max(n,o),r=Math.max(n+1,r)):(n=Math.min(n,o),this.filter!==e.FILTER_PCSS&&(r=Math.min(r,h)))),v.OrthoOffCenterLHToRef(this._cascadeMinExtents[i].x,this._cascadeMaxExtents[i].x,this._cascadeMinExtents[i].y,this._cascadeMaxExtents[i].y,s?r:n,s?n:r,this._projectionMatrices[i],t.getEngine().isNDCHalfZRange),this._cascadeMinExtents[i].z=n,this._cascadeMaxExtents[i].z=r,this._viewMatrices[i].multiplyToRef(this._projectionMatrices[i],this._transformMatrices[i]),E.TransformCoordinatesToRef(ie,this._transformMatrices[i],ne),ne.scaleInPlace(this._mapSize/2),re.copyFromFloats(Math.round(ne.x),Math.round(ne.y),Math.round(ne.z)),re.subtractInPlace(ne).scaleInPlace(2/this._mapSize),v.TranslationToRef(re.x,re.y,0,ae),this._projectionMatrices[i].multiplyToRef(ae,this._projectionMatrices[i]),this._viewMatrices[i].multiplyToRef(this._projectionMatrices[i],this._transformMatrices[i]),this._transformMatrices[i].copyToArray(this._transformMatricesAsArray,16*i)}}_computeFrustumInWorldSpace(e){const t=this._getCamera();if(!t)return;const s=this._cascades[e].prevBreakDistance,i=this._cascades[e].breakDistance,n=this._scene.getEngine().isNDCHalfZRange;t.getViewMatrix();const r=0===t.maxZ,a=t.maxZ;r&&(t.maxZ=this._shadowMaxZ,t.getProjectionMatrix(!0));const o=v.Invert(t.getTransformationMatrix());r&&(t.maxZ=a,t.getProjectionMatrix(!0));const h=this._scene.getEngine().useReverseDepthBuffer?4:0;for(let t=0;t<oe._FrustumCornersNdcSpace.length;++t)ne.copyFrom(oe._FrustumCornersNdcSpace[(t+h)%oe._FrustumCornersNdcSpace.length]),n&&-1===ne.z&&(ne.z=0),E.TransformCoordinatesToRef(ne,o,this._frustumCornersWorldSpace[e][t]);for(let t=0;t<oe._FrustumCornersNdcSpace.length/2;++t)ne.copyFrom(this._frustumCornersWorldSpace[e][t+4]).subtractInPlace(this._frustumCornersWorldSpace[e][t]),re.copyFrom(ne).scaleInPlace(s),ne.scaleInPlace(i),ne.addInPlace(this._frustumCornersWorldSpace[e][t]),this._frustumCornersWorldSpace[e][t+4].copyFrom(ne),this._frustumCornersWorldSpace[e][t].addInPlace(re)}_computeCascadeFrustum(e){this._cascadeMinExtents[e].copyFromFloats(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),this._cascadeMaxExtents[e].copyFromFloats(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),this._frustumCenter[e].copyFromFloats(0,0,0);if(this._getCamera()){for(let t=0;t<this._frustumCornersWorldSpace[e].length;++t)this._frustumCenter[e].addInPlace(this._frustumCornersWorldSpace[e][t]);if(this._frustumCenter[e].scaleInPlace(1/this._frustumCornersWorldSpace[e].length),this.stabilizeCascades){let t=0;for(let s=0;s<this._frustumCornersWorldSpace[e].length;++s){const i=this._frustumCornersWorldSpace[e][s].subtractToRef(this._frustumCenter[e],ne).length();t=Math.max(t,i)}t=Math.ceil(16*t)/16,this._cascadeMaxExtents[e].copyFromFloats(t,t,t),this._cascadeMinExtents[e].copyFromFloats(-t,-t,-t)}else{const t=this._frustumCenter[e];this._frustumCenter[e].addToRef(this._lightDirection,ne),v.LookAtLHToRef(t,ne,se,ae);for(let t=0;t<this._frustumCornersWorldSpace[e].length;++t)E.TransformCoordinatesToRef(this._frustumCornersWorldSpace[e][t],ae,ne),this._cascadeMinExtents[e].minimizeInPlace(ne),this._cascadeMaxExtents[e].maximizeInPlace(ne)}}}_recreateSceneUBOs(){if(this._disposeSceneUBOs(),this._sceneUBOs)for(let e=0;e<this._numCascades;++e)this._sceneUBOs.push(this._scene.createSceneUniformBuffer(`Scene for CSM Shadow Generator (light "${this._light.name}" cascade #${e})`,{forceMono:!0}))}static get IsSupported(){const e=T.LastCreatedEngine;return!!e&&e._features.supportCSM}constructor(e,t,s,i,n=!0){oe.IsSupported?(super(e,t,s,i,n),this.usePercentageCloserFiltering=!0):R.Error("CascadedShadowMap is not supported by the current engine.")}_initializeGenerator(){this.penumbraDarkness=this.penumbraDarkness??1,this._numCascades=this._numCascades??oe.DEFAULT_CASCADES_COUNT,this.stabilizeCascades=this.stabilizeCascades??!1,this._freezeShadowCastersBoundingInfoObservable=this._freezeShadowCastersBoundingInfoObservable??null,this.freezeShadowCastersBoundingInfo=this.freezeShadowCastersBoundingInfo??!1,this._scbiMin=this._scbiMin??new E(0,0,0),this._scbiMax=this._scbiMax??new E(0,0,0),this._shadowCastersBoundingInfo=this._shadowCastersBoundingInfo??new A(new E(0,0,0),new E(0,0,0)),this._breaksAreDirty=this._breaksAreDirty??!0,this._minDistance=this._minDistance??0,this._maxDistance=this._maxDistance??1,this._currentLayer=this._currentLayer??0,this._shadowMaxZ=this._shadowMaxZ??this._getCamera()?.maxZ??1e4,this._debug=this._debug??!1,this._depthClamp=this._depthClamp??!0,this._cascadeBlendPercentage=this._cascadeBlendPercentage??.1,this._lambda=this._lambda??.5,this._autoCalcDepthBounds=this._autoCalcDepthBounds??!1,this._recreateSceneUBOs(),super._initializeGenerator()}_createTargetRenderTexture(){const e=this._scene.getEngine();this._shadowMap?.dispose();const t={width:this._mapSize,height:this._mapSize,layers:this.numCascades};this._shadowMap=new r(this._light.name+"_CSMShadowMap",t,this._scene,!1,!0,this._textureType,!1,void 0,!1,!1,void 0,this._useRedTextureType?s.TEXTUREFORMAT_RED:s.TEXTUREFORMAT_RGBA),this._shadowMap.createDepthStencilTexture(e.useReverseDepthBuffer?s.GREATER:s.LESS,!0,void 0,void 0,void 0,`DepthStencilForCSMShadowGenerator-${this._light.name}`),this._shadowMap.noPrePassRenderer=!0}_initializeShadowMap(){if(super._initializeShadowMap(),null===this._shadowMap)return;this._transformMatricesAsArray=new Float32Array(16*this._numCascades),this._tempTransformMatricesAsArray=new Float32Array(16*this._numCascades),this._viewSpaceFrustumsZ=new Array(this._numCascades),this._frustumLengths=new Array(this._numCascades),this._lightSizeUVCorrection=new Array(2*this._numCascades),this._depthCorrection=new Array(this._numCascades),this._cascades=[],this._viewMatrices=[],this._projectionMatrices=[],this._transformMatrices=[],this._cascadeMinExtents=[],this._cascadeMaxExtents=[],this._frustumCenter=[],this._shadowCameraPos=[],this._frustumCornersWorldSpace=[];for(let e=0;e<this._numCascades;++e){this._cascades[e]={prevBreakDistance:0,breakDistance:0},this._viewMatrices[e]=v.Zero(),this._projectionMatrices[e]=v.Zero(),this._transformMatrices[e]=v.Zero(),this._cascadeMinExtents[e]=new E,this._cascadeMaxExtents[e]=new E,this._frustumCenter[e]=new E,this._shadowCameraPos[e]=new E,this._frustumCornersWorldSpace[e]=new Array(oe._FrustumCornersNdcSpace.length);for(let t=0;t<oe._FrustumCornersNdcSpace.length;++t)this._frustumCornersWorldSpace[e][t]=new E}const t=this._scene.getEngine();this._shadowMap.onBeforeBindObservable.clear(),this._shadowMap.onBeforeRenderObservable.clear(),this._shadowMap.onBeforeRenderObservable.add((s=>{this._sceneUBOs&&this._scene.setSceneUniformBuffer(this._sceneUBOs[s]),this._currentLayer=s,this._filter===e.FILTER_PCF&&t.setColorWrite(!1),b.eyeAtCamera=!1,this._scene.setTransformMatrix(this.getCascadeViewMatrix(s),this.getCascadeProjectionMatrix(s)),this._useUBO&&(this._scene.getSceneUniformBuffer().unbindEffect(),this._scene.finalizeSceneUbo())})),this._shadowMap.onBeforeBindObservable.add((()=>{this._currentSceneUBO=this._scene.getSceneUniformBuffer(),t._enableGPUDebugMarkers&&(t.restoreDefaultFramebuffer(!0),t._debugPushGroup?.(`Cascaded shadow map generation for pass id ${t.currentRenderPassId}`)),this._breaksAreDirty&&this._splitFrustum(),this._computeMatrices()})),this._splitFrustum()}_bindCustomEffectForRenderSubMeshForShadowMap(e,t){t.setMatrix("viewProjection",this.getCascadeTransformMatrix(this._currentLayer))}_isReadyCustomDefines(t){t.push("#define SM_DEPTHCLAMP "+(this._depthClamp&&this._filter!==e.FILTER_PCSS?"1":"0"))}prepareDefines(e,t){super.prepareDefines(e,t);const s=this._scene,i=this._light;if(!s.shadowsEnabled||!i.shadowEnabled)return;e["SHADOWCSM"+t]=!0,e["SHADOWCSMDEBUG"+t]=this.debug,e["SHADOWCSMNUM_CASCADES"+t]=this.numCascades,e["SHADOWCSM_RIGHTHANDED"+t]=s.useRightHandedSystem;const n=this._getCamera();n&&this._shadowMaxZ<=(n.maxZ||this._shadowMaxZ)&&(e["SHADOWCSMUSESHADOWMAXZ"+t]=!0),0===this.cascadeBlendPercentage&&(e["SHADOWCSMNOBLEND"+t]=!0)}bindShadowLight(t,s){const i=this._light,n=this._scene;if(!n.shadowsEnabled||!i.shadowEnabled)return;const r=this._getCamera();if(!r)return;const a=this.getShadowMap();if(!a)return;const o=a.getSize().width,h=this._transformMatricesAsArray,d=n.floatingOriginMode?D(this._scene.floatingOriginOffset,this._viewMatrices,this._projectionMatrices,this._numCascades,this._tempTransformMatricesAsArray):h;if(s.setMatrices("lightMatrix"+t,d),s.setArray("viewFrustumZ"+t,this._viewSpaceFrustumsZ),s.setFloat("cascadeBlendFactor"+t,0===this.cascadeBlendPercentage?1e4:1/this.cascadeBlendPercentage),s.setArray("frustumLengths"+t,this._frustumLengths),this._filter===e.FILTER_PCF)s.setDepthStencilTexture("shadowTexture"+t,a),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),o,1/o,this.frustumEdgeFalloff,t);else if(this._filter===e.FILTER_PCSS){for(let e=0;e<this._numCascades;++e)this._lightSizeUVCorrection[2*e+0]=0===e?1:(this._cascadeMaxExtents[0].x-this._cascadeMinExtents[0].x)/(this._cascadeMaxExtents[e].x-this._cascadeMinExtents[e].x),this._lightSizeUVCorrection[2*e+1]=0===e?1:(this._cascadeMaxExtents[0].y-this._cascadeMinExtents[0].y)/(this._cascadeMaxExtents[e].y-this._cascadeMinExtents[e].y),this._depthCorrection[e]=0===e?1:(this._cascadeMaxExtents[e].z-this._cascadeMinExtents[e].z)/(this._cascadeMaxExtents[0].z-this._cascadeMinExtents[0].z);s.setDepthStencilTexture("shadowTexture"+t,a),s.setTexture("depthTexture"+t,a),s.setArray2("lightSizeUVCorrection"+t,this._lightSizeUVCorrection),s.setArray("depthCorrection"+t,this._depthCorrection),s.setFloat("penumbraDarkness"+t,this.penumbraDarkness),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),1/o,this._contactHardeningLightSizeUVRatio*o,this.frustumEdgeFalloff,t)}else s.setTexture("shadowTexture"+t,a),i._uniformBuffer.updateFloat4("shadowsInfo",this.getDarkness(),o,1/o,this.frustumEdgeFalloff,t);i._uniformBuffer.updateFloat2("depthValues",this.getLight().getDepthMinZ(r),this.getLight().getDepthMinZ(r)+this.getLight().getDepthMaxZ(r),t)}getTransformMatrix(){return this.getCascadeTransformMatrix(0)}dispose(){super.dispose(),this._freezeShadowCastersBoundingInfoObservable&&(this._scene.onBeforeRenderObservable.remove(this._freezeShadowCastersBoundingInfoObservable),this._freezeShadowCastersBoundingInfoObservable=null),this._depthReducer&&(this._depthReducer.dispose(),this._depthReducer=null)}serialize(){const e=super.serialize(),t=this.getShadowMap();if(!t)return e;if(e.numCascades=this._numCascades,e.debug=this._debug,e.stabilizeCascades=this.stabilizeCascades,e.lambda=this._lambda,e.cascadeBlendPercentage=this.cascadeBlendPercentage,e.depthClamp=this._depthClamp,e.autoCalcDepthBounds=this.autoCalcDepthBounds,e.shadowMaxZ=this._shadowMaxZ,e.penumbraDarkness=this.penumbraDarkness,e.freezeShadowCastersBoundingInfo=this._freezeShadowCastersBoundingInfo,e.minDistance=this.minDistance,e.maxDistance=this.maxDistance,e.renderList=[],t.renderList)for(let s=0;s<t.renderList.length;s++){const i=t.renderList[s];e.renderList.push(i.id)}return e}static Parse(t,s){const i=e.Parse(t,s,((e,t,s)=>new oe(e,t,void 0,s)));return void 0!==t.numCascades&&(i.numCascades=t.numCascades),void 0!==t.debug&&(i.debug=t.debug),void 0!==t.stabilizeCascades&&(i.stabilizeCascades=t.stabilizeCascades),void 0!==t.lambda&&(i.lambda=t.lambda),void 0!==t.cascadeBlendPercentage&&(i.cascadeBlendPercentage=t.cascadeBlendPercentage),void 0!==t.depthClamp&&(i.depthClamp=t.depthClamp),void 0!==t.autoCalcDepthBounds&&(i.autoCalcDepthBounds=t.autoCalcDepthBounds),void 0!==t.shadowMaxZ&&(i.shadowMaxZ=t.shadowMaxZ),void 0!==t.penumbraDarkness&&(i.penumbraDarkness=t.penumbraDarkness),void 0!==t.freezeShadowCastersBoundingInfo&&(i.freezeShadowCastersBoundingInfo=t.freezeShadowCastersBoundingInfo),void 0!==t.minDistance&&void 0!==t.maxDistance&&i.setMinMaxDistance(t.minDistance,t.maxDistance),i}}oe._FrustumCornersNdcSpace=[new E(-1,1,-1),new E(1,1,-1),new E(1,-1,-1),new E(-1,-1,-1),new E(-1,1,1),new E(1,1,1),new E(1,-1,1),new E(-1,-1,1)],oe.CLASSNAME="CascadedShadowGenerator",oe.DEFAULT_CASCADES_COUNT=4,oe.MIN_CASCADES_COUNT=2,oe.MAX_CASCADES_COUNT=4,oe._SceneComponentInitialization=e=>{throw p("ShadowGeneratorSceneComponent")};class he{constructor(e){this.name=w.NAME_SHADOWGENERATOR,this.scene=e}register(){this.scene._gatherRenderTargetsStage.registerStep(w.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR,this,this._gatherRenderTargets)}rebuild(){}serialize(e){e.shadowGenerators=[];const t=this.scene.lights;for(const s of t){if(s.doNotSerialize)continue;const t=s.getShadowGenerators();if(t){const s=t.values();for(let t=s.next();!0!==t.done;t=s.next()){const s=t.value;s.doNotSerialize||e.shadowGenerators.push(s.serialize())}}}}addFromContainer(e){}removeFromContainer(e,t){}dispose(){}_gatherRenderTargets(e){const t=this.scene;if(this.scene.shadowsEnabled)for(let s=0;s<t.lights.length;s++){const i=t.lights[s],n=i.getShadowGenerators();if(i.isEnabled()&&i.shadowEnabled&&n){const s=n.values();for(let i=s.next();!0!==i.done;i=s.next()){const s=i.value.getShadowMap();-1!==t.textures.indexOf(s)&&e.push(s)}}}}}e._SceneComponentInitialization=e=>{let t=e._getComponent(w.NAME_SHADOWGENERATOR);t||(t=new he(e),e._addComponent(t))};export{he as ShadowGeneratorSceneComponent};
//# sourceMappingURL=shadowGeneratorSceneComponent-DeYx6hAu.esm.min.js.map
