{"version":3,"file":"stlFileLoader-WbHVuseT.esm.min.js","sources":["../../../../../dev/loaders/dist/STL/stlFileLoader.js"],"sourcesContent":["import { Tools } from \"core/Misc/tools\";\nimport { VertexBuffer } from \"core/Buffers/buffer\";\nimport { Mesh } from \"core/Meshes/mesh\";\nimport { RegisterSceneLoaderPlugin } from \"core/Loading/sceneLoader\";\nimport { AssetContainer } from \"core/assetContainer\";\nimport { STLFileLoaderMetadata } from \"./stlFileLoader.metadata\";\nimport \"core/Materials/standardMaterial\";\n/**\n * STL file type loader.\n * This is a babylon scene loader plugin.\n */\nexport class STLFileLoader {\n    constructor() {\n        /** @internal */\n        this.solidPattern = /solid (\\S*)([\\S\\s]*?)endsolid[ ]*(\\S*)/g;\n        /** @internal */\n        this.facetsPattern = /facet([\\s\\S]*?)endfacet/g;\n        /** @internal */\n        this.normalPattern = /normal[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\n        /** @internal */\n        this.vertexPattern = /vertex[\\s]+([-+]?[0-9]+\\.?[0-9]*([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+[\\s]+([-+]?[0-9]*\\.?[0-9]+([eE][-+]?[0-9]+)?)+/g;\n        /**\n         * Defines the name of the plugin.\n         */\n        this.name = STLFileLoaderMetadata.name;\n        /**\n         * Defines the extensions the stl loader is able to load.\n         * force data to come in as an ArrayBuffer\n         * we'll convert to string if it looks like it's an ASCII .stl\n         */\n        this.extensions = STLFileLoaderMetadata.extensions;\n    }\n    /**\n     * Import meshes into a scene.\n     * @param meshesNames An array of mesh names, a single mesh name, or empty string for all meshes that filter what meshes are imported\n     * @param scene The scene to import into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @param meshes The meshes array to import into\n     * @returns True if successful or false otherwise\n     */\n    importMesh(meshesNames, scene, data, rootUrl, meshes) {\n        let matches;\n        if (typeof data !== \"string\") {\n            if (this._isBinary(data)) {\n                // binary .stl\n                const babylonMesh = new Mesh(\"stlmesh\", scene);\n                this._parseBinary(babylonMesh, data);\n                if (meshes) {\n                    meshes.push(babylonMesh);\n                }\n                return true;\n            }\n            // ASCII .stl\n            // convert to string\n            data = new TextDecoder().decode(new Uint8Array(data));\n        }\n        //if arrived here, data is a string, containing the STLA data.\n        while ((matches = this.solidPattern.exec(data))) {\n            let meshName = matches[1];\n            const meshNameFromEnd = matches[3];\n            if (meshNameFromEnd && meshName != meshNameFromEnd) {\n                Tools.Error(\"Error in STL, solid name != endsolid name\");\n                return false;\n            }\n            // check meshesNames\n            if (meshesNames && meshName) {\n                if (meshesNames instanceof Array) {\n                    if (!meshesNames.indexOf(meshName)) {\n                        continue;\n                    }\n                }\n                else {\n                    if (meshName !== meshesNames) {\n                        continue;\n                    }\n                }\n            }\n            // stl mesh name can be empty as well\n            meshName = meshName || \"stlmesh\";\n            const babylonMesh = new Mesh(meshName, scene);\n            this._parseASCII(babylonMesh, matches[2]);\n            if (meshes) {\n                meshes.push(babylonMesh);\n            }\n        }\n        return true;\n    }\n    /**\n     * Load into a scene.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns true if successful or false otherwise\n     */\n    load(scene, data, rootUrl) {\n        const result = this.importMesh(null, scene, data, rootUrl, null);\n        return result;\n    }\n    /**\n     * Load into an asset container.\n     * @param scene The scene to load into\n     * @param data The data to import\n     * @param rootUrl The root url for scene and resources\n     * @returns The loaded asset container\n     */\n    loadAssetContainer(scene, data, rootUrl) {\n        const container = new AssetContainer(scene);\n        scene._blockEntityCollection = true;\n        this.importMesh(null, scene, data, rootUrl, container.meshes);\n        scene._blockEntityCollection = false;\n        return container;\n    }\n    _isBinary(data) {\n        // check if file size is correct for binary stl\n        const reader = new DataView(data);\n        // A Binary STL header is 80 bytes, if the data size is not great than\n        // that then it's not a binary STL.\n        if (reader.byteLength <= 80) {\n            return false;\n        }\n        const faceSize = (32 / 8) * 3 + (32 / 8) * 3 * 3 + 16 / 8;\n        const nFaces = reader.getUint32(80, true);\n        if (80 + 32 / 8 + nFaces * faceSize === reader.byteLength) {\n            return true;\n        }\n        // US-ASCII begin with 's', 'o', 'l', 'i', 'd'\n        const ascii = [115, 111, 108, 105, 100];\n        for (let off = 0; off < 5; off++) {\n            if (reader.getUint8(off) !== ascii[off]) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _parseBinary(mesh, data) {\n        const reader = new DataView(data);\n        const faces = reader.getUint32(80, true);\n        const dataOffset = 84;\n        const faceLength = 12 * 4 + 2;\n        let offset = 0;\n        const positions = new Float32Array(faces * 3 * 3);\n        const normals = new Float32Array(faces * 3 * 3);\n        const indices = new Uint32Array(faces * 3);\n        let indicesCount = 0;\n        for (let face = 0; face < faces; face++) {\n            const start = dataOffset + face * faceLength;\n            const normalX = reader.getFloat32(start, true);\n            const normalY = reader.getFloat32(start + 4, true);\n            const normalZ = reader.getFloat32(start + 8, true);\n            for (let i = 1; i <= 3; i++) {\n                const vertexstart = start + i * 12;\n                // ordering is intentional to match ascii import\n                positions[offset] = reader.getFloat32(vertexstart, true);\n                normals[offset] = normalX;\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 4, true);\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 8, true);\n                    normals[offset + 2] = normalY;\n                    normals[offset + 1] = normalZ;\n                }\n                else {\n                    positions[offset + 1] = reader.getFloat32(vertexstart + 4, true);\n                    positions[offset + 2] = reader.getFloat32(vertexstart + 8, true);\n                    normals[offset + 1] = normalY;\n                    normals[offset + 2] = normalZ;\n                }\n                offset += 3;\n            }\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\n                indices[indicesCount] = indicesCount;\n                indices[indicesCount + 1] = indicesCount + 2;\n                indices[indicesCount + 2] = indicesCount + 1;\n                indicesCount += 3;\n            }\n            else {\n                indices[indicesCount] = indicesCount++;\n                indices[indicesCount] = indicesCount++;\n                indices[indicesCount] = indicesCount++;\n            }\n        }\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n        mesh.setIndices(indices);\n        mesh.computeWorldMatrix(true);\n    }\n    _parseASCII(mesh, solidData) {\n        const positions = [];\n        const normals = [];\n        const indices = [];\n        let indicesCount = 0;\n        //load facets, ignoring loop as the standard doesn't define it can contain more than vertices\n        let matches;\n        while ((matches = this.facetsPattern.exec(solidData))) {\n            const facet = matches[1];\n            //one normal per face\n            const normalMatches = this.normalPattern.exec(facet);\n            this.normalPattern.lastIndex = 0;\n            if (!normalMatches) {\n                continue;\n            }\n            const normal = [Number(normalMatches[1]), Number(normalMatches[5]), Number(normalMatches[3])];\n            let vertexMatch;\n            while ((vertexMatch = this.vertexPattern.exec(facet))) {\n                if (!STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[5]), Number(vertexMatch[3]));\n                    normals.push(normal[0], normal[1], normal[2]);\n                }\n                else {\n                    positions.push(Number(vertexMatch[1]), Number(vertexMatch[3]), Number(vertexMatch[5]));\n                    // Flipping the second and third component because inverted\n                    // when normal was declared.\n                    normals.push(normal[0], normal[2], normal[1]);\n                }\n            }\n            if (STLFileLoader.DO_NOT_ALTER_FILE_COORDINATES) {\n                indices.push(indicesCount, indicesCount + 2, indicesCount + 1);\n                indicesCount += 3;\n            }\n            else {\n                indices.push(indicesCount++, indicesCount++, indicesCount++);\n            }\n            this.vertexPattern.lastIndex = 0;\n        }\n        this.facetsPattern.lastIndex = 0;\n        mesh.setVerticesData(VertexBuffer.PositionKind, positions);\n        mesh.setVerticesData(VertexBuffer.NormalKind, normals);\n        mesh.setIndices(indices);\n        mesh.computeWorldMatrix(true);\n    }\n}\n/**\n * Defines if Y and Z axes are swapped or not when loading an STL file.\n * The default is false to maintain backward compatibility. When set to\n * true, coordinates from the STL file are used without change.\n */\nSTLFileLoader.DO_NOT_ALTER_FILE_COORDINATES = false;\nRegisterSceneLoaderPlugin(new STLFileLoader());\n//# sourceMappingURL=stlFileLoader.js.map"],"names":["STLFileLoader","constructor","this","solidPattern","facetsPattern","normalPattern","vertexPattern","name","STLFileLoaderMetadata","extensions","importMesh","meshesNames","scene","data","rootUrl","meshes","matches","_isBinary","babylonMesh","Mesh","_parseBinary","push","TextDecoder","decode","Uint8Array","exec","meshName","meshNameFromEnd","Tools","Error","Array","indexOf","_parseASCII","load","loadAssetContainer","container","AssetContainer","_blockEntityCollection","reader","DataView","byteLength","getUint32","ascii","off","getUint8","mesh","faces","offset","positions","Float32Array","normals","indices","Uint32Array","indicesCount","face","start","normalX","getFloat32","normalY","normalZ","i","vertexstart","DO_NOT_ALTER_FILE_COORDINATES","setVerticesData","VertexBuffer","PositionKind","NormalKind","setIndices","computeWorldMatrix","solidData","facet","normalMatches","lastIndex","normal","Number","vertexMatch","RegisterSceneLoaderPlugin"],"mappings":"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"}