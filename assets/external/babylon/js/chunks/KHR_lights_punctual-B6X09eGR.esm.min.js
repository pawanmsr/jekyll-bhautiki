import{c0 as e,ac as t,b as i,p as s,bD as n,_ as o,s as r,g as a,cg as h,b1 as l,bS as d,bR as f}from"./index-C7lpuH7l.esm.min.js";import{b as c}from"./objectModelMapping-EW6prSP3.esm.min.js";import{ArrayItem as u,GLTFLoader as m}from"./glTFLoader-Cy3hFpAv.esm.min.js";import"./bone-C8BOn9ne.esm.min.js";import"./skeleton-CpeT1KDV.esm.min.js";import"./rawTexture-GcKYJ37d.esm.min.js";import"./assetContainer-BpinJ-Pb.esm.min.js";n.AddNodeConstructor("Light_Type_0",((e,t)=>()=>new g(e,i.Zero(),t)));class g extends e{get shadowAngle(){return this._shadowAngle}set shadowAngle(e){this._shadowAngle=e,this.forceProjectionMatrixCompute()}get direction(){return this._direction}set direction(e){const t=this.needCube();if(this._direction=e,this.needCube()!==t&&this._shadowGenerators){const e=this._shadowGenerators.values();for(let t=e.next();!0!==t.done;t=e.next()){t.value.recreateShadowMap()}}}constructor(e,t,i,s){super(e,i,s),this._shadowAngle=Math.PI/2,this.position=t}getClassName(){return"PointLight"}getTypeID(){return t.LIGHTTYPEID_POINTLIGHT}needCube(){return!this.direction}getShadowDirection(e){if(this.direction)return super.getShadowDirection(e);switch(e){case 0:return new i(1,0,0);case 1:return new i(-1,0,0);case 2:return new i(0,-1,0);case 3:return new i(0,1,0);case 4:return new i(0,0,1);case 5:return new i(0,0,-1)}return i.Zero()}_setDefaultShadowProjectionMatrix(e,t,i){const n=this.getScene().activeCamera,o=this.getDepthMinZ(n),r=this.getDepthMaxZ(n),a=this.getScene().getEngine().useReverseDepthBuffer;s.PerspectiveFovLHToRef(this.shadowAngle,1,a?r:o,a?o:r,e,!0,this._scene.getEngine().isNDCHalfZRange,void 0,a)}_buildUniformLayout(){this._uniformBuffer.addUniform("vLightData",4),this._uniformBuffer.addUniform("vLightDiffuse",4),this._uniformBuffer.addUniform("vLightSpecular",4),this._uniformBuffer.addUniform("vLightFalloff",4),this._uniformBuffer.addUniform("shadowsInfo",3),this._uniformBuffer.addUniform("depthValues",2),this._uniformBuffer.create()}transferToEffect(e,t){const i=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?this._uniformBuffer.updateFloat4("vLightData",this.transformedPosition.x-i.x,this.transformedPosition.y-i.y,this.transformedPosition.z-i.z,0,t):this._uniformBuffer.updateFloat4("vLightData",this.position.x-i.x,this.position.y-i.y,this.position.z-i.z,0,t),this._uniformBuffer.updateFloat4("vLightFalloff",this.range,this._inverseSquaredRange,0,0,t),this}transferToNodeMaterialEffect(e,t){const i=this._scene.floatingOriginOffset;return this.computeTransformedInformation()?e.setFloat3(t,this.transformedPosition.x-i.x,this.transformedPosition.y-i.y,this.transformedPosition.z-i.z):e.setFloat3(t,this.position.x-i.x,this.position.y-i.y,this.position.z-i.z),this}prepareLightSpecificDefines(e,t){e["POINTLIGHT"+t]=!0}}o([r()],g.prototype,"shadowAngle",null),a("BABYLON.PointLight",g);const _="KHR_lights_punctual";class p{constructor(e){this.name=_,this._loader=e,this.enabled=this._loader.isExtensionUsed(_)}dispose(){this._loader=null,delete this._lights}onLoading(){const e=this._loader.gltf.extensions;if(e&&e[this.name]){const t=e[this.name];this._lights=t.lights,u.Assign(this._lights)}}loadNodeAsync(e,s,n){return m.LoadExtensionAsync(e,s,this.name,(async(o,r)=>(this._loader._allMaterialsDirtyRequired=!0,await this._loader.loadNodeAsync(e,s,(e=>{let s;const a=u.Get(o,this._lights,r.light),d=a.name||e.name;switch(this._loader.babylonScene._blockEntityCollection=!!this._loader._assetContainer,a.type){case"directional":{const e=new h(d,i.Backward(),this._loader.babylonScene);e.position.setAll(0),s=e;break}case"point":s=new g(d,i.Zero(),this._loader.babylonScene);break;case"spot":{const e=new c(d,i.Zero(),i.Backward(),0,1,this._loader.babylonScene);e.angle=2*(a.spot&&a.spot.outerConeAngle||Math.PI/4),e.innerAngle=2*(a.spot&&a.spot.innerConeAngle||0),s=e;break}default:throw this._loader.babylonScene._blockEntityCollection=!1,new Error(`${o}: Invalid light type (${a.type})`)}s._parentContainer=this._loader._assetContainer,this._loader.babylonScene._blockEntityCollection=!1,a._babylonLight=s,s.falloffType=t.FALLOFF_GLTF,s.diffuse=a.color?l.FromArray(a.color):l.White(),s.intensity=null==a.intensity?1:a.intensity,s.range=null==a.range?Number.MAX_VALUE:a.range,s.parent=e,this._loader._babylonLights.push(s),m.AddPointerMetadata(s,o),n(e)})))))}}d(_),f(_,!0,(e=>new p(e)));export{p as KHR_lights};
//# sourceMappingURL=KHR_lights_punctual-B6X09eGR.esm.min.js.map
