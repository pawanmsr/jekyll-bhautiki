{"version":3,"file":"flowGraphDataSwitchBlock-BrdiXXKI.esm.min.js","sources":["../../../../../dev/core/dist/FlowGraph/Blocks/Data/flowGraphDataSwitchBlock.js"],"sourcesContent":["import { FlowGraphBlock } from \"core/FlowGraph/flowGraphBlock\";\nimport { RichTypeAny } from \"core/FlowGraph/flowGraphRichTypes\";\nimport { getNumericValue, isNumeric } from \"core/FlowGraph/utils\";\nimport { RegisterClass } from \"core/Misc/typeStore\";\n/**\n * This block conditionally outputs one of its inputs, based on a condition and a list of cases.\n *\n * This of it as a passive (data) version of the switch statement in programming languages.\n */\nexport class FlowGraphDataSwitchBlock extends FlowGraphBlock {\n    constructor(\n    /**\n     * the configuration of the block\n     */\n    config) {\n        super(config);\n        this.config = config;\n        this._inputCases = new Map();\n        this.case = this.registerDataInput(\"case\", RichTypeAny, NaN);\n        this.default = this.registerDataInput(\"default\", RichTypeAny);\n        this.value = this.registerDataOutput(\"value\", RichTypeAny);\n        // iterate the set not using for of\n        const array = this.config.cases || [];\n        for (let caseValue of array) {\n            // if treat as integers, make sure not to set it again if it exists\n            caseValue = getNumericValue(caseValue);\n            if (this.config.treatCasesAsIntegers) {\n                caseValue = caseValue | 0;\n                if (this._inputCases.has(caseValue)) {\n                    return;\n                }\n            }\n            this._inputCases.set(caseValue, this.registerDataInput(`in_${caseValue}`, RichTypeAny));\n        }\n    }\n    _updateOutputs(context) {\n        const selectionValue = this.case.getValue(context);\n        let outputValue;\n        if (isNumeric(selectionValue)) {\n            outputValue = this._getOutputValueForCase(getNumericValue(selectionValue), context);\n        }\n        if (!outputValue) {\n            outputValue = this.default.getValue(context);\n        }\n        this.value.setValue(outputValue, context);\n    }\n    _getOutputValueForCase(caseValue, context) {\n        return this._inputCases.get(caseValue)?.getValue(context);\n    }\n    getClassName() {\n        return \"FlowGraphDataSwitchBlock\" /* FlowGraphBlockNames.DataSwitch */;\n    }\n}\nRegisterClass(\"FlowGraphDataSwitchBlock\" /* FlowGraphBlockNames.DataSwitch */, FlowGraphDataSwitchBlock);\n//# sourceMappingURL=flowGraphDataSwitchBlock.js.map"],"names":["FlowGraphDataSwitchBlock","FlowGraphBlock","constructor","config","super","this","_inputCases","Map","case","registerDataInput","RichTypeAny","NaN","default","value","registerDataOutput","array","cases","caseValue","getNumericValue","treatCasesAsIntegers","has","set","_updateOutputs","context","selectionValue","getValue","outputValue","isNumeric","_getOutputValueForCase","setValue","get","getClassName","RegisterClass"],"mappings":"uOASO,MAAMA,UAAiCC,EAC1C,WAAAC,CAIAC,GACIC,MAAMD,GACNE,KAAKF,OAASA,EACdE,KAAKC,YAAc,IAAIC,IACvBF,KAAKG,KAAOH,KAAKI,kBAAkB,OAAQC,EAAaC,KACxDN,KAAKO,QAAUP,KAAKI,kBAAkB,UAAWC,GACjDL,KAAKQ,MAAQR,KAAKS,mBAAmB,QAASJ,GAE9C,MAAMK,EAAQV,KAAKF,OAAOa,OAAS,GACnC,IAAK,IAAIC,KAAaF,EAAO,CAGzB,GADAE,EAAYC,EAAgBD,GACxBZ,KAAKF,OAAOgB,uBACZF,GAAwB,EACpBZ,KAAKC,YAAYc,IAAIH,IACrB,OAGRZ,KAAKC,YAAYe,IAAIJ,EAAWZ,KAAKI,kBAAkB,MAAMQ,IAAaP,GACtF,CACA,CACI,cAAAY,CAAeC,GACX,MAAMC,EAAiBnB,KAAKG,KAAKiB,SAASF,GAC1C,IAAIG,EACAC,EAAUH,KACVE,EAAcrB,KAAKuB,uBAAuBV,EAAgBM,GAAiBD,IAE1EG,IACDA,EAAcrB,KAAKO,QAAQa,SAASF,IAExClB,KAAKQ,MAAMgB,SAASH,EAAaH,EACzC,CACI,sBAAAK,CAAuBX,EAAWM,GAC9B,OAAOlB,KAAKC,YAAYwB,IAAIb,IAAYQ,SAASF,EACzD,CACI,YAAAQ,GACI,MAAO,0BACf,EAEAC,EAAc,2BAAiEhC"}