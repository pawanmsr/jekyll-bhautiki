{"version":3,"file":"dds-WUdGfAlt.esm.min.js","sources":["../../../../../dev/core/dist/Misc/dds.js"],"sourcesContent":["/* eslint-disable @typescript-eslint/naming-convention */\nimport { Clamp } from \"../Maths/math.scalar.functions\";\nimport { Constants } from \"../Engines/constants\";\nimport { Logger } from \"../Misc/logger\";\nimport { CubeMapToSphericalPolynomialTools } from \"../Misc/HighDynamicRange/cubemapToSphericalPolynomial\";\nimport { FromHalfFloat, ToHalfFloat } from \"./textureTools\";\nimport \"../Engines/AbstractEngine/abstractEngine.cubeTexture\";\n// Based on demo done by Brandon Jones - http://media.tojicode.com/webgl-samples/dds.html\n// All values and structures referenced from:\n// http://msdn.microsoft.com/en-us/library/bb943991.aspx/\nconst DDS_MAGIC = 0x20534444;\nconst //DDSD_CAPS = 0x1,\n//DDSD_HEIGHT = 0x2,\n//DDSD_WIDTH = 0x4,\n//DDSD_PITCH = 0x8,\n//DDSD_PIXELFORMAT = 0x1000,\nDDSD_MIPMAPCOUNT = 0x20000;\n//DDSD_LINEARSIZE = 0x80000,\n//DDSD_DEPTH = 0x800000;\n// var DDSCAPS_COMPLEX = 0x8,\n//     DDSCAPS_MIPMAP = 0x400000,\n//     DDSCAPS_TEXTURE = 0x1000;\nconst DDSCAPS2_CUBEMAP = 0x200;\n// DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,\n// DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,\n// DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,\n// DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,\n// DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,\n// DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,\n// DDSCAPS2_VOLUME = 0x200000;\nconst //DDPF_ALPHAPIXELS = 0x1,\n//DDPF_ALPHA = 0x2,\nDDPF_FOURCC = 0x4, DDPF_RGB = 0x40, \n//DDPF_YUV = 0x200,\nDDPF_LUMINANCE = 0x20000;\nfunction FourCCToInt32(value) {\n    return value.charCodeAt(0) + (value.charCodeAt(1) << 8) + (value.charCodeAt(2) << 16) + (value.charCodeAt(3) << 24);\n}\nfunction Int32ToFourCC(value) {\n    return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);\n}\nconst FOURCC_DXT1 = FourCCToInt32(\"DXT1\");\nconst FOURCC_DXT3 = FourCCToInt32(\"DXT3\");\nconst FOURCC_DXT5 = FourCCToInt32(\"DXT5\");\nconst FOURCC_DX10 = FourCCToInt32(\"DX10\");\nconst FOURCC_D3DFMT_R16G16B16A16F = 113;\nconst FOURCC_D3DFMT_R32G32B32A32F = 116;\nconst DXGI_FORMAT_R32G32B32A32_FLOAT = 2;\nconst DXGI_FORMAT_R16G16B16A16_FLOAT = 10;\nconst DXGI_FORMAT_B8G8R8X8_UNORM = 88;\nconst headerLengthInt = 31; // The header length in 32 bit ints\n// Offsets into the header array\nconst off_magic = 0;\nconst off_size = 1;\nconst off_flags = 2;\nconst off_height = 3;\nconst off_width = 4;\nconst off_mipmapCount = 7;\nconst off_pfFlags = 20;\nconst off_pfFourCC = 21;\nconst off_RGBbpp = 22;\nconst off_RMask = 23;\nconst off_GMask = 24;\nconst off_BMask = 25;\nconst off_AMask = 26;\n// var off_caps1 = 27;\nconst off_caps2 = 28;\n// var off_caps3 = 29;\n// var off_caps4 = 30;\nconst off_dxgiFormat = 32;\n/**\n * Class used to provide DDS decompression tools\n */\nexport class DDSTools {\n    /**\n     * Gets DDS information from an array buffer\n     * @param data defines the array buffer view to read data from\n     * @returns the DDS information\n     */\n    static GetDDSInfo(data) {\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n        const extendedHeader = new Int32Array(data.buffer, data.byteOffset, headerLengthInt + 4);\n        let mipmapCount = 1;\n        if (header[off_flags] & DDSD_MIPMAPCOUNT) {\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\n        }\n        const fourCC = header[off_pfFourCC];\n        const dxgiFormat = fourCC === FOURCC_DX10 ? extendedHeader[off_dxgiFormat] : 0;\n        let textureType = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n        switch (fourCC) {\n            case FOURCC_D3DFMT_R16G16B16A16F:\n                textureType = Constants.TEXTURETYPE_HALF_FLOAT;\n                break;\n            case FOURCC_D3DFMT_R32G32B32A32F:\n                textureType = Constants.TEXTURETYPE_FLOAT;\n                break;\n            case FOURCC_DX10:\n                if (dxgiFormat === DXGI_FORMAT_R16G16B16A16_FLOAT) {\n                    textureType = Constants.TEXTURETYPE_HALF_FLOAT;\n                    break;\n                }\n                if (dxgiFormat === DXGI_FORMAT_R32G32B32A32_FLOAT) {\n                    textureType = Constants.TEXTURETYPE_FLOAT;\n                    break;\n                }\n        }\n        return {\n            width: header[off_width],\n            height: header[off_height],\n            mipmapCount: mipmapCount,\n            isFourCC: (header[off_pfFlags] & DDPF_FOURCC) === DDPF_FOURCC,\n            isRGB: (header[off_pfFlags] & DDPF_RGB) === DDPF_RGB,\n            isLuminance: (header[off_pfFlags] & DDPF_LUMINANCE) === DDPF_LUMINANCE,\n            isCube: (header[off_caps2] & DDSCAPS2_CUBEMAP) === DDSCAPS2_CUBEMAP,\n            isCompressed: fourCC === FOURCC_DXT1 || fourCC === FOURCC_DXT3 || fourCC === FOURCC_DXT5,\n            dxgiFormat: dxgiFormat,\n            textureType: textureType,\n        };\n    }\n    static _GetHalfFloatAsFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Float32Array(dataLength);\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                destArray[index] = FromHalfFloat(srcData[srcPos]);\n                destArray[index + 1] = FromHalfFloat(srcData[srcPos + 1]);\n                destArray[index + 2] = FromHalfFloat(srcData[srcPos + 2]);\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = lod;\n                }\n                else {\n                    destArray[index + 3] = FromHalfFloat(srcData[srcPos + 3]);\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        if (DDSTools.StoreLODInAlphaChannel) {\n            const destArray = new Uint16Array(dataLength);\n            const srcData = new Uint16Array(arrayBuffer, dataOffset);\n            let index = 0;\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const srcPos = (x + y * width) * 4;\n                    destArray[index] = srcData[srcPos];\n                    destArray[index + 1] = srcData[srcPos + 1];\n                    destArray[index + 2] = srcData[srcPos + 2];\n                    destArray[index + 3] = ToHalfFloat(lod);\n                    index += 4;\n                }\n            }\n            return destArray;\n        }\n        return new Uint16Array(arrayBuffer, dataOffset, dataLength);\n    }\n    static _GetFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        if (DDSTools.StoreLODInAlphaChannel) {\n            const destArray = new Float32Array(dataLength);\n            const srcData = new Float32Array(arrayBuffer, dataOffset);\n            let index = 0;\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    const srcPos = (x + y * width) * 4;\n                    destArray[index] = srcData[srcPos];\n                    destArray[index + 1] = srcData[srcPos + 1];\n                    destArray[index + 2] = srcData[srcPos + 2];\n                    destArray[index + 3] = lod;\n                    index += 4;\n                }\n            }\n            return destArray;\n        }\n        return new Float32Array(arrayBuffer, dataOffset, dataLength);\n    }\n    static _GetFloatAsHalfFloatRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Uint16Array(dataLength);\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                destArray[index] = ToHalfFloat(srcData[index]);\n                destArray[index + 1] = ToHalfFloat(srcData[index + 1]);\n                destArray[index + 2] = ToHalfFloat(srcData[index + 2]);\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = ToHalfFloat(lod);\n                }\n                else {\n                    destArray[index + 3] = ToHalfFloat(srcData[index + 3]);\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Uint8Array(dataLength);\n        const srcData = new Float32Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                destArray[index] = Clamp(srcData[srcPos]) * 255;\n                destArray[index + 1] = Clamp(srcData[srcPos + 1]) * 255;\n                destArray[index + 2] = Clamp(srcData[srcPos + 2]) * 255;\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = lod;\n                }\n                else {\n                    destArray[index + 3] = Clamp(srcData[srcPos + 3]) * 255;\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetHalfFloatAsUIntRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, lod) {\n        const destArray = new Uint8Array(dataLength);\n        const srcData = new Uint16Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                destArray[index] = Clamp(FromHalfFloat(srcData[srcPos])) * 255;\n                destArray[index + 1] = Clamp(FromHalfFloat(srcData[srcPos + 1])) * 255;\n                destArray[index + 2] = Clamp(FromHalfFloat(srcData[srcPos + 2])) * 255;\n                if (DDSTools.StoreLODInAlphaChannel) {\n                    destArray[index + 3] = lod;\n                }\n                else {\n                    destArray[index + 3] = Clamp(FromHalfFloat(srcData[srcPos + 3])) * 255;\n                }\n                index += 4;\n            }\n        }\n        return destArray;\n    }\n    static _GetRGBAArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset, aOffset) {\n        const byteArray = new Uint8Array(dataLength);\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 4;\n                byteArray[index] = srcData[srcPos + rOffset];\n                byteArray[index + 1] = srcData[srcPos + gOffset];\n                byteArray[index + 2] = srcData[srcPos + bOffset];\n                byteArray[index + 3] = srcData[srcPos + aOffset];\n                index += 4;\n            }\n        }\n        return byteArray;\n    }\n    static _ExtractLongWordOrder(value) {\n        if (value === 0 || value === 255 || value === -16777216) {\n            return 0;\n        }\n        return 1 + DDSTools._ExtractLongWordOrder(value >> 8);\n    }\n    static _GetRGBArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer, rOffset, gOffset, bOffset) {\n        const byteArray = new Uint8Array(dataLength);\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = (x + y * width) * 3;\n                byteArray[index] = srcData[srcPos + rOffset];\n                byteArray[index + 1] = srcData[srcPos + gOffset];\n                byteArray[index + 2] = srcData[srcPos + bOffset];\n                index += 3;\n            }\n        }\n        return byteArray;\n    }\n    static _GetLuminanceArrayBuffer(width, height, dataOffset, dataLength, arrayBuffer) {\n        const byteArray = new Uint8Array(dataLength);\n        const srcData = new Uint8Array(arrayBuffer, dataOffset);\n        let index = 0;\n        for (let y = 0; y < height; y++) {\n            for (let x = 0; x < width; x++) {\n                const srcPos = x + y * width;\n                byteArray[index] = srcData[srcPos];\n                index++;\n            }\n        }\n        return byteArray;\n    }\n    /**\n     * Uploads DDS Levels to a Babylon Texture\n     * @internal\n     */\n    static UploadDDSLevels(engine, texture, data, info, loadMipmaps, faces, lodIndex = -1, currentFace, destTypeMustBeFilterable = true) {\n        let sphericalPolynomialFaces = null;\n        if (info.sphericalPolynomial) {\n            sphericalPolynomialFaces = [];\n        }\n        const ext = !!engine.getCaps().s3tc;\n        // TODO WEBGPU Once generateMipMaps is split into generateMipMaps + hasMipMaps in InternalTexture this line can be removed\n        texture.generateMipMaps = loadMipmaps;\n        const header = new Int32Array(data.buffer, data.byteOffset, headerLengthInt);\n        let fourCC, width, height, dataLength = 0, dataOffset;\n        let byteArray, mipmapCount, mip;\n        let internalCompressedFormat = 0;\n        let blockBytes = 1;\n        if (header[off_magic] !== DDS_MAGIC) {\n            Logger.Error(\"Invalid magic number in DDS header\");\n            return;\n        }\n        if (!info.isFourCC && !info.isRGB && !info.isLuminance) {\n            Logger.Error(\"Unsupported format, must contain a FourCC, RGB or LUMINANCE code\");\n            return;\n        }\n        if (info.isCompressed && !ext) {\n            Logger.Error(\"Compressed textures are not supported on this platform.\");\n            return;\n        }\n        let bpp = header[off_RGBbpp];\n        dataOffset = header[off_size] + 4;\n        let computeFormats = false;\n        if (info.isFourCC) {\n            fourCC = header[off_pfFourCC];\n            switch (fourCC) {\n                case FOURCC_DXT1:\n                    blockBytes = 8;\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1;\n                    break;\n                case FOURCC_DXT3:\n                    blockBytes = 16;\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3;\n                    break;\n                case FOURCC_DXT5:\n                    blockBytes = 16;\n                    internalCompressedFormat = Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5;\n                    break;\n                case FOURCC_D3DFMT_R16G16B16A16F:\n                    computeFormats = true;\n                    bpp = 64;\n                    break;\n                case FOURCC_D3DFMT_R32G32B32A32F:\n                    computeFormats = true;\n                    bpp = 128;\n                    break;\n                case FOURCC_DX10: {\n                    // There is an additionnal header so dataOffset need to be changed\n                    dataOffset += 5 * 4; // 5 uints\n                    let supported = false;\n                    switch (info.dxgiFormat) {\n                        case DXGI_FORMAT_R16G16B16A16_FLOAT:\n                            computeFormats = true;\n                            bpp = 64;\n                            supported = true;\n                            break;\n                        case DXGI_FORMAT_R32G32B32A32_FLOAT:\n                            computeFormats = true;\n                            bpp = 128;\n                            supported = true;\n                            break;\n                        case DXGI_FORMAT_B8G8R8X8_UNORM:\n                            info.isRGB = true;\n                            info.isFourCC = false;\n                            bpp = 32;\n                            supported = true;\n                            break;\n                    }\n                    if (supported) {\n                        break;\n                    }\n                }\n                // eslint-disable-next-line no-fallthrough\n                default:\n                    Logger.Error([\"Unsupported FourCC code:\", Int32ToFourCC(fourCC)]);\n                    return;\n            }\n        }\n        const rOffset = DDSTools._ExtractLongWordOrder(header[off_RMask]);\n        const gOffset = DDSTools._ExtractLongWordOrder(header[off_GMask]);\n        const bOffset = DDSTools._ExtractLongWordOrder(header[off_BMask]);\n        const aOffset = DDSTools._ExtractLongWordOrder(header[off_AMask]);\n        if (computeFormats) {\n            internalCompressedFormat = engine._getRGBABufferInternalSizedFormat(info.textureType);\n        }\n        mipmapCount = 1;\n        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {\n            mipmapCount = Math.max(1, header[off_mipmapCount]);\n        }\n        const startFace = currentFace || 0;\n        const caps = engine.getCaps();\n        for (let face = startFace; face < faces; face++) {\n            width = header[off_width];\n            height = header[off_height];\n            for (mip = 0; mip < mipmapCount; ++mip) {\n                if (lodIndex === -1 || lodIndex === mip) {\n                    // In case of fixed LOD, if the lod has just been uploaded, early exit.\n                    const i = lodIndex === -1 ? mip : 0;\n                    if (!info.isCompressed && info.isFourCC) {\n                        texture.format = Constants.TEXTUREFORMAT_RGBA;\n                        dataLength = width * height * 4;\n                        let floatArray = null;\n                        if (engine._badOS || engine._badDesktopOS || (!caps.textureHalfFloat && !caps.textureFloat)) {\n                            // Required because iOS has many issues with float and half float generation\n                            if (bpp === 128) {\n                                floatArray = DDSTools._GetFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                                if (sphericalPolynomialFaces && i == 0) {\n                                    sphericalPolynomialFaces.push(DDSTools._GetFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                                }\n                            }\n                            else if (bpp === 64) {\n                                floatArray = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                                if (sphericalPolynomialFaces && i == 0) {\n                                    sphericalPolynomialFaces.push(DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i));\n                                }\n                            }\n                            texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n                        }\n                        else {\n                            const floatAvailable = caps.textureFloat && ((destTypeMustBeFilterable && caps.textureFloatLinearFiltering) || !destTypeMustBeFilterable);\n                            const halfFloatAvailable = caps.textureHalfFloat && ((destTypeMustBeFilterable && caps.textureHalfFloatLinearFiltering) || !destTypeMustBeFilterable);\n                            const destType = (bpp === 128 || (bpp === 64 && !halfFloatAvailable)) && floatAvailable\n                                ? Constants.TEXTURETYPE_FLOAT\n                                : (bpp === 64 || (bpp === 128 && !floatAvailable)) && halfFloatAvailable\n                                    ? Constants.TEXTURETYPE_HALF_FLOAT\n                                    : Constants.TEXTURETYPE_UNSIGNED_BYTE;\n                            let dataGetter;\n                            let dataGetterPolynomial = null;\n                            switch (bpp) {\n                                case 128: {\n                                    switch (destType) {\n                                        case Constants.TEXTURETYPE_FLOAT:\n                                            dataGetter = DDSTools._GetFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = null;\n                                            break;\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\n                                            dataGetter = DDSTools._GetFloatAsHalfFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                                            break;\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\n                                            dataGetter = DDSTools._GetFloatAsUIntRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetFloatRGBAArrayBuffer;\n                                            break;\n                                    }\n                                    break;\n                                }\n                                default: {\n                                    // 64 bpp\n                                    switch (destType) {\n                                        case Constants.TEXTURETYPE_FLOAT:\n                                            dataGetter = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = null;\n                                            break;\n                                        case Constants.TEXTURETYPE_HALF_FLOAT:\n                                            dataGetter = DDSTools._GetHalfFloatRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                                            break;\n                                        case Constants.TEXTURETYPE_UNSIGNED_BYTE:\n                                            dataGetter = DDSTools._GetHalfFloatAsUIntRGBAArrayBuffer;\n                                            dataGetterPolynomial = DDSTools._GetHalfFloatAsFloatRGBAArrayBuffer;\n                                            break;\n                                    }\n                                    break;\n                                }\n                            }\n                            texture.type = destType;\n                            floatArray = dataGetter(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i);\n                            if (sphericalPolynomialFaces && i == 0) {\n                                sphericalPolynomialFaces.push(dataGetterPolynomial ? dataGetterPolynomial(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, i) : floatArray);\n                            }\n                        }\n                        if (floatArray) {\n                            engine._uploadDataToTextureDirectly(texture, floatArray, face, i);\n                        }\n                    }\n                    else if (info.isRGB) {\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n                        if (bpp === 24) {\n                            texture.format = Constants.TEXTUREFORMAT_RGB;\n                            dataLength = width * height * 3;\n                            byteArray = DDSTools._GetRGBArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset);\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n                        }\n                        else {\n                            // 32\n                            texture.format = Constants.TEXTUREFORMAT_RGBA;\n                            dataLength = width * height * 4;\n                            byteArray = DDSTools._GetRGBAArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer, rOffset, gOffset, bOffset, aOffset);\n                            engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n                        }\n                    }\n                    else if (info.isLuminance) {\n                        const unpackAlignment = engine._getUnpackAlignement();\n                        const unpaddedRowSize = width;\n                        const paddedRowSize = Math.floor((width + unpackAlignment - 1) / unpackAlignment) * unpackAlignment;\n                        dataLength = paddedRowSize * (height - 1) + unpaddedRowSize;\n                        byteArray = DDSTools._GetLuminanceArrayBuffer(width, height, data.byteOffset + dataOffset, dataLength, data.buffer);\n                        texture.format = Constants.TEXTUREFORMAT_LUMINANCE;\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n                        engine._uploadDataToTextureDirectly(texture, byteArray, face, i);\n                    }\n                    else {\n                        dataLength = (((Math.max(4, width) / 4) * Math.max(4, height)) / 4) * blockBytes;\n                        byteArray = new Uint8Array(data.buffer, data.byteOffset + dataOffset, dataLength);\n                        texture.type = Constants.TEXTURETYPE_UNSIGNED_BYTE;\n                        engine._uploadCompressedDataToTextureDirectly(texture, internalCompressedFormat, width, height, byteArray, face, i);\n                    }\n                }\n                dataOffset += bpp ? width * height * (bpp / 8) : dataLength;\n                width *= 0.5;\n                height *= 0.5;\n                width = Math.max(1.0, width);\n                height = Math.max(1.0, height);\n            }\n            if (currentFace !== undefined) {\n                // Loading a single face\n                break;\n            }\n        }\n        if (sphericalPolynomialFaces && sphericalPolynomialFaces.length > 0) {\n            info.sphericalPolynomial = CubeMapToSphericalPolynomialTools.ConvertCubeMapToSphericalPolynomial({\n                size: header[off_width],\n                right: sphericalPolynomialFaces[0],\n                left: sphericalPolynomialFaces[1],\n                up: sphericalPolynomialFaces[2],\n                down: sphericalPolynomialFaces[3],\n                front: sphericalPolynomialFaces[4],\n                back: sphericalPolynomialFaces[5],\n                format: Constants.TEXTUREFORMAT_RGBA,\n                type: Constants.TEXTURETYPE_FLOAT,\n                gammaSpace: false,\n            });\n        }\n        else {\n            info.sphericalPolynomial = undefined;\n        }\n    }\n}\n/**\n * Gets or sets a boolean indicating that LOD info is stored in alpha channel (false by default)\n */\nDDSTools.StoreLODInAlphaChannel = false;\n//# sourceMappingURL=dds.js.map"],"names":["DDSD_MIPMAPCOUNT","DDPF_LUMINANCE","FourCCToInt32","value","charCodeAt","FOURCC_DXT1","FOURCC_DXT3","FOURCC_DXT5","FOURCC_DX10","DDSTools","GetDDSInfo","data","header","Int32Array","buffer","byteOffset","extendedHeader","headerLengthInt","mipmapCount","Math","max","fourCC","dxgiFormat","textureType","Constants","TEXTURETYPE_UNSIGNED_BYTE","TEXTURETYPE_HALF_FLOAT","TEXTURETYPE_FLOAT","width","height","isFourCC","isRGB","isLuminance","isCube","isCompressed","_GetHalfFloatAsFloatRGBAArrayBuffer","dataOffset","dataLength","arrayBuffer","lod","destArray","Float32Array","srcData","Uint16Array","index","y","x","srcPos","FromHalfFloat","StoreLODInAlphaChannel","_GetHalfFloatRGBAArrayBuffer","ToHalfFloat","_GetFloatRGBAArrayBuffer","_GetFloatAsHalfFloatRGBAArrayBuffer","_GetFloatAsUIntRGBAArrayBuffer","Uint8Array","Clamp","_GetHalfFloatAsUIntRGBAArrayBuffer","_GetRGBAArrayBuffer","rOffset","gOffset","bOffset","aOffset","byteArray","_ExtractLongWordOrder","_GetRGBArrayBuffer","_GetLuminanceArrayBuffer","UploadDDSLevels","engine","texture","info","loadMipmaps","faces","lodIndex","currentFace","destTypeMustBeFilterable","sphericalPolynomialFaces","sphericalPolynomial","ext","getCaps","s3tc","generateMipMaps","mip","internalCompressedFormat","blockBytes","Logger","Error","bpp","computeFormats","TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1","TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3","TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5","supported","String","fromCharCode","_getRGBABufferInternalSizedFormat","startFace","caps","face","i","format","TEXTUREFORMAT_RGBA","floatArray","_badOS","_badDesktopOS","textureHalfFloat","textureFloat","push","type","floatAvailable","textureFloatLinearFiltering","halfFloatAvailable","textureHalfFloatLinearFiltering","destType","dataGetter","dataGetterPolynomial","_uploadDataToTextureDirectly","TEXTUREFORMAT_RGB","unpackAlignment","_getUnpackAlignement","unpaddedRowSize","floor","TEXTUREFORMAT_LUMINANCE","_uploadCompressedDataToTextureDirectly","undefined","length","CubeMapToSphericalPolynomialTools","ConvertCubeMapToSphericalPolynomial","size","right","left","up","down","front","back","gammaSpace"],"mappings":"8IAUA,MAMAA,EAAmB,OAkBnBC,EAAiB,OACjB,SAASC,EAAcC,GACnB,OAAOA,EAAMC,WAAW,IAAMD,EAAMC,WAAW,IAAM,IAAMD,EAAMC,WAAW,IAAM,KAAOD,EAAMC,WAAW,IAAM,GACpH,CAIA,MAAMC,EAAcH,EAAc,QAC5BI,EAAcJ,EAAc,QAC5BK,EAAcL,EAAc,QAC5BM,EAAcN,EAAc,QA6B3B,MAAMO,EAMT,iBAAOC,CAAWC,GACd,MAAMC,EAAS,IAAIC,WAAWF,EAAKG,OAAQH,EAAKI,WA9BhC,IA+BVC,EAAiB,IAAIH,WAAWF,EAAKG,OAAQH,EAAKI,WAAYE,IACpE,IAAIC,EAAc,EACdN,EA7BM,GA6BcZ,IACpBkB,EAAcC,KAAKC,IAAI,EAAGR,EA3Bd,KA6BhB,MAAMS,EAAST,EA3BF,IA4BPU,EAAaD,IAAWb,EAAcQ,EAlB7B,IAkB8D,EAC7E,IAAIO,EAAcC,EAAUC,0BAC5B,OAAQJ,GACJ,KA7CwB,IA8CpBE,EAAcC,EAAUE,uBACxB,MACJ,KA/CwB,IAgDpBH,EAAcC,EAAUG,kBACxB,MACJ,KAAKnB,EACD,GAjDuB,KAiDnBc,EAA+C,CAC/CC,EAAcC,EAAUE,uBACxB,KACpB,CACgB,GAtDuB,IAsDnBJ,EAA+C,CAC/CC,EAAcC,EAAUG,kBACxB,KACpB,EAEQ,MAAO,CACHC,MAAOhB,EAnDD,GAoDNiB,OAAQjB,EArDD,GAsDPM,YAAaA,EACbY,WA9EE,GA8ESlB,EApDH,KAqDRmB,QA/EkB,IA+EVnB,EArDA,KAsDRoB,aAAcpB,EAtDN,IAsD4BX,KAAoBA,EACxDgC,SA3Fa,KA2FJrB,EA/CH,KAgDNsB,aAAcb,IAAWhB,GAAegB,IAAWf,GAAee,IAAWd,EAC7Ee,WAAYA,EACZC,YAAaA,EAEzB,CACI,0CAAOY,CAAoCP,EAAOC,EAAQO,EAAYC,EAAYC,EAAaC,GAC3F,MAAMC,EAAY,IAAIC,aAAaJ,GAC7BK,EAAU,IAAIC,YAAYL,EAAaF,GAC7C,IAAIQ,EAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAQgB,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOkB,IAAK,CAC5B,MAAMC,EAA2B,GAAjBD,EAAID,EAAIjB,GACxBY,EAAUI,GAASI,EAAcN,EAAQK,IACzCP,EAAUI,EAAQ,GAAKI,EAAcN,EAAQK,EAAS,IACtDP,EAAUI,EAAQ,GAAKI,EAAcN,EAAQK,EAAS,IAClDtC,EAASwC,uBACTT,EAAUI,EAAQ,GAAKL,EAGvBC,EAAUI,EAAQ,GAAKI,EAAcN,EAAQK,EAAS,IAE1DH,GAAS,CACzB,CAEQ,OAAOJ,CACf,CACI,mCAAOU,CAA6BtB,EAAOC,EAAQO,EAAYC,EAAYC,EAAaC,GACpF,GAAI9B,EAASwC,uBAAwB,CACjC,MAAMT,EAAY,IAAIG,YAAYN,GAC5BK,EAAU,IAAIC,YAAYL,EAAaF,GAC7C,IAAIQ,EAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAQgB,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOkB,IAAK,CAC5B,MAAMC,EAA2B,GAAjBD,EAAID,EAAIjB,GACxBY,EAAUI,GAASF,EAAQK,GAC3BP,EAAUI,EAAQ,GAAKF,EAAQK,EAAS,GACxCP,EAAUI,EAAQ,GAAKF,EAAQK,EAAS,GACxCP,EAAUI,EAAQ,GAAKO,EAAYZ,GACnCK,GAAS,CAC7B,CAEY,OAAOJ,CACnB,CACQ,OAAO,IAAIG,YAAYL,EAAaF,EAAYC,EACxD,CACI,+BAAOe,CAAyBxB,EAAOC,EAAQO,EAAYC,EAAYC,EAAaC,GAChF,GAAI9B,EAASwC,uBAAwB,CACjC,MAAMT,EAAY,IAAIC,aAAaJ,GAC7BK,EAAU,IAAID,aAAaH,EAAaF,GAC9C,IAAIQ,EAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAQgB,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOkB,IAAK,CAC5B,MAAMC,EAA2B,GAAjBD,EAAID,EAAIjB,GACxBY,EAAUI,GAASF,EAAQK,GAC3BP,EAAUI,EAAQ,GAAKF,EAAQK,EAAS,GACxCP,EAAUI,EAAQ,GAAKF,EAAQK,EAAS,GACxCP,EAAUI,EAAQ,GAAKL,EACvBK,GAAS,CAC7B,CAEY,OAAOJ,CACnB,CACQ,OAAO,IAAIC,aAAaH,EAAaF,EAAYC,EACzD,CACI,0CAAOgB,CAAoCzB,EAAOC,EAAQO,EAAYC,EAAYC,EAAaC,GAC3F,MAAMC,EAAY,IAAIG,YAAYN,GAC5BK,EAAU,IAAID,aAAaH,EAAaF,GAC9C,IAAIQ,EAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAQgB,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOkB,IACvBN,EAAUI,GAASO,EAAYT,EAAQE,IACvCJ,EAAUI,EAAQ,GAAKO,EAAYT,EAAQE,EAAQ,IACnDJ,EAAUI,EAAQ,GAAKO,EAAYT,EAAQE,EAAQ,IAC/CnC,EAASwC,uBACTT,EAAUI,EAAQ,GAAKO,EAAYZ,GAGnCC,EAAUI,EAAQ,GAAKO,EAAYT,EAAQE,EAAQ,IAEvDA,GAAS,EAGjB,OAAOJ,CACf,CACI,qCAAOc,CAA+B1B,EAAOC,EAAQO,EAAYC,EAAYC,EAAaC,GACtF,MAAMC,EAAY,IAAIe,WAAWlB,GAC3BK,EAAU,IAAID,aAAaH,EAAaF,GAC9C,IAAIQ,EAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAQgB,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOkB,IAAK,CAC5B,MAAMC,EAA2B,GAAjBD,EAAID,EAAIjB,GACxBY,EAAUI,GAAkC,IAAzBY,EAAMd,EAAQK,IACjCP,EAAUI,EAAQ,GAAkC,IAA7BY,EAAMd,EAAQK,EAAS,IAC9CP,EAAUI,EAAQ,GAAkC,IAA7BY,EAAMd,EAAQK,EAAS,IAC1CtC,EAASwC,uBACTT,EAAUI,EAAQ,GAAKL,EAGvBC,EAAUI,EAAQ,GAAkC,IAA7BY,EAAMd,EAAQK,EAAS,IAElDH,GAAS,CACzB,CAEQ,OAAOJ,CACf,CACI,yCAAOiB,CAAmC7B,EAAOC,EAAQO,EAAYC,EAAYC,EAAaC,GAC1F,MAAMC,EAAY,IAAIe,WAAWlB,GAC3BK,EAAU,IAAIC,YAAYL,EAAaF,GAC7C,IAAIQ,EAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAQgB,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOkB,IAAK,CAC5B,MAAMC,EAA2B,GAAjBD,EAAID,EAAIjB,GACxBY,EAAUI,GAAiD,IAAxCY,EAAMR,EAAcN,EAAQK,KAC/CP,EAAUI,EAAQ,GAAiD,IAA5CY,EAAMR,EAAcN,EAAQK,EAAS,KAC5DP,EAAUI,EAAQ,GAAiD,IAA5CY,EAAMR,EAAcN,EAAQK,EAAS,KACxDtC,EAASwC,uBACTT,EAAUI,EAAQ,GAAKL,EAGvBC,EAAUI,EAAQ,GAAiD,IAA5CY,EAAMR,EAAcN,EAAQK,EAAS,KAEhEH,GAAS,CACzB,CAEQ,OAAOJ,CACf,CACI,0BAAOkB,CAAoB9B,EAAOC,EAAQO,EAAYC,EAAYC,EAAaqB,EAASC,EAASC,EAASC,GACtG,MAAMC,EAAY,IAAIR,WAAWlB,GAC3BK,EAAU,IAAIa,WAAWjB,EAAaF,GAC5C,IAAIQ,EAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAQgB,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOkB,IAAK,CAC5B,MAAMC,EAA2B,GAAjBD,EAAID,EAAIjB,GACxBmC,EAAUnB,GAASF,EAAQK,EAASY,GACpCI,EAAUnB,EAAQ,GAAKF,EAAQK,EAASa,GACxCG,EAAUnB,EAAQ,GAAKF,EAAQK,EAASc,GACxCE,EAAUnB,EAAQ,GAAKF,EAAQK,EAASe,GACxClB,GAAS,CACzB,CAEQ,OAAOmB,CACf,CACI,4BAAOC,CAAsB7D,GACzB,OAAc,IAAVA,GAAyB,MAAVA,IAA2B,WAAVA,EACzB,EAEJ,EAAIM,EAASuD,sBAAsB7D,GAAS,EAC3D,CACI,yBAAO8D,CAAmBrC,EAAOC,EAAQO,EAAYC,EAAYC,EAAaqB,EAASC,EAASC,GAC5F,MAAME,EAAY,IAAIR,WAAWlB,GAC3BK,EAAU,IAAIa,WAAWjB,EAAaF,GAC5C,IAAIQ,EAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAQgB,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOkB,IAAK,CAC5B,MAAMC,EAA2B,GAAjBD,EAAID,EAAIjB,GACxBmC,EAAUnB,GAASF,EAAQK,EAASY,GACpCI,EAAUnB,EAAQ,GAAKF,EAAQK,EAASa,GACxCG,EAAUnB,EAAQ,GAAKF,EAAQK,EAASc,GACxCjB,GAAS,CACzB,CAEQ,OAAOmB,CACf,CACI,+BAAOG,CAAyBtC,EAAOC,EAAQO,EAAYC,EAAYC,GACnE,MAAMyB,EAAY,IAAIR,WAAWlB,GAC3BK,EAAU,IAAIa,WAAWjB,EAAaF,GAC5C,IAAIQ,EAAQ,EACZ,IAAK,IAAIC,EAAI,EAAGA,EAAIhB,EAAQgB,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIlB,EAAOkB,IAAK,CAC5B,MAAMC,EAASD,EAAID,EAAIjB,EACvBmC,EAAUnB,GAASF,EAAQK,GAC3BH,GAChB,CAEQ,OAAOmB,CACf,CAKI,sBAAOI,CAAgBC,EAAQC,EAAS1D,EAAM2D,EAAMC,EAAaC,EAAOC,GAAW,EAAIC,EAAaC,GAA2B,GAC3H,IAAIC,EAA2B,KAC3BN,EAAKO,sBACLD,EAA2B,IAE/B,MAAME,IAAQV,EAAOW,UAAUC,KAE/BX,EAAQY,gBAAkBV,EAC1B,MAAM3D,EAAS,IAAIC,WAAWF,EAAKG,OAAQH,EAAKI,WA5PhC,IA6PhB,IAAIM,EAAQO,EAAOC,EAAwBO,EACvC2B,EAAW7C,EAAagE,EADD7C,EAAa,EAEpC8C,EAA2B,EAC3BC,EAAa,EACjB,GAzSU,YAySNxE,EA/PM,GAiQN,YADAyE,EAAOC,MAAM,sCAGjB,IAAKhB,EAAKxC,WAAawC,EAAKvC,QAAUuC,EAAKtC,YAEvC,YADAqD,EAAOC,MAAM,oEAGjB,GAAIhB,EAAKpC,eAAiB4C,EAEtB,YADAO,EAAOC,MAAM,2DAGjB,IAAIC,EAAM3E,EAnQC,IAoQXwB,EAAaxB,EA3QJ,GA2QuB,EAChC,IAAI4E,GAAiB,EACrB,GAAIlB,EAAKxC,SAEL,OADAT,EAAST,EAxQA,IAyQDS,GACJ,KAAKhB,EACD+E,EAAa,EACbD,EAA2B3D,EAAUiE,wCACrC,MACJ,KAAKnF,EACD8E,EAAa,GACbD,EAA2B3D,EAAUkE,wCACrC,MACJ,KAAKnF,EACD6E,EAAa,GACbD,EAA2B3D,EAAUmE,wCACrC,MACJ,KApSoB,IAqShBH,GAAiB,EACjBD,EAAM,GACN,MACJ,KAvSoB,IAwShBC,GAAiB,EACjBD,EAAM,IACN,MACJ,KAAK/E,EAAa,CAEd4B,GAAc,GACd,IAAIwD,GAAY,EAChB,OAAQtB,EAAKhD,YACT,KA9Se,GA+SXkE,GAAiB,EACjBD,EAAM,GACNK,GAAY,EACZ,MACJ,KApTe,EAqTXJ,GAAiB,EACjBD,EAAM,IACNK,GAAY,EACZ,MACJ,KAvTW,GAwTPtB,EAAKvC,OAAQ,EACbuC,EAAKxC,UAAW,EAChByD,EAAM,GACNK,GAAY,EAGpB,GAAIA,EACA,KAExB,CAEgB,QAEI,YADAP,EAAOC,MAAM,CAAC,4BA/UXnF,EA+UqDkB,EA9UjEwE,OAAOC,aAAqB,IAAR3F,EAAeA,GAAS,EAAK,IAAOA,GAAS,GAAM,IAAOA,GAAS,GAAM,QADxG,IAAuBA,EAmVf,MAAMwD,EAAUlD,EAASuD,sBAAsBpD,EA5TrC,KA6TJgD,EAAUnD,EAASuD,sBAAsBpD,EA5TrC,KA6TJiD,EAAUpD,EAASuD,sBAAsBpD,EA5TrC,KA6TJkD,EAAUrD,EAASuD,sBAAsBpD,EA5TrC,KA6TN4E,IACAL,EAA2Bf,EAAO2B,kCAAkCzB,EAAK/C,cAE7EL,EAAc,EACVN,EA3UM,GA2UcZ,IAAoC,IAAhBuE,IACxCrD,EAAcC,KAAKC,IAAI,EAAGR,EAzUd,KA2UhB,MAAMoF,EAAYtB,GAAe,EAC3BuB,EAAO7B,EAAOW,UACpB,IAAK,IAAImB,EAAOF,EAAWE,EAAO1B,EAAO0B,IAAQ,CAG7C,IAFAtE,EAAQhB,EA/UF,GAgVNiB,EAASjB,EAjVF,GAkVFsE,EAAM,EAAGA,EAAMhE,IAAegE,EAAK,CACpC,IAAiB,IAAbT,GAAmBA,IAAaS,EAAK,CAErC,MAAMiB,GAAmB,IAAf1B,EAAkBS,EAAM,EAClC,IAAKZ,EAAKpC,cAAgBoC,EAAKxC,SAAU,CACrCuC,EAAQ+B,OAAS5E,EAAU6E,mBAC3BhE,EAAaT,EAAQC,EAAS,EAC9B,IAAIyE,EAAa,KACjB,GAAIlC,EAAOmC,QAAUnC,EAAOoC,gBAAmBP,EAAKQ,mBAAqBR,EAAKS,aAE9D,MAARnB,GACAe,EAAa7F,EAAS6C,+BAA+B1B,EAAOC,EAAQlB,EAAKI,WAAaqB,EAAYC,EAAY1B,EAAKG,OAAQqF,GACvHvB,GAAiC,GAALuB,GAC5BvB,EAAyB+B,KAAKlG,EAAS2C,yBAAyBxB,EAAOC,EAAQlB,EAAKI,WAAaqB,EAAYC,EAAY1B,EAAKG,OAAQqF,KAG7H,KAARZ,IACLe,EAAa7F,EAASgD,mCAAmC7B,EAAOC,EAAQlB,EAAKI,WAAaqB,EAAYC,EAAY1B,EAAKG,OAAQqF,GAC3HvB,GAAiC,GAALuB,GAC5BvB,EAAyB+B,KAAKlG,EAAS0B,oCAAoCP,EAAOC,EAAQlB,EAAKI,WAAaqB,EAAYC,EAAY1B,EAAKG,OAAQqF,KAGzJ9B,EAAQuC,KAAOpF,EAAUC,8BAExB,CACD,MAAMoF,EAAiBZ,EAAKS,eAAkB/B,GAA4BsB,EAAKa,8BAAiCnC,GAC1GoC,EAAqBd,EAAKQ,mBAAsB9B,GAA4BsB,EAAKe,kCAAqCrC,GACtHsC,GAAoB,MAAR1B,GAAwB,KAARA,IAAewB,IAAwBF,EACnErF,EAAUG,mBACD,KAAR4D,GAAuB,MAARA,IAAgBsB,IAAoBE,EAChDvF,EAAUE,uBACVF,EAAUC,0BACpB,IAAIyF,EACAC,EAAuB,KAC3B,GACS,MADD5B,EAEA,OAAQ0B,GACJ,KAAKzF,EAAUG,kBACXuF,EAAazG,EAAS2C,yBACtB+D,EAAuB,KACvB,MACJ,KAAK3F,EAAUE,uBACXwF,EAAazG,EAAS4C,oCACtB8D,EAAuB1G,EAAS2C,yBAChC,MACJ,KAAK5B,EAAUC,0BACXyF,EAAazG,EAAS6C,+BACtB6D,EAAuB1G,EAAS2C,8BAOxC,OAAQ6D,GACJ,KAAKzF,EAAUG,kBACXuF,EAAazG,EAAS0B,oCACtBgF,EAAuB,KACvB,MACJ,KAAK3F,EAAUE,uBACXwF,EAAazG,EAASyC,6BACtBiE,EAAuB1G,EAAS0B,oCAChC,MACJ,KAAKX,EAAUC,0BACXyF,EAAazG,EAASgD,mCACtB0D,EAAuB1G,EAAS0B,oCAMhDkC,EAAQuC,KAAOK,EACfX,EAAaY,EAAWtF,EAAOC,EAAQlB,EAAKI,WAAaqB,EAAYC,EAAY1B,EAAKG,OAAQqF,GAC1FvB,GAAiC,GAALuB,GAC5BvB,EAAyB+B,KAAKQ,EAAuBA,EAAqBvF,EAAOC,EAAQlB,EAAKI,WAAaqB,EAAYC,EAAY1B,EAAKG,OAAQqF,GAAKG,EAErL,CAC4BA,GACAlC,EAAOgD,6BAA6B/C,EAASiC,EAAYJ,EAAMC,EAE3F,MACyB,GAAI7B,EAAKvC,MACVsC,EAAQuC,KAAOpF,EAAUC,0BACb,KAAR8D,GACAlB,EAAQ+B,OAAS5E,EAAU6F,kBAC3BhF,EAAaT,EAAQC,EAAS,EAC9BkC,EAAYtD,EAASwD,mBAAmBrC,EAAOC,EAAQlB,EAAKI,WAAaqB,EAAYC,EAAY1B,EAAKG,OAAQ6C,EAASC,EAASC,GAChIO,EAAOgD,6BAA6B/C,EAASN,EAAWmC,EAAMC,KAI9D9B,EAAQ+B,OAAS5E,EAAU6E,mBAC3BhE,EAAaT,EAAQC,EAAS,EAC9BkC,EAAYtD,EAASiD,oBAAoB9B,EAAOC,EAAQlB,EAAKI,WAAaqB,EAAYC,EAAY1B,EAAKG,OAAQ6C,EAASC,EAASC,EAASC,GAC1IM,EAAOgD,6BAA6B/C,EAASN,EAAWmC,EAAMC,SAGjE,GAAI7B,EAAKtC,YAAa,CACvB,MAAMsF,EAAkBlD,EAAOmD,uBACzBC,EAAkB5F,EAExBS,EADsBlB,KAAKsG,OAAO7F,EAAQ0F,EAAkB,GAAKA,GAAmBA,GACtDzF,EAAS,GAAK2F,EAC5CzD,EAAYtD,EAASyD,yBAAyBtC,EAAOC,EAAQlB,EAAKI,WAAaqB,EAAYC,EAAY1B,EAAKG,QAC5GuD,EAAQ+B,OAAS5E,EAAUkG,wBAC3BrD,EAAQuC,KAAOpF,EAAUC,0BACzB2C,EAAOgD,6BAA6B/C,EAASN,EAAWmC,EAAMC,EACtF,MAEwB9D,EAAgBlB,KAAKC,IAAI,EAAGQ,GAAS,EAAKT,KAAKC,IAAI,EAAGS,GAAW,EAAKuD,EACtErB,EAAY,IAAIR,WAAW5C,EAAKG,OAAQH,EAAKI,WAAaqB,EAAYC,GACtEgC,EAAQuC,KAAOpF,EAAUC,0BACzB2C,EAAOuD,uCAAuCtD,EAASc,EAA0BvD,EAAOC,EAAQkC,EAAWmC,EAAMC,EAEzI,CACgB/D,GAAcmD,EAAM3D,EAAQC,GAAU0D,EAAM,GAAKlD,EACjDT,GAAS,GACTC,GAAU,GACVD,EAAQT,KAAKC,IAAI,EAAKQ,GACtBC,EAASV,KAAKC,IAAI,EAAKS,EACvC,CACY,QAAoB+F,IAAhBlD,EAEA,KAEhB,CACYE,GAA4BA,EAAyBiD,OAAS,EAC9DvD,EAAKO,oBAAsBiD,EAAkCC,oCAAoC,CAC7FC,KAAMpH,EAhdJ,GAidFqH,MAAOrD,EAAyB,GAChCsD,KAAMtD,EAAyB,GAC/BuD,GAAIvD,EAAyB,GAC7BwD,KAAMxD,EAAyB,GAC/ByD,MAAOzD,EAAyB,GAChC0D,KAAM1D,EAAyB,GAC/BwB,OAAQ5E,EAAU6E,mBAClBO,KAAMpF,EAAUG,kBAChB4G,YAAY,IAIhBjE,EAAKO,yBAAsB+C,CAEvC,EAKAnH,EAASwC,wBAAyB"}