{"version":3,"file":"MSFT_lod-DWEwrrMN.esm.min.js","sources":["../../../../../dev/loaders/dist/glTF/2.0/Extensions/MSFT_lod.js"],"sourcesContent":["import { Observable } from \"core/Misc/observable\";\nimport { Deferred } from \"core/Misc/deferred\";\nimport { GLTFLoader, ArrayItem } from \"../glTFLoader\";\nimport { registerGLTFExtension, unregisterGLTFExtension } from \"../glTFLoaderExtensionRegistry\";\nconst NAME = \"MSFT_lod\";\n/**\n * [Specification](https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/MSFT_lod/README.md)\n */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nexport class MSFT_lod {\n    /**\n     * @internal\n     */\n    constructor(loader) {\n        /**\n         * The name of this extension.\n         */\n        this.name = NAME;\n        /**\n         * Defines a number that determines the order the extensions are applied.\n         */\n        this.order = 100;\n        /**\n         * Maximum number of LODs to load, starting from the lowest LOD.\n         */\n        this.maxLODsToLoad = 10;\n        /**\n         * Observable raised when all node LODs of one level are loaded.\n         * The event data is the index of the loaded LOD starting from zero.\n         * Dispose the loader to cancel the loading of the next level of LODs.\n         */\n        this.onNodeLODsLoadedObservable = new Observable();\n        /**\n         * Observable raised when all material LODs of one level are loaded.\n         * The event data is the index of the loaded LOD starting from zero.\n         * Dispose the loader to cancel the loading of the next level of LODs.\n         */\n        this.onMaterialLODsLoadedObservable = new Observable();\n        this._bufferLODs = new Array();\n        this._nodeIndexLOD = null;\n        this._nodeSignalLODs = new Array();\n        this._nodePromiseLODs = new Array();\n        this._nodeBufferLODs = new Array();\n        this._materialIndexLOD = null;\n        this._materialSignalLODs = new Array();\n        this._materialPromiseLODs = new Array();\n        this._materialBufferLODs = new Array();\n        this._loader = loader;\n        // Options takes precedence. The maxLODsToLoad extension property is retained for back compat.\n        // For new extensions, they should only use options.\n        this.maxLODsToLoad = this._loader.parent.extensionOptions[NAME]?.maxLODsToLoad ?? this.maxLODsToLoad;\n        this.enabled = this._loader.isExtensionUsed(NAME);\n    }\n    /** @internal */\n    dispose() {\n        this._loader = null;\n        this._nodeIndexLOD = null;\n        this._nodeSignalLODs.length = 0;\n        this._nodePromiseLODs.length = 0;\n        this._nodeBufferLODs.length = 0;\n        this._materialIndexLOD = null;\n        this._materialSignalLODs.length = 0;\n        this._materialPromiseLODs.length = 0;\n        this._materialBufferLODs.length = 0;\n        this.onMaterialLODsLoadedObservable.clear();\n        this.onNodeLODsLoadedObservable.clear();\n    }\n    /** @internal */\n    onReady() {\n        for (let indexLOD = 0; indexLOD < this._nodePromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._nodePromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Node LOD ${indexLOD}`);\n                    this._loader.log(`Loaded node LOD ${indexLOD}`);\n                }\n                this.onNodeLODsLoadedObservable.notifyObservers(indexLOD);\n                if (indexLOD !== this._nodePromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Node LOD ${indexLOD + 1}`);\n                    this._loadBufferLOD(this._nodeBufferLODs, indexLOD + 1);\n                    if (this._nodeSignalLODs[indexLOD]) {\n                        this._nodeSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n            this._loader._completePromises.push(promise);\n        }\n        for (let indexLOD = 0; indexLOD < this._materialPromiseLODs.length; indexLOD++) {\n            const promise = Promise.all(this._materialPromiseLODs[indexLOD]).then(() => {\n                if (indexLOD !== 0) {\n                    this._loader.endPerformanceCounter(`Material LOD ${indexLOD}`);\n                    this._loader.log(`Loaded material LOD ${indexLOD}`);\n                }\n                this.onMaterialLODsLoadedObservable.notifyObservers(indexLOD);\n                if (indexLOD !== this._materialPromiseLODs.length - 1) {\n                    this._loader.startPerformanceCounter(`Material LOD ${indexLOD + 1}`);\n                    this._loadBufferLOD(this._materialBufferLODs, indexLOD + 1);\n                    if (this._materialSignalLODs[indexLOD]) {\n                        this._materialSignalLODs[indexLOD].resolve();\n                    }\n                }\n            });\n            this._loader._completePromises.push(promise);\n        }\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadSceneAsync(context, scene) {\n        const promise = this._loader.loadSceneAsync(context, scene);\n        this._loadBufferLOD(this._bufferLODs, 0);\n        return promise;\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadNodeAsync(context, node, assign) {\n        return GLTFLoader.LoadExtensionAsync(context, node, this.name, async (extensionContext, extension) => {\n            let firstPromise;\n            const nodeLODs = this._getLODs(extensionContext, node, this._loader.gltf.nodes, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n            for (let indexLOD = 0; indexLOD < nodeLODs.length; indexLOD++) {\n                const nodeLOD = nodeLODs[indexLOD];\n                if (indexLOD !== 0) {\n                    this._nodeIndexLOD = indexLOD;\n                    this._nodeSignalLODs[indexLOD] = this._nodeSignalLODs[indexLOD] || new Deferred();\n                }\n                const assignWrap = (babylonTransformNode) => {\n                    assign(babylonTransformNode);\n                    babylonTransformNode.setEnabled(false);\n                };\n                const promise = this._loader.loadNodeAsync(`/nodes/${nodeLOD.index}`, nodeLOD, assignWrap).then((babylonMesh) => {\n                    if (indexLOD !== 0) {\n                        // TODO: should not rely on _babylonTransformNode\n                        const previousNodeLOD = nodeLODs[indexLOD - 1];\n                        if (previousNodeLOD._babylonTransformNode) {\n                            this._disposeTransformNode(previousNodeLOD._babylonTransformNode);\n                            delete previousNodeLOD._babylonTransformNode;\n                        }\n                    }\n                    babylonMesh.setEnabled(true);\n                    return babylonMesh;\n                });\n                this._nodePromiseLODs[indexLOD] = this._nodePromiseLODs[indexLOD] || [];\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._nodeIndexLOD = null;\n                    this._nodePromiseLODs[indexLOD].push(promise);\n                }\n            }\n            this._loader.logClose();\n            return await firstPromise;\n        });\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    _loadMaterialAsync(context, material, babylonMesh, babylonDrawMode, assign) {\n        // Don't load material LODs if already loading a node LOD.\n        if (this._nodeIndexLOD) {\n            return null;\n        }\n        return GLTFLoader.LoadExtensionAsync(context, material, this.name, async (extensionContext, extension) => {\n            let firstPromise;\n            const materialLODs = this._getLODs(extensionContext, material, this._loader.gltf.materials, extension.ids);\n            this._loader.logOpen(`${extensionContext}`);\n            for (let indexLOD = 0; indexLOD < materialLODs.length; indexLOD++) {\n                const materialLOD = materialLODs[indexLOD];\n                if (indexLOD !== 0) {\n                    this._materialIndexLOD = indexLOD;\n                }\n                const promise = this._loader\n                    ._loadMaterialAsync(`/materials/${materialLOD.index}`, materialLOD, babylonMesh, babylonDrawMode, (babylonMaterial) => {\n                    if (indexLOD === 0) {\n                        assign(babylonMaterial);\n                    }\n                })\n                    .then((babylonMaterial) => {\n                    if (indexLOD !== 0) {\n                        assign(babylonMaterial);\n                        // TODO: should not rely on _data\n                        const previousDataLOD = materialLODs[indexLOD - 1]._data;\n                        if (previousDataLOD[babylonDrawMode]) {\n                            this._disposeMaterials([previousDataLOD[babylonDrawMode].babylonMaterial]);\n                            delete previousDataLOD[babylonDrawMode];\n                        }\n                    }\n                    return babylonMaterial;\n                });\n                this._materialPromiseLODs[indexLOD] = this._materialPromiseLODs[indexLOD] || [];\n                if (indexLOD === 0) {\n                    firstPromise = promise;\n                }\n                else {\n                    this._materialIndexLOD = null;\n                    this._materialPromiseLODs[indexLOD].push(promise);\n                }\n            }\n            this._loader.logClose();\n            return await firstPromise;\n        });\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    _loadUriAsync(context, property, uri) {\n        // Defer the loading of uris if loading a node or material LOD.\n        if (this._nodeIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._nodeIndexLOD - 1;\n            this._nodeSignalLODs[previousIndexLOD] = this._nodeSignalLODs[previousIndexLOD] || new Deferred();\n            return this._nodeSignalLODs[this._nodeIndexLOD - 1].promise.then(async () => {\n                return await this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n        else if (this._materialIndexLOD !== null) {\n            this._loader.log(`deferred`);\n            const previousIndexLOD = this._materialIndexLOD - 1;\n            this._materialSignalLODs[previousIndexLOD] = this._materialSignalLODs[previousIndexLOD] || new Deferred();\n            return this._materialSignalLODs[previousIndexLOD].promise.then(async () => {\n                return await this._loader.loadUriAsync(context, property, uri);\n            });\n        }\n        return null;\n    }\n    /**\n     * @internal\n     */\n    // eslint-disable-next-line no-restricted-syntax\n    loadBufferAsync(context, buffer, byteOffset, byteLength) {\n        if (this._loader.parent.useRangeRequests && !buffer.uri) {\n            if (!this._loader.bin) {\n                throw new Error(`${context}: Uri is missing or the binary glTF is missing its binary chunk`);\n            }\n            const loadAsync = async (bufferLODs, indexLOD) => {\n                const start = byteOffset;\n                const end = start + byteLength - 1;\n                let bufferLOD = bufferLODs[indexLOD];\n                if (bufferLOD) {\n                    bufferLOD.start = Math.min(bufferLOD.start, start);\n                    bufferLOD.end = Math.max(bufferLOD.end, end);\n                }\n                else {\n                    bufferLOD = { start: start, end: end, loaded: new Deferred() };\n                    bufferLODs[indexLOD] = bufferLOD;\n                }\n                return await bufferLOD.loaded.promise.then((data) => {\n                    return new Uint8Array(data.buffer, data.byteOffset + byteOffset - bufferLOD.start, byteLength);\n                });\n            };\n            this._loader.log(`deferred`);\n            if (this._nodeIndexLOD !== null) {\n                return loadAsync(this._nodeBufferLODs, this._nodeIndexLOD);\n            }\n            else if (this._materialIndexLOD !== null) {\n                return loadAsync(this._materialBufferLODs, this._materialIndexLOD);\n            }\n            else {\n                return loadAsync(this._bufferLODs, 0);\n            }\n        }\n        return null;\n    }\n    _loadBufferLOD(bufferLODs, indexLOD) {\n        const bufferLOD = bufferLODs[indexLOD];\n        if (bufferLOD) {\n            this._loader.log(`Loading buffer range [${bufferLOD.start}-${bufferLOD.end}]`);\n            this._loader.bin.readAsync(bufferLOD.start, bufferLOD.end - bufferLOD.start + 1).then((data) => {\n                bufferLOD.loaded.resolve(data);\n            }, (error) => {\n                bufferLOD.loaded.reject(error);\n            });\n        }\n    }\n    /**\n     * @returns an array of LOD properties from lowest to highest.\n     * @param context\n     * @param property\n     * @param array\n     * @param ids\n     */\n    _getLODs(context, property, array, ids) {\n        if (this.maxLODsToLoad <= 0) {\n            throw new Error(\"maxLODsToLoad must be greater than zero\");\n        }\n        const properties = [];\n        for (let i = ids.length - 1; i >= 0; i--) {\n            properties.push(ArrayItem.Get(`${context}/ids/${ids[i]}`, array, ids[i]));\n            if (properties.length === this.maxLODsToLoad) {\n                return properties;\n            }\n        }\n        properties.push(property);\n        return properties;\n    }\n    _disposeTransformNode(babylonTransformNode) {\n        const babylonMaterials = [];\n        const babylonMaterial = babylonTransformNode.material;\n        if (babylonMaterial) {\n            babylonMaterials.push(babylonMaterial);\n        }\n        for (const babylonMesh of babylonTransformNode.getChildMeshes()) {\n            if (babylonMesh.material) {\n                babylonMaterials.push(babylonMesh.material);\n            }\n        }\n        babylonTransformNode.dispose();\n        const babylonMaterialsToDispose = babylonMaterials.filter((babylonMaterial) => this._loader.babylonScene.meshes.every((mesh) => mesh.material != babylonMaterial));\n        this._disposeMaterials(babylonMaterialsToDispose);\n    }\n    _disposeMaterials(babylonMaterials) {\n        const babylonTextures = {};\n        for (const babylonMaterial of babylonMaterials) {\n            for (const babylonTexture of babylonMaterial.getActiveTextures()) {\n                babylonTextures[babylonTexture.uniqueId] = babylonTexture;\n            }\n            babylonMaterial.dispose();\n        }\n        for (const uniqueId in babylonTextures) {\n            for (const babylonMaterial of this._loader.babylonScene.materials) {\n                if (babylonMaterial.hasTexture(babylonTextures[uniqueId])) {\n                    delete babylonTextures[uniqueId];\n                }\n            }\n        }\n        for (const uniqueId in babylonTextures) {\n            babylonTextures[uniqueId].dispose();\n        }\n    }\n}\nunregisterGLTFExtension(NAME);\nregisterGLTFExtension(NAME, true, (loader) => new MSFT_lod(loader));\n//# sourceMappingURL=MSFT_lod.js.map"],"names":["NAME","MSFT_lod","constructor","loader","this","name","order","maxLODsToLoad","onNodeLODsLoadedObservable","Observable","onMaterialLODsLoadedObservable","_bufferLODs","Array","_nodeIndexLOD","_nodeSignalLODs","_nodePromiseLODs","_nodeBufferLODs","_materialIndexLOD","_materialSignalLODs","_materialPromiseLODs","_materialBufferLODs","_loader","parent","extensionOptions","enabled","isExtensionUsed","dispose","length","clear","onReady","indexLOD","promise","Promise","all","then","endPerformanceCounter","log","notifyObservers","startPerformanceCounter","_loadBufferLOD","resolve","_completePromises","push","loadSceneAsync","context","scene","loadNodeAsync","node","assign","GLTFLoader","LoadExtensionAsync","async","extensionContext","extension","firstPromise","nodeLODs","_getLODs","gltf","nodes","ids","logOpen","nodeLOD","Deferred","assignWrap","babylonTransformNode","setEnabled","index","babylonMesh","previousNodeLOD","_babylonTransformNode","_disposeTransformNode","logClose","_loadMaterialAsync","material","babylonDrawMode","materialLODs","materials","materialLOD","babylonMaterial","previousDataLOD","_data","_disposeMaterials","_loadUriAsync","property","uri","previousIndexLOD","loadUriAsync","loadBufferAsync","buffer","byteOffset","byteLength","useRangeRequests","bin","Error","loadAsync","bufferLODs","start","end","bufferLOD","Math","min","max","loaded","data","Uint8Array","readAsync","error","reject","array","properties","i","ArrayItem","Get","babylonMaterials","getChildMeshes","babylonMaterialsToDispose","filter","babylonScene","meshes","every","mesh","babylonTextures","babylonTexture","getActiveTextures","uniqueId","hasTexture","unregisterGLTFExtension","registerGLTFExtension"],"mappings":"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"}