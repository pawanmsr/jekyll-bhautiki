{"version":3,"file":"shaderMaterial-CLASU8Ae.esm.min.js","sources":["../../../../../dev/core/dist/Materials/vertexPullingHelper.functions.js","../../../../../dev/core/dist/Materials/shaderMaterial.js"],"sourcesContent":["// Store vertex pulling metadata per geometry\nconst _VertexPullingMetadataCache = new WeakMap();\n/**\n * Prepares vertex pulling uniforms for the given attributes and mesh\n * @param geometry The geometry containing the vertex buffers\n * @returns A map of attribute names to their metadata, or null if unavailable\n */\nexport function PrepareVertexPullingUniforms(geometry) {\n    const vertexBuffers = geometry.getVertexBuffers();\n    if (!vertexBuffers) {\n        return null;\n    }\n    // Check cache first\n    let metadata = _VertexPullingMetadataCache.get(geometry);\n    if (!metadata) {\n        metadata = new Map();\n        _VertexPullingMetadataCache.set(geometry, metadata);\n    }\n    else {\n        // Return cached metadata if it exists and hasn't changed\n        let needsUpdate = false;\n        for (const vb in vertexBuffers) {\n            if (!metadata.has(vb)) {\n                needsUpdate = true;\n                break;\n            }\n        }\n        if (!needsUpdate) {\n            return metadata;\n        }\n    }\n    // Build or update metadata\n    for (const vb in vertexBuffers) {\n        const vertexBuffer = vertexBuffers[vb];\n        if (vertexBuffer) {\n            const offset = vertexBuffer.byteOffset;\n            const stride = vertexBuffer.byteStride;\n            const type = vertexBuffer.type;\n            metadata.set(vb, {\n                offset: offset,\n                stride: stride,\n                type: type,\n            });\n        }\n    }\n    return metadata;\n}\n/**\n * Bind vertex pulling uniforms to the effect\n * @param effect The effect to bind the uniforms to\n * @param metadata The vertex pulling metadata\n */\nexport function BindVertexPullingUniforms(effect, metadata) {\n    metadata.forEach((data, attribute) => {\n        const uniformName = `vp_${attribute}_info`;\n        // Pack into vec3: (offset, stride, type)\n        effect.setFloat3(uniformName, data.offset, data.stride, data.type);\n    });\n}\n//# sourceMappingURL=vertexPullingHelper.functions.js.map","import { SerializationHelper } from \"../Misc/decorators.serialization\";\nimport { Scene } from \"../scene\";\nimport { Matrix, Quaternion } from \"../Maths/math.vector\";\nimport { VertexBuffer } from \"../Buffers/buffer\";\nimport { Texture } from \"../Materials/Textures/texture\";\nimport { RegisterClass } from \"../Misc/typeStore\";\nimport { EffectFallbacks } from \"./effectFallbacks\";\nimport { WebRequest } from \"../Misc/webRequest\";\nimport { PushMaterial } from \"./pushMaterial\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Constants } from \"../Engines/constants\";\nimport { AddClipPlaneUniforms, BindClipPlane, PrepareStringDefinesForClipPlanes } from \"./clipPlaneMaterialHelper\";\nimport { BindBonesParameters, BindFogParameters, BindLogDepth, BindMorphTargetParameters, BindSceneUniformBuffer, PrepareDefinesAndAttributesForMorphTargets, PushAttributesForInstances, } from \"./materialHelper.functions\";\nimport { PrepareVertexPullingUniforms, BindVertexPullingUniforms } from \"./vertexPullingHelper.functions\";\nconst OnCreatedEffectParameters = { effect: null, subMesh: null };\n/**\n * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\n *\n * This returned material effects how the mesh will look based on the code in the shaders.\n *\n * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\n */\nexport class ShaderMaterial extends PushMaterial {\n    /**\n     * Instantiate a new shader material.\n     * The ShaderMaterial object has the necessary methods to pass data from your scene to the Vertex and Fragment Shaders and returns a material that can be applied to any mesh.\n     * This returned material effects how the mesh will look based on the code in the shaders.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/materials/shaders/shaderMaterial\n     * @param name Define the name of the material in the scene\n     * @param scene Define the scene the material belongs to\n     * @param shaderPath Defines  the route to the shader code.\n     * @param options Define the options used to create the shader\n     * @param storeEffectOnSubMeshes true to store effect on submeshes, false to store the effect directly in the material class.\n     */\n    constructor(name, scene, shaderPath, options = {}, storeEffectOnSubMeshes = true) {\n        super(name, scene, storeEffectOnSubMeshes);\n        this._textures = {};\n        this._internalTextures = {};\n        this._textureArrays = {};\n        this._externalTextures = {};\n        this._floats = {};\n        this._ints = {};\n        this._uints = {};\n        this._floatsArrays = {};\n        this._colors3 = {};\n        this._colors3Arrays = {};\n        this._colors4 = {};\n        this._colors4Arrays = {};\n        this._vectors2 = {};\n        this._vectors3 = {};\n        this._vectors4 = {};\n        this._quaternions = {};\n        this._quaternionsArrays = {};\n        this._matrices = {};\n        this._matrixArrays = {};\n        this._matrices3x3 = {};\n        this._matrices2x2 = {};\n        this._vectors2Arrays = {};\n        this._vectors3Arrays = {};\n        this._vectors4Arrays = {};\n        this._uniformBuffers = {};\n        this._textureSamplers = {};\n        this._storageBuffers = {};\n        this._cachedWorldViewMatrix = new Matrix();\n        this._cachedWorldViewProjectionMatrix = new Matrix();\n        this._multiview = false;\n        this._vertexPullingMetadata = null;\n        /**\n         * @internal\n         */\n        this._materialHelperNeedsPreviousMatrices = false;\n        this._shaderPath = shaderPath;\n        this._options = {\n            needAlphaBlending: false,\n            needAlphaTesting: false,\n            attributes: [\"position\", \"normal\", \"uv\"],\n            uniforms: [\"worldViewProjection\"],\n            uniformBuffers: [],\n            samplers: [],\n            externalTextures: [],\n            samplerObjects: [],\n            storageBuffers: [],\n            defines: [],\n            useClipPlane: false,\n            ...options,\n        };\n    }\n    /**\n     * Gets the shader path used to define the shader code\n     * It can be modified to trigger a new compilation\n     */\n    get shaderPath() {\n        return this._shaderPath;\n    }\n    /**\n     * Sets the shader path used to define the shader code\n     * It can be modified to trigger a new compilation\n     */\n    set shaderPath(shaderPath) {\n        this._shaderPath = shaderPath;\n    }\n    /**\n     * Gets the options used to compile the shader.\n     * They can be modified to trigger a new compilation\n     */\n    get options() {\n        return this._options;\n    }\n    /**\n     * is multiview set to true?\n     */\n    get isMultiview() {\n        return this._multiview;\n    }\n    /**\n     * Gets the current class name of the material e.g. \"ShaderMaterial\"\n     * Mainly use in serialization.\n     * @returns the class name\n     */\n    getClassName() {\n        return \"ShaderMaterial\";\n    }\n    /**\n     * Specifies if the material will require alpha blending\n     * @returns a boolean specifying if alpha blending is needed\n     */\n    needAlphaBlending() {\n        return this.alpha < 1.0 || this._options.needAlphaBlending;\n    }\n    /**\n     * Specifies if this material should be rendered in alpha test mode\n     * @returns a boolean specifying if an alpha test is needed.\n     */\n    needAlphaTesting() {\n        return this._options.needAlphaTesting;\n    }\n    _checkUniform(uniformName) {\n        if (this._options.uniforms.indexOf(uniformName) === -1) {\n            this._options.uniforms.push(uniformName);\n        }\n    }\n    /**\n     * Set a texture in the shader.\n     * @param name Define the name of the uniform samplers as defined in the shader\n     * @param texture Define the texture to bind to this sampler\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setTexture(name, texture) {\n        if (this._options.samplers.indexOf(name) === -1) {\n            this._options.samplers.push(name);\n        }\n        this._textures[name] = texture;\n        return this;\n    }\n    /**\n     * Set an internal texture in the shader.\n     * @param name Define the name of the uniform samplers as defined in the shader\n     * @param texture Define the texture to bind to this sampler\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setInternalTexture(name, texture) {\n        if (this._options.samplers.indexOf(name) === -1) {\n            this._options.samplers.push(name);\n        }\n        this._internalTextures[name] = texture;\n        return this;\n    }\n    /**\n     * Remove a texture from the material.\n     * @param name Define the name of the texture to remove\n     */\n    removeTexture(name) {\n        delete this._textures[name];\n    }\n    /**\n     * Set a texture array in the shader.\n     * @param name Define the name of the uniform sampler array as defined in the shader\n     * @param textures Define the list of textures to bind to this sampler\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setTextureArray(name, textures) {\n        if (this._options.samplers.indexOf(name) === -1) {\n            this._options.samplers.push(name);\n        }\n        this._checkUniform(name);\n        this._textureArrays[name] = textures;\n        return this;\n    }\n    /**\n     * Set an internal texture in the shader.\n     * @param name Define the name of the uniform samplers as defined in the shader\n     * @param texture Define the texture to bind to this sampler\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setExternalTexture(name, texture) {\n        if (this._options.externalTextures.indexOf(name) === -1) {\n            this._options.externalTextures.push(name);\n        }\n        this._externalTextures[name] = texture;\n        return this;\n    }\n    /**\n     * Set a float in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setFloat(name, value) {\n        this._checkUniform(name);\n        this._floats[name] = value;\n        return this;\n    }\n    /**\n     * Set a int in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setInt(name, value) {\n        this._checkUniform(name);\n        this._ints[name] = value;\n        return this;\n    }\n    /**\n     * Set a unsigned int in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setUInt(name, value) {\n        this._checkUniform(name);\n        this._uints[name] = value;\n        return this;\n    }\n    /**\n     * Set an array of floats in the shader.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setFloats(name, value) {\n        this._checkUniform(name);\n        this._floatsArrays[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec3 in the shader from a Color3.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setColor3(name, value) {\n        this._checkUniform(name);\n        this._colors3[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec3 array in the shader from a IColor3Like array.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setColor3Array(name, value) {\n        this._checkUniform(name);\n        this._colors3Arrays[name] = value.reduce((arr, color) => {\n            arr.push(color.r, color.g, color.b);\n            return arr;\n        }, []);\n        return this;\n    }\n    /**\n     * Set a vec4 in the shader from a Color4.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setColor4(name, value) {\n        this._checkUniform(name);\n        this._colors4[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec4 array in the shader from a IColor4Like array.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setColor4Array(name, value) {\n        this._checkUniform(name);\n        this._colors4Arrays[name] = value.reduce((arr, color) => {\n            arr.push(color.r, color.g, color.b, color.a);\n            return arr;\n        }, []);\n        return this;\n    }\n    /**\n     * Set a vec2 in the shader from a Vector2.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setVector2(name, value) {\n        this._checkUniform(name);\n        this._vectors2[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec3 in the shader from a Vector3.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setVector3(name, value) {\n        this._checkUniform(name);\n        this._vectors3[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec4 in the shader from a Vector4.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setVector4(name, value) {\n        this._checkUniform(name);\n        this._vectors4[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec4 in the shader from a Quaternion.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setQuaternion(name, value) {\n        this._checkUniform(name);\n        this._quaternions[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec4 array in the shader from a Quaternion array.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setQuaternionArray(name, value) {\n        this._checkUniform(name);\n        this._quaternionsArrays[name] = value.reduce((arr, quaternion) => {\n            quaternion.toArray(arr, arr.length);\n            return arr;\n        }, []);\n        return this;\n    }\n    /**\n     * Set a mat4 in the shader from a Matrix.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setMatrix(name, value) {\n        this._checkUniform(name);\n        this._matrices[name] = value;\n        return this;\n    }\n    /**\n     * Set a float32Array in the shader from a matrix array.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setMatrices(name, value) {\n        this._checkUniform(name);\n        const float32Array = new Float32Array(value.length * 16);\n        for (let index = 0; index < value.length; index++) {\n            const matrix = value[index];\n            matrix.copyToArray(float32Array, index * 16);\n        }\n        this._matrixArrays[name] = float32Array;\n        return this;\n    }\n    /**\n     * Set a mat3 in the shader from a Float32Array.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setMatrix3x3(name, value) {\n        this._checkUniform(name);\n        this._matrices3x3[name] = value;\n        return this;\n    }\n    /**\n     * Set a mat2 in the shader from a Float32Array.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setMatrix2x2(name, value) {\n        this._checkUniform(name);\n        this._matrices2x2[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec2 array in the shader from a number array.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setArray2(name, value) {\n        this._checkUniform(name);\n        this._vectors2Arrays[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec3 array in the shader from a number array.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setArray3(name, value) {\n        this._checkUniform(name);\n        this._vectors3Arrays[name] = value;\n        return this;\n    }\n    /**\n     * Set a vec4 array in the shader from a number array.\n     * @param name Define the name of the uniform as defined in the shader\n     * @param value Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setArray4(name, value) {\n        this._checkUniform(name);\n        this._vectors4Arrays[name] = value;\n        return this;\n    }\n    /**\n     * Set a uniform buffer in the shader\n     * @param name Define the name of the uniform as defined in the shader\n     * @param buffer Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setUniformBuffer(name, buffer) {\n        if (this._options.uniformBuffers.indexOf(name) === -1) {\n            this._options.uniformBuffers.push(name);\n        }\n        this._uniformBuffers[name] = buffer;\n        return this;\n    }\n    /**\n     * Set a texture sampler in the shader\n     * @param name Define the name of the uniform as defined in the shader\n     * @param sampler Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setTextureSampler(name, sampler) {\n        if (this._options.samplerObjects.indexOf(name) === -1) {\n            this._options.samplerObjects.push(name);\n        }\n        this._textureSamplers[name] = sampler;\n        return this;\n    }\n    /**\n     * Set a storage buffer in the shader\n     * @param name Define the name of the storage buffer as defined in the shader\n     * @param buffer Define the value to give to the uniform\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setStorageBuffer(name, buffer) {\n        if (this._options.storageBuffers.indexOf(name) === -1) {\n            this._options.storageBuffers.push(name);\n        }\n        this._storageBuffers[name] = buffer;\n        return this;\n    }\n    /**\n     * Adds, removes, or replaces the specified shader define and value.\n     * * setDefine(\"MY_DEFINE\", true); // enables a boolean define\n     * * setDefine(\"MY_DEFINE\", \"0.5\"); // adds \"#define MY_DEFINE 0.5\" to the shader (or sets and replaces the value of any existing define with that name)\n     * * setDefine(\"MY_DEFINE\", false); // disables and removes the define\n     * Note if the active defines do change, the shader will be recompiled and this can be expensive.\n     * @param define the define name e.g., \"OUTPUT_TO_SRGB\" or \"#define OUTPUT_TO_SRGB\". If the define was passed into the constructor already, the version used should match that, and in either case, it should not include any appended value.\n     * @param value either the value of the define (e.g. a numerical value) or for booleans, true if the define should be enabled or false if it should be disabled\n     * @returns the material itself allowing \"fluent\" like uniform updates\n     */\n    setDefine(define, value) {\n        // First remove any existing define with this name.\n        const defineName = define.trimEnd() + \" \";\n        const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));\n        if (existingDefineIdx >= 0) {\n            this.options.defines.splice(existingDefineIdx, 1);\n        }\n        // Then add the new define value. (If it's a boolean value and false, don't add it.)\n        if (typeof value !== \"boolean\" || value) {\n            this.options.defines.push(defineName + value);\n        }\n        return this;\n    }\n    /**\n     * Specifies that the submesh is ready to be used\n     * @param mesh defines the mesh to check\n     * @param subMesh defines which submesh to check\n     * @param useInstances specifies that instances should be used\n     * @returns a boolean indicating that the submesh is ready or not\n     */\n    isReadyForSubMesh(mesh, subMesh, useInstances) {\n        return this.isReady(mesh, useInstances, subMesh);\n    }\n    /**\n     * Checks if the material is ready to render the requested mesh\n     * @param mesh Define the mesh to render\n     * @param useInstances Define whether or not the material is used with instances\n     * @param subMesh defines which submesh to render\n     * @returns true if ready, otherwise false\n     */\n    isReady(mesh, useInstances, subMesh) {\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\n        if (this.isFrozen) {\n            const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\n            if (drawWrapper.effect && drawWrapper._wasPreviouslyReady && drawWrapper._wasPreviouslyUsingInstances === useInstances) {\n                return true;\n            }\n        }\n        const scene = this.getScene();\n        const engine = scene.getEngine();\n        // Instances\n        const defines = [];\n        const attribs = [];\n        let fallbacks = null;\n        let shaderName = this._shaderPath, uniforms = this._options.uniforms, uniformBuffers = this._options.uniformBuffers, samplers = this._options.samplers;\n        // global multiview\n        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {\n            this._multiview = true;\n            defines.push(\"#define MULTIVIEW\");\n            if (uniforms.indexOf(\"viewProjection\") !== -1 && uniforms.indexOf(\"viewProjectionR\") === -1) {\n                uniforms.push(\"viewProjectionR\");\n            }\n        }\n        for (let index = 0; index < this._options.defines.length; index++) {\n            const defineToAdd = this._options.defines[index].indexOf(\"#define\") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;\n            defines.push(defineToAdd);\n        }\n        for (let index = 0; index < this._options.attributes.length; index++) {\n            attribs.push(this._options.attributes[index]);\n        }\n        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {\n            if (attribs.indexOf(VertexBuffer.ColorKind) === -1) {\n                attribs.push(VertexBuffer.ColorKind);\n            }\n            defines.push(\"#define VERTEXCOLOR\");\n        }\n        if (useInstances) {\n            defines.push(\"#define INSTANCES\");\n            PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);\n            if (mesh?.hasThinInstances) {\n                defines.push(\"#define THIN_INSTANCES\");\n                if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {\n                    attribs.push(VertexBuffer.ColorInstanceKind);\n                    defines.push(\"#define INSTANCESCOLOR\");\n                }\n            }\n        }\n        // Bones\n        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n            attribs.push(VertexBuffer.MatricesIndicesKind);\n            attribs.push(VertexBuffer.MatricesWeightsKind);\n            if (mesh.numBoneInfluencers > 4) {\n                attribs.push(VertexBuffer.MatricesIndicesExtraKind);\n                attribs.push(VertexBuffer.MatricesWeightsExtraKind);\n            }\n            const skeleton = mesh.skeleton;\n            defines.push(\"#define NUM_BONE_INFLUENCERS \" + mesh.numBoneInfluencers);\n            fallbacks = new EffectFallbacks();\n            fallbacks.addCPUSkinningFallback(0, mesh);\n            if (skeleton.isUsingTextureForMatrices) {\n                defines.push(\"#define BONETEXTURE\");\n                if (uniforms.indexOf(\"boneTextureWidth\") === -1) {\n                    uniforms.push(\"boneTextureWidth\");\n                }\n                if (this._options.samplers.indexOf(\"boneSampler\") === -1) {\n                    this._options.samplers.push(\"boneSampler\");\n                }\n            }\n            else {\n                defines.push(\"#define BonesPerMesh \" + (skeleton.bones.length + 1));\n                if (uniforms.indexOf(\"mBones\") === -1) {\n                    uniforms.push(\"mBones\");\n                }\n            }\n        }\n        else {\n            defines.push(\"#define NUM_BONE_INFLUENCERS 0\");\n        }\n        // Morph\n        let numInfluencers = 0;\n        const manager = mesh ? mesh.morphTargetManager : null;\n        if (manager) {\n            const uv = defines.indexOf(\"#define UV1\") !== -1;\n            const uv2 = defines.indexOf(\"#define UV2\") !== -1;\n            const tangent = defines.indexOf(\"#define TANGENT\") !== -1;\n            const normal = defines.indexOf(\"#define NORMAL\") !== -1;\n            const color = defines.indexOf(\"#define VERTEXCOLOR\") !== -1;\n            numInfluencers = PrepareDefinesAndAttributesForMorphTargets(manager, defines, attribs, mesh, true, // usePositionMorph\n            normal, // useNormalMorph\n            tangent, // useTangentMorph\n            uv, // useUVMorph\n            uv2, // useUV2Morph\n            color // useColorMorph\n            );\n            if (manager.isUsingTextureForTargets) {\n                if (uniforms.indexOf(\"morphTargetTextureIndices\") === -1) {\n                    uniforms.push(\"morphTargetTextureIndices\");\n                }\n                if (this._options.samplers.indexOf(\"morphTargets\") === -1) {\n                    this._options.samplers.push(\"morphTargets\");\n                }\n            }\n            if (numInfluencers > 0) {\n                uniforms = uniforms.slice();\n                uniforms.push(\"morphTargetInfluences\");\n                uniforms.push(\"morphTargetCount\");\n                uniforms.push(\"morphTargetTextureInfo\");\n                uniforms.push(\"morphTargetTextureIndices\");\n            }\n        }\n        else {\n            defines.push(\"#define NUM_MORPH_INFLUENCERS 0\");\n        }\n        // Baked Vertex Animation\n        if (mesh) {\n            const bvaManager = mesh.bakedVertexAnimationManager;\n            if (bvaManager && bvaManager.isEnabled) {\n                defines.push(\"#define BAKED_VERTEX_ANIMATION_TEXTURE\");\n                if (uniforms.indexOf(\"bakedVertexAnimationSettings\") === -1) {\n                    uniforms.push(\"bakedVertexAnimationSettings\");\n                }\n                if (uniforms.indexOf(\"bakedVertexAnimationTextureSizeInverted\") === -1) {\n                    uniforms.push(\"bakedVertexAnimationTextureSizeInverted\");\n                }\n                if (uniforms.indexOf(\"bakedVertexAnimationTime\") === -1) {\n                    uniforms.push(\"bakedVertexAnimationTime\");\n                }\n                if (this._options.samplers.indexOf(\"bakedVertexAnimationTexture\") === -1) {\n                    this._options.samplers.push(\"bakedVertexAnimationTexture\");\n                }\n                if (useInstances) {\n                    attribs.push(\"bakedVertexAnimationSettingsInstanced\");\n                }\n            }\n        }\n        // Textures\n        for (const name in this._textures) {\n            if (!this._textures[name].isReady()) {\n                return false;\n            }\n        }\n        for (const name in this._internalTextures) {\n            if (!this._internalTextures[name].isReady) {\n                return false;\n            }\n        }\n        // Alpha test\n        if (mesh && this.needAlphaTestingForMesh(mesh)) {\n            defines.push(\"#define ALPHATEST\");\n        }\n        // Clip planes\n        if (this._options.useClipPlane !== false) {\n            AddClipPlaneUniforms(uniforms);\n            PrepareStringDefinesForClipPlanes(this, scene, defines);\n        }\n        // Fog\n        if (scene.fogEnabled && mesh?.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {\n            defines.push(\"#define FOG\");\n            if (uniforms.indexOf(\"view\") === -1) {\n                uniforms.push(\"view\");\n            }\n            if (uniforms.indexOf(\"vFogInfos\") === -1) {\n                uniforms.push(\"vFogInfos\");\n            }\n            if (uniforms.indexOf(\"vFogColor\") === -1) {\n                uniforms.push(\"vFogColor\");\n            }\n        }\n        // Misc\n        if (this._useLogarithmicDepth) {\n            defines.push(\"#define LOGARITHMICDEPTH\");\n            if (uniforms.indexOf(\"logarithmicDepthConstant\") === -1) {\n                uniforms.push(\"logarithmicDepthConstant\");\n            }\n        }\n        const renderingMesh = subMesh ? subMesh.getRenderingMesh() : mesh;\n        if (renderingMesh && this.useVertexPulling) {\n            // Add vertex buffer metadata defines for proper stride/offset handling\n            const geometry = renderingMesh.geometry;\n            if (geometry) {\n                this._vertexPullingMetadata = PrepareVertexPullingUniforms(geometry);\n                if (this._vertexPullingMetadata) {\n                    this._vertexPullingMetadata.forEach((_, attribute) => {\n                        uniforms.push(`vp_${attribute}_info`);\n                    });\n                }\n            }\n            defines.push(\"#define USE_VERTEX_PULLING\");\n            const indexBuffer = renderingMesh.geometry?.getIndexBuffer();\n            if (indexBuffer && !renderingMesh.isUnIndexed) {\n                defines.push(\"#define VERTEX_PULLING_USE_INDEX_BUFFER\");\n                if (indexBuffer.is32Bits) {\n                    defines.push(\"#define VERTEX_PULLING_INDEX_BUFFER_32BITS\");\n                }\n            }\n        }\n        if (this.customShaderNameResolve) {\n            uniforms = uniforms.slice();\n            uniformBuffers = uniformBuffers.slice();\n            samplers = samplers.slice();\n            shaderName = this.customShaderNameResolve(this.name, uniforms, uniformBuffers, samplers, defines, attribs);\n        }\n        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper(undefined, true) : this._drawWrapper;\n        const previousEffect = drawWrapper?.effect ?? null;\n        const previousDefines = drawWrapper?.defines ?? null;\n        const join = defines.join(\"\\n\");\n        let effect = previousEffect;\n        if (previousDefines !== join) {\n            effect = engine.createEffect(shaderName, {\n                attributes: attribs,\n                uniformsNames: uniforms,\n                uniformBuffersNames: uniformBuffers,\n                samplers: samplers,\n                defines: join,\n                fallbacks: fallbacks,\n                onCompiled: this.onCompiled,\n                onError: this.onError,\n                indexParameters: { maxSimultaneousMorphTargets: numInfluencers },\n                shaderLanguage: this._options.shaderLanguage,\n                extraInitializationsAsync: this._options.extraInitializationsAsync,\n            }, engine);\n            if (storeEffectOnSubMeshes) {\n                subMesh.setEffect(effect, join, this._materialContext);\n            }\n            else if (drawWrapper) {\n                drawWrapper.setEffect(effect, join);\n            }\n            if (this._onEffectCreatedObservable) {\n                OnCreatedEffectParameters.effect = effect;\n                OnCreatedEffectParameters.subMesh = subMesh ?? mesh?.subMeshes[0] ?? null;\n                this._onEffectCreatedObservable.notifyObservers(OnCreatedEffectParameters);\n            }\n        }\n        drawWrapper._wasPreviouslyUsingInstances = !!useInstances;\n        if (!effect?.isReady()) {\n            return false;\n        }\n        if (previousEffect !== effect) {\n            scene.resetCachedMaterial();\n        }\n        drawWrapper._wasPreviouslyReady = true;\n        return true;\n    }\n    /**\n     * Binds the world matrix to the material\n     * @param world defines the world transformation matrix\n     * @param effectOverride - If provided, use this effect instead of internal effect\n     */\n    bindOnlyWorldMatrix(world, effectOverride) {\n        const effect = effectOverride ?? this.getEffect();\n        if (!effect) {\n            return;\n        }\n        const uniforms = this._options.uniforms;\n        if (uniforms.indexOf(\"world\") !== -1) {\n            effect.setMatrix(\"world\", world);\n        }\n        const scene = this.getScene();\n        if (uniforms.indexOf(\"worldView\") !== -1) {\n            world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);\n            effect.setMatrix(\"worldView\", this._cachedWorldViewMatrix);\n        }\n        if (uniforms.indexOf(\"worldViewProjection\") !== -1) {\n            world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);\n            effect.setMatrix(\"worldViewProjection\", this._cachedWorldViewProjectionMatrix);\n        }\n        if (uniforms.indexOf(\"view\") !== -1) {\n            effect.setMatrix(\"view\", scene.getViewMatrix());\n        }\n    }\n    /**\n     * Binds the submesh to this material by preparing the effect and shader to draw\n     * @param world defines the world transformation matrix\n     * @param mesh defines the mesh containing the submesh\n     * @param subMesh defines the submesh to bind the material to\n     */\n    bindForSubMesh(world, mesh, subMesh) {\n        this.bind(world, mesh, subMesh._drawWrapperOverride?.effect, subMesh);\n    }\n    /**\n     * Binds the material to the mesh\n     * @param world defines the world transformation matrix\n     * @param mesh defines the mesh to bind the material to\n     * @param effectOverride - If provided, use this effect instead of internal effect\n     * @param subMesh defines the submesh to bind the material to\n     */\n    bind(world, mesh, effectOverride, subMesh) {\n        // Std values\n        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;\n        const effect = effectOverride ?? (storeEffectOnSubMeshes ? subMesh.effect : this.getEffect());\n        if (!effect) {\n            return;\n        }\n        const scene = this.getScene();\n        this._activeEffect = effect;\n        this.bindOnlyWorldMatrix(world, effectOverride);\n        const uniformBuffers = this._options.uniformBuffers;\n        let useSceneUBO = false;\n        if (effect && uniformBuffers && uniformBuffers.length > 0 && scene.getEngine().supportsUniformBuffers) {\n            for (let i = 0; i < uniformBuffers.length; ++i) {\n                const bufferName = uniformBuffers[i];\n                switch (bufferName) {\n                    case \"Mesh\":\n                        if (mesh) {\n                            mesh.getMeshUniformBuffer().bindToEffect(effect, \"Mesh\");\n                            mesh.transferToEffect(world);\n                        }\n                        break;\n                    case \"Scene\":\n                        BindSceneUniformBuffer(effect, scene.getSceneUniformBuffer());\n                        scene.finalizeSceneUbo();\n                        useSceneUBO = true;\n                        break;\n                }\n            }\n        }\n        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(scene, effect, subMesh, mesh.visibility) : scene.getCachedMaterial() !== this;\n        if (effect && mustRebind) {\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"view\") !== -1) {\n                effect.setMatrix(\"view\", scene.getViewMatrix());\n            }\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"projection\") !== -1) {\n                effect.setMatrix(\"projection\", scene.getProjectionMatrix());\n            }\n            if (!useSceneUBO && this._options.uniforms.indexOf(\"viewProjection\") !== -1) {\n                effect.setMatrix(\"viewProjection\", scene.getTransformMatrix());\n                if (this._multiview) {\n                    effect.setMatrix(\"viewProjectionR\", scene._transformMatrixR);\n                }\n            }\n            if (scene.activeCamera && this._options.uniforms.indexOf(\"cameraPosition\") !== -1) {\n                effect.setVector3(\"cameraPosition\", scene.activeCamera.globalPosition);\n            }\n            // Bones\n            BindBonesParameters(mesh, effect);\n            // Clip plane\n            BindClipPlane(effect, this, scene);\n            if (this._vertexPullingMetadata) {\n                BindVertexPullingUniforms(effect, this._vertexPullingMetadata);\n            }\n            // Misc\n            if (this._useLogarithmicDepth) {\n                BindLogDepth(storeEffectOnSubMeshes ? subMesh.materialDefines : effect.defines, effect, scene);\n            }\n            // Fog\n            if (mesh) {\n                BindFogParameters(scene, mesh, effect);\n            }\n            let name;\n            // Texture\n            for (name in this._textures) {\n                effect.setTexture(name, this._textures[name]);\n            }\n            for (name in this._internalTextures) {\n                effect._bindTexture(name, this._internalTextures[name]);\n            }\n            // Texture arrays\n            for (name in this._textureArrays) {\n                effect.setTextureArray(name, this._textureArrays[name]);\n            }\n            // Int\n            for (name in this._ints) {\n                effect.setInt(name, this._ints[name]);\n            }\n            // UInt\n            for (name in this._uints) {\n                effect.setUInt(name, this._uints[name]);\n            }\n            // Float\n            for (name in this._floats) {\n                effect.setFloat(name, this._floats[name]);\n            }\n            // Floats\n            for (name in this._floatsArrays) {\n                effect.setArray(name, this._floatsArrays[name]);\n            }\n            // Color3\n            for (name in this._colors3) {\n                effect.setColor3(name, this._colors3[name]);\n            }\n            // Color3Array\n            for (name in this._colors3Arrays) {\n                effect.setArray3(name, this._colors3Arrays[name]);\n            }\n            // Color4\n            for (name in this._colors4) {\n                const color = this._colors4[name];\n                effect.setFloat4(name, color.r, color.g, color.b, color.a);\n            }\n            // Color4Array\n            for (name in this._colors4Arrays) {\n                effect.setArray4(name, this._colors4Arrays[name]);\n            }\n            // Vector2\n            for (name in this._vectors2) {\n                effect.setVector2(name, this._vectors2[name]);\n            }\n            // Vector3\n            for (name in this._vectors3) {\n                effect.setVector3(name, this._vectors3[name]);\n            }\n            // Vector4\n            for (name in this._vectors4) {\n                effect.setVector4(name, this._vectors4[name]);\n            }\n            // Quaternion\n            for (name in this._quaternions) {\n                effect.setQuaternion(name, this._quaternions[name]);\n            }\n            // Matrix\n            for (name in this._matrices) {\n                effect.setMatrix(name, this._matrices[name]);\n            }\n            // MatrixArray\n            for (name in this._matrixArrays) {\n                effect.setMatrices(name, this._matrixArrays[name]);\n            }\n            // Matrix 3x3\n            for (name in this._matrices3x3) {\n                effect.setMatrix3x3(name, this._matrices3x3[name]);\n            }\n            // Matrix 2x2\n            for (name in this._matrices2x2) {\n                effect.setMatrix2x2(name, this._matrices2x2[name]);\n            }\n            // Vector2Array\n            for (name in this._vectors2Arrays) {\n                effect.setArray2(name, this._vectors2Arrays[name]);\n            }\n            // Vector3Array\n            for (name in this._vectors3Arrays) {\n                effect.setArray3(name, this._vectors3Arrays[name]);\n            }\n            // Vector4Array\n            for (name in this._vectors4Arrays) {\n                effect.setArray4(name, this._vectors4Arrays[name]);\n            }\n            // QuaternionArray\n            for (name in this._quaternionsArrays) {\n                effect.setArray4(name, this._quaternionsArrays[name]);\n            }\n            // Uniform buffers\n            for (name in this._uniformBuffers) {\n                const buffer = this._uniformBuffers[name].getBuffer();\n                if (buffer) {\n                    effect.bindUniformBuffer(buffer, name);\n                }\n            }\n            const engineWebGPU = scene.getEngine();\n            // External texture\n            const setExternalTexture = engineWebGPU.setExternalTexture;\n            if (setExternalTexture) {\n                for (name in this._externalTextures) {\n                    setExternalTexture.call(engineWebGPU, name, this._externalTextures[name]);\n                }\n            }\n            // Samplers\n            const setTextureSampler = engineWebGPU.setTextureSampler;\n            if (setTextureSampler) {\n                for (name in this._textureSamplers) {\n                    setTextureSampler.call(engineWebGPU, name, this._textureSamplers[name]);\n                }\n            }\n            // Storage buffers\n            const setStorageBuffer = engineWebGPU.setStorageBuffer;\n            if (setStorageBuffer) {\n                for (name in this._storageBuffers) {\n                    setStorageBuffer.call(engineWebGPU, name, this._storageBuffers[name]);\n                }\n            }\n        }\n        if (effect && mesh && (mustRebind || !this.isFrozen)) {\n            // Morph targets\n            BindMorphTargetParameters(mesh, effect);\n            if (mesh.morphTargetManager && mesh.morphTargetManager.isUsingTextureForTargets) {\n                mesh.morphTargetManager._bind(effect);\n            }\n            const bvaManager = mesh.bakedVertexAnimationManager;\n            if (bvaManager && bvaManager.isEnabled) {\n                const drawWrapper = storeEffectOnSubMeshes ? subMesh._drawWrapper : this._drawWrapper;\n                mesh.bakedVertexAnimationManager?.bind(effect, !!drawWrapper._wasPreviouslyUsingInstances);\n            }\n        }\n        this._afterBind(mesh, effect, subMesh);\n    }\n    /**\n     * Gets the active textures from the material\n     * @returns an array of textures\n     */\n    getActiveTextures() {\n        const activeTextures = super.getActiveTextures();\n        for (const name in this._textures) {\n            activeTextures.push(this._textures[name]);\n        }\n        for (const name in this._textureArrays) {\n            const array = this._textureArrays[name];\n            for (let index = 0; index < array.length; index++) {\n                activeTextures.push(array[index]);\n            }\n        }\n        return activeTextures;\n    }\n    /**\n     * Specifies if the material uses a texture\n     * @param texture defines the texture to check against the material\n     * @returns a boolean specifying if the material uses the texture\n     */\n    hasTexture(texture) {\n        if (super.hasTexture(texture)) {\n            return true;\n        }\n        for (const name in this._textures) {\n            if (this._textures[name] === texture) {\n                return true;\n            }\n        }\n        const internalTexture = texture.getInternalTexture();\n        for (const name in this._internalTextures) {\n            if (this._internalTextures[name] === internalTexture) {\n                return true;\n            }\n        }\n        for (const name in this._textureArrays) {\n            const array = this._textureArrays[name];\n            for (let index = 0; index < array.length; index++) {\n                if (array[index] === texture) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Makes a duplicate of the material, and gives it a new name\n     * @param name defines the new name for the duplicated material\n     * @returns the cloned material\n     */\n    clone(name) {\n        const result = SerializationHelper.Clone(() => new ShaderMaterial(name, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);\n        result.name = name;\n        result.id = name;\n        // Shader code path\n        if (typeof result._shaderPath === \"object\") {\n            result._shaderPath = { ...result._shaderPath };\n        }\n        // Options\n        this._options = { ...this._options };\n        const keys = Object.keys(this._options);\n        for (const propName of keys) {\n            const propValue = this._options[propName];\n            if (Array.isArray(propValue)) {\n                this._options[propName] = propValue.slice(0);\n            }\n        }\n        // Stencil\n        this.stencil.copyTo(result.stencil);\n        // Texture\n        for (const key in this._textures) {\n            result.setTexture(key, this._textures[key]);\n        }\n        for (const key in this._internalTextures) {\n            result.setInternalTexture(key, this._internalTextures[key]);\n        }\n        // TextureArray\n        for (const key in this._textureArrays) {\n            result.setTextureArray(key, this._textureArrays[key]);\n        }\n        // External texture\n        for (const key in this._externalTextures) {\n            result.setExternalTexture(key, this._externalTextures[key]);\n        }\n        // Int\n        for (const key in this._ints) {\n            result.setInt(key, this._ints[key]);\n        }\n        // UInt\n        for (const key in this._uints) {\n            result.setUInt(key, this._uints[key]);\n        }\n        // Float\n        for (const key in this._floats) {\n            result.setFloat(key, this._floats[key]);\n        }\n        // Floats\n        for (const key in this._floatsArrays) {\n            result.setFloats(key, this._floatsArrays[key]);\n        }\n        // Color3\n        for (const key in this._colors3) {\n            result.setColor3(key, this._colors3[key]);\n        }\n        // Color3Array\n        for (const key in this._colors3Arrays) {\n            result._colors3Arrays[key] = this._colors3Arrays[key];\n        }\n        // Color4\n        for (const key in this._colors4) {\n            result.setColor4(key, this._colors4[key]);\n        }\n        // Color4Array\n        for (const key in this._colors4Arrays) {\n            result._colors4Arrays[key] = this._colors4Arrays[key];\n        }\n        // Vector2\n        for (const key in this._vectors2) {\n            result.setVector2(key, this._vectors2[key]);\n        }\n        // Vector3\n        for (const key in this._vectors3) {\n            result.setVector3(key, this._vectors3[key]);\n        }\n        // Vector4\n        for (const key in this._vectors4) {\n            result.setVector4(key, this._vectors4[key]);\n        }\n        // Quaternion\n        for (const key in this._quaternions) {\n            result.setQuaternion(key, this._quaternions[key]);\n        }\n        // QuaternionArray\n        for (const key in this._quaternionsArrays) {\n            result._quaternionsArrays[key] = this._quaternionsArrays[key];\n        }\n        // Matrix\n        for (const key in this._matrices) {\n            result.setMatrix(key, this._matrices[key]);\n        }\n        // MatrixArray\n        for (const key in this._matrixArrays) {\n            result._matrixArrays[key] = this._matrixArrays[key].slice();\n        }\n        // Matrix 3x3\n        for (const key in this._matrices3x3) {\n            result.setMatrix3x3(key, this._matrices3x3[key]);\n        }\n        // Matrix 2x2\n        for (const key in this._matrices2x2) {\n            result.setMatrix2x2(key, this._matrices2x2[key]);\n        }\n        // Vector2Array\n        for (const key in this._vectors2Arrays) {\n            result.setArray2(key, this._vectors2Arrays[key]);\n        }\n        // Vector3Array\n        for (const key in this._vectors3Arrays) {\n            result.setArray3(key, this._vectors3Arrays[key]);\n        }\n        // Vector4Array\n        for (const key in this._vectors4Arrays) {\n            result.setArray4(key, this._vectors4Arrays[key]);\n        }\n        // Uniform buffers\n        for (const key in this._uniformBuffers) {\n            result.setUniformBuffer(key, this._uniformBuffers[key]);\n        }\n        // Samplers\n        for (const key in this._textureSamplers) {\n            result.setTextureSampler(key, this._textureSamplers[key]);\n        }\n        // Storag buffers\n        for (const key in this._storageBuffers) {\n            result.setStorageBuffer(key, this._storageBuffers[key]);\n        }\n        return result;\n    }\n    /**\n     * Disposes the material\n     * @param forceDisposeEffect specifies if effects should be forcefully disposed\n     * @param forceDisposeTextures specifies if textures should be forcefully disposed\n     * @param notBoundToMesh specifies if the material that is being disposed is known to be not bound to any mesh\n     */\n    dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {\n        if (forceDisposeTextures) {\n            let name;\n            for (name in this._textures) {\n                this._textures[name].dispose();\n            }\n            for (name in this._internalTextures) {\n                this._internalTextures[name].dispose();\n            }\n            for (name in this._textureArrays) {\n                const array = this._textureArrays[name];\n                for (let index = 0; index < array.length; index++) {\n                    array[index].dispose();\n                }\n            }\n        }\n        this._textures = {};\n        this._internalTextures = {};\n        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);\n    }\n    /**\n     * Serializes this material in a JSON representation\n     * @returns the serialized material object\n     */\n    serialize() {\n        const serializationObject = SerializationHelper.Serialize(this);\n        serializationObject.customType = \"BABYLON.ShaderMaterial\";\n        serializationObject.uniqueId = this.uniqueId;\n        serializationObject.options = this._options;\n        serializationObject.shaderPath = this._shaderPath;\n        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;\n        let name;\n        // Stencil\n        serializationObject.stencil = this.stencil.serialize();\n        // Texture\n        serializationObject.textures = {};\n        for (name in this._textures) {\n            serializationObject.textures[name] = this._textures[name].serialize();\n        }\n        // Texture arrays\n        serializationObject.textureArrays = {};\n        for (name in this._textureArrays) {\n            serializationObject.textureArrays[name] = [];\n            const array = this._textureArrays[name];\n            for (let index = 0; index < array.length; index++) {\n                serializationObject.textureArrays[name].push(array[index].serialize());\n            }\n        }\n        // Int\n        serializationObject.ints = {};\n        for (name in this._ints) {\n            serializationObject.ints[name] = this._ints[name];\n        }\n        // UInt\n        serializationObject.uints = {};\n        for (name in this._uints) {\n            serializationObject.uints[name] = this._uints[name];\n        }\n        // Float\n        serializationObject.floats = {};\n        for (name in this._floats) {\n            serializationObject.floats[name] = this._floats[name];\n        }\n        // Floats\n        serializationObject.floatsArrays = {};\n        for (name in this._floatsArrays) {\n            serializationObject.floatsArrays[name] = this._floatsArrays[name];\n        }\n        // Color3\n        serializationObject.colors3 = {};\n        for (name in this._colors3) {\n            const color3 = this._colors3[name];\n            serializationObject.colors3[name] = [color3.r, color3.g, color3.b];\n        }\n        // Color3 array\n        serializationObject.colors3Arrays = {};\n        for (name in this._colors3Arrays) {\n            serializationObject.colors3Arrays[name] = this._colors3Arrays[name];\n        }\n        // Color4\n        serializationObject.colors4 = {};\n        for (name in this._colors4) {\n            const color4 = this._colors4[name];\n            serializationObject.colors4[name] = [color4.r, color4.g, color4.b, color4.a];\n        }\n        // Color4 array\n        serializationObject.colors4Arrays = {};\n        for (name in this._colors4Arrays) {\n            serializationObject.colors4Arrays[name] = this._colors4Arrays[name];\n        }\n        // Vector2\n        serializationObject.vectors2 = {};\n        for (name in this._vectors2) {\n            const v2 = this._vectors2[name];\n            serializationObject.vectors2[name] = [v2.x, v2.y];\n        }\n        // Vector3\n        serializationObject.vectors3 = {};\n        for (name in this._vectors3) {\n            const v3 = this._vectors3[name];\n            serializationObject.vectors3[name] = [v3.x, v3.y, v3.z];\n        }\n        // Vector4\n        serializationObject.vectors4 = {};\n        for (name in this._vectors4) {\n            const v4 = this._vectors4[name];\n            serializationObject.vectors4[name] = [v4.x, v4.y, v4.z, v4.w];\n        }\n        // Quaternion\n        serializationObject.quaternions = {};\n        for (name in this._quaternions) {\n            serializationObject.quaternions[name] = this._quaternions[name].asArray();\n        }\n        // Matrix\n        serializationObject.matrices = {};\n        for (name in this._matrices) {\n            serializationObject.matrices[name] = this._matrices[name].asArray();\n        }\n        // MatrixArray\n        serializationObject.matrixArray = {};\n        for (name in this._matrixArrays) {\n            serializationObject.matrixArray[name] = this._matrixArrays[name];\n        }\n        // Matrix 3x3\n        serializationObject.matrices3x3 = {};\n        for (name in this._matrices3x3) {\n            serializationObject.matrices3x3[name] = this._matrices3x3[name];\n        }\n        // Matrix 2x2\n        serializationObject.matrices2x2 = {};\n        for (name in this._matrices2x2) {\n            serializationObject.matrices2x2[name] = this._matrices2x2[name];\n        }\n        // Vector2Array\n        serializationObject.vectors2Arrays = {};\n        for (name in this._vectors2Arrays) {\n            serializationObject.vectors2Arrays[name] = this._vectors2Arrays[name];\n        }\n        // Vector3Array\n        serializationObject.vectors3Arrays = {};\n        for (name in this._vectors3Arrays) {\n            serializationObject.vectors3Arrays[name] = this._vectors3Arrays[name];\n        }\n        // Vector4Array\n        serializationObject.vectors4Arrays = {};\n        for (name in this._vectors4Arrays) {\n            serializationObject.vectors4Arrays[name] = this._vectors4Arrays[name];\n        }\n        // QuaternionArray\n        serializationObject.quaternionsArrays = {};\n        for (name in this._quaternionsArrays) {\n            serializationObject.quaternionsArrays[name] = this._quaternionsArrays[name];\n        }\n        return serializationObject;\n    }\n    /**\n     * Creates a shader material from parsed shader material data\n     * @param source defines the JSON representation of the material\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a new material\n     */\n    static Parse(source, scene, rootUrl) {\n        const material = SerializationHelper.Parse(() => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes), source, scene, rootUrl);\n        let name;\n        // Stencil\n        if (source.stencil) {\n            material.stencil.parse(source.stencil, scene, rootUrl);\n        }\n        // Texture\n        for (name in source.textures) {\n            material.setTexture(name, Texture.Parse(source.textures[name], scene, rootUrl));\n        }\n        // Texture arrays\n        for (name in source.textureArrays) {\n            const array = source.textureArrays[name];\n            const textureArray = [];\n            for (let index = 0; index < array.length; index++) {\n                textureArray.push(Texture.Parse(array[index], scene, rootUrl));\n            }\n            material.setTextureArray(name, textureArray);\n        }\n        // Int\n        for (name in source.ints) {\n            material.setInt(name, source.ints[name]);\n        }\n        // UInt\n        for (name in source.uints) {\n            material.setUInt(name, source.uints[name]);\n        }\n        // Float\n        for (name in source.floats) {\n            material.setFloat(name, source.floats[name]);\n        }\n        // Floats\n        for (name in source.floatsArrays) {\n            material.setFloats(name, source.floatsArrays[name]);\n        }\n        // Color3\n        for (name in source.colors3) {\n            const color = source.colors3[name];\n            material.setColor3(name, { r: color[0], g: color[1], b: color[2] });\n        }\n        // Color3 arrays\n        for (name in source.colors3Arrays) {\n            const colors = source.colors3Arrays[name]\n                .reduce((arr, num, i) => {\n                if (i % 3 === 0) {\n                    arr.push([num]);\n                }\n                else {\n                    arr[arr.length - 1].push(num);\n                }\n                return arr;\n            }, [])\n                .map((color) => ({ r: color[0], g: color[1], b: color[2] }));\n            material.setColor3Array(name, colors);\n        }\n        // Color4\n        for (name in source.colors4) {\n            const color = source.colors4[name];\n            material.setColor4(name, { r: color[0], g: color[1], b: color[2], a: color[3] });\n        }\n        // Color4 arrays\n        for (name in source.colors4Arrays) {\n            const colors = source.colors4Arrays[name]\n                .reduce((arr, num, i) => {\n                if (i % 4 === 0) {\n                    arr.push([num]);\n                }\n                else {\n                    arr[arr.length - 1].push(num);\n                }\n                return arr;\n            }, [])\n                .map((color) => ({ r: color[0], g: color[1], b: color[2], a: color[3] }));\n            material.setColor4Array(name, colors);\n        }\n        // Vector2\n        for (name in source.vectors2) {\n            const vector = source.vectors2[name];\n            material.setVector2(name, { x: vector[0], y: vector[1] });\n        }\n        // Vector3\n        for (name in source.vectors3) {\n            const vector = source.vectors3[name];\n            material.setVector3(name, { x: vector[0], y: vector[1], z: vector[2] });\n        }\n        // Vector4\n        for (name in source.vectors4) {\n            const vector = source.vectors4[name];\n            material.setVector4(name, { x: vector[0], y: vector[1], z: vector[2], w: vector[3] });\n        }\n        // Quaternion\n        for (name in source.quaternions) {\n            material.setQuaternion(name, Quaternion.FromArray(source.quaternions[name]));\n        }\n        // Matrix\n        for (name in source.matrices) {\n            material.setMatrix(name, Matrix.FromArray(source.matrices[name]));\n        }\n        // MatrixArray\n        for (name in source.matrixArray) {\n            material._matrixArrays[name] = new Float32Array(source.matrixArray[name]);\n        }\n        // Matrix 3x3\n        for (name in source.matrices3x3) {\n            material.setMatrix3x3(name, source.matrices3x3[name]);\n        }\n        // Matrix 2x2\n        for (name in source.matrices2x2) {\n            material.setMatrix2x2(name, source.matrices2x2[name]);\n        }\n        // Vector2Array\n        for (name in source.vectors2Arrays) {\n            material.setArray2(name, source.vectors2Arrays[name]);\n        }\n        // Vector3Array\n        for (name in source.vectors3Arrays) {\n            material.setArray3(name, source.vectors3Arrays[name]);\n        }\n        // Vector4Array\n        for (name in source.vectors4Arrays) {\n            material.setArray4(name, source.vectors4Arrays[name]);\n        }\n        // QuaternionArray\n        for (name in source.quaternionsArrays) {\n            material.setArray4(name, source.quaternionsArrays[name]);\n        }\n        return material;\n    }\n    /**\n     * Creates a new ShaderMaterial from a snippet saved in a remote file\n     * @param name defines the name of the ShaderMaterial to create (can be null or empty to use the one from the json data)\n     * @param url defines the url to load from\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new ShaderMaterial\n     */\n    static async ParseFromFileAsync(name, url, scene, rootUrl = \"\") {\n        return await new Promise((resolve, reject) => {\n            const request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        const serializationObject = JSON.parse(request.responseText);\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n                        if (name) {\n                            output.name = name;\n                        }\n                        resolve(output);\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(\"Unable to load the ShaderMaterial\");\n                    }\n                }\n            });\n            request.open(\"GET\", url);\n            request.send();\n        });\n    }\n    /**\n     * Creates a ShaderMaterial from a snippet saved by the Inspector\n     * @param snippetId defines the snippet to load\n     * @param scene defines the hosting scene\n     * @param rootUrl defines the root URL to use to load textures and relative dependencies\n     * @returns a promise that will resolve to the new ShaderMaterial\n     */\n    static async ParseFromSnippetAsync(snippetId, scene, rootUrl = \"\") {\n        return await new Promise((resolve, reject) => {\n            const request = new WebRequest();\n            request.addEventListener(\"readystatechange\", () => {\n                if (request.readyState == 4) {\n                    if (request.status == 200) {\n                        const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);\n                        const serializationObject = JSON.parse(snippet.shaderMaterial);\n                        const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);\n                        output.snippetId = snippetId;\n                        resolve(output);\n                    }\n                    else {\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\n                        reject(\"Unable to load the snippet \" + snippetId);\n                    }\n                }\n            });\n            request.open(\"GET\", this.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"));\n            request.send();\n        });\n    }\n}\n/** Define the Url to load snippets */\nShaderMaterial.SnippetUrl = Constants.SnippetUrl;\n/**\n * Creates a ShaderMaterial from a snippet saved by the Inspector\n * @deprecated Please use ParseFromSnippetAsync instead\n * @param snippetId defines the snippet to load\n * @param scene defines the hosting scene\n * @param rootUrl defines the root URL to use to load textures and relative dependencies\n * @returns a promise that will resolve to the new ShaderMaterial\n */\nShaderMaterial.CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;\nRegisterClass(\"BABYLON.ShaderMaterial\", ShaderMaterial);\n//# sourceMappingURL=shaderMaterial.js.map"],"names":["_VertexPullingMetadataCache","WeakMap","OnCreatedEffectParameters","effect","subMesh","ShaderMaterial","PushMaterial","constructor","name","scene","shaderPath","options","storeEffectOnSubMeshes","super","this","_textures","_internalTextures","_textureArrays","_externalTextures","_floats","_ints","_uints","_floatsArrays","_colors3","_colors3Arrays","_colors4","_colors4Arrays","_vectors2","_vectors3","_vectors4","_quaternions","_quaternionsArrays","_matrices","_matrixArrays","_matrices3x3","_matrices2x2","_vectors2Arrays","_vectors3Arrays","_vectors4Arrays","_uniformBuffers","_textureSamplers","_storageBuffers","_cachedWorldViewMatrix","Matrix","_cachedWorldViewProjectionMatrix","_multiview","_vertexPullingMetadata","_materialHelperNeedsPreviousMatrices","_shaderPath","_options","needAlphaBlending","needAlphaTesting","attributes","uniforms","uniformBuffers","samplers","externalTextures","samplerObjects","storageBuffers","defines","useClipPlane","isMultiview","getClassName","alpha","_checkUniform","uniformName","indexOf","push","setTexture","texture","setInternalTexture","removeTexture","setTextureArray","textures","setExternalTexture","setFloat","value","setInt","setUInt","setFloats","setColor3","setColor3Array","reduce","arr","color","r","g","b","setColor4","setColor4Array","a","setVector2","setVector3","setVector4","setQuaternion","setQuaternionArray","quaternion","toArray","length","setMatrix","setMatrices","float32Array","Float32Array","index","copyToArray","setMatrix3x3","setMatrix2x2","setArray2","setArray3","setArray4","setUniformBuffer","buffer","setTextureSampler","sampler","setStorageBuffer","setDefine","define","defineName","trimEnd","existingDefineIdx","findIndex","x","startsWith","splice","isReadyForSubMesh","mesh","useInstances","isReady","_storeEffectOnSubMeshes","isFrozen","drawWrapper","_drawWrapper","_wasPreviouslyReady","_wasPreviouslyUsingInstances","getScene","engine","getEngine","attribs","fallbacks","shaderName","getCaps","multiview","activeCamera","outputRenderTarget","getViewCount","defineToAdd","isVerticesDataPresent","VertexBuffer","ColorKind","PushAttributesForInstances","hasThinInstances","ColorInstanceKind","useBones","computeBonesUsingShaders","skeleton","MatricesIndicesKind","MatricesWeightsKind","numBoneInfluencers","MatricesIndicesExtraKind","MatricesWeightsExtraKind","EffectFallbacks","addCPUSkinningFallback","isUsingTextureForMatrices","bones","numInfluencers","manager","morphTargetManager","uv","uv2","tangent","normal","PrepareDefinesAndAttributesForMorphTargets","isUsingTextureForTargets","slice","bvaManager","bakedVertexAnimationManager","isEnabled","needAlphaTestingForMesh","AddClipPlaneUniforms","PrepareStringDefinesForClipPlanes","fogEnabled","applyFog","fogMode","Scene","FOGMODE_NONE","_useLogarithmicDepth","renderingMesh","getRenderingMesh","useVertexPulling","geometry","vertexBuffers","getVertexBuffers","metadata","get","needsUpdate","vb","has","Map","set","vertexBuffer","offset","byteOffset","stride","byteStride","type","PrepareVertexPullingUniforms","forEach","_","attribute","indexBuffer","getIndexBuffer","isUnIndexed","is32Bits","customShaderNameResolve","_getDrawWrapper","undefined","previousEffect","previousDefines","join","createEffect","uniformsNames","uniformBuffersNames","onCompiled","onError","indexParameters","maxSimultaneousMorphTargets","shaderLanguage","extraInitializationsAsync","setEffect","_materialContext","_onEffectCreatedObservable","subMeshes","notifyObservers","resetCachedMaterial","bindOnlyWorldMatrix","world","effectOverride","getEffect","multiplyToRef","getViewMatrix","getTransformMatrix","bindForSubMesh","bind","_drawWrapperOverride","_activeEffect","useSceneUBO","supportsUniformBuffers","i","getMeshUniformBuffer","bindToEffect","transferToEffect","BindSceneUniformBuffer","getSceneUniformBuffer","finalizeSceneUbo","mustRebind","_mustRebind","visibility","getCachedMaterial","getProjectionMatrix","_transformMatrixR","globalPosition","BindBonesParameters","BindClipPlane","data","setFloat3","BindVertexPullingUniforms","BindLogDepth","materialDefines","BindFogParameters","_bindTexture","setArray","setFloat4","getBuffer","bindUniformBuffer","engineWebGPU","call","BindMorphTargetParameters","_bind","_afterBind","getActiveTextures","activeTextures","array","hasTexture","internalTexture","getInternalTexture","clone","result","SerializationHelper","Clone","id","keys","Object","propName","propValue","Array","isArray","stencil","copyTo","key","dispose","forceDisposeEffect","forceDisposeTextures","notBoundToMesh","serialize","serializationObject","Serialize","customType","uniqueId","textureArrays","ints","uints","floats","floatsArrays","colors3","color3","colors3Arrays","colors4","color4","colors4Arrays","vectors2","v2","y","vectors3","v3","z","vectors4","v4","w","quaternions","asArray","matrices","matrixArray","matrices3x3","matrices2x2","vectors2Arrays","vectors3Arrays","vectors4Arrays","quaternionsArrays","Parse","source","rootUrl","material","parse","Texture","textureArray","colors","num","map","vector","Quaternion","FromArray","ParseFromFileAsync","url","Promise","resolve","reject","request","WebRequest","addEventListener","readyState","status","JSON","responseText","output","EngineStore","LastCreatedScene","open","send","ParseFromSnippetAsync","snippetId","snippet","jsonPayload","shaderMaterial","SnippetUrl","replace","Constants","CreateFromSnippetAsync","RegisterClass"],"mappings":"0MACA,MAAMA,EAA8B,IAAIC,QCaxC,MAAMC,EAA4B,CAAEC,OAAQ,KAAMC,QAAS,MAQpD,MAAMC,UAAuBC,EAYhC,WAAAC,CAAYC,EAAMC,EAAOC,EAAYC,EAAU,CAAE,EAAEC,GAAyB,GACxEC,MAAML,EAAMC,EAAOG,GACnBE,KAAKC,UAAY,CAAE,EACnBD,KAAKE,kBAAoB,CAAE,EAC3BF,KAAKG,eAAiB,CAAE,EACxBH,KAAKI,kBAAoB,CAAE,EAC3BJ,KAAKK,QAAU,CAAE,EACjBL,KAAKM,MAAQ,CAAE,EACfN,KAAKO,OAAS,CAAE,EAChBP,KAAKQ,cAAgB,CAAE,EACvBR,KAAKS,SAAW,CAAE,EAClBT,KAAKU,eAAiB,CAAE,EACxBV,KAAKW,SAAW,CAAE,EAClBX,KAAKY,eAAiB,CAAE,EACxBZ,KAAKa,UAAY,CAAE,EACnBb,KAAKc,UAAY,CAAE,EACnBd,KAAKe,UAAY,CAAE,EACnBf,KAAKgB,aAAe,CAAE,EACtBhB,KAAKiB,mBAAqB,CAAE,EAC5BjB,KAAKkB,UAAY,CAAE,EACnBlB,KAAKmB,cAAgB,CAAE,EACvBnB,KAAKoB,aAAe,CAAE,EACtBpB,KAAKqB,aAAe,CAAE,EACtBrB,KAAKsB,gBAAkB,CAAE,EACzBtB,KAAKuB,gBAAkB,CAAE,EACzBvB,KAAKwB,gBAAkB,CAAE,EACzBxB,KAAKyB,gBAAkB,CAAE,EACzBzB,KAAK0B,iBAAmB,CAAE,EAC1B1B,KAAK2B,gBAAkB,CAAE,EACzB3B,KAAK4B,uBAAyB,IAAIC,EAClC7B,KAAK8B,iCAAmC,IAAID,EAC5C7B,KAAK+B,YAAa,EAClB/B,KAAKgC,uBAAyB,KAI9BhC,KAAKiC,sCAAuC,EAC5CjC,KAAKkC,YAActC,EACnBI,KAAKmC,SAAW,CACZC,mBAAmB,EACnBC,kBAAkB,EAClBC,WAAY,CAAC,WAAY,SAAU,MACnCC,SAAU,CAAC,uBACXC,eAAgB,GAChBC,SAAU,GACVC,iBAAkB,GAClBC,eAAgB,GAChBC,eAAgB,GAChBC,QAAS,GACTC,cAAc,KACXjD,EAEf,CAKI,cAAID,GACA,OAAOI,KAAKkC,WACpB,CAKI,cAAItC,CAAWA,GACXI,KAAKkC,YAActC,CAC3B,CAKI,WAAIC,GACA,OAAOG,KAAKmC,QACpB,CAII,eAAIY,GACA,OAAO/C,KAAK+B,UACpB,CAMI,YAAAiB,GACI,MAAO,gBACf,CAKI,iBAAAZ,GACI,OAAOpC,KAAKiD,MAAQ,GAAOjD,KAAKmC,SAASC,iBACjD,CAKI,gBAAAC,GACI,OAAOrC,KAAKmC,SAASE,gBAC7B,CACI,aAAAa,CAAcC,QACNnD,KAAKmC,SAASI,SAASa,QAAQD,IAC/BnD,KAAKmC,SAASI,SAASc,KAAKF,EAExC,CAOI,UAAAG,CAAW5D,EAAM6D,GAKb,WAJIvD,KAAKmC,SAASM,SAASW,QAAQ1D,IAC/BM,KAAKmC,SAASM,SAASY,KAAK3D,GAEhCM,KAAKC,UAAUP,GAAQ6D,EAChBvD,IACf,CAOI,kBAAAwD,CAAmB9D,EAAM6D,GAKrB,WAJIvD,KAAKmC,SAASM,SAASW,QAAQ1D,IAC/BM,KAAKmC,SAASM,SAASY,KAAK3D,GAEhCM,KAAKE,kBAAkBR,GAAQ6D,EACxBvD,IACf,CAKI,aAAAyD,CAAc/D,UACHM,KAAKC,UAAUP,EAC9B,CAOI,eAAAgE,CAAgBhE,EAAMiE,GAMlB,WALI3D,KAAKmC,SAASM,SAASW,QAAQ1D,IAC/BM,KAAKmC,SAASM,SAASY,KAAK3D,GAEhCM,KAAKkD,cAAcxD,GACnBM,KAAKG,eAAeT,GAAQiE,EACrB3D,IACf,CAOI,kBAAA4D,CAAmBlE,EAAM6D,GAKrB,WAJIvD,KAAKmC,SAASO,iBAAiBU,QAAQ1D,IACvCM,KAAKmC,SAASO,iBAAiBW,KAAK3D,GAExCM,KAAKI,kBAAkBV,GAAQ6D,EACxBvD,IACf,CAOI,QAAA6D,CAASnE,EAAMoE,GAGX,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKK,QAAQX,GAAQoE,EACd9D,IACf,CAOI,MAAA+D,CAAOrE,EAAMoE,GAGT,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKM,MAAMZ,GAAQoE,EACZ9D,IACf,CAOI,OAAAgE,CAAQtE,EAAMoE,GAGV,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKO,OAAOb,GAAQoE,EACb9D,IACf,CAOI,SAAAiE,CAAUvE,EAAMoE,GAGZ,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKQ,cAAcd,GAAQoE,EACpB9D,IACf,CAOI,SAAAkE,CAAUxE,EAAMoE,GAGZ,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKS,SAASf,GAAQoE,EACf9D,IACf,CAOI,cAAAmE,CAAezE,EAAMoE,GAMjB,OALA9D,KAAKkD,cAAcxD,GACnBM,KAAKU,eAAehB,GAAQoE,EAAMM,QAAO,CAACC,EAAKC,KAC3CD,EAAIhB,KAAKiB,EAAMC,EAAGD,EAAME,EAAGF,EAAMG,GAC1BJ,IACR,IACIrE,IACf,CAOI,SAAA0E,CAAUhF,EAAMoE,GAGZ,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKW,SAASjB,GAAQoE,EACf9D,IACf,CAOI,cAAA2E,CAAejF,EAAMoE,GAMjB,OALA9D,KAAKkD,cAAcxD,GACnBM,KAAKY,eAAelB,GAAQoE,EAAMM,QAAO,CAACC,EAAKC,KAC3CD,EAAIhB,KAAKiB,EAAMC,EAAGD,EAAME,EAAGF,EAAMG,EAAGH,EAAMM,GACnCP,IACR,IACIrE,IACf,CAOI,UAAA6E,CAAWnF,EAAMoE,GAGb,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKa,UAAUnB,GAAQoE,EAChB9D,IACf,CAOI,UAAA8E,CAAWpF,EAAMoE,GAGb,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKc,UAAUpB,GAAQoE,EAChB9D,IACf,CAOI,UAAA+E,CAAWrF,EAAMoE,GAGb,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKe,UAAUrB,GAAQoE,EAChB9D,IACf,CAOI,aAAAgF,CAActF,EAAMoE,GAGhB,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKgB,aAAatB,GAAQoE,EACnB9D,IACf,CAOI,kBAAAiF,CAAmBvF,EAAMoE,GAMrB,OALA9D,KAAKkD,cAAcxD,GACnBM,KAAKiB,mBAAmBvB,GAAQoE,EAAMM,QAAO,CAACC,EAAKa,KAC/CA,EAAWC,QAAQd,EAAKA,EAAIe,QACrBf,IACR,IACIrE,IACf,CAOI,SAAAqF,CAAU3F,EAAMoE,GAGZ,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKkB,UAAUxB,GAAQoE,EAChB9D,IACf,CAOI,WAAAsF,CAAY5F,EAAMoE,GACd9D,KAAKkD,cAAcxD,GACnB,MAAM6F,EAAe,IAAIC,aAA4B,GAAf1B,EAAMsB,QAC5C,IAAK,IAAIK,EAAQ,EAAGA,EAAQ3B,EAAMsB,OAAQK,IAAS,CAChC3B,EAAM2B,GACdC,YAAYH,EAAsB,GAARE,EAC7C,CAEQ,OADAzF,KAAKmB,cAAczB,GAAQ6F,EACpBvF,IACf,CAOI,YAAA2F,CAAajG,EAAMoE,GAGf,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKoB,aAAa1B,GAAQoE,EACnB9D,IACf,CAOI,YAAA4F,CAAalG,EAAMoE,GAGf,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKqB,aAAa3B,GAAQoE,EACnB9D,IACf,CAOI,SAAA6F,CAAUnG,EAAMoE,GAGZ,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKsB,gBAAgB5B,GAAQoE,EACtB9D,IACf,CAOI,SAAA8F,CAAUpG,EAAMoE,GAGZ,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKuB,gBAAgB7B,GAAQoE,EACtB9D,IACf,CAOI,SAAA+F,CAAUrG,EAAMoE,GAGZ,OAFA9D,KAAKkD,cAAcxD,GACnBM,KAAKwB,gBAAgB9B,GAAQoE,EACtB9D,IACf,CAOI,gBAAAgG,CAAiBtG,EAAMuG,GAKnB,WAJIjG,KAAKmC,SAASK,eAAeY,QAAQ1D,IACrCM,KAAKmC,SAASK,eAAea,KAAK3D,GAEtCM,KAAKyB,gBAAgB/B,GAAQuG,EACtBjG,IACf,CAOI,iBAAAkG,CAAkBxG,EAAMyG,GAKpB,WAJInG,KAAKmC,SAASQ,eAAeS,QAAQ1D,IACrCM,KAAKmC,SAASQ,eAAeU,KAAK3D,GAEtCM,KAAK0B,iBAAiBhC,GAAQyG,EACvBnG,IACf,CAOI,gBAAAoG,CAAiB1G,EAAMuG,GAKnB,WAJIjG,KAAKmC,SAASS,eAAeQ,QAAQ1D,IACrCM,KAAKmC,SAASS,eAAeS,KAAK3D,GAEtCM,KAAK2B,gBAAgBjC,GAAQuG,EACtBjG,IACf,CAWI,SAAAqG,CAAUC,EAAQxC,GAEd,MAAMyC,EAAaD,EAAOE,UAAY,IAChCC,EAAoBzG,KAAKH,QAAQgD,QAAQ6D,WAAWC,GAAMA,IAAML,GAAUK,EAAEC,WAAWL,KAQ7F,OAPIE,GAAqB,GACrBzG,KAAKH,QAAQgD,QAAQgE,OAAOJ,EAAmB,IAG9B,kBAAV3C,GAAuBA,IAC9B9D,KAAKH,QAAQgD,QAAQQ,KAAKkD,EAAazC,GAEpC9D,IACf,CAQI,iBAAA8G,CAAkBC,EAAMzH,EAAS0H,GAC7B,OAAOhH,KAAKiH,QAAQF,EAAMC,EAAc1H,EAChD,CAQI,OAAA2H,CAAQF,EAAMC,EAAc1H,GACxB,MAAMQ,EAAyBR,GAAWU,KAAKkH,wBAC/C,GAAIlH,KAAKmH,SAAU,CACf,MAAMC,EAActH,EAAyBR,EAAQ+H,aAAerH,KAAKqH,aACzE,GAAID,EAAY/H,QAAU+H,EAAYE,qBAAuBF,EAAYG,+BAAiCP,EACtG,OAAO,CAEvB,CACQ,MAAMrH,EAAQK,KAAKwH,WACbC,EAAS9H,EAAM+H,YAEf7E,EAAU,GACV8E,EAAU,GAChB,IAAIC,EAAY,KACZC,EAAa7H,KAAKkC,YAAaK,EAAWvC,KAAKmC,SAASI,SAAUC,EAAiBxC,KAAKmC,SAASK,eAAgBC,EAAWzC,KAAKmC,SAASM,SAE1IgF,EAAOK,UAAUC,WAAapI,EAAMqI,cAAgBrI,EAAMqI,aAAaC,oBAAsBtI,EAAMqI,aAAaC,mBAAmBC,eAAiB,IACpJlI,KAAK+B,YAAa,EAClBc,EAAQQ,KAAK,sBAC8B,IAAvCd,EAASa,QAAQ,wBAA4Bb,EAASa,QAAQ,oBAC9Db,EAASc,KAAK,oBAGtB,IAAK,IAAIoC,EAAQ,EAAGA,EAAQzF,KAAKmC,SAASU,QAAQuC,OAAQK,IAAS,CAC/D,MAAM0C,EAAkE,IAApDnI,KAAKmC,SAASU,QAAQ4C,GAAOrC,QAAQ,WAAmBpD,KAAKmC,SAASU,QAAQ4C,GAAS,WAAWzF,KAAKmC,SAASU,QAAQ4C,KAC5I5C,EAAQQ,KAAK8E,EACzB,CACQ,IAAK,IAAI1C,EAAQ,EAAGA,EAAQzF,KAAKmC,SAASG,WAAW8C,OAAQK,IACzDkC,EAAQtE,KAAKrD,KAAKmC,SAASG,WAAWmD,IAoB1C,GAlBIsB,GAAQA,EAAKqB,sBAAsBC,EAAaC,cACA,IAA5CX,EAAQvE,QAAQiF,EAAaC,YAC7BX,EAAQtE,KAAKgF,EAAaC,WAE9BzF,EAAQQ,KAAK,wBAEb2D,IACAnE,EAAQQ,KAAK,qBACbkF,EAA2BZ,EAAS3H,KAAKiC,sCACrC8E,GAAMyB,mBACN3F,EAAQQ,KAAK,0BACT0D,GAAQA,EAAKqB,sBAAsBC,EAAaI,qBAChDd,EAAQtE,KAAKgF,EAAaI,mBAC1B5F,EAAQQ,KAAK,6BAKrB0D,GAAQA,EAAK2B,UAAY3B,EAAK4B,0BAA4B5B,EAAK6B,SAAU,CACzEjB,EAAQtE,KAAKgF,EAAaQ,qBAC1BlB,EAAQtE,KAAKgF,EAAaS,qBACtB/B,EAAKgC,mBAAqB,IAC1BpB,EAAQtE,KAAKgF,EAAaW,0BAC1BrB,EAAQtE,KAAKgF,EAAaY,2BAE9B,MAAML,EAAW7B,EAAK6B,SACtB/F,EAAQQ,KAAK,gCAAkC0D,EAAKgC,oBACpDnB,EAAY,IAAIsB,EAChBtB,EAAUuB,uBAAuB,EAAGpC,GAChC6B,EAASQ,2BACTvG,EAAQQ,KAAK,wBACgC,IAAzCd,EAASa,QAAQ,qBACjBb,EAASc,KAAK,yBAEdrD,KAAKmC,SAASM,SAASW,QAAQ,gBAC/BpD,KAAKmC,SAASM,SAASY,KAAK,iBAIhCR,EAAQQ,KAAK,yBAA2BuF,EAASS,MAAMjE,OAAS,KAC7B,IAA/B7C,EAASa,QAAQ,WACjBb,EAASc,KAAK,UAGlC,MAEYR,EAAQQ,KAAK,kCAGjB,IAAIiG,EAAiB,EACrB,MAAMC,EAAUxC,EAAOA,EAAKyC,mBAAqB,KACjD,GAAID,EAAS,CACT,MAAME,GAA0C,IAArC5G,EAAQO,QAAQ,eACrBsG,GAA2C,IAArC7G,EAAQO,QAAQ,eACtBuG,GAAmD,IAAzC9G,EAAQO,QAAQ,mBAC1BwG,GAAiD,IAAxC/G,EAAQO,QAAQ,kBACzBkB,GAAqD,IAA7CzB,EAAQO,QAAQ,uBAC9BkG,EAAiBO,EAA2CN,EAAS1G,EAAS8E,EAASZ,GAAM,EAC7F6C,EACAD,EACAF,EACAC,EACApF,GAEIiF,EAAQO,4BAC8C,IAAlDvH,EAASa,QAAQ,8BACjBb,EAASc,KAAK,kCAEdrD,KAAKmC,SAASM,SAASW,QAAQ,iBAC/BpD,KAAKmC,SAASM,SAASY,KAAK,iBAGhCiG,EAAiB,IACjB/G,EAAWA,EAASwH,QACpBxH,EAASc,KAAK,yBACdd,EAASc,KAAK,oBACdd,EAASc,KAAK,0BACdd,EAASc,KAAK,6BAE9B,MAEYR,EAAQQ,KAAK,mCAGjB,GAAI0D,EAAM,CACN,MAAMiD,EAAajD,EAAKkD,4BACpBD,GAAcA,EAAWE,YACzBrH,EAAQQ,KAAK,2CAC4C,IAArDd,EAASa,QAAQ,iCACjBb,EAASc,KAAK,iCAEkD,IAAhEd,EAASa,QAAQ,4CACjBb,EAASc,KAAK,4CAEmC,IAAjDd,EAASa,QAAQ,6BACjBb,EAASc,KAAK,iCAEdrD,KAAKmC,SAASM,SAASW,QAAQ,gCAC/BpD,KAAKmC,SAASM,SAASY,KAAK,+BAE5B2D,GACAW,EAAQtE,KAAK,yCAGjC,CAEQ,IAAK,MAAM3D,KAAQM,KAAKC,UACpB,IAAKD,KAAKC,UAAUP,GAAMuH,UACtB,OAAO,EAGf,IAAK,MAAMvH,KAAQM,KAAKE,kBACpB,IAAKF,KAAKE,kBAAkBR,GAAMuH,QAC9B,OAAO,EAIXF,GAAQ/G,KAAKmK,wBAAwBpD,IACrClE,EAAQQ,KAAK,sBAGkB,IAA/BrD,KAAKmC,SAASW,eACdsH,EAAqB7H,GACrB8H,EAAkCrK,KAAML,EAAOkD,IAG/ClD,EAAM2K,YAAcvD,GAAMwD,UAAY5K,EAAM6K,UAAYC,EAAMC,eAC9D7H,EAAQQ,KAAK,gBACoB,IAA7Bd,EAASa,QAAQ,SACjBb,EAASc,KAAK,SAEoB,IAAlCd,EAASa,QAAQ,cACjBb,EAASc,KAAK,cAEoB,IAAlCd,EAASa,QAAQ,cACjBb,EAASc,KAAK,cAIlBrD,KAAK2K,uBACL9H,EAAQQ,KAAK,6BACwC,IAAjDd,EAASa,QAAQ,6BACjBb,EAASc,KAAK,6BAGtB,MAAMuH,EAAgBtL,EAAUA,EAAQuL,mBAAqB9D,EAC7D,GAAI6D,GAAiB5K,KAAK8K,iBAAkB,CAExC,MAAMC,EAAWH,EAAcG,SAC3BA,IACA/K,KAAKgC,uBD/qBd,SAAsC+I,GACzC,MAAMC,EAAgBD,EAASE,mBAC/B,IAAKD,EACD,OAAO,KAGX,IAAIE,EAAWhM,EAA4BiM,IAAIJ,GAC/C,GAAKG,EAIA,CAED,IAAIE,GAAc,EAClB,IAAK,MAAMC,KAAML,EACb,IAAKE,EAASI,IAAID,GAAK,CACnBD,GAAc,EACd,KAChB,CAEQ,IAAKA,EACD,OAAOF,CAEnB,MAfQA,EAAW,IAAIK,IACfrM,EAA4BsM,IAAIT,EAAUG,GAgB9C,IAAK,MAAMG,KAAML,EAAe,CAC5B,MAAMS,EAAeT,EAAcK,GACnC,GAAII,EAAc,CACd,MAAMC,EAASD,EAAaE,WACtBC,EAASH,EAAaI,WACtBC,EAAOL,EAAaK,KAC1BZ,EAASM,IAAIH,EAAI,CACbK,OAAQA,EACRE,OAAQA,EACRE,KAAMA,GAEtB,CACA,CACI,OAAOZ,CACX,CCwoB8Ca,CAA6BhB,GACvD/K,KAAKgC,wBACLhC,KAAKgC,uBAAuBgK,SAAQ,CAACC,EAAGC,KACpC3J,EAASc,KAAK,MAAM6I,cAIhCrJ,EAAQQ,KAAK,8BACb,MAAM8I,EAAcvB,EAAcG,UAAUqB,iBACxCD,IAAgBvB,EAAcyB,cAC9BxJ,EAAQQ,KAAK,2CACT8I,EAAYG,UACZzJ,EAAQQ,KAAK,8CAGjC,CACYrD,KAAKuM,0BACLhK,EAAWA,EAASwH,QACpBvH,EAAiBA,EAAeuH,QAChCtH,EAAWA,EAASsH,QACpBlC,EAAa7H,KAAKuM,wBAAwBvM,KAAKN,KAAM6C,EAAUC,EAAgBC,EAAUI,EAAS8E,IAEtG,MAAMP,EAActH,EAAyBR,EAAQkN,qBAAgBC,GAAW,GAAQzM,KAAKqH,aACvFqF,EAAiBtF,GAAa/H,QAAU,KACxCsN,EAAkBvF,GAAavE,SAAW,KAC1C+J,EAAO/J,EAAQ+J,KAAK,MAC1B,IAAIvN,EAASqN,EA4Bb,OA3BIC,IAAoBC,IACpBvN,EAASoI,EAAOoF,aAAahF,EAAY,CACrCvF,WAAYqF,EACZmF,cAAevK,EACfwK,oBAAqBvK,EACrBC,SAAUA,EACVI,QAAS+J,EACThF,UAAWA,EACXoF,WAAYhN,KAAKgN,WACjBC,QAASjN,KAAKiN,QACdC,gBAAiB,CAAEC,4BAA6B7D,GAChD8D,eAAgBpN,KAAKmC,SAASiL,eAC9BC,0BAA2BrN,KAAKmC,SAASkL,2BAC1C5F,GACC3H,EACAR,EAAQgO,UAAUjO,EAAQuN,EAAM5M,KAAKuN,kBAEhCnG,GACLA,EAAYkG,UAAUjO,EAAQuN,GAE9B5M,KAAKwN,6BACLpO,EAA0BC,OAASA,EACnCD,EAA0BE,QAAUA,GAAWyH,GAAM0G,UAAU,IAAM,KACrEzN,KAAKwN,2BAA2BE,gBAAgBtO,KAGxDgI,EAAYG,+BAAiCP,IACxC3H,GAAQ4H,YAGTyF,IAAmBrN,GACnBM,EAAMgO,sBAEVvG,EAAYE,qBAAsB,GAC3B,EACf,CAMI,mBAAAsG,CAAoBC,EAAOC,GACvB,MAAMzO,EAASyO,GAAkB9N,KAAK+N,YACtC,IAAK1O,EACD,OAEJ,MAAMkD,EAAWvC,KAAKmC,SAASI,UACG,IAA9BA,EAASa,QAAQ,UACjB/D,EAAOgG,UAAU,QAASwI,GAE9B,MAAMlO,EAAQK,KAAKwH,YACmB,IAAlCjF,EAASa,QAAQ,eACjByK,EAAMG,cAAcrO,EAAMsO,gBAAiBjO,KAAK4B,wBAChDvC,EAAOgG,UAAU,YAAarF,KAAK4B,0BAES,IAA5CW,EAASa,QAAQ,yBACjByK,EAAMG,cAAcrO,EAAMuO,qBAAsBlO,KAAK8B,kCACrDzC,EAAOgG,UAAU,sBAAuBrF,KAAK8B,oCAEhB,IAA7BS,EAASa,QAAQ,SACjB/D,EAAOgG,UAAU,OAAQ1F,EAAMsO,gBAE3C,CAOI,cAAAE,CAAeN,EAAO9G,EAAMzH,GACxBU,KAAKoO,KAAKP,EAAO9G,EAAMzH,EAAQ+O,sBAAsBhP,OAAQC,EACrE,CAQI,IAAA8O,CAAKP,EAAO9G,EAAM+G,EAAgBxO,GAE9B,MAAMQ,EAAyBR,GAAWU,KAAKkH,wBACzC7H,EAASyO,IAAmBhO,EAAyBR,EAAQD,OAASW,KAAK+N,aACjF,IAAK1O,EACD,OAEJ,MAAMM,EAAQK,KAAKwH,WACnBxH,KAAKsO,cAAgBjP,EACrBW,KAAK4N,oBAAoBC,EAAOC,GAChC,MAAMtL,EAAiBxC,KAAKmC,SAASK,eACrC,IAAI+L,GAAc,EAClB,GAAIlP,GAAUmD,GAAkBA,EAAe4C,OAAS,GAAKzF,EAAM+H,YAAY8G,uBAC3E,IAAK,IAAIC,EAAI,EAAGA,EAAIjM,EAAe4C,SAAUqJ,EAAG,CAE5C,OADmBjM,EAAeiM,IAE9B,IAAK,OACG1H,IACAA,EAAK2H,uBAAuBC,aAAatP,EAAQ,QACjD0H,EAAK6H,iBAAiBf,IAE1B,MACJ,IAAK,QACDgB,EAAuBxP,EAAQM,EAAMmP,yBACrCnP,EAAMoP,mBACNR,GAAc,EAGtC,CAEQ,MAAMS,EAAajI,GAAQjH,EAAyBE,KAAKiP,YAAYtP,EAAON,EAAQC,EAASyH,EAAKmI,YAAcvP,EAAMwP,sBAAwBnP,KAC9I,GAAIX,GAAU2P,EAAY,CA+BtB,IAAItP,EAEJ,IAAKA,KAhCA6O,QAAevO,KAAKmC,SAASI,SAASa,QAAQ,SAC/C/D,EAAOgG,UAAU,OAAQ1F,EAAMsO,iBAE9BM,QAAevO,KAAKmC,SAASI,SAASa,QAAQ,eAC/C/D,EAAOgG,UAAU,aAAc1F,EAAMyP,uBAEpCb,QAAevO,KAAKmC,SAASI,SAASa,QAAQ,oBAC/C/D,EAAOgG,UAAU,iBAAkB1F,EAAMuO,sBACrClO,KAAK+B,YACL1C,EAAOgG,UAAU,kBAAmB1F,EAAM0P,oBAG9C1P,EAAMqI,mBAAgBhI,KAAKmC,SAASI,SAASa,QAAQ,mBACrD/D,EAAOyF,WAAW,iBAAkBnF,EAAMqI,aAAasH,gBAG3DC,EAAoBxI,EAAM1H,GAE1BmQ,EAAcnQ,EAAQW,KAAML,GACxBK,KAAKgC,wBD/xBd,SAAmC3C,EAAQ6L,GAC9CA,EAASc,SAAQ,CAACyD,EAAMvD,KACpB,MAAM/I,EAAc,MAAM+I,SAE1B7M,EAAOqQ,UAAUvM,EAAasM,EAAK/D,OAAQ+D,EAAK7D,OAAQ6D,EAAK3D,QAErE,CC0xBgB6D,CAA0BtQ,EAAQW,KAAKgC,wBAGvChC,KAAK2K,sBACLiF,EAAa9P,EAAyBR,EAAQuQ,gBAAkBxQ,EAAOwD,QAASxD,EAAQM,GAGxFoH,GACA+I,EAAkBnQ,EAAOoH,EAAM1H,GAItBW,KAAKC,UACdZ,EAAOiE,WAAW5D,EAAMM,KAAKC,UAAUP,IAE3C,IAAKA,KAAQM,KAAKE,kBACdb,EAAO0Q,aAAarQ,EAAMM,KAAKE,kBAAkBR,IAGrD,IAAKA,KAAQM,KAAKG,eACdd,EAAOqE,gBAAgBhE,EAAMM,KAAKG,eAAeT,IAGrD,IAAKA,KAAQM,KAAKM,MACdjB,EAAO0E,OAAOrE,EAAMM,KAAKM,MAAMZ,IAGnC,IAAKA,KAAQM,KAAKO,OACdlB,EAAO2E,QAAQtE,EAAMM,KAAKO,OAAOb,IAGrC,IAAKA,KAAQM,KAAKK,QACdhB,EAAOwE,SAASnE,EAAMM,KAAKK,QAAQX,IAGvC,IAAKA,KAAQM,KAAKQ,cACdnB,EAAO2Q,SAAStQ,EAAMM,KAAKQ,cAAcd,IAG7C,IAAKA,KAAQM,KAAKS,SACdpB,EAAO6E,UAAUxE,EAAMM,KAAKS,SAASf,IAGzC,IAAKA,KAAQM,KAAKU,eACdrB,EAAOyG,UAAUpG,EAAMM,KAAKU,eAAehB,IAG/C,IAAKA,KAAQM,KAAKW,SAAU,CACxB,MAAM2D,EAAQtE,KAAKW,SAASjB,GAC5BL,EAAO4Q,UAAUvQ,EAAM4E,EAAMC,EAAGD,EAAME,EAAGF,EAAMG,EAAGH,EAAMM,EACxE,CAEY,IAAKlF,KAAQM,KAAKY,eACdvB,EAAO0G,UAAUrG,EAAMM,KAAKY,eAAelB,IAG/C,IAAKA,KAAQM,KAAKa,UACdxB,EAAOwF,WAAWnF,EAAMM,KAAKa,UAAUnB,IAG3C,IAAKA,KAAQM,KAAKc,UACdzB,EAAOyF,WAAWpF,EAAMM,KAAKc,UAAUpB,IAG3C,IAAKA,KAAQM,KAAKe,UACd1B,EAAO0F,WAAWrF,EAAMM,KAAKe,UAAUrB,IAG3C,IAAKA,KAAQM,KAAKgB,aACd3B,EAAO2F,cAActF,EAAMM,KAAKgB,aAAatB,IAGjD,IAAKA,KAAQM,KAAKkB,UACd7B,EAAOgG,UAAU3F,EAAMM,KAAKkB,UAAUxB,IAG1C,IAAKA,KAAQM,KAAKmB,cACd9B,EAAOiG,YAAY5F,EAAMM,KAAKmB,cAAczB,IAGhD,IAAKA,KAAQM,KAAKoB,aACd/B,EAAOsG,aAAajG,EAAMM,KAAKoB,aAAa1B,IAGhD,IAAKA,KAAQM,KAAKqB,aACdhC,EAAOuG,aAAalG,EAAMM,KAAKqB,aAAa3B,IAGhD,IAAKA,KAAQM,KAAKsB,gBACdjC,EAAOwG,UAAUnG,EAAMM,KAAKsB,gBAAgB5B,IAGhD,IAAKA,KAAQM,KAAKuB,gBACdlC,EAAOyG,UAAUpG,EAAMM,KAAKuB,gBAAgB7B,IAGhD,IAAKA,KAAQM,KAAKwB,gBACdnC,EAAO0G,UAAUrG,EAAMM,KAAKwB,gBAAgB9B,IAGhD,IAAKA,KAAQM,KAAKiB,mBACd5B,EAAO0G,UAAUrG,EAAMM,KAAKiB,mBAAmBvB,IAGnD,IAAKA,KAAQM,KAAKyB,gBAAiB,CAC/B,MAAMwE,EAASjG,KAAKyB,gBAAgB/B,GAAMwQ,YACtCjK,GACA5G,EAAO8Q,kBAAkBlK,EAAQvG,EAErD,CACY,MAAM0Q,EAAezQ,EAAM+H,YAErB9D,EAAqBwM,EAAaxM,mBACxC,GAAIA,EACA,IAAKlE,KAAQM,KAAKI,kBACdwD,EAAmByM,KAAKD,EAAc1Q,EAAMM,KAAKI,kBAAkBV,IAI3E,MAAMwG,EAAoBkK,EAAalK,kBACvC,GAAIA,EACA,IAAKxG,KAAQM,KAAK0B,iBACdwE,EAAkBmK,KAAKD,EAAc1Q,EAAMM,KAAK0B,iBAAiBhC,IAIzE,MAAM0G,EAAmBgK,EAAahK,iBACtC,GAAIA,EACA,IAAK1G,KAAQM,KAAK2B,gBACdyE,EAAiBiK,KAAKD,EAAc1Q,EAAMM,KAAK2B,gBAAgBjC,GAGnF,CACQ,GAAIL,GAAU0H,IAASiI,IAAehP,KAAKmH,UAAW,CAElDmJ,EAA0BvJ,EAAM1H,GAC5B0H,EAAKyC,oBAAsBzC,EAAKyC,mBAAmBM,0BACnD/C,EAAKyC,mBAAmB+G,MAAMlR,GAElC,MAAM2K,EAAajD,EAAKkD,4BACxB,GAAID,GAAcA,EAAWE,UAAW,CACpC,MAAM9C,EAActH,EAAyBR,EAAQ+H,aAAerH,KAAKqH,aACzEN,EAAKkD,6BAA6BmE,KAAK/O,IAAU+H,EAAYG,6BAC7E,CACA,CACQvH,KAAKwQ,WAAWzJ,EAAM1H,EAAQC,EACtC,CAKI,iBAAAmR,GACI,MAAMC,EAAiB3Q,MAAM0Q,oBAC7B,IAAK,MAAM/Q,KAAQM,KAAKC,UACpByQ,EAAerN,KAAKrD,KAAKC,UAAUP,IAEvC,IAAK,MAAMA,KAAQM,KAAKG,eAAgB,CACpC,MAAMwQ,EAAQ3Q,KAAKG,eAAeT,GAClC,IAAK,IAAI+F,EAAQ,EAAGA,EAAQkL,EAAMvL,OAAQK,IACtCiL,EAAerN,KAAKsN,EAAMlL,GAE1C,CACQ,OAAOiL,CACf,CAMI,UAAAE,CAAWrN,GACP,GAAIxD,MAAM6Q,WAAWrN,GACjB,OAAO,EAEX,IAAK,MAAM7D,KAAQM,KAAKC,UACpB,GAAID,KAAKC,UAAUP,KAAU6D,EACzB,OAAO,EAGf,MAAMsN,EAAkBtN,EAAQuN,qBAChC,IAAK,MAAMpR,KAAQM,KAAKE,kBACpB,GAAIF,KAAKE,kBAAkBR,KAAUmR,EACjC,OAAO,EAGf,IAAK,MAAMnR,KAAQM,KAAKG,eAAgB,CACpC,MAAMwQ,EAAQ3Q,KAAKG,eAAeT,GAClC,IAAK,IAAI+F,EAAQ,EAAGA,EAAQkL,EAAMvL,OAAQK,IACtC,GAAIkL,EAAMlL,KAAWlC,EACjB,OAAO,CAG3B,CACQ,OAAO,CACf,CAMI,KAAAwN,CAAMrR,GACF,MAAMsR,EAASC,EAAoBC,OAAM,IAAM,IAAI3R,EAAeG,EAAMM,KAAKwH,WAAYxH,KAAKkC,YAAalC,KAAKmC,SAAUnC,KAAKkH,0BAA0BlH,MACzJgR,EAAOtR,KAAOA,EACdsR,EAAOG,GAAKzR,EAEsB,iBAAvBsR,EAAO9O,cACd8O,EAAO9O,YAAc,IAAK8O,EAAO9O,cAGrClC,KAAKmC,SAAW,IAAKnC,KAAKmC,UAC1B,MAAMiP,EAAOC,OAAOD,KAAKpR,KAAKmC,UAC9B,IAAK,MAAMmP,KAAYF,EAAM,CACzB,MAAMG,EAAYvR,KAAKmC,SAASmP,GAC5BE,MAAMC,QAAQF,KACdvR,KAAKmC,SAASmP,GAAYC,EAAUxH,MAAM,GAE1D,CAEQ/J,KAAK0R,QAAQC,OAAOX,EAAOU,SAE3B,IAAK,MAAME,KAAO5R,KAAKC,UACnB+Q,EAAO1N,WAAWsO,EAAK5R,KAAKC,UAAU2R,IAE1C,IAAK,MAAMA,KAAO5R,KAAKE,kBACnB8Q,EAAOxN,mBAAmBoO,EAAK5R,KAAKE,kBAAkB0R,IAG1D,IAAK,MAAMA,KAAO5R,KAAKG,eACnB6Q,EAAOtN,gBAAgBkO,EAAK5R,KAAKG,eAAeyR,IAGpD,IAAK,MAAMA,KAAO5R,KAAKI,kBACnB4Q,EAAOpN,mBAAmBgO,EAAK5R,KAAKI,kBAAkBwR,IAG1D,IAAK,MAAMA,KAAO5R,KAAKM,MACnB0Q,EAAOjN,OAAO6N,EAAK5R,KAAKM,MAAMsR,IAGlC,IAAK,MAAMA,KAAO5R,KAAKO,OACnByQ,EAAOhN,QAAQ4N,EAAK5R,KAAKO,OAAOqR,IAGpC,IAAK,MAAMA,KAAO5R,KAAKK,QACnB2Q,EAAOnN,SAAS+N,EAAK5R,KAAKK,QAAQuR,IAGtC,IAAK,MAAMA,KAAO5R,KAAKQ,cACnBwQ,EAAO/M,UAAU2N,EAAK5R,KAAKQ,cAAcoR,IAG7C,IAAK,MAAMA,KAAO5R,KAAKS,SACnBuQ,EAAO9M,UAAU0N,EAAK5R,KAAKS,SAASmR,IAGxC,IAAK,MAAMA,KAAO5R,KAAKU,eACnBsQ,EAAOtQ,eAAekR,GAAO5R,KAAKU,eAAekR,GAGrD,IAAK,MAAMA,KAAO5R,KAAKW,SACnBqQ,EAAOtM,UAAUkN,EAAK5R,KAAKW,SAASiR,IAGxC,IAAK,MAAMA,KAAO5R,KAAKY,eACnBoQ,EAAOpQ,eAAegR,GAAO5R,KAAKY,eAAegR,GAGrD,IAAK,MAAMA,KAAO5R,KAAKa,UACnBmQ,EAAOnM,WAAW+M,EAAK5R,KAAKa,UAAU+Q,IAG1C,IAAK,MAAMA,KAAO5R,KAAKc,UACnBkQ,EAAOlM,WAAW8M,EAAK5R,KAAKc,UAAU8Q,IAG1C,IAAK,MAAMA,KAAO5R,KAAKe,UACnBiQ,EAAOjM,WAAW6M,EAAK5R,KAAKe,UAAU6Q,IAG1C,IAAK,MAAMA,KAAO5R,KAAKgB,aACnBgQ,EAAOhM,cAAc4M,EAAK5R,KAAKgB,aAAa4Q,IAGhD,IAAK,MAAMA,KAAO5R,KAAKiB,mBACnB+P,EAAO/P,mBAAmB2Q,GAAO5R,KAAKiB,mBAAmB2Q,GAG7D,IAAK,MAAMA,KAAO5R,KAAKkB,UACnB8P,EAAO3L,UAAUuM,EAAK5R,KAAKkB,UAAU0Q,IAGzC,IAAK,MAAMA,KAAO5R,KAAKmB,cACnB6P,EAAO7P,cAAcyQ,GAAO5R,KAAKmB,cAAcyQ,GAAK7H,QAGxD,IAAK,MAAM6H,KAAO5R,KAAKoB,aACnB4P,EAAOrL,aAAaiM,EAAK5R,KAAKoB,aAAawQ,IAG/C,IAAK,MAAMA,KAAO5R,KAAKqB,aACnB2P,EAAOpL,aAAagM,EAAK5R,KAAKqB,aAAauQ,IAG/C,IAAK,MAAMA,KAAO5R,KAAKsB,gBACnB0P,EAAOnL,UAAU+L,EAAK5R,KAAKsB,gBAAgBsQ,IAG/C,IAAK,MAAMA,KAAO5R,KAAKuB,gBACnByP,EAAOlL,UAAU8L,EAAK5R,KAAKuB,gBAAgBqQ,IAG/C,IAAK,MAAMA,KAAO5R,KAAKwB,gBACnBwP,EAAOjL,UAAU6L,EAAK5R,KAAKwB,gBAAgBoQ,IAG/C,IAAK,MAAMA,KAAO5R,KAAKyB,gBACnBuP,EAAOhL,iBAAiB4L,EAAK5R,KAAKyB,gBAAgBmQ,IAGtD,IAAK,MAAMA,KAAO5R,KAAK0B,iBACnBsP,EAAO9K,kBAAkB0L,EAAK5R,KAAK0B,iBAAiBkQ,IAGxD,IAAK,MAAMA,KAAO5R,KAAK2B,gBACnBqP,EAAO5K,iBAAiBwL,EAAK5R,KAAK2B,gBAAgBiQ,IAEtD,OAAOZ,CACf,CAOI,OAAAa,CAAQC,EAAoBC,EAAsBC,GAC9C,GAAID,EAAsB,CACtB,IAAIrS,EACJ,IAAKA,KAAQM,KAAKC,UACdD,KAAKC,UAAUP,GAAMmS,UAEzB,IAAKnS,KAAQM,KAAKE,kBACdF,KAAKE,kBAAkBR,GAAMmS,UAEjC,IAAKnS,KAAQM,KAAKG,eAAgB,CAC9B,MAAMwQ,EAAQ3Q,KAAKG,eAAeT,GAClC,IAAK,IAAI+F,EAAQ,EAAGA,EAAQkL,EAAMvL,OAAQK,IACtCkL,EAAMlL,GAAOoM,SAEjC,CACA,CACQ7R,KAAKC,UAAY,CAAE,EACnBD,KAAKE,kBAAoB,CAAE,EAC3BH,MAAM8R,QAAQC,EAAoBC,EAAsBC,EAChE,CAKI,SAAAC,GACI,MAAMC,EAAsBjB,EAAoBkB,UAAUnS,MAM1D,IAAIN,EAKJ,IAAKA,KAVLwS,EAAoBE,WAAa,yBACjCF,EAAoBG,SAAWrS,KAAKqS,SACpCH,EAAoBrS,QAAUG,KAAKmC,SACnC+P,EAAoBtS,WAAaI,KAAKkC,YACtCgQ,EAAoBpS,uBAAyBE,KAAKkH,wBAGlDgL,EAAoBR,QAAU1R,KAAK0R,QAAQO,YAE3CC,EAAoBvO,SAAW,CAAE,EACpB3D,KAAKC,UACdiS,EAAoBvO,SAASjE,GAAQM,KAAKC,UAAUP,GAAMuS,YAI9D,IAAKvS,KADLwS,EAAoBI,cAAgB,CAAE,EACzBtS,KAAKG,eAAgB,CAC9B+R,EAAoBI,cAAc5S,GAAQ,GAC1C,MAAMiR,EAAQ3Q,KAAKG,eAAeT,GAClC,IAAK,IAAI+F,EAAQ,EAAGA,EAAQkL,EAAMvL,OAAQK,IACtCyM,EAAoBI,cAAc5S,GAAM2D,KAAKsN,EAAMlL,GAAOwM,YAE1E,CAGQ,IAAKvS,KADLwS,EAAoBK,KAAO,CAAE,EAChBvS,KAAKM,MACd4R,EAAoBK,KAAK7S,GAAQM,KAAKM,MAAMZ,GAIhD,IAAKA,KADLwS,EAAoBM,MAAQ,CAAE,EACjBxS,KAAKO,OACd2R,EAAoBM,MAAM9S,GAAQM,KAAKO,OAAOb,GAIlD,IAAKA,KADLwS,EAAoBO,OAAS,CAAE,EAClBzS,KAAKK,QACd6R,EAAoBO,OAAO/S,GAAQM,KAAKK,QAAQX,GAIpD,IAAKA,KADLwS,EAAoBQ,aAAe,CAAE,EACxB1S,KAAKQ,cACd0R,EAAoBQ,aAAahT,GAAQM,KAAKQ,cAAcd,GAIhE,IAAKA,KADLwS,EAAoBS,QAAU,CAAE,EACnB3S,KAAKS,SAAU,CACxB,MAAMmS,EAAS5S,KAAKS,SAASf,GAC7BwS,EAAoBS,QAAQjT,GAAQ,CAACkT,EAAOrO,EAAGqO,EAAOpO,EAAGoO,EAAOnO,EAC5E,CAGQ,IAAK/E,KADLwS,EAAoBW,cAAgB,CAAE,EACzB7S,KAAKU,eACdwR,EAAoBW,cAAcnT,GAAQM,KAAKU,eAAehB,GAIlE,IAAKA,KADLwS,EAAoBY,QAAU,CAAE,EACnB9S,KAAKW,SAAU,CACxB,MAAMoS,EAAS/S,KAAKW,SAASjB,GAC7BwS,EAAoBY,QAAQpT,GAAQ,CAACqT,EAAOxO,EAAGwO,EAAOvO,EAAGuO,EAAOtO,EAAGsO,EAAOnO,EACtF,CAGQ,IAAKlF,KADLwS,EAAoBc,cAAgB,CAAE,EACzBhT,KAAKY,eACdsR,EAAoBc,cAActT,GAAQM,KAAKY,eAAelB,GAIlE,IAAKA,KADLwS,EAAoBe,SAAW,CAAE,EACpBjT,KAAKa,UAAW,CACzB,MAAMqS,EAAKlT,KAAKa,UAAUnB,GAC1BwS,EAAoBe,SAASvT,GAAQ,CAACwT,EAAGvM,EAAGuM,EAAGC,EAC3D,CAGQ,IAAKzT,KADLwS,EAAoBkB,SAAW,CAAE,EACpBpT,KAAKc,UAAW,CACzB,MAAMuS,EAAKrT,KAAKc,UAAUpB,GAC1BwS,EAAoBkB,SAAS1T,GAAQ,CAAC2T,EAAG1M,EAAG0M,EAAGF,EAAGE,EAAGC,EACjE,CAGQ,IAAK5T,KADLwS,EAAoBqB,SAAW,CAAE,EACpBvT,KAAKe,UAAW,CACzB,MAAMyS,EAAKxT,KAAKe,UAAUrB,GAC1BwS,EAAoBqB,SAAS7T,GAAQ,CAAC8T,EAAG7M,EAAG6M,EAAGL,EAAGK,EAAGF,EAAGE,EAAGC,EACvE,CAGQ,IAAK/T,KADLwS,EAAoBwB,YAAc,CAAE,EACvB1T,KAAKgB,aACdkR,EAAoBwB,YAAYhU,GAAQM,KAAKgB,aAAatB,GAAMiU,UAIpE,IAAKjU,KADLwS,EAAoB0B,SAAW,CAAE,EACpB5T,KAAKkB,UACdgR,EAAoB0B,SAASlU,GAAQM,KAAKkB,UAAUxB,GAAMiU,UAI9D,IAAKjU,KADLwS,EAAoB2B,YAAc,CAAE,EACvB7T,KAAKmB,cACd+Q,EAAoB2B,YAAYnU,GAAQM,KAAKmB,cAAczB,GAI/D,IAAKA,KADLwS,EAAoB4B,YAAc,CAAE,EACvB9T,KAAKoB,aACd8Q,EAAoB4B,YAAYpU,GAAQM,KAAKoB,aAAa1B,GAI9D,IAAKA,KADLwS,EAAoB6B,YAAc,CAAE,EACvB/T,KAAKqB,aACd6Q,EAAoB6B,YAAYrU,GAAQM,KAAKqB,aAAa3B,GAI9D,IAAKA,KADLwS,EAAoB8B,eAAiB,CAAE,EAC1BhU,KAAKsB,gBACd4Q,EAAoB8B,eAAetU,GAAQM,KAAKsB,gBAAgB5B,GAIpE,IAAKA,KADLwS,EAAoB+B,eAAiB,CAAE,EAC1BjU,KAAKuB,gBACd2Q,EAAoB+B,eAAevU,GAAQM,KAAKuB,gBAAgB7B,GAIpE,IAAKA,KADLwS,EAAoBgC,eAAiB,CAAE,EAC1BlU,KAAKwB,gBACd0Q,EAAoBgC,eAAexU,GAAQM,KAAKwB,gBAAgB9B,GAIpE,IAAKA,KADLwS,EAAoBiC,kBAAoB,CAAE,EAC7BnU,KAAKiB,mBACdiR,EAAoBiC,kBAAkBzU,GAAQM,KAAKiB,mBAAmBvB,GAE1E,OAAOwS,CACf,CAQI,YAAOkC,CAAMC,EAAQ1U,EAAO2U,GACxB,MAAMC,EAAWtD,EAAoBmD,OAAM,IAAM,IAAI7U,EAAe8U,EAAO3U,KAAMC,EAAO0U,EAAOzU,WAAYyU,EAAOxU,QAASwU,EAAOvU,yBAAyBuU,EAAQ1U,EAAO2U,GAC1K,IAAI5U,EAMJ,IAAKA,KAJD2U,EAAO3C,SACP6C,EAAS7C,QAAQ8C,MAAMH,EAAO3C,QAAS/R,EAAO2U,GAGrCD,EAAO1Q,SAChB4Q,EAASjR,WAAW5D,EAAM+U,EAAQL,MAAMC,EAAO1Q,SAASjE,GAAOC,EAAO2U,IAG1E,IAAK5U,KAAQ2U,EAAO/B,cAAe,CAC/B,MAAM3B,EAAQ0D,EAAO/B,cAAc5S,GAC7BgV,EAAe,GACrB,IAAK,IAAIjP,EAAQ,EAAGA,EAAQkL,EAAMvL,OAAQK,IACtCiP,EAAarR,KAAKoR,EAAQL,MAAMzD,EAAMlL,GAAQ9F,EAAO2U,IAEzDC,EAAS7Q,gBAAgBhE,EAAMgV,EAC3C,CAEQ,IAAKhV,KAAQ2U,EAAO9B,KAChBgC,EAASxQ,OAAOrE,EAAM2U,EAAO9B,KAAK7S,IAGtC,IAAKA,KAAQ2U,EAAO7B,MAChB+B,EAASvQ,QAAQtE,EAAM2U,EAAO7B,MAAM9S,IAGxC,IAAKA,KAAQ2U,EAAO5B,OAChB8B,EAAS1Q,SAASnE,EAAM2U,EAAO5B,OAAO/S,IAG1C,IAAKA,KAAQ2U,EAAO3B,aAChB6B,EAAStQ,UAAUvE,EAAM2U,EAAO3B,aAAahT,IAGjD,IAAKA,KAAQ2U,EAAO1B,QAAS,CACzB,MAAMrO,EAAQ+P,EAAO1B,QAAQjT,GAC7B6U,EAASrQ,UAAUxE,EAAM,CAAE6E,EAAGD,EAAM,GAAIE,EAAGF,EAAM,GAAIG,EAAGH,EAAM,IAC1E,CAEQ,IAAK5E,KAAQ2U,EAAOxB,cAAe,CAC/B,MAAM8B,EAASN,EAAOxB,cAAcnT,GAC/B0E,QAAO,CAACC,EAAKuQ,EAAKnG,KACfA,EAAI,GAAM,EACVpK,EAAIhB,KAAK,CAACuR,IAGVvQ,EAAIA,EAAIe,OAAS,GAAG/B,KAAKuR,GAEtBvQ,IACR,IACEwQ,KAAKvQ,IAAW,CAAEC,EAAGD,EAAM,GAAIE,EAAGF,EAAM,GAAIG,EAAGH,EAAM,OAC1DiQ,EAASpQ,eAAezE,EAAMiV,EAC1C,CAEQ,IAAKjV,KAAQ2U,EAAOvB,QAAS,CACzB,MAAMxO,EAAQ+P,EAAOvB,QAAQpT,GAC7B6U,EAAS7P,UAAUhF,EAAM,CAAE6E,EAAGD,EAAM,GAAIE,EAAGF,EAAM,GAAIG,EAAGH,EAAM,GAAIM,EAAGN,EAAM,IACvF,CAEQ,IAAK5E,KAAQ2U,EAAOrB,cAAe,CAC/B,MAAM2B,EAASN,EAAOrB,cAActT,GAC/B0E,QAAO,CAACC,EAAKuQ,EAAKnG,KACfA,EAAI,GAAM,EACVpK,EAAIhB,KAAK,CAACuR,IAGVvQ,EAAIA,EAAIe,OAAS,GAAG/B,KAAKuR,GAEtBvQ,IACR,IACEwQ,KAAKvQ,KAAaC,EAAGD,EAAM,GAAIE,EAAGF,EAAM,GAAIG,EAAGH,EAAM,GAAIM,EAAGN,EAAM,OACvEiQ,EAAS5P,eAAejF,EAAMiV,EAC1C,CAEQ,IAAKjV,KAAQ2U,EAAOpB,SAAU,CAC1B,MAAM6B,EAAST,EAAOpB,SAASvT,GAC/B6U,EAAS1P,WAAWnF,EAAM,CAAEiH,EAAGmO,EAAO,GAAI3B,EAAG2B,EAAO,IAChE,CAEQ,IAAKpV,KAAQ2U,EAAOjB,SAAU,CAC1B,MAAM0B,EAAST,EAAOjB,SAAS1T,GAC/B6U,EAASzP,WAAWpF,EAAM,CAAEiH,EAAGmO,EAAO,GAAI3B,EAAG2B,EAAO,GAAIxB,EAAGwB,EAAO,IAC9E,CAEQ,IAAKpV,KAAQ2U,EAAOd,SAAU,CAC1B,MAAMuB,EAAST,EAAOd,SAAS7T,GAC/B6U,EAASxP,WAAWrF,EAAM,CAAEiH,EAAGmO,EAAO,GAAI3B,EAAG2B,EAAO,GAAIxB,EAAGwB,EAAO,GAAIrB,EAAGqB,EAAO,IAC5F,CAEQ,IAAKpV,KAAQ2U,EAAOX,YAChBa,EAASvP,cAActF,EAAMqV,EAAWC,UAAUX,EAAOX,YAAYhU,KAGzE,IAAKA,KAAQ2U,EAAOT,SAChBW,EAASlP,UAAU3F,EAAMmC,EAAOmT,UAAUX,EAAOT,SAASlU,KAG9D,IAAKA,KAAQ2U,EAAOR,YAChBU,EAASpT,cAAczB,GAAQ,IAAI8F,aAAa6O,EAAOR,YAAYnU,IAGvE,IAAKA,KAAQ2U,EAAOP,YAChBS,EAAS5O,aAAajG,EAAM2U,EAAOP,YAAYpU,IAGnD,IAAKA,KAAQ2U,EAAON,YAChBQ,EAAS3O,aAAalG,EAAM2U,EAAON,YAAYrU,IAGnD,IAAKA,KAAQ2U,EAAOL,eAChBO,EAAS1O,UAAUnG,EAAM2U,EAAOL,eAAetU,IAGnD,IAAKA,KAAQ2U,EAAOJ,eAChBM,EAASzO,UAAUpG,EAAM2U,EAAOJ,eAAevU,IAGnD,IAAKA,KAAQ2U,EAAOH,eAChBK,EAASxO,UAAUrG,EAAM2U,EAAOH,eAAexU,IAGnD,IAAKA,KAAQ2U,EAAOF,kBAChBI,EAASxO,UAAUrG,EAAM2U,EAAOF,kBAAkBzU,IAEtD,OAAO6U,CACf,CASI,+BAAaU,CAAmBvV,EAAMwV,EAAKvV,EAAO2U,EAAU,IACxD,aAAa,IAAIa,SAAQ,CAACC,EAASC,KAC/B,MAAMC,EAAU,IAAIC,EACpBD,EAAQE,iBAAiB,oBAAoB,KACzC,GAA0B,GAAtBF,EAAQG,WACR,GAAsB,KAAlBH,EAAQI,OAAe,CACvB,MAAMxD,EAAsByD,KAAKnB,MAAMc,EAAQM,cACzCC,EAAS7V,KAAKoU,MAAMlC,EAAqBvS,GAASmW,EAAYC,iBAAkBzB,GAClF5U,IACAmW,EAAOnW,KAAOA,GAElB0V,EAAQS,EAChC,MAGwBR,EAAO,wCAInBC,EAAQU,KAAK,MAAOd,GACpBI,EAAQW,SAEpB,CAQI,kCAAaC,CAAsBC,EAAWxW,EAAO2U,EAAU,IAC3D,aAAa,IAAIa,SAAQ,CAACC,EAASC,KAC/B,MAAMC,EAAU,IAAIC,EACpBD,EAAQE,iBAAiB,oBAAoB,KACzC,GAA0B,GAAtBF,EAAQG,WACR,GAAsB,KAAlBH,EAAQI,OAAe,CACvB,MAAMU,EAAUT,KAAKnB,MAAMmB,KAAKnB,MAAMc,EAAQM,cAAcS,aACtDnE,EAAsByD,KAAKnB,MAAM4B,EAAQE,gBACzCT,EAAS7V,KAAKoU,MAAMlC,EAAqBvS,GAASmW,EAAYC,iBAAkBzB,GACtFuB,EAAOM,UAAYA,EACnBf,EAAQS,EAChC,MAGwBR,EAAO,8BAAgCc,MAInDb,EAAQU,KAAK,MAAOhW,KAAKuW,WAAa,IAAMJ,EAAUK,QAAQ,KAAM,MACpElB,EAAQW,SAEpB,EAGA1W,EAAegX,WAAaE,EAAUF,WAStChX,EAAemX,uBAAyBnX,EAAe2W,sBACvDS,EAAc,yBAA0BpX"}