{"version":3,"file":"thinInstanceMesh-BRurJ3_A.esm.min.js","sources":["../../../../../dev/core/dist/Meshes/thinInstanceMesh.js"],"sourcesContent":["import { Mesh } from \"../Meshes/mesh\";\nimport { VertexBuffer, Buffer } from \"../Buffers/buffer\";\nimport { Matrix, Vector3, TmpVectors } from \"../Maths/math.vector\";\nimport { Logger } from \"../Misc/logger\";\nimport { BoundingInfo } from \"core/Culling/boundingInfo\";\nMesh.prototype.thinInstanceAdd = function (matrix, refresh = true) {\n    if (!this.getScene().getEngine().getCaps().instancedArrays) {\n        Logger.Error(\"Thin Instances are not supported on this device as Instanced Array extension not supported\");\n        return -1;\n    }\n    this._thinInstanceUpdateBufferSize(\"matrix\", Array.isArray(matrix) ? matrix.length : 1);\n    const index = this._thinInstanceDataStorage.instancesCount;\n    if (Array.isArray(matrix)) {\n        for (let i = 0; i < matrix.length; ++i) {\n            this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);\n        }\n    }\n    else {\n        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);\n    }\n    return index;\n};\nMesh.prototype.thinInstanceAddSelf = function (refresh = true) {\n    return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);\n};\nMesh.prototype.thinInstanceRegisterAttribute = function (kind, stride) {\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n        kind = VertexBuffer.ColorInstanceKind;\n    }\n    this.removeVerticesData(kind);\n    this._thinInstanceInitializeUserStorage();\n    this._userThinInstanceBuffersStorage.strides[kind] = stride;\n    this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount); // Initial size\n    this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);\n    this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);\n    this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n};\nMesh.prototype.thinInstanceSetMatrixAt = function (index, matrix, refresh = true) {\n    if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {\n        return false;\n    }\n    const matrixData = this._thinInstanceDataStorage.matrixData;\n    matrix.copyToArray(matrixData, index * 16);\n    if (this._thinInstanceDataStorage.worldMatrices) {\n        this._thinInstanceDataStorage.worldMatrices[index] = matrix;\n    }\n    if (refresh) {\n        this.thinInstanceBufferUpdated(\"matrix\");\n        if (!this.doNotSyncBoundingInfo) {\n            this.thinInstanceRefreshBoundingInfo(false);\n        }\n    }\n    return true;\n};\nMesh.prototype.thinInstanceSetAttributeAt = function (kind, index, value, refresh = true) {\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n        kind = VertexBuffer.ColorInstanceKind;\n    }\n    if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {\n        return false;\n    }\n    this._thinInstanceUpdateBufferSize(kind, 0); // make sur the buffer for the kind attribute is big enough\n    this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);\n    if (refresh) {\n        this.thinInstanceBufferUpdated(kind);\n    }\n    return true;\n};\nObject.defineProperty(Mesh.prototype, \"thinInstanceCount\", {\n    get: function () {\n        return this._thinInstanceDataStorage.instancesCount;\n    },\n    set: function (value) {\n        const matrixData = this._thinInstanceDataStorage.matrixData ?? this.source?._thinInstanceDataStorage.matrixData;\n        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;\n        if (value <= numMaxInstances) {\n            this._thinInstanceDataStorage.instancesCount = value;\n        }\n    },\n    enumerable: true,\n    configurable: true,\n});\nMesh.prototype._thinInstanceCreateMatrixBuffer = function (kind, buffer, staticBuffer = true) {\n    const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);\n    for (let i = 0; i < 4; i++) {\n        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));\n    }\n    return matrixBuffer;\n};\nMesh.prototype.thinInstanceSetBuffer = function (kind, buffer, stride = 0, staticBuffer = true) {\n    stride = stride || 16;\n    if (kind === \"matrix\") {\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\n        this._thinInstanceDataStorage.matrixBuffer = null;\n        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;\n        this._thinInstanceDataStorage.matrixData = buffer;\n        this._thinInstanceDataStorage.worldMatrices = null;\n        if (buffer !== null) {\n            this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", buffer, staticBuffer);\n            if (!this.doNotSyncBoundingInfo) {\n                this.thinInstanceRefreshBoundingInfo(false);\n            }\n        }\n        else {\n            this._thinInstanceDataStorage.instancesCount = 0;\n            if (!this.doNotSyncBoundingInfo) {\n                // mesh has no more thin instances, so need to recompute the bounding box because it's the regular mesh that will now be displayed\n                this.refreshBoundingInfo();\n            }\n        }\n    }\n    else if (kind === \"previousMatrix\") {\n        this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\n        this._thinInstanceDataStorage.previousMatrixData = buffer;\n        if (buffer !== null) {\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", buffer, staticBuffer);\n        }\n    }\n    else if (kind === \"splatIndex\" && buffer) {\n        this._thinInstanceInitializeUserStorage();\n        this._thinInstanceDataStorage.instancesCount = buffer.length / stride;\n        this._userThinInstanceBuffersStorage.data[kind] = buffer;\n        this._userThinInstanceBuffersStorage.strides[kind] = stride;\n        this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\n        const splatInstancesBuffer = new Buffer(this.getEngine(), buffer, true, 16, false, true);\n        this._thinInstanceDataStorage.matrixBuffer = splatInstancesBuffer;\n        for (let i = 0; i < 4; i++) {\n            this.setVerticesBuffer(splatInstancesBuffer.createVertexBuffer(kind + i, i * 4, 4));\n        }\n    }\n    else {\n        // color for instanced mesh is ColorInstanceKind and not ColorKind because of native that needs to do the differenciation\n        // hot switching kind here to preserve backward compatibility\n        if (kind === VertexBuffer.ColorKind) {\n            kind = VertexBuffer.ColorInstanceKind;\n        }\n        if (buffer === null) {\n            if (this._userThinInstanceBuffersStorage?.data[kind]) {\n                this.removeVerticesData(kind);\n                delete this._userThinInstanceBuffersStorage.data[kind];\n                delete this._userThinInstanceBuffersStorage.strides[kind];\n                delete this._userThinInstanceBuffersStorage.sizes[kind];\n                delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];\n            }\n        }\n        else {\n            this._thinInstanceInitializeUserStorage();\n            this._userThinInstanceBuffersStorage.data[kind] = buffer;\n            this._userThinInstanceBuffersStorage.strides[kind] = stride;\n            this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n        }\n    }\n};\nMesh.prototype.thinInstanceBufferUpdated = function (kind) {\n    if (kind === \"matrix\") {\n        if (this.thinInstanceAllowAutomaticStaticBufferRecreation && this._thinInstanceDataStorage.matrixBuffer && !this._thinInstanceDataStorage.matrixBuffer.isUpdatable()) {\n            this._thinInstanceRecreateBuffer(kind);\n        }\n        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);\n    }\n    else if (kind === \"previousMatrix\") {\n        if (this.thinInstanceAllowAutomaticStaticBufferRecreation &&\n            this._thinInstanceDataStorage.previousMatrixBuffer &&\n            !this._thinInstanceDataStorage.previousMatrixBuffer.isUpdatable()) {\n            this._thinInstanceRecreateBuffer(kind);\n        }\n        this._thinInstanceDataStorage.previousMatrixBuffer?.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);\n    }\n    else if (kind === \"splatIndex\") {\n        this._thinInstanceDataStorage.matrixBuffer?.updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0, this._thinInstanceDataStorage.instancesCount);\n    }\n    else {\n        // preserve backward compatibility\n        if (kind === VertexBuffer.ColorKind) {\n            kind = VertexBuffer.ColorInstanceKind;\n        }\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\n            if (this.thinInstanceAllowAutomaticStaticBufferRecreation && !this._userThinInstanceBuffersStorage.vertexBuffers[kind].isUpdatable()) {\n                this._thinInstanceRecreateBuffer(kind);\n            }\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);\n        }\n    }\n};\nMesh.prototype.thinInstancePartialBufferUpdate = function (kind, data, offset) {\n    if (kind === \"matrix\") {\n        if (this._thinInstanceDataStorage.matrixBuffer) {\n            this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);\n        }\n    }\n    else {\n        // preserve backward compatibility\n        if (kind === VertexBuffer.ColorKind) {\n            kind = VertexBuffer.ColorInstanceKind;\n        }\n        if (this._userThinInstanceBuffersStorage?.vertexBuffers[kind]) {\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);\n        }\n    }\n};\nMesh.prototype.thinInstanceGetWorldMatrices = function () {\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n        return [];\n    }\n    const matrixData = this._thinInstanceDataStorage.matrixData;\n    if (!this._thinInstanceDataStorage.worldMatrices) {\n        this._thinInstanceDataStorage.worldMatrices = [];\n        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n            this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);\n        }\n    }\n    return this._thinInstanceDataStorage.worldMatrices;\n};\nMesh.prototype.thinInstanceRefreshBoundingInfo = function (forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {\n    if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {\n        return;\n    }\n    const vectors = this._thinInstanceDataStorage.boundingVectors;\n    if (forceRefreshParentInfo || !this.rawBoundingInfo) {\n        vectors.length = 0;\n        this.refreshBoundingInfo(applySkeleton, applyMorph);\n        const boundingInfo = this.getBoundingInfo();\n        this.rawBoundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n    }\n    const boundingInfo = this.getBoundingInfo();\n    const matrixData = this._thinInstanceDataStorage.matrixData;\n    if (vectors.length === 0) {\n        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {\n            vectors.push(boundingInfo.boundingBox.vectors[v].clone());\n        }\n    }\n    TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY); // min\n    TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY); // max\n    for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {\n        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);\n        for (let v = 0; v < vectors.length; ++v) {\n            Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);\n            TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);\n            TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);\n        }\n    }\n    boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);\n    this._updateBoundingInfo();\n};\nMesh.prototype._thinInstanceRecreateBuffer = function (kind, staticBuffer = true) {\n    if (kind === \"matrix\") {\n        this._thinInstanceDataStorage.matrixBuffer?.dispose();\n        this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", this._thinInstanceDataStorage.matrixData, staticBuffer);\n    }\n    else if (kind === \"previousMatrix\") {\n        if (this._scene.needsPreviousWorldMatrices) {\n            this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\n            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", this._thinInstanceDataStorage.previousMatrixData ?? this._thinInstanceDataStorage.matrixData, staticBuffer);\n        }\n    }\n    else {\n        if (kind === VertexBuffer.ColorKind) {\n            kind = VertexBuffer.ColorInstanceKind;\n        }\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\n        this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, !staticBuffer, false, this._userThinInstanceBuffersStorage.strides[kind], true);\n        this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n    }\n};\nMesh.prototype._thinInstanceUpdateBufferSize = function (kind, numInstances = 1) {\n    // preserve backward compatibility\n    if (kind === VertexBuffer.ColorKind) {\n        kind = VertexBuffer.ColorInstanceKind;\n    }\n    const kindIsMatrix = kind === \"matrix\";\n    if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {\n        return;\n    }\n    const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];\n    const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];\n    let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];\n    const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;\n    let newSize = currentSize;\n    while (newSize < bufferSize) {\n        newSize *= 2;\n    }\n    if (!data || currentSize != newSize) {\n        if (!data) {\n            data = new Float32Array(newSize);\n        }\n        else {\n            const newData = new Float32Array(newSize);\n            newData.set(data, 0);\n            data = newData;\n        }\n        if (kindIsMatrix) {\n            this._thinInstanceDataStorage.matrixBuffer?.dispose();\n            this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer(\"world\", data, false);\n            this._thinInstanceDataStorage.matrixData = data;\n            this._thinInstanceDataStorage.matrixBufferSize = newSize;\n            if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {\n                this._thinInstanceDataStorage.previousMatrixBuffer?.dispose();\n                this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer(\"previousWorld\", data, false);\n            }\n        }\n        else {\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind]?.dispose();\n            this._userThinInstanceBuffersStorage.data[kind] = data;\n            this._userThinInstanceBuffersStorage.sizes[kind] = newSize;\n            this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);\n            this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);\n        }\n    }\n};\nMesh.prototype._thinInstanceInitializeUserStorage = function () {\n    if (!this._userThinInstanceBuffersStorage) {\n        this._userThinInstanceBuffersStorage = {\n            data: {},\n            sizes: {},\n            vertexBuffers: {},\n            strides: {},\n        };\n    }\n};\nMesh.prototype._disposeThinInstanceSpecificData = function () {\n    if (this._thinInstanceDataStorage?.matrixBuffer) {\n        this._thinInstanceDataStorage.matrixBuffer.dispose();\n        this._thinInstanceDataStorage.matrixBuffer = null;\n    }\n    if (this._thinInstanceDataStorage?.previousMatrixBuffer) {\n        this._thinInstanceDataStorage.previousMatrixBuffer.dispose();\n        this._thinInstanceDataStorage.previousMatrixBuffer = null;\n    }\n};\n//# sourceMappingURL=thinInstanceMesh.js.map"],"names":["Mesh","prototype","thinInstanceAdd","matrix","refresh","this","getScene","getEngine","getCaps","instancedArrays","Logger","Error","_thinInstanceUpdateBufferSize","Array","isArray","length","index","_thinInstanceDataStorage","instancesCount","i","thinInstanceSetMatrixAt","thinInstanceAddSelf","Matrix","IdentityReadOnly","thinInstanceRegisterAttribute","kind","stride","VertexBuffer","ColorKind","ColorInstanceKind","removeVerticesData","_thinInstanceInitializeUserStorage","_userThinInstanceBuffersStorage","strides","sizes","Math","max","data","Float32Array","vertexBuffers","setVerticesBuffer","matrixData","copyToArray","worldMatrices","thinInstanceBufferUpdated","doNotSyncBoundingInfo","thinInstanceRefreshBoundingInfo","thinInstanceSetAttributeAt","value","set","Object","defineProperty","get","source","enumerable","configurable","_thinInstanceCreateMatrixBuffer","buffer","staticBuffer","matrixBuffer","Buffer","createVertexBuffer","thinInstanceSetBuffer","dispose","matrixBufferSize","refreshBoundingInfo","previousMatrixBuffer","previousMatrixData","splatInstancesBuffer","thinInstanceAllowAutomaticStaticBufferRecreation","isUpdatable","_thinInstanceRecreateBuffer","updateDirectly","thinInstancePartialBufferUpdate","offset","thinInstanceGetWorldMatrices","FromArray","forceRefreshParentInfo","applySkeleton","applyMorph","vectors","boundingVectors","rawBoundingInfo","boundingInfo","getBoundingInfo","BoundingInfo","minimum","maximum","v","boundingBox","push","clone","TmpVectors","Vector3","setAll","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","FromArrayToRef","TransformCoordinatesToRef","minimizeInPlace","maximizeInPlace","reConstruct","_updateBoundingInfo","_scene","needsPreviousWorldMatrices","numInstances","kindIsMatrix","currentSize","bufferSize","newSize","newData","_disposeThinInstanceSpecificData"],"mappings":"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"}