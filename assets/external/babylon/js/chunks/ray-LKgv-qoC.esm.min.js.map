{"version":3,"file":"ray-LKgv-qoC.esm.min.js","sources":["../../../../../dev/core/dist/Culling/ray.core.js","../../../../../dev/core/dist/Culling/ray.js"],"sourcesContent":["import { Epsilon } from \"core/Maths/math.constants\";\nimport { Matrix, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\nimport { BuildArray } from \"core/Misc/arrayTools\";\nimport { IntersectionInfo } from \"../Collisions/intersectionInfo\";\nimport { PickingInfo } from \"core/Collisions/pickingInfo\";\nimport { EngineStore } from \"core/Engines/engineStore\";\nimport { _ImportHelper } from \"core/import.helper\";\n/**\n * Use this object to customize mesh picking behavior\n */\nexport const PickingCustomization = {\n    internalPickerForMesh: undefined,\n};\n/**\n * Class representing a ray with position and direction\n */\nexport class Ray {\n    /**\n     * Creates a new ray\n     * @param origin origin point\n     * @param direction direction\n     * @param length length of the ray\n     * @param epsilon The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants)\n     */\n    constructor(\n    /** origin point */\n    origin, \n    /** direction */\n    direction, \n    /** [Number.MAX_VALUE] length of the ray */\n    length = Number.MAX_VALUE, \n    /** [Epsilon] The epsilon value to use when calculating the ray/triangle intersection (default: Epsilon from math constants) */\n    epsilon = Epsilon) {\n        this.origin = origin;\n        this.direction = direction;\n        this.length = length;\n        this.epsilon = epsilon;\n    }\n    // Methods\n    /**\n     * Clone the current ray\n     * @returns a new ray\n     */\n    clone() {\n        return new Ray(this.origin.clone(), this.direction.clone(), this.length);\n    }\n    /**\n     * Checks if the ray intersects a box\n     * This does not account for the ray length by design to improve perfs.\n     * @param minimum bound of the box\n     * @param maximum bound of the box\n     * @param intersectionTreshold extra extend to be added to the box in all direction\n     * @returns if the box was hit\n     */\n    intersectsBoxMinMax(minimum, maximum, intersectionTreshold = 0) {\n        const newMinimum = Ray._TmpVector3[0].copyFromFloats(minimum.x - intersectionTreshold, minimum.y - intersectionTreshold, minimum.z - intersectionTreshold);\n        const newMaximum = Ray._TmpVector3[1].copyFromFloats(maximum.x + intersectionTreshold, maximum.y + intersectionTreshold, maximum.z + intersectionTreshold);\n        let d = 0.0;\n        let maxValue = Number.MAX_VALUE;\n        let inv;\n        let min;\n        let max;\n        let temp;\n        if (Math.abs(this.direction.x) < 0.0000001) {\n            if (this.origin.x < newMinimum.x || this.origin.x > newMaximum.x) {\n                return false;\n            }\n        }\n        else {\n            inv = 1.0 / this.direction.x;\n            min = (newMinimum.x - this.origin.x) * inv;\n            max = (newMaximum.x - this.origin.x) * inv;\n            if (max === -Infinity) {\n                max = Infinity;\n            }\n            if (min > max) {\n                temp = min;\n                min = max;\n                max = temp;\n            }\n            d = Math.max(min, d);\n            maxValue = Math.min(max, maxValue);\n            if (d > maxValue) {\n                return false;\n            }\n        }\n        if (Math.abs(this.direction.y) < 0.0000001) {\n            if (this.origin.y < newMinimum.y || this.origin.y > newMaximum.y) {\n                return false;\n            }\n        }\n        else {\n            inv = 1.0 / this.direction.y;\n            min = (newMinimum.y - this.origin.y) * inv;\n            max = (newMaximum.y - this.origin.y) * inv;\n            if (max === -Infinity) {\n                max = Infinity;\n            }\n            if (min > max) {\n                temp = min;\n                min = max;\n                max = temp;\n            }\n            d = Math.max(min, d);\n            maxValue = Math.min(max, maxValue);\n            if (d > maxValue) {\n                return false;\n            }\n        }\n        if (Math.abs(this.direction.z) < 0.0000001) {\n            if (this.origin.z < newMinimum.z || this.origin.z > newMaximum.z) {\n                return false;\n            }\n        }\n        else {\n            inv = 1.0 / this.direction.z;\n            min = (newMinimum.z - this.origin.z) * inv;\n            max = (newMaximum.z - this.origin.z) * inv;\n            if (max === -Infinity) {\n                max = Infinity;\n            }\n            if (min > max) {\n                temp = min;\n                min = max;\n                max = temp;\n            }\n            d = Math.max(min, d);\n            maxValue = Math.min(max, maxValue);\n            if (d > maxValue) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Checks if the ray intersects a box\n     * This does not account for the ray length by design to improve perfs.\n     * @param box the bounding box to check\n     * @param intersectionTreshold extra extend to be added to the BoundingBox in all direction\n     * @returns if the box was hit\n     */\n    intersectsBox(box, intersectionTreshold = 0) {\n        return this.intersectsBoxMinMax(box.minimum, box.maximum, intersectionTreshold);\n    }\n    /**\n     * If the ray hits a sphere\n     * @param sphere the bounding sphere to check\n     * @param intersectionTreshold extra extend to be added to the BoundingSphere in all direction\n     * @returns true if it hits the sphere\n     */\n    intersectsSphere(sphere, intersectionTreshold = 0) {\n        const x = sphere.center.x - this.origin.x;\n        const y = sphere.center.y - this.origin.y;\n        const z = sphere.center.z - this.origin.z;\n        const pyth = x * x + y * y + z * z;\n        const radius = sphere.radius + intersectionTreshold;\n        const rr = radius * radius;\n        if (pyth <= rr) {\n            return true;\n        }\n        const dot = x * this.direction.x + y * this.direction.y + z * this.direction.z;\n        if (dot < 0.0) {\n            return false;\n        }\n        const temp = pyth - dot * dot;\n        return temp <= rr;\n    }\n    /**\n     * If the ray hits a triange\n     * @param vertex0 triangle vertex\n     * @param vertex1 triangle vertex\n     * @param vertex2 triangle vertex\n     * @returns intersection information if hit\n     */\n    intersectsTriangle(vertex0, vertex1, vertex2) {\n        const edge1 = Ray._TmpVector3[0];\n        const edge2 = Ray._TmpVector3[1];\n        const pvec = Ray._TmpVector3[2];\n        const tvec = Ray._TmpVector3[3];\n        const qvec = Ray._TmpVector3[4];\n        vertex1.subtractToRef(vertex0, edge1);\n        vertex2.subtractToRef(vertex0, edge2);\n        Vector3.CrossToRef(this.direction, edge2, pvec);\n        const det = Vector3.Dot(edge1, pvec);\n        if (det === 0) {\n            return null;\n        }\n        const invdet = 1 / det;\n        this.origin.subtractToRef(vertex0, tvec);\n        const bv = Vector3.Dot(tvec, pvec) * invdet;\n        if (bv < -this.epsilon || bv > 1.0 + this.epsilon) {\n            return null;\n        }\n        Vector3.CrossToRef(tvec, edge1, qvec);\n        const bw = Vector3.Dot(this.direction, qvec) * invdet;\n        if (bw < -this.epsilon || bv + bw > 1.0 + this.epsilon) {\n            return null;\n        }\n        //check if the distance is longer than the predefined length.\n        const distance = Vector3.Dot(edge2, qvec) * invdet;\n        if (distance > this.length || distance < 0) {\n            return null;\n        }\n        return new IntersectionInfo(1 - bv - bw, bv, distance);\n    }\n    /**\n     * Checks if ray intersects a plane\n     * @param plane the plane to check\n     * @returns the distance away it was hit\n     */\n    intersectsPlane(plane) {\n        let distance;\n        const result1 = Vector3.Dot(plane.normal, this.direction);\n        if (Math.abs(result1) < 9.99999997475243e-7) {\n            return null;\n        }\n        else {\n            const result2 = Vector3.Dot(plane.normal, this.origin);\n            distance = (-plane.d - result2) / result1;\n            if (distance < 0.0) {\n                if (distance < -9.99999997475243e-7) {\n                    return null;\n                }\n                else {\n                    return 0;\n                }\n            }\n            return distance;\n        }\n    }\n    /**\n     * Calculate the intercept of a ray on a given axis\n     * @param axis to check 'x' | 'y' | 'z'\n     * @param offset from axis interception (i.e. an offset of 1y is intercepted above ground)\n     * @returns a vector containing the coordinates where 'axis' is equal to zero (else offset), or null if there is no intercept.\n     */\n    intersectsAxis(axis, offset = 0) {\n        switch (axis) {\n            case \"y\": {\n                const t = (this.origin.y - offset) / this.direction.y;\n                if (t > 0) {\n                    return null;\n                }\n                return new Vector3(this.origin.x + this.direction.x * -t, offset, this.origin.z + this.direction.z * -t);\n            }\n            case \"x\": {\n                const t = (this.origin.x - offset) / this.direction.x;\n                if (t > 0) {\n                    return null;\n                }\n                return new Vector3(offset, this.origin.y + this.direction.y * -t, this.origin.z + this.direction.z * -t);\n            }\n            case \"z\": {\n                const t = (this.origin.z - offset) / this.direction.z;\n                if (t > 0) {\n                    return null;\n                }\n                return new Vector3(this.origin.x + this.direction.x * -t, this.origin.y + this.direction.y * -t, offset);\n            }\n            default:\n                return null;\n        }\n    }\n    /**\n     * Checks if ray intersects a mesh. The ray is defined in WORLD space. A mesh triangle can be picked both from its front and back sides,\n     * irrespective of orientation.\n     * @param mesh the mesh to check\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n     * @param onlyBoundingInfo defines a boolean indicating if picking should only happen using bounding info (false by default)\n     * @param worldToUse defines the world matrix to use to get the world coordinate of the intersection point\n     * @param skipBoundingInfo a boolean indicating if we should skip the bounding info check\n     * @returns picking info of the intersection\n     */\n    intersectsMesh(mesh, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {\n        const tm = TmpVectors.Matrix[0];\n        mesh.getWorldMatrix().invertToRef(tm);\n        if (this._tmpRay) {\n            Ray.TransformToRef(this, tm, this._tmpRay);\n        }\n        else {\n            this._tmpRay = Ray.Transform(this, tm);\n        }\n        return mesh.intersects(this._tmpRay, fastCheck, trianglePredicate, onlyBoundingInfo, worldToUse, skipBoundingInfo);\n    }\n    /**\n     * Checks if ray intersects a mesh\n     * @param meshes the meshes to check\n     * @param fastCheck defines if the first intersection will be used (and not the closest)\n     * @param results array to store result in\n     * @returns Array of picking infos\n     */\n    intersectsMeshes(meshes, fastCheck, results) {\n        if (results) {\n            results.length = 0;\n        }\n        else {\n            results = [];\n        }\n        for (let i = 0; i < meshes.length; i++) {\n            const pickInfo = this.intersectsMesh(meshes[i], fastCheck);\n            if (pickInfo.hit) {\n                results.push(pickInfo);\n            }\n        }\n        results.sort(this._comparePickingInfo);\n        return results;\n    }\n    _comparePickingInfo(pickingInfoA, pickingInfoB) {\n        if (pickingInfoA.distance < pickingInfoB.distance) {\n            return -1;\n        }\n        else if (pickingInfoA.distance > pickingInfoB.distance) {\n            return 1;\n        }\n        else {\n            return 0;\n        }\n    }\n    /**\n     * Intersection test between the ray and a given segment within a given tolerance (threshold)\n     * @param sega the first point of the segment to test the intersection against\n     * @param segb the second point of the segment to test the intersection against\n     * @param threshold the tolerance margin, if the ray doesn't intersect the segment but is close to the given threshold, the intersection is successful\n     * @returns the distance from the ray origin to the intersection point if there's intersection, or -1 if there's no intersection\n     */\n    intersectionSegment(sega, segb, threshold) {\n        const o = this.origin;\n        const u = TmpVectors.Vector3[0];\n        const rsegb = TmpVectors.Vector3[1];\n        const v = TmpVectors.Vector3[2];\n        const w = TmpVectors.Vector3[3];\n        segb.subtractToRef(sega, u);\n        this.direction.scaleToRef(Ray._Rayl, v);\n        o.addToRef(v, rsegb);\n        sega.subtractToRef(o, w);\n        const a = Vector3.Dot(u, u); // always >= 0\n        const b = Vector3.Dot(u, v);\n        const c = Vector3.Dot(v, v); // always >= 0\n        const d = Vector3.Dot(u, w);\n        const e = Vector3.Dot(v, w);\n        const discriminant = a * c - b * b; // always >= 0\n        let sN, sD = discriminant; // sc = sN / sD, default sD = D >= 0\n        let tN, tD = discriminant; // tc = tN / tD, default tD = D >= 0\n        // compute the line parameters of the two closest points\n        if (discriminant < Ray._Smallnum) {\n            // the lines are almost parallel\n            sN = 0.0; // force using point P0 on segment S1\n            sD = 1.0; // to prevent possible division by 0.0 later\n            tN = e;\n            tD = c;\n        }\n        else {\n            // get the closest points on the infinite lines\n            sN = b * e - c * d;\n            tN = a * e - b * d;\n            if (sN < 0.0) {\n                // sc < 0 => the s=0 edge is visible\n                sN = 0.0;\n                tN = e;\n                tD = c;\n            }\n            else if (sN > sD) {\n                // sc > 1 => the s=1 edge is visible\n                sN = sD;\n                tN = e + b;\n                tD = c;\n            }\n        }\n        if (tN < 0.0) {\n            // tc < 0 => the t=0 edge is visible\n            tN = 0.0;\n            // recompute sc for this edge\n            if (-d < 0.0) {\n                sN = 0.0;\n            }\n            else if (-d > a) {\n                sN = sD;\n            }\n            else {\n                sN = -d;\n                sD = a;\n            }\n        }\n        else if (tN > tD) {\n            // tc > 1 => the t=1 edge is visible\n            tN = tD;\n            // recompute sc for this edge\n            if (-d + b < 0.0) {\n                sN = 0;\n            }\n            else if (-d + b > a) {\n                sN = sD;\n            }\n            else {\n                sN = -d + b;\n                sD = a;\n            }\n        }\n        // finally do the division to get sc and tc\n        const sc = Math.abs(sN) < Ray._Smallnum ? 0.0 : sN / sD;\n        const tc = Math.abs(tN) < Ray._Smallnum ? 0.0 : tN / tD;\n        // get the difference of the two closest points\n        const qtc = TmpVectors.Vector3[4];\n        v.scaleToRef(tc, qtc);\n        const qsc = TmpVectors.Vector3[5];\n        u.scaleToRef(sc, qsc);\n        qsc.addInPlace(w);\n        const dP = TmpVectors.Vector3[6];\n        qsc.subtractToRef(qtc, dP); // = S1(sc) - S2(tc)\n        const isIntersected = tc > 0 && tc <= this.length && dP.lengthSquared() < threshold * threshold; // return intersection result\n        if (isIntersected) {\n            return qsc.length();\n        }\n        return -1;\n    }\n    /**\n     * Update the ray from viewport position\n     * @param x position\n     * @param y y position\n     * @param viewportWidth viewport width\n     * @param viewportHeight viewport height\n     * @param world world matrix\n     * @param view view matrix\n     * @param projection projection matrix\n     * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n     * @returns this ray updated\n     */\n    update(x, y, viewportWidth, viewportHeight, world, view, projection, enableDistantPicking = false) {\n        if (enableDistantPicking) {\n            // With world matrices having great values (like 8000000000 on 1 or more scaling or position axis),\n            // multiplying view/projection/world and doing invert will result in loss of float precision in the matrix.\n            // One way to fix it is to compute the ray with world at identity then transform the ray in object space.\n            // This is slower (2 matrix inverts instead of 1) but precision is preserved.\n            // This is hidden behind `EnableDistantPicking` flag (default is false)\n            if (!Ray._RayDistant) {\n                Ray._RayDistant = Ray.Zero();\n            }\n            Ray._RayDistant.unprojectRayToRef(x, y, viewportWidth, viewportHeight, Matrix.IdentityReadOnly, view, projection);\n            const tm = TmpVectors.Matrix[0];\n            world.invertToRef(tm);\n            Ray.TransformToRef(Ray._RayDistant, tm, this);\n        }\n        else {\n            this.unprojectRayToRef(x, y, viewportWidth, viewportHeight, world, view, projection);\n        }\n        return this;\n    }\n    // Statics\n    /**\n     * Creates a ray with origin and direction of 0,0,0\n     * @returns the new ray\n     */\n    static Zero() {\n        return new Ray(Vector3.Zero(), Vector3.Zero());\n    }\n    /**\n     * Creates a new ray from screen space and viewport\n     * @param x position\n     * @param y y position\n     * @param viewportWidth viewport width\n     * @param viewportHeight viewport height\n     * @param world world matrix\n     * @param view view matrix\n     * @param projection projection matrix\n     * @returns new ray\n     */\n    static CreateNew(x, y, viewportWidth, viewportHeight, world, view, projection) {\n        const result = Ray.Zero();\n        return result.update(x, y, viewportWidth, viewportHeight, world, view, projection);\n    }\n    /**\n     * Function will create a new transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\n     * transformed to the given world matrix.\n     * @param origin The origin point\n     * @param end The end point\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\n     * @returns the new ray\n     */\n    static CreateNewFromTo(origin, end, world = Matrix.IdentityReadOnly) {\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n        return Ray.CreateFromToToRef(origin, end, result, world);\n    }\n    /**\n     * Function will update a transformed ray starting from origin and ending at the end point. Ray's length will be set, and ray will be\n     * transformed to the given world matrix.\n     * @param origin The origin point\n     * @param end The end point\n     * @param result the object to store the result\n     * @param world a matrix to transform the ray to. Default is the identity matrix.\n     * @returns the ref ray\n     */\n    static CreateFromToToRef(origin, end, result, world = Matrix.IdentityReadOnly) {\n        result.origin.copyFrom(origin);\n        const direction = end.subtractToRef(origin, result.direction);\n        const length = Math.sqrt(direction.x * direction.x + direction.y * direction.y + direction.z * direction.z);\n        result.length = length;\n        result.direction.normalize();\n        return Ray.TransformToRef(result, world, result);\n    }\n    /**\n     * Transforms a ray by a matrix\n     * @param ray ray to transform\n     * @param matrix matrix to apply\n     * @returns the resulting new ray\n     */\n    static Transform(ray, matrix) {\n        const result = new Ray(new Vector3(0, 0, 0), new Vector3(0, 0, 0));\n        Ray.TransformToRef(ray, matrix, result);\n        return result;\n    }\n    /**\n     * Transforms a ray by a matrix\n     * @param ray ray to transform\n     * @param matrix matrix to apply\n     * @param result ray to store result in\n     * @returns the updated result ray\n     */\n    static TransformToRef(ray, matrix, result) {\n        Vector3.TransformCoordinatesToRef(ray.origin, matrix, result.origin);\n        Vector3.TransformNormalToRef(ray.direction, matrix, result.direction);\n        result.length = ray.length;\n        result.epsilon = ray.epsilon;\n        const dir = result.direction;\n        const len = dir.length();\n        if (!(len === 0 || len === 1)) {\n            const num = 1.0 / len;\n            dir.x *= num;\n            dir.y *= num;\n            dir.z *= num;\n            result.length *= len;\n        }\n        return result;\n    }\n    /**\n     * Unproject a ray from screen space to object space\n     * @param sourceX defines the screen space x coordinate to use\n     * @param sourceY defines the screen space y coordinate to use\n     * @param viewportWidth defines the current width of the viewport\n     * @param viewportHeight defines the current height of the viewport\n     * @param world defines the world matrix to use (can be set to Identity to go to world space)\n     * @param view defines the view matrix to use\n     * @param projection defines the projection matrix to use\n     */\n    unprojectRayToRef(sourceX, sourceY, viewportWidth, viewportHeight, world, view, projection) {\n        const matrix = TmpVectors.Matrix[0];\n        world.multiplyToRef(view, matrix);\n        matrix.multiplyToRef(projection, matrix);\n        matrix.invert();\n        const engine = EngineStore.LastCreatedEngine;\n        const nearScreenSource = TmpVectors.Vector3[0];\n        nearScreenSource.x = (sourceX / viewportWidth) * 2 - 1;\n        nearScreenSource.y = -((sourceY / viewportHeight) * 2 - 1);\n        nearScreenSource.z = engine?.useReverseDepthBuffer ? 1 : engine?.isNDCHalfZRange ? 0 : -1;\n        // far Z need to be close but < to 1 or camera projection matrix with maxZ = 0 will NaN\n        const farScreenSource = TmpVectors.Vector3[1].copyFromFloats(nearScreenSource.x, nearScreenSource.y, 1.0 - 1e-8);\n        const nearVec3 = TmpVectors.Vector3[2];\n        const farVec3 = TmpVectors.Vector3[3];\n        Vector3.TransformCoordinatesToRef(nearScreenSource, matrix, nearVec3);\n        Vector3.TransformCoordinatesToRef(farScreenSource, matrix, farVec3);\n        this.origin.copyFrom(nearVec3);\n        farVec3.subtractToRef(nearVec3, this.direction);\n        this.direction.normalize();\n    }\n}\nRay._TmpVector3 = BuildArray(6, Vector3.Zero);\nRay._RayDistant = Ray.Zero();\nRay._Smallnum = 0.00000001;\nRay._Rayl = 10e8;\n/**\n * Creates a ray that can be used to pick in the scene\n * @param scene defines the scene to use for the picking\n * @param x defines the x coordinate of the origin (on-screen)\n * @param y defines the y coordinate of the origin (on-screen)\n * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n * @param camera defines the camera to use for the picking\n * @param cameraViewSpace defines if picking will be done in view space (false by default)\n * @returns a Ray\n */\nexport function CreatePickingRay(scene, x, y, world, camera, cameraViewSpace = false) {\n    const result = Ray.Zero();\n    CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace);\n    return result;\n}\n/**\n * Creates a ray that can be used to pick in the scene\n * @param scene defines the scene to use for the picking\n * @param x defines the x coordinate of the origin (on-screen)\n * @param y defines the y coordinate of the origin (on-screen)\n * @param world defines the world matrix to use if you want to pick in object space (instead of world space)\n * @param result defines the ray where to store the picking ray\n * @param camera defines the camera to use for the picking\n * @param cameraViewSpace defines if picking will be done in view space (false by default)\n * @param enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n * @returns the current scene\n */\nexport function CreatePickingRayToRef(scene, x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {\n    const engine = scene.getEngine();\n    if (!camera && !(camera = scene.activeCamera) && !(camera = scene.cameraToUseForPointers)) {\n        return scene;\n    }\n    const cameraViewport = camera.viewport;\n    const renderHeight = engine.getRenderHeight();\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\n    // Moving coordinates to local viewport world\n    const levelInv = 1 / engine.getHardwareScalingLevel();\n    x = x * levelInv - vx;\n    y = y * levelInv - (renderHeight - vy - height);\n    result.update(x, y, width, height, world ? world : Matrix.IdentityReadOnly, cameraViewSpace ? Matrix.IdentityReadOnly : camera.getViewMatrix(), camera.getProjectionMatrix(), enableDistantPicking);\n    return scene;\n}\n/**\n * Creates a ray that can be used to pick in the scene\n * @param scene defines the scene to use for the picking\n * @param x defines the x coordinate of the origin (on-screen)\n * @param y defines the y coordinate of the origin (on-screen)\n * @param camera defines the camera to use for the picking\n * @returns a Ray\n */\nexport function CreatePickingRayInCameraSpace(scene, x, y, camera) {\n    const result = Ray.Zero();\n    CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera);\n    return result;\n}\n/**\n * Creates a ray that can be used to pick in the scene\n * @param scene defines the scene to use for the picking\n * @param x defines the x coordinate of the origin (on-screen)\n * @param y defines the y coordinate of the origin (on-screen)\n * @param result defines the ray where to store the picking ray\n * @param camera defines the camera to use for the picking\n * @returns the current scene\n */\nexport function CreatePickingRayInCameraSpaceToRef(scene, x, y, result, camera) {\n    if (!PickingInfo) {\n        return scene;\n    }\n    const engine = scene.getEngine();\n    if (!camera && !(camera = scene.activeCamera) && !(camera = scene.cameraToUseForPointers)) {\n        throw new Error(\"Active camera not set\");\n    }\n    const cameraViewport = camera.viewport;\n    const renderHeight = engine.getRenderHeight();\n    const { x: vx, y: vy, width, height } = cameraViewport.toGlobal(engine.getRenderWidth(), renderHeight);\n    const identity = Matrix.Identity();\n    // Moving coordinates to local viewport world\n    const levelInv = 1 / engine.getHardwareScalingLevel();\n    x = x * levelInv - vx;\n    y = y * levelInv - (renderHeight - vy - height);\n    result.update(x, y, width, height, identity, identity, camera.getProjectionMatrix());\n    return scene;\n}\nfunction InternalPickForMesh(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate, skipBoundingInfo) {\n    const ray = rayFunction(world, mesh.enableDistantPicking);\n    const result = mesh.intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo, world, skipBoundingInfo);\n    if (!result || !result.hit) {\n        return null;\n    }\n    if (!fastCheck && pickingInfo != null && result.distance >= pickingInfo.distance) {\n        return null;\n    }\n    return result;\n}\nfunction InternalPick(scene, rayFunction, predicate, fastCheck, onlyBoundingInfo, trianglePredicate) {\n    let pickingInfo = null;\n    const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);\n    const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;\n    const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;\n    for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {\n        const mesh = scene.meshes[meshIndex];\n        if (predicate) {\n            if (!predicate(mesh, -1)) {\n                continue;\n            }\n        }\n        else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n            continue;\n        }\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\n        if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n            // first check if the ray intersects the whole bounding box/sphere of the mesh\n            const result = picker(pickingInfo, rayFunction, mesh, world, true, true, trianglePredicate);\n            if (result) {\n                if (onlyBoundingInfo) {\n                    // the user only asked for a bounding info check so we can return\n                    return result;\n                }\n                const tmpMatrix = TmpVectors.Matrix[1];\n                const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n                for (let index = 0; index < thinMatrices.length; index++) {\n                    if (predicate && !predicate(mesh, index)) {\n                        continue;\n                    }\n                    const thinMatrix = thinMatrices[index];\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\n                    const result = picker(pickingInfo, rayFunction, mesh, tmpMatrix, fastCheck, onlyBoundingInfo, trianglePredicate, true);\n                    if (result) {\n                        pickingInfo = result;\n                        pickingInfo.thinInstanceIndex = index;\n                        if (fastCheck) {\n                            return pickingInfo;\n                        }\n                    }\n                }\n            }\n        }\n        else {\n            const result = picker(pickingInfo, rayFunction, mesh, world, fastCheck, onlyBoundingInfo, trianglePredicate);\n            if (result) {\n                pickingInfo = result;\n                if (fastCheck) {\n                    return pickingInfo;\n                }\n            }\n        }\n    }\n    return pickingInfo || new PickingInfo();\n}\nfunction InternalMultiPick(scene, rayFunction, predicate, trianglePredicate) {\n    if (!PickingInfo) {\n        return null;\n    }\n    const pickingInfos = [];\n    const computeWorldMatrixForCamera = !!(scene.activeCameras && scene.activeCameras.length > 1 && scene.cameraToUseForPointers !== scene.activeCamera);\n    const currentCamera = scene.cameraToUseForPointers || scene.activeCamera;\n    const picker = PickingCustomization.internalPickerForMesh || InternalPickForMesh;\n    for (let meshIndex = 0; meshIndex < scene.meshes.length; meshIndex++) {\n        const mesh = scene.meshes[meshIndex];\n        if (predicate) {\n            if (!predicate(mesh, -1)) {\n                continue;\n            }\n        }\n        else if (!mesh.isEnabled() || !mesh.isVisible || !mesh.isPickable) {\n            continue;\n        }\n        const forceCompute = computeWorldMatrixForCamera && mesh.isWorldMatrixCameraDependent();\n        const world = mesh.computeWorldMatrix(forceCompute, currentCamera);\n        if (mesh.hasThinInstances && mesh.thinInstanceEnablePicking) {\n            const result = picker(null, rayFunction, mesh, world, true, true, trianglePredicate);\n            if (result) {\n                const tmpMatrix = TmpVectors.Matrix[1];\n                const thinMatrices = mesh.thinInstanceGetWorldMatrices();\n                for (let index = 0; index < thinMatrices.length; index++) {\n                    if (predicate && !predicate(mesh, index)) {\n                        continue;\n                    }\n                    const thinMatrix = thinMatrices[index];\n                    thinMatrix.multiplyToRef(world, tmpMatrix);\n                    const result = picker(null, rayFunction, mesh, tmpMatrix, false, false, trianglePredicate, true);\n                    if (result) {\n                        result.thinInstanceIndex = index;\n                        pickingInfos.push(result);\n                    }\n                }\n            }\n        }\n        else {\n            const result = picker(null, rayFunction, mesh, world, false, false, trianglePredicate);\n            if (result) {\n                pickingInfos.push(result);\n            }\n        }\n    }\n    return pickingInfos;\n}\n/** Launch a ray to try to pick a mesh in the scene using only bounding information of the main mesh (not using submeshes)\n * @param scene defines the scene to use for the picking\n * @param x position on screen\n * @param y position on screen\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n * @param fastCheck defines if the first intersection will be used (and not the closest)\n * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n * @returns a PickingInfo (Please note that some info will not be set like distance, bv, bu and everything that cannot be capture by only using bounding infos)\n */\nexport function PickWithBoundingInfo(scene, x, y, predicate, fastCheck, camera) {\n    if (!PickingInfo) {\n        return null;\n    }\n    const result = InternalPick(scene, (world) => {\n        if (!scene._tempPickingRay) {\n            scene._tempPickingRay = Ray.Zero();\n        }\n        CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null);\n        return scene._tempPickingRay;\n    }, predicate, fastCheck, true);\n    if (result) {\n        result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);\n    }\n    return result;\n}\n/** Launch a ray to try to pick a mesh in the scene\n * @param scene defines the scene to use for the picking\n * @param x position on screen\n * @param y position on screen\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n * @param fastCheck defines if the first intersection will be used (and not the closest)\n * @param camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n * @param _enableDistantPicking defines if picking should handle large values for mesh position/scaling (false by default)\n * @returns a PickingInfo\n */\nexport function Pick(scene, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {\n    const result = InternalPick(scene, (world, enableDistantPicking) => {\n        if (!scene._tempPickingRay) {\n            scene._tempPickingRay = Ray.Zero();\n        }\n        CreatePickingRayToRef(scene, x, y, world, scene._tempPickingRay, camera || null, false, enableDistantPicking);\n        return scene._tempPickingRay;\n    }, predicate, fastCheck, false, trianglePredicate);\n    if (result) {\n        result.ray = CreatePickingRay(scene, x, y, Matrix.Identity(), camera || null);\n    }\n    return result;\n}\n/**\n * Use the given ray to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n * irrespective of orientation.\n * @param scene defines the scene to use for the picking\n * @param ray The ray to use to pick meshes\n * @param predicate Predicate function used to determine eligible meshes. Can be set to null. In this case, a mesh must have isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n * @param fastCheck defines if the first intersection will be used (and not the closest)\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n * @returns a PickingInfo\n */\nexport function PickWithRay(scene, ray, predicate, fastCheck, trianglePredicate) {\n    const result = InternalPick(scene, (world) => {\n        if (!scene._pickWithRayInverseMatrix) {\n            scene._pickWithRayInverseMatrix = Matrix.Identity();\n        }\n        world.invertToRef(scene._pickWithRayInverseMatrix);\n        if (!scene._cachedRayForTransform) {\n            scene._cachedRayForTransform = Ray.Zero();\n        }\n        Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);\n        return scene._cachedRayForTransform;\n    }, predicate, fastCheck, false, trianglePredicate);\n    if (result) {\n        result.ray = ray;\n    }\n    return result;\n}\n/**\n * Launch a ray to try to pick a mesh in the scene. A mesh triangle can be picked both from its front and back sides,\n * irrespective of orientation.\n * @param scene defines the scene to use for the picking\n * @param x X position on screen\n * @param y Y position on screen\n * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n * @param camera camera to use for computing the picking ray. Can be set to null. In this case, the scene.activeCamera will be used\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n * @returns an array of PickingInfo\n */\nexport function MultiPick(scene, x, y, predicate, camera, trianglePredicate) {\n    return InternalMultiPick(scene, (world) => CreatePickingRay(scene, x, y, world, camera || null), predicate, trianglePredicate);\n}\n/**\n * Launch a ray to try to pick a mesh in the scene\n * @param scene defines the scene to use for the picking\n * @param ray Ray to use\n * @param predicate Predicate function used to determine eligible meshes and instances. Can be set to null. In this case, a mesh must be enabled, visible and with isPickable set to true. thinInstanceIndex is -1 when the mesh is non-instanced\n * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n * @returns an array of PickingInfo\n */\nexport function MultiPickWithRay(scene, ray, predicate, trianglePredicate) {\n    return InternalMultiPick(scene, (world) => {\n        if (!scene._pickWithRayInverseMatrix) {\n            scene._pickWithRayInverseMatrix = Matrix.Identity();\n        }\n        world.invertToRef(scene._pickWithRayInverseMatrix);\n        if (!scene._cachedRayForTransform) {\n            scene._cachedRayForTransform = Ray.Zero();\n        }\n        Ray.TransformToRef(ray, scene._pickWithRayInverseMatrix, scene._cachedRayForTransform);\n        return scene._cachedRayForTransform;\n    }, predicate, trianglePredicate);\n}\n/**\n * Gets a ray in the forward direction from the camera.\n * @param camera Defines the camera to use to get the ray from\n * @param length Defines the length of the ray to create\n * @param transform Defines the transform to apply to the ray, by default the world matrix is used to create a workd space ray\n * @param origin Defines the start point of the ray which defaults to the camera position\n * @returns the forward ray\n */\nexport function GetForwardRay(camera, length = 100, transform, origin) {\n    return GetForwardRayToRef(camera, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\n}\n/**\n * Gets a ray in the forward direction from the camera.\n * @param camera Defines the camera to use to get the ray from\n * @param refRay the ray to (re)use when setting the values\n * @param length Defines the length of the ray to create\n * @param transform Defines the transform to apply to the ray, by default the world matrx is used to create a workd space ray\n * @param origin Defines the start point of the ray which defaults to the camera position\n * @returns the forward ray\n */\nexport function GetForwardRayToRef(camera, refRay, length = 100, transform, origin) {\n    if (!transform) {\n        transform = camera.getWorldMatrix();\n    }\n    refRay.length = length;\n    if (origin) {\n        refRay.origin.copyFrom(origin);\n    }\n    else {\n        refRay.origin.copyFrom(camera.position);\n    }\n    const forward = TmpVectors.Vector3[2];\n    forward.set(0, 0, camera._scene.useRightHandedSystem ? -1 : 1);\n    const worldForward = TmpVectors.Vector3[3];\n    Vector3.TransformNormalToRef(forward, transform, worldForward);\n    Vector3.NormalizeToRef(worldForward, refRay.direction);\n    return refRay;\n}\n/**\n * Initialize the minimal interdependecies between the Ray and Scene and Camera\n * @param sceneClass defines the scene prototype to use\n * @param cameraClass defines the camera prototype to use\n */\nexport function AddRayExtensions(sceneClass, cameraClass) {\n    if (cameraClass) {\n        cameraClass.prototype.getForwardRay = function (length = 100, transform, origin) {\n            return GetForwardRayToRef(this, new Ray(Vector3.Zero(), Vector3.Zero(), length), length, transform, origin);\n        };\n        cameraClass.prototype.getForwardRayToRef = function (refRay, length = 100, transform, origin) {\n            return GetForwardRayToRef(this, refRay, length, transform, origin);\n        };\n    }\n    if (!sceneClass) {\n        return;\n    }\n    _ImportHelper._IsPickingAvailable = true;\n    sceneClass.prototype.createPickingRay = function (x, y, world, camera, cameraViewSpace = false) {\n        return CreatePickingRay(this, x, y, world, camera, cameraViewSpace);\n    };\n}\n//# sourceMappingURL=ray.core.js.map","import { Scene } from \"../scene\";\nimport { Camera } from \"../Cameras/camera\";\nimport { AddRayExtensions, CreatePickingRayInCameraSpace, CreatePickingRayInCameraSpaceToRef, CreatePickingRayToRef, MultiPick, MultiPickWithRay, Pick, PickWithBoundingInfo, PickWithRay, } from \"./ray.core\";\nexport * from \"./ray.core\";\n// Picking\nAddRayExtensions(Scene, Camera);\nScene.prototype.createPickingRayToRef = function (x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {\n    return CreatePickingRayToRef(this, x, y, world, result, camera, cameraViewSpace, enableDistantPicking);\n};\nScene.prototype.createPickingRayInCameraSpace = function (x, y, camera) {\n    return CreatePickingRayInCameraSpace(this, x, y, camera);\n};\nScene.prototype.createPickingRayInCameraSpaceToRef = function (x, y, result, camera) {\n    return CreatePickingRayInCameraSpaceToRef(this, x, y, result, camera);\n};\nScene.prototype.pickWithBoundingInfo = function (x, y, predicate, fastCheck, camera) {\n    return PickWithBoundingInfo(this, x, y, predicate, fastCheck, camera);\n};\nScene.prototype.pick = function (x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking = false) {\n    return Pick(this, x, y, predicate, fastCheck, camera, trianglePredicate, _enableDistantPicking);\n};\nScene.prototype.pickWithRay = function (ray, predicate, fastCheck, trianglePredicate) {\n    return PickWithRay(this, ray, predicate, fastCheck, trianglePredicate);\n};\nScene.prototype.multiPick = function (x, y, predicate, camera, trianglePredicate) {\n    return MultiPick(this, x, y, predicate, camera, trianglePredicate);\n};\nScene.prototype.multiPickWithRay = function (ray, predicate, trianglePredicate) {\n    return MultiPickWithRay(this, ray, predicate, trianglePredicate);\n};\n//# sourceMappingURL=ray.js.map"],"names":["Ray","constructor","origin","direction","length","Number","MAX_VALUE","epsilon","Epsilon","this","clone","intersectsBoxMinMax","minimum","maximum","intersectionTreshold","newMinimum","_TmpVector3","copyFromFloats","x","y","z","newMaximum","inv","min","max","temp","d","maxValue","Math","abs","Infinity","intersectsBox","box","intersectsSphere","sphere","center","pyth","radius","rr","dot","intersectsTriangle","vertex0","vertex1","vertex2","edge1","edge2","pvec","tvec","qvec","subtractToRef","Vector3","CrossToRef","det","Dot","invdet","bv","bw","distance","IntersectionInfo","intersectsPlane","plane","result1","normal","result2","intersectsAxis","axis","offset","t","intersectsMesh","mesh","fastCheck","trianglePredicate","onlyBoundingInfo","worldToUse","skipBoundingInfo","tm","TmpVectors","Matrix","getWorldMatrix","invertToRef","_tmpRay","TransformToRef","Transform","intersects","intersectsMeshes","meshes","results","i","pickInfo","hit","push","sort","_comparePickingInfo","pickingInfoA","pickingInfoB","intersectionSegment","sega","segb","threshold","o","u","rsegb","v","w","scaleToRef","_Rayl","addToRef","a","b","c","e","discriminant","sN","tN","sD","tD","_Smallnum","sc","tc","qtc","qsc","addInPlace","dP","lengthSquared","update","viewportWidth","viewportHeight","world","view","projection","enableDistantPicking","_RayDistant","Zero","unprojectRayToRef","IdentityReadOnly","CreateNew","CreateNewFromTo","end","result","CreateFromToToRef","copyFrom","sqrt","normalize","ray","matrix","TransformCoordinatesToRef","TransformNormalToRef","dir","len","num","sourceX","sourceY","multiplyToRef","invert","engine","EngineStore","LastCreatedEngine","nearScreenSource","useReverseDepthBuffer","isNDCHalfZRange","farScreenSource","nearVec3","farVec3","CreatePickingRay","scene","camera","cameraViewSpace","CreatePickingRayToRef","getEngine","activeCamera","cameraToUseForPointers","cameraViewport","viewport","renderHeight","getRenderHeight","vx","vy","width","height","toGlobal","getRenderWidth","levelInv","getHardwareScalingLevel","getViewMatrix","getProjectionMatrix","CreatePickingRayInCameraSpace","CreatePickingRayInCameraSpaceToRef","PickingInfo","Error","identity","Identity","InternalPickForMesh","pickingInfo","rayFunction","InternalPick","predicate","computeWorldMatrixForCamera","activeCameras","currentCamera","picker","meshIndex","isEnabled","isVisible","isPickable","forceCompute","isWorldMatrixCameraDependent","computeWorldMatrix","hasThinInstances","thinInstanceEnablePicking","tmpMatrix","thinMatrices","thinInstanceGetWorldMatrices","index","thinInstanceIndex","InternalMultiPick","pickingInfos","PickWithBoundingInfo","_tempPickingRay","Pick","_enableDistantPicking","PickWithRay","_pickWithRayInverseMatrix","_cachedRayForTransform","MultiPick","MultiPickWithRay","GetForwardRayToRef","refRay","transform","position","forward","set","_scene","useRightHandedSystem","worldForward","NormalizeToRef","AddRayExtensions","sceneClass","cameraClass","prototype","getForwardRay","getForwardRayToRef","_ImportHelper","_IsPickingAvailable","createPickingRay","BuildArray","Scene","Camera","createPickingRayToRef","createPickingRayInCameraSpace","createPickingRayInCameraSpaceToRef","pickWithBoundingInfo","pick","pickWithRay","multiPick","multiPickWithRay"],"mappings":"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"}