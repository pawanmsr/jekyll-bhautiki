{"version":3,"file":"animationGroup-CNrTHU36.esm.min.js","sources":["../../../../../dev/core/dist/Animations/runtimeAnimation.js","../../../../../dev/core/dist/Animations/animatable.core.js","../../../../../dev/core/dist/Animations/animatable.js","../../../../../dev/core/dist/Animations/animationGroup.js"],"sourcesContent":["import { Matrix } from \"../Maths/math.vector\";\nimport { Animation, _StaticOffsetValueColor3, _StaticOffsetValueColor4, _StaticOffsetValueQuaternion, _StaticOffsetValueSize, _StaticOffsetValueVector2, _StaticOffsetValueVector3, } from \"./animation\";\n/**\n * Defines a runtime animation\n */\nexport class RuntimeAnimation {\n    /**\n     * Gets the current frame of the runtime animation\n     */\n    get currentFrame() {\n        return this._currentFrame;\n    }\n    /**\n     * Gets the weight of the runtime animation\n     */\n    get weight() {\n        return this._weight;\n    }\n    /**\n     * Gets the current value of the runtime animation\n     */\n    get currentValue() {\n        return this._currentValue;\n    }\n    /**\n     * Gets or sets the target path of the runtime animation\n     */\n    get targetPath() {\n        return this._targetPath;\n    }\n    /**\n     * Gets the actual target of the runtime animation\n     */\n    get target() {\n        return this._currentActiveTarget;\n    }\n    /**\n     * Gets the additive state of the runtime animation\n     */\n    get isAdditive() {\n        return this._host && this._host.isAdditive;\n    }\n    /**\n     * Create a new RuntimeAnimation object\n     * @param target defines the target of the animation\n     * @param animation defines the source animation object\n     * @param scene defines the hosting scene\n     * @param host defines the initiating Animatable\n     */\n    constructor(target, animation, scene, host) {\n        this._events = new Array();\n        /**\n         * The current frame of the runtime animation\n         */\n        this._currentFrame = 0;\n        /**\n         * The original value of the runtime animation\n         */\n        this._originalValue = new Array();\n        /**\n         * The original blend value of the runtime animation\n         */\n        this._originalBlendValue = null;\n        /**\n         * The offsets cache of the runtime animation\n         */\n        this._offsetsCache = {};\n        /**\n         * The high limits cache of the runtime animation\n         */\n        this._highLimitsCache = {};\n        /**\n         * Specifies if the runtime animation has been stopped\n         */\n        this._stopped = false;\n        /**\n         * The blending factor of the runtime animation\n         */\n        this._blendingFactor = 0;\n        /**\n         * The current value of the runtime animation\n         */\n        this._currentValue = null;\n        this._currentActiveTarget = null;\n        this._directTarget = null;\n        /**\n         * The target path of the runtime animation\n         */\n        this._targetPath = \"\";\n        /**\n         * The weight of the runtime animation\n         */\n        this._weight = 1.0;\n        /**\n         * The absolute frame offset of the runtime animation\n         */\n        this._absoluteFrameOffset = 0;\n        /**\n         * The previous elapsed time (since start of animation) of the runtime animation\n         */\n        this._previousElapsedTime = 0;\n        this._yoyoDirection = 1;\n        /**\n         * The previous absolute frame of the runtime animation (meaning, without taking into account the from/to values, only the elapsed time and the fps)\n         */\n        this._previousAbsoluteFrame = 0;\n        this._targetIsArray = false;\n        /** @internal */\n        this._coreRuntimeAnimation = null;\n        this._animation = animation;\n        this._target = target;\n        this._scene = scene;\n        this._host = host;\n        this._activeTargets = [];\n        animation._runtimeAnimations.push(this);\n        // State\n        this._animationState = {\n            key: 0,\n            repeatCount: 0,\n            loopMode: this._getCorrectLoopMode(),\n        };\n        if (this._animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {\n            this._animationState.workValue = Matrix.Zero();\n        }\n        // Limits\n        this._keys = this._animation.getKeys();\n        this._minFrame = this._keys[0].frame;\n        this._maxFrame = this._keys[this._keys.length - 1].frame;\n        // Add a start key at frame 0 if missing\n        if (this._minFrame !== 0) {\n            const newKey = { frame: 0, value: this._keys[0].value };\n            this._keys.splice(0, 0, newKey);\n        }\n        // Check data\n        if (this._target instanceof Array) {\n            let index = 0;\n            for (const target of this._target) {\n                this._preparePath(target, index);\n                this._getOriginalValues(index);\n                index++;\n            }\n            this._targetIsArray = true;\n        }\n        else {\n            this._preparePath(this._target);\n            this._getOriginalValues();\n            this._targetIsArray = false;\n            this._directTarget = this._activeTargets[0];\n        }\n        // Cloning events locally\n        const events = animation.getEvents();\n        if (events && events.length > 0) {\n            for (const e of events) {\n                this._events.push(e._clone());\n            }\n        }\n        this._enableBlending = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.enableBlending : this._animation.enableBlending;\n    }\n    _preparePath(target, targetIndex = 0) {\n        const targetPropertyPath = this._animation.targetPropertyPath;\n        if (targetPropertyPath.length > 1) {\n            let property = target;\n            for (let index = 0; index < targetPropertyPath.length - 1; index++) {\n                const name = targetPropertyPath[index];\n                property = property[name];\n                if (property === undefined) {\n                    throw new Error(`Invalid property (${name}) in property path (${targetPropertyPath.join(\".\")})`);\n                }\n            }\n            this._targetPath = targetPropertyPath[targetPropertyPath.length - 1];\n            this._activeTargets[targetIndex] = property;\n        }\n        else {\n            this._targetPath = targetPropertyPath[0];\n            this._activeTargets[targetIndex] = target;\n        }\n        if (this._activeTargets[targetIndex][this._targetPath] === undefined) {\n            throw new Error(`Invalid property (${this._targetPath}) in property path (${targetPropertyPath.join(\".\")})`);\n        }\n    }\n    /**\n     * Gets the animation from the runtime animation\n     */\n    get animation() {\n        return this._animation;\n    }\n    /**\n     * Resets the runtime animation to the beginning\n     * @param restoreOriginal defines whether to restore the target property to the original value\n     */\n    reset(restoreOriginal = false) {\n        if (restoreOriginal) {\n            if (this._target instanceof Array) {\n                let index = 0;\n                for (const target of this._target) {\n                    if (this._originalValue[index] !== undefined) {\n                        this._setValue(target, this._activeTargets[index], this._originalValue[index], -1, index);\n                    }\n                    index++;\n                }\n            }\n            else {\n                if (this._originalValue[0] !== undefined) {\n                    this._setValue(this._target, this._directTarget, this._originalValue[0], -1, 0);\n                }\n            }\n        }\n        this._offsetsCache = {};\n        this._highLimitsCache = {};\n        this._currentFrame = 0;\n        this._blendingFactor = 0;\n        // Events\n        for (let index = 0; index < this._events.length; index++) {\n            this._events[index].isDone = false;\n        }\n    }\n    /**\n     * Specifies if the runtime animation is stopped\n     * @returns Boolean specifying if the runtime animation is stopped\n     */\n    isStopped() {\n        return this._stopped;\n    }\n    /**\n     * Disposes of the runtime animation\n     */\n    dispose() {\n        const index = this._animation.runtimeAnimations.indexOf(this);\n        if (index > -1) {\n            this._animation.runtimeAnimations.splice(index, 1);\n        }\n    }\n    /**\n     * Apply the interpolated value to the target\n     * @param currentValue defines the value computed by the animation\n     * @param weight defines the weight to apply to this value (Defaults to 1.0)\n     */\n    setValue(currentValue, weight) {\n        if (this._targetIsArray) {\n            for (let index = 0; index < this._target.length; index++) {\n                const target = this._target[index];\n                this._setValue(target, this._activeTargets[index], currentValue, weight, index);\n            }\n            return;\n        }\n        this._setValue(this._target, this._directTarget, currentValue, weight, 0);\n    }\n    _getOriginalValues(targetIndex = 0) {\n        let originalValue;\n        const target = this._activeTargets[targetIndex];\n        if (target.getLocalMatrix && this._targetPath === \"_matrix\") {\n            // For bones\n            originalValue = target.getLocalMatrix();\n        }\n        else {\n            originalValue = target[this._targetPath];\n        }\n        if (originalValue && originalValue.clone) {\n            this._originalValue[targetIndex] = originalValue.clone();\n        }\n        else {\n            this._originalValue[targetIndex] = originalValue;\n        }\n    }\n    _registerTargetForLateAnimationBinding(runtimeAnimation, originalValue) {\n        const target = runtimeAnimation.target;\n        this._scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\n        if (!target._lateAnimationHolders) {\n            target._lateAnimationHolders = {};\n        }\n        if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n            target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n                totalWeight: 0,\n                totalAdditiveWeight: 0,\n                animations: [],\n                additiveAnimations: [],\n                originalValue: originalValue,\n            };\n        }\n        if (runtimeAnimation.isAdditive) {\n            target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n        }\n        else {\n            target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n            target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n        }\n    }\n    _setValue(target, destination, currentValue, weight, targetIndex) {\n        // Set value\n        this._currentActiveTarget = destination;\n        this._weight = weight;\n        if (this._enableBlending && this._blendingFactor <= 1.0) {\n            if (!this._originalBlendValue) {\n                const originalValue = destination[this._targetPath];\n                if (originalValue.clone) {\n                    this._originalBlendValue = originalValue.clone();\n                }\n                else {\n                    this._originalBlendValue = originalValue;\n                }\n            }\n            if (this._originalBlendValue.m) {\n                // Matrix\n                if (Animation.AllowMatrixDecomposeForInterpolation) {\n                    if (this._currentValue) {\n                        Matrix.DecomposeLerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n                    }\n                    else {\n                        this._currentValue = Matrix.DecomposeLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n                    }\n                }\n                else {\n                    if (this._currentValue) {\n                        Matrix.LerpToRef(this._originalBlendValue, currentValue, this._blendingFactor, this._currentValue);\n                    }\n                    else {\n                        this._currentValue = Matrix.Lerp(this._originalBlendValue, currentValue, this._blendingFactor);\n                    }\n                }\n            }\n            else {\n                this._currentValue = Animation._UniversalLerp(this._originalBlendValue, currentValue, this._blendingFactor);\n            }\n            const blendingSpeed = target && target.animationPropertiesOverride ? target.animationPropertiesOverride.blendingSpeed : this._animation.blendingSpeed;\n            this._blendingFactor += blendingSpeed;\n        }\n        else {\n            if (!this._currentValue) {\n                if (currentValue?.clone) {\n                    this._currentValue = currentValue.clone();\n                }\n                else {\n                    this._currentValue = currentValue;\n                }\n            }\n            else if (this._currentValue.copyFrom) {\n                this._currentValue.copyFrom(currentValue);\n            }\n            else {\n                this._currentValue = currentValue;\n            }\n        }\n        if (weight !== -1.0) {\n            this._registerTargetForLateAnimationBinding(this, this._originalValue[targetIndex]);\n        }\n        else {\n            if (this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT) {\n                if (this._currentValue.addToRef) {\n                    this._currentValue.addToRef(this._originalValue[targetIndex], destination[this._targetPath]);\n                }\n                else {\n                    destination[this._targetPath] = this._originalValue[targetIndex] + this._currentValue;\n                }\n            }\n            else {\n                destination[this._targetPath] = this._currentValue;\n            }\n        }\n        if (target.markAsDirty) {\n            target.markAsDirty(this._animation.targetProperty);\n        }\n    }\n    /**\n     * Gets the loop pmode of the runtime animation\n     * @returns Loop Mode\n     */\n    _getCorrectLoopMode() {\n        if (this._target && this._target.animationPropertiesOverride) {\n            return this._target.animationPropertiesOverride.loopMode;\n        }\n        return this._animation.loopMode;\n    }\n    /**\n     * Move the current animation to a given frame\n     * @param frame defines the frame to move to\n     * @param weight defines the weight to apply to the animation (-1.0 by default)\n     */\n    goToFrame(frame, weight = -1) {\n        const keys = this._animation.getKeys();\n        if (frame < keys[0].frame) {\n            frame = keys[0].frame;\n        }\n        else if (frame > keys[keys.length - 1].frame) {\n            frame = keys[keys.length - 1].frame;\n        }\n        // Need to reset animation events\n        const events = this._events;\n        if (events.length) {\n            for (let index = 0; index < events.length; index++) {\n                if (!events[index].onlyOnce) {\n                    // reset events in the future\n                    events[index].isDone = events[index].frame < frame;\n                }\n            }\n        }\n        this._currentFrame = frame;\n        const currentValue = this._animation._interpolate(frame, this._animationState);\n        this.setValue(currentValue, weight);\n    }\n    /**\n     * @internal Internal use only\n     */\n    _prepareForSpeedRatioChange(newSpeedRatio) {\n        const newAbsoluteFrame = (this._previousElapsedTime * (this._animation.framePerSecond * newSpeedRatio)) / 1000.0;\n        this._absoluteFrameOffset = this._previousAbsoluteFrame - newAbsoluteFrame;\n    }\n    /**\n     * Execute the current animation\n     * @param elapsedTimeSinceAnimationStart defines the elapsed time (in milliseconds) since the animation was started\n     * @param from defines the lower frame of the animation range\n     * @param to defines the upper frame of the animation range\n     * @param loop defines if the current animation must loop\n     * @param speedRatio defines the current speed ratio\n     * @param weight defines the weight of the animation (default is -1 so no weight)\n     * @returns a boolean indicating if the animation is running\n     */\n    animate(elapsedTimeSinceAnimationStart, from, to, loop, speedRatio, weight = -1.0) {\n        const animation = this._animation;\n        const targetPropertyPath = animation.targetPropertyPath;\n        if (!targetPropertyPath || targetPropertyPath.length < 1) {\n            this._stopped = true;\n            return false;\n        }\n        let returnValue = true;\n        let currentFrame;\n        const events = this._events;\n        let frameRange = 0;\n        if (!this._coreRuntimeAnimation) {\n            // Check limits\n            if (from < this._minFrame || from > this._maxFrame) {\n                from = this._minFrame;\n            }\n            if (to < this._minFrame || to > this._maxFrame) {\n                to = this._maxFrame;\n            }\n            frameRange = to - from;\n            let offsetValue;\n            // Compute the frame according to the elapsed time and the fps of the animation (\"from\" and \"to\" are not factored in!)\n            let absoluteFrame = (elapsedTimeSinceAnimationStart * (animation.framePerSecond * speedRatio)) / 1000.0 + this._absoluteFrameOffset;\n            let highLimitValue = 0;\n            // Apply the yoyo function if required\n            let yoyoLoop = false;\n            const yoyoMode = loop && this._animationState.loopMode === Animation.ANIMATIONLOOPMODE_YOYO;\n            if (yoyoMode) {\n                const position = (absoluteFrame - from) / frameRange;\n                // Apply the yoyo curve\n                const sin = Math.sin(position * Math.PI);\n                const yoyoPosition = Math.abs(sin);\n                // Map the yoyo position back to the range\n                absoluteFrame = yoyoPosition * frameRange + from;\n                const direction = sin >= 0 ? 1 : -1;\n                if (this._yoyoDirection !== direction) {\n                    yoyoLoop = true;\n                }\n                this._yoyoDirection = direction;\n            }\n            this._previousElapsedTime = elapsedTimeSinceAnimationStart;\n            this._previousAbsoluteFrame = absoluteFrame;\n            if (!loop && to >= from && ((absoluteFrame >= frameRange && speedRatio > 0) || (absoluteFrame <= 0 && speedRatio < 0))) {\n                // If we are out of range and not looping get back to caller\n                returnValue = false;\n                highLimitValue = animation.evaluate(to);\n            }\n            else if (!loop && from >= to && ((absoluteFrame <= frameRange && speedRatio < 0) || (absoluteFrame >= 0 && speedRatio > 0))) {\n                returnValue = false;\n                highLimitValue = animation.evaluate(from);\n            }\n            else if (this._animationState.loopMode !== Animation.ANIMATIONLOOPMODE_CYCLE) {\n                const keyOffset = to.toString() + from.toString();\n                if (!this._offsetsCache[keyOffset]) {\n                    this._animationState.repeatCount = 0;\n                    this._animationState.loopMode = Animation.ANIMATIONLOOPMODE_CYCLE; // force a specific codepath in animation._interpolate()!\n                    const fromValue = animation._interpolate(from, this._animationState);\n                    const toValue = animation._interpolate(to, this._animationState);\n                    this._animationState.loopMode = this._getCorrectLoopMode();\n                    switch (animation.dataType) {\n                        // Float\n                        case Animation.ANIMATIONTYPE_FLOAT:\n                            this._offsetsCache[keyOffset] = toValue - fromValue;\n                            break;\n                        // Quaternion\n                        case Animation.ANIMATIONTYPE_QUATERNION:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Vector3\n                        case Animation.ANIMATIONTYPE_VECTOR3:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Vector2\n                        case Animation.ANIMATIONTYPE_VECTOR2:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Size\n                        case Animation.ANIMATIONTYPE_SIZE:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        // Color3\n                        case Animation.ANIMATIONTYPE_COLOR3:\n                            this._offsetsCache[keyOffset] = toValue.subtract(fromValue);\n                            break;\n                        default:\n                            break;\n                    }\n                    this._highLimitsCache[keyOffset] = toValue;\n                }\n                highLimitValue = this._highLimitsCache[keyOffset];\n                offsetValue = this._offsetsCache[keyOffset];\n            }\n            if (offsetValue === undefined) {\n                switch (animation.dataType) {\n                    // Float\n                    case Animation.ANIMATIONTYPE_FLOAT:\n                        offsetValue = 0;\n                        break;\n                    // Quaternion\n                    case Animation.ANIMATIONTYPE_QUATERNION:\n                        offsetValue = _StaticOffsetValueQuaternion;\n                        break;\n                    // Vector3\n                    case Animation.ANIMATIONTYPE_VECTOR3:\n                        offsetValue = _StaticOffsetValueVector3;\n                        break;\n                    // Vector2\n                    case Animation.ANIMATIONTYPE_VECTOR2:\n                        offsetValue = _StaticOffsetValueVector2;\n                        break;\n                    // Size\n                    case Animation.ANIMATIONTYPE_SIZE:\n                        offsetValue = _StaticOffsetValueSize;\n                        break;\n                    // Color3\n                    case Animation.ANIMATIONTYPE_COLOR3:\n                        offsetValue = _StaticOffsetValueColor3;\n                        break;\n                    case Animation.ANIMATIONTYPE_COLOR4:\n                        offsetValue = _StaticOffsetValueColor4;\n                        break;\n                }\n            }\n            // Compute value\n            if (this._host && this._host.syncRoot) {\n                // If we must sync with an animatable, calculate the current frame based on the frame of the root animatable\n                const syncRoot = this._host.syncRoot;\n                const hostNormalizedFrame = (syncRoot.masterFrame - syncRoot.fromFrame) / (syncRoot.toFrame - syncRoot.fromFrame);\n                currentFrame = from + frameRange * hostNormalizedFrame;\n            }\n            else {\n                if ((absoluteFrame > 0 && from > to) || (absoluteFrame < 0 && from < to)) {\n                    currentFrame = returnValue && frameRange !== 0 ? to + (absoluteFrame % frameRange) : from;\n                }\n                else {\n                    currentFrame = returnValue && frameRange !== 0 ? from + (absoluteFrame % frameRange) : to;\n                }\n            }\n            // Reset event/state if looping\n            if ((!yoyoMode && ((speedRatio > 0 && this.currentFrame > currentFrame) || (speedRatio < 0 && this.currentFrame < currentFrame))) || (yoyoMode && yoyoLoop)) {\n                this._onLoop();\n                // Need to reset animation events\n                for (let index = 0; index < events.length; index++) {\n                    if (!events[index].onlyOnce) {\n                        // reset event, the animation is looping\n                        events[index].isDone = false;\n                    }\n                }\n                this._animationState.key = speedRatio > 0 ? 0 : animation.getKeys().length - 1;\n            }\n            this._currentFrame = currentFrame;\n            this._animationState.repeatCount = frameRange === 0 ? 0 : (absoluteFrame / frameRange) >> 0;\n            this._animationState.highLimitValue = highLimitValue;\n            this._animationState.offsetValue = offsetValue;\n        }\n        else {\n            frameRange = to - from;\n            currentFrame = this._coreRuntimeAnimation.currentFrame;\n            this._currentFrame = currentFrame;\n            this._animationState.repeatCount = this._coreRuntimeAnimation._animationState.repeatCount;\n            this._animationState.highLimitValue = this._coreRuntimeAnimation._animationState.highLimitValue;\n            this._animationState.offsetValue = this._coreRuntimeAnimation._animationState.offsetValue;\n        }\n        const currentValue = animation._interpolate(currentFrame, this._animationState);\n        // Set value\n        this.setValue(currentValue, weight);\n        // Check events\n        if (events.length) {\n            for (let index = 0; index < events.length; index++) {\n                // Make sure current frame has passed event frame and that event frame is within the current range\n                // Also, handle both forward and reverse animations\n                if ((frameRange >= 0 && currentFrame >= events[index].frame && events[index].frame >= from) ||\n                    (frameRange < 0 && currentFrame <= events[index].frame && events[index].frame <= from)) {\n                    const event = events[index];\n                    if (!event.isDone) {\n                        // If event should be done only once, remove it.\n                        if (event.onlyOnce) {\n                            events.splice(index, 1);\n                            index--;\n                        }\n                        event.isDone = true;\n                        event.action(currentFrame);\n                    } // Don't do anything if the event has already been done.\n                }\n            }\n        }\n        if (!returnValue) {\n            this._stopped = true;\n        }\n        return returnValue;\n    }\n}\n//# sourceMappingURL=runtimeAnimation.js.map","import { Observable } from \"core/Misc/observable\";\nimport { RuntimeAnimation } from \"./runtimeAnimation\";\nimport { Animation } from \"./animation\";\nimport { PrecisionDate } from \"core/Misc/precisionDate\";\nimport { Matrix, Quaternion, TmpVectors, Vector3 } from \"core/Maths/math.vector\";\n/**\n * Class used to store an actual running animation\n */\nexport class Animatable {\n    /**\n     * Gets the root Animatable used to synchronize and normalize animations\n     */\n    get syncRoot() {\n        return this._syncRoot;\n    }\n    /**\n     * Gets the current frame of the first RuntimeAnimation\n     * Used to synchronize Animatables\n     */\n    get masterFrame() {\n        if (this._runtimeAnimations.length === 0) {\n            return 0;\n        }\n        return this._runtimeAnimations[0].currentFrame;\n    }\n    /**\n     * Gets or sets the animatable weight (-1.0 by default meaning not weighted)\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(value) {\n        if (value === -1) {\n            // -1 is ok and means no weight\n            this._weight = -1;\n            return;\n        }\n        // Else weight must be in [0, 1] range\n        this._weight = Math.min(Math.max(value, 0), 1.0);\n    }\n    /**\n     * Gets or sets the speed ratio to apply to the animatable (1.0 by default)\n     */\n    get speedRatio() {\n        return this._speedRatio;\n    }\n    set speedRatio(value) {\n        for (let index = 0; index < this._runtimeAnimations.length; index++) {\n            const animation = this._runtimeAnimations[index];\n            animation._prepareForSpeedRatioChange(value);\n        }\n        this._speedRatio = value;\n        // Resync _manualJumpDelay in case goToFrame was called before speedRatio was set.\n        if (this._goToFrame !== null) {\n            this.goToFrame(this._goToFrame);\n        }\n    }\n    /**\n     * Gets the elapsed time since the animatable started in milliseconds\n     */\n    get elapsedTime() {\n        return this._localDelayOffset === null ? 0 : this._scene._animationTime - this._localDelayOffset;\n    }\n    /**\n     * Creates a new Animatable\n     * @param scene defines the hosting scene\n     * @param target defines the target object\n     * @param fromFrame defines the starting frame number (default is 0)\n     * @param toFrame defines the ending frame number (default is 100)\n     * @param loopAnimation defines if the animation must loop (default is false)\n     * @param speedRatio defines the factor to apply to animation speed (default is 1)\n     * @param onAnimationEnd defines a callback to call when animation ends if it is not looping\n     * @param animations defines a group of animation to add to the new Animatable\n     * @param onAnimationLoop defines a callback to call when animation loops\n     * @param isAdditive defines whether the animation should be evaluated additively\n     * @param playOrder defines the order in which this animatable should be processed in the list of active animatables (default: 0)\n     */\n    constructor(scene, \n    /** defines the target object */\n    target, \n    /** [0] defines the starting frame number (default is 0) */\n    fromFrame = 0, \n    /** [100] defines the ending frame number (default is 100) */\n    toFrame = 100, \n    /** [false] defines if the animation must loop (default is false)  */\n    loopAnimation = false, speedRatio = 1.0, \n    /** defines a callback to call when animation ends if it is not looping */\n    onAnimationEnd, animations, \n    /** defines a callback to call when animation loops */\n    onAnimationLoop, \n    /** [false] defines whether the animation should be evaluated additively */\n    isAdditive = false, \n    /** [0] defines the order in which this animatable should be processed in the list of active animatables (default: 0) */\n    playOrder = 0) {\n        this.target = target;\n        this.fromFrame = fromFrame;\n        this.toFrame = toFrame;\n        this.loopAnimation = loopAnimation;\n        this.onAnimationEnd = onAnimationEnd;\n        this.onAnimationLoop = onAnimationLoop;\n        this.isAdditive = isAdditive;\n        this.playOrder = playOrder;\n        this._localDelayOffset = null;\n        this._pausedDelay = null;\n        this._manualJumpDelay = null;\n        /** @hidden */\n        this._runtimeAnimations = new Array();\n        this._paused = false;\n        this._speedRatio = 1;\n        this._weight = -1.0;\n        this._previousWeight = -1.0;\n        this._syncRoot = null;\n        this._frameToSyncFromJump = null;\n        this._goToFrame = null;\n        /**\n         * Gets or sets a boolean indicating if the animatable must be disposed and removed at the end of the animation.\n         * This will only apply for non looping animation (default is true)\n         */\n        this.disposeOnEnd = true;\n        /**\n         * Gets a boolean indicating if the animation has started\n         */\n        this.animationStarted = false;\n        /**\n         * Observer raised when the animation ends\n         */\n        this.onAnimationEndObservable = new Observable();\n        /**\n         * Observer raised when the animation loops\n         */\n        this.onAnimationLoopObservable = new Observable();\n        this._scene = scene;\n        if (animations) {\n            this.appendAnimations(target, animations);\n        }\n        this._speedRatio = speedRatio;\n        scene._activeAnimatables.push(this);\n    }\n    // Methods\n    /**\n     * Synchronize and normalize current Animatable with a source Animatable\n     * This is useful when using animation weights and when animations are not of the same length\n     * @param root defines the root Animatable to synchronize with (null to stop synchronizing)\n     * @returns the current Animatable\n     */\n    syncWith(root) {\n        this._syncRoot = root;\n        if (root) {\n            // Make sure this animatable will animate after the root\n            const index = this._scene._activeAnimatables.indexOf(this);\n            if (index > -1) {\n                this._scene._activeAnimatables.splice(index, 1);\n                this._scene._activeAnimatables.push(this);\n            }\n        }\n        return this;\n    }\n    /**\n     * Gets the list of runtime animations\n     * @returns an array of RuntimeAnimation\n     */\n    getAnimations() {\n        return this._runtimeAnimations;\n    }\n    /**\n     * Adds more animations to the current animatable\n     * @param target defines the target of the animations\n     * @param animations defines the new animations to add\n     */\n    appendAnimations(target, animations) {\n        for (let index = 0; index < animations.length; index++) {\n            const animation = animations[index];\n            const newRuntimeAnimation = new RuntimeAnimation(target, animation, this._scene, this);\n            newRuntimeAnimation._onLoop = () => {\n                this.onAnimationLoopObservable.notifyObservers(this);\n                if (this.onAnimationLoop) {\n                    this.onAnimationLoop();\n                }\n            };\n            this._runtimeAnimations.push(newRuntimeAnimation);\n        }\n    }\n    /**\n     * Gets the source animation for a specific property\n     * @param property defines the property to look for\n     * @returns null or the source animation for the given property\n     */\n    getAnimationByTargetProperty(property) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            if (runtimeAnimations[index].animation.targetProperty === property) {\n                return runtimeAnimations[index].animation;\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets the runtime animation for a specific property\n     * @param property defines the property to look for\n     * @returns null or the runtime animation for the given property\n     */\n    getRuntimeAnimationByTargetProperty(property) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            if (runtimeAnimations[index].animation.targetProperty === property) {\n                return runtimeAnimations[index];\n            }\n        }\n        return null;\n    }\n    /**\n     * Resets the animatable to its original state\n     */\n    reset() {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].reset(true);\n        }\n        this._localDelayOffset = null;\n        this._pausedDelay = null;\n    }\n    /**\n     * Allows the animatable to blend with current running animations\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     * @param blendingSpeed defines the blending speed to use\n     */\n    enableBlending(blendingSpeed) {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].animation.enableBlending = true;\n            runtimeAnimations[index].animation.blendingSpeed = blendingSpeed;\n        }\n    }\n    /**\n     * Disable animation blending\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-blending\n     */\n    disableBlending() {\n        const runtimeAnimations = this._runtimeAnimations;\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].animation.enableBlending = false;\n        }\n    }\n    /**\n     * Jump directly to a given frame\n     * @param frame defines the frame to jump to\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\n     */\n    goToFrame(frame, useWeight = false) {\n        const runtimeAnimations = this._runtimeAnimations;\n        if (runtimeAnimations[0]) {\n            const fps = runtimeAnimations[0].animation.framePerSecond;\n            this._frameToSyncFromJump = this._frameToSyncFromJump ?? runtimeAnimations[0].currentFrame;\n            const delay = this.speedRatio === 0 ? 0 : (((frame - this._frameToSyncFromJump) / fps) * 1000) / this.speedRatio;\n            this._manualJumpDelay = -delay;\n        }\n        for (let index = 0; index < runtimeAnimations.length; index++) {\n            runtimeAnimations[index].goToFrame(frame, useWeight ? this._weight : -1);\n        }\n        this._goToFrame = frame;\n    }\n    /**\n     * Returns true if the animations for this animatable are paused\n     */\n    get paused() {\n        return this._paused;\n    }\n    /**\n     * Pause the animation\n     */\n    pause() {\n        if (this._paused) {\n            return;\n        }\n        this._paused = true;\n    }\n    /**\n     * Restart the animation\n     */\n    restart() {\n        this._paused = false;\n    }\n    _raiseOnAnimationEnd() {\n        if (this.onAnimationEnd) {\n            this.onAnimationEnd();\n        }\n        this.onAnimationEndObservable.notifyObservers(this);\n    }\n    /**\n     * Stop and delete the current animation\n     * @param animationName defines a string used to only stop some of the runtime animations instead of all\n     * @param targetMask a function that determines if the animation should be stopped based on its target (all animations will be stopped if both this and animationName are empty)\n     * @param useGlobalSplice if true, the animatables will be removed by the caller of this function (false by default)\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\n     */\n    stop(animationName, targetMask, useGlobalSplice = false, skipOnAnimationEnd = false) {\n        if (animationName || targetMask) {\n            const idx = this._scene._activeAnimatables.indexOf(this);\n            if (idx > -1) {\n                const runtimeAnimations = this._runtimeAnimations;\n                for (let index = runtimeAnimations.length - 1; index >= 0; index--) {\n                    const runtimeAnimation = runtimeAnimations[index];\n                    if (animationName && runtimeAnimation.animation.name != animationName) {\n                        continue;\n                    }\n                    if (targetMask && !targetMask(runtimeAnimation.target)) {\n                        continue;\n                    }\n                    runtimeAnimation.dispose();\n                    runtimeAnimations.splice(index, 1);\n                }\n                if (runtimeAnimations.length == 0) {\n                    if (!useGlobalSplice) {\n                        this._scene._activeAnimatables.splice(idx, 1);\n                    }\n                    if (!skipOnAnimationEnd) {\n                        this._raiseOnAnimationEnd();\n                    }\n                }\n            }\n        }\n        else {\n            const index = this._scene._activeAnimatables.indexOf(this);\n            if (index > -1) {\n                if (!useGlobalSplice) {\n                    this._scene._activeAnimatables.splice(index, 1);\n                }\n                const runtimeAnimations = this._runtimeAnimations;\n                for (let index = 0; index < runtimeAnimations.length; index++) {\n                    runtimeAnimations[index].dispose();\n                }\n                this._runtimeAnimations.length = 0;\n                if (!skipOnAnimationEnd) {\n                    this._raiseOnAnimationEnd();\n                }\n            }\n        }\n    }\n    /**\n     * Wait asynchronously for the animation to end\n     * @returns a promise which will be fulfilled when the animation ends\n     */\n    async waitAsync() {\n        return await new Promise((resolve) => {\n            this.onAnimationEndObservable.add(() => {\n                resolve(this);\n            }, undefined, undefined, this, true);\n        });\n    }\n    /**\n     * @internal\n     */\n    _animate(delay) {\n        if (this._paused) {\n            this.animationStarted = false;\n            if (this._pausedDelay === null) {\n                this._pausedDelay = delay;\n            }\n            return true;\n        }\n        if (this._localDelayOffset === null) {\n            this._localDelayOffset = delay;\n            this._pausedDelay = null;\n        }\n        else if (this._pausedDelay !== null) {\n            this._localDelayOffset += delay - this._pausedDelay;\n            this._pausedDelay = null;\n        }\n        if (this._manualJumpDelay !== null) {\n            this._localDelayOffset += this.speedRatio < 0 ? -this._manualJumpDelay : this._manualJumpDelay;\n            this._manualJumpDelay = null;\n            this._frameToSyncFromJump = null;\n        }\n        this._goToFrame = null;\n        if (!Animatable.ProcessPausedAnimatables && this._weight === 0 && this._previousWeight === 0) {\n            // We consider that an animatable with a weight === 0 is \"actively\" paused\n            return true;\n        }\n        this._previousWeight = this._weight;\n        // Animating\n        let running = false;\n        const runtimeAnimations = this._runtimeAnimations;\n        let index;\n        for (index = 0; index < runtimeAnimations.length; index++) {\n            const animation = runtimeAnimations[index];\n            const isRunning = animation.animate(delay - this._localDelayOffset, this.fromFrame, this.toFrame, this.loopAnimation, this._speedRatio, this._weight);\n            running = running || isRunning;\n        }\n        this.animationStarted = running;\n        if (!running) {\n            if (this.disposeOnEnd) {\n                // Remove from active animatables\n                index = this._scene._activeAnimatables.indexOf(this);\n                this._scene._activeAnimatables.splice(index, 1);\n                // Dispose all runtime animations\n                for (index = 0; index < runtimeAnimations.length; index++) {\n                    runtimeAnimations[index].dispose();\n                }\n            }\n            this._raiseOnAnimationEnd();\n            if (this.disposeOnEnd) {\n                this.onAnimationEnd = null;\n                this.onAnimationLoop = null;\n                this.onAnimationLoopObservable.clear();\n                this.onAnimationEndObservable.clear();\n            }\n        }\n        return running;\n    }\n}\n/**\n * If true, the animatable will be processed even if it is considered actively paused (weight of 0 and previous weight of 0).\n * This can be used to force the full processing of paused animatables in the animation engine.\n * Default is false.\n */\nAnimatable.ProcessPausedAnimatables = false;\n/** @internal */\nfunction ProcessLateAnimationBindingsForMatrices(holder) {\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n        return holder.originalValue;\n    }\n    let normalizer = 1.0;\n    const finalPosition = TmpVectors.Vector3[0];\n    const finalScaling = TmpVectors.Vector3[1];\n    const finalQuaternion = TmpVectors.Quaternion[0];\n    let startIndex = 0;\n    const originalAnimation = holder.animations[0];\n    const originalValue = holder.originalValue;\n    let scale = 1;\n    let skipOverride = false;\n    if (holder.totalWeight < 1.0) {\n        // We need to mix the original value in\n        scale = 1.0 - holder.totalWeight;\n        originalValue.decompose(finalScaling, finalQuaternion, finalPosition);\n    }\n    else {\n        startIndex = 1;\n        // We need to normalize the weights\n        normalizer = holder.totalWeight;\n        scale = originalAnimation.weight / normalizer;\n        if (scale == 1) {\n            if (holder.totalAdditiveWeight) {\n                skipOverride = true;\n            }\n            else {\n                return originalAnimation.currentValue;\n            }\n        }\n        originalAnimation.currentValue.decompose(finalScaling, finalQuaternion, finalPosition);\n    }\n    // Add up the override animations\n    if (!skipOverride) {\n        finalScaling.scaleInPlace(scale);\n        finalPosition.scaleInPlace(scale);\n        finalQuaternion.scaleInPlace(scale);\n        for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            if (runtimeAnimation.weight === 0) {\n                continue;\n            }\n            scale = runtimeAnimation.weight / normalizer;\n            const currentPosition = TmpVectors.Vector3[2];\n            const currentScaling = TmpVectors.Vector3[3];\n            const currentQuaternion = TmpVectors.Quaternion[1];\n            runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n            currentScaling.scaleAndAddToRef(scale, finalScaling);\n            currentQuaternion.scaleAndAddToRef(Quaternion.Dot(finalQuaternion, currentQuaternion) > 0 ? scale : -scale, finalQuaternion);\n            currentPosition.scaleAndAddToRef(scale, finalPosition);\n        }\n        finalQuaternion.normalize();\n    }\n    // Add up the additive animations\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\n        if (runtimeAnimation.weight === 0) {\n            continue;\n        }\n        const currentPosition = TmpVectors.Vector3[2];\n        const currentScaling = TmpVectors.Vector3[3];\n        const currentQuaternion = TmpVectors.Quaternion[1];\n        runtimeAnimation.currentValue.decompose(currentScaling, currentQuaternion, currentPosition);\n        currentScaling.multiplyToRef(finalScaling, currentScaling);\n        Vector3.LerpToRef(finalScaling, currentScaling, runtimeAnimation.weight, finalScaling);\n        finalQuaternion.multiplyToRef(currentQuaternion, currentQuaternion);\n        Quaternion.SlerpToRef(finalQuaternion, currentQuaternion, runtimeAnimation.weight, finalQuaternion);\n        currentPosition.scaleAndAddToRef(runtimeAnimation.weight, finalPosition);\n    }\n    const workValue = originalAnimation ? originalAnimation._animationState.workValue : TmpVectors.Matrix[0].clone();\n    Matrix.ComposeToRef(finalScaling, finalQuaternion, finalPosition, workValue);\n    return workValue;\n}\n/** @internal */\nfunction ProcessLateAnimationBindingsForQuaternions(holder, refQuaternion) {\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight === 0) {\n        return refQuaternion;\n    }\n    const originalAnimation = holder.animations[0];\n    const originalValue = holder.originalValue;\n    let cumulativeQuaternion = refQuaternion;\n    if (holder.totalWeight === 0 && holder.totalAdditiveWeight > 0) {\n        cumulativeQuaternion.copyFrom(originalValue);\n    }\n    else if (holder.animations.length === 1) {\n        Quaternion.SlerpToRef(originalValue, originalAnimation.currentValue, Math.min(1.0, holder.totalWeight), cumulativeQuaternion);\n        if (holder.totalAdditiveWeight === 0) {\n            return cumulativeQuaternion;\n        }\n    }\n    else if (holder.animations.length > 1) {\n        // Add up the override animations\n        let normalizer = 1.0;\n        let quaternions;\n        let weights;\n        if (holder.totalWeight < 1.0) {\n            const scale = 1.0 - holder.totalWeight;\n            quaternions = [];\n            weights = [];\n            quaternions.push(originalValue);\n            weights.push(scale);\n        }\n        else {\n            if (holder.animations.length === 2) {\n                // Slerp as soon as we can\n                Quaternion.SlerpToRef(holder.animations[0].currentValue, holder.animations[1].currentValue, holder.animations[1].weight / holder.totalWeight, refQuaternion);\n                if (holder.totalAdditiveWeight === 0) {\n                    return refQuaternion;\n                }\n            }\n            quaternions = [];\n            weights = [];\n            normalizer = holder.totalWeight;\n        }\n        for (let animIndex = 0; animIndex < holder.animations.length; animIndex++) {\n            const runtimeAnimation = holder.animations[animIndex];\n            quaternions.push(runtimeAnimation.currentValue);\n            weights.push(runtimeAnimation.weight / normalizer);\n        }\n        // https://gamedev.stackexchange.com/questions/62354/method-for-interpolation-between-3-quaternions\n        let cumulativeAmount = 0;\n        for (let index = 0; index < quaternions.length;) {\n            if (!index) {\n                Quaternion.SlerpToRef(quaternions[index], quaternions[index + 1], weights[index + 1] / (weights[index] + weights[index + 1]), refQuaternion);\n                cumulativeQuaternion = refQuaternion;\n                cumulativeAmount = weights[index] + weights[index + 1];\n                index += 2;\n                continue;\n            }\n            cumulativeAmount += weights[index];\n            Quaternion.SlerpToRef(cumulativeQuaternion, quaternions[index], weights[index] / cumulativeAmount, cumulativeQuaternion);\n            index++;\n        }\n    }\n    // Add up the additive animations\n    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n        const runtimeAnimation = holder.additiveAnimations[animIndex];\n        if (runtimeAnimation.weight === 0) {\n            continue;\n        }\n        cumulativeQuaternion.multiplyToRef(runtimeAnimation.currentValue, TmpVectors.Quaternion[0]);\n        Quaternion.SlerpToRef(cumulativeQuaternion, TmpVectors.Quaternion[0], runtimeAnimation.weight, cumulativeQuaternion);\n    }\n    return cumulativeQuaternion;\n}\n/** @internal */\nfunction ProcessLateAnimationBindings(scene) {\n    if (!scene._registeredForLateAnimationBindings.length) {\n        return;\n    }\n    for (let index = 0; index < scene._registeredForLateAnimationBindings.length; index++) {\n        const target = scene._registeredForLateAnimationBindings.data[index];\n        for (const path in target._lateAnimationHolders) {\n            const holder = target._lateAnimationHolders[path];\n            const originalAnimation = holder.animations[0];\n            const originalValue = holder.originalValue;\n            if (originalValue === undefined || originalValue === null) {\n                continue;\n            }\n            const matrixDecomposeMode = Animation.AllowMatrixDecomposeForInterpolation && originalValue.m; // ie. data is matrix\n            let finalValue = target[path];\n            if (matrixDecomposeMode) {\n                finalValue = ProcessLateAnimationBindingsForMatrices(holder);\n            }\n            else {\n                const quaternionMode = originalValue.w !== undefined;\n                if (quaternionMode) {\n                    finalValue = ProcessLateAnimationBindingsForQuaternions(holder, finalValue || Quaternion.Identity());\n                }\n                else {\n                    let startIndex = 0;\n                    let normalizer = 1.0;\n                    const originalAnimationIsLoopRelativeFromCurrent = originalAnimation && originalAnimation._animationState.loopMode === Animation.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;\n                    if (holder.totalWeight < 1.0) {\n                        // We need to mix the original value in\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\n                            finalValue = originalValue.clone ? originalValue.clone() : originalValue;\n                        }\n                        else if (originalAnimation && originalValue.scale) {\n                            finalValue = originalValue.scale(1.0 - holder.totalWeight);\n                        }\n                        else if (originalAnimation) {\n                            finalValue = originalValue * (1.0 - holder.totalWeight);\n                        }\n                        else if (originalValue.clone) {\n                            finalValue = originalValue.clone();\n                        }\n                        else {\n                            finalValue = originalValue;\n                        }\n                    }\n                    else if (originalAnimation) {\n                        // We need to normalize the weights\n                        normalizer = holder.totalWeight;\n                        const scale = originalAnimation.weight / normalizer;\n                        if (scale !== 1) {\n                            if (originalAnimation.currentValue.scale) {\n                                finalValue = originalAnimation.currentValue.scale(scale);\n                            }\n                            else {\n                                finalValue = originalAnimation.currentValue * scale;\n                            }\n                        }\n                        else {\n                            finalValue = originalAnimation.currentValue;\n                        }\n                        if (originalAnimationIsLoopRelativeFromCurrent) {\n                            if (finalValue.addToRef) {\n                                finalValue.addToRef(originalValue, finalValue);\n                            }\n                            else {\n                                finalValue += originalValue;\n                            }\n                        }\n                        startIndex = 1;\n                    }\n                    // Add up the override animations\n                    for (let animIndex = startIndex; animIndex < holder.animations.length; animIndex++) {\n                        const runtimeAnimation = holder.animations[animIndex];\n                        const scale = runtimeAnimation.weight / normalizer;\n                        if (!scale) {\n                            continue;\n                        }\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n                        }\n                        else {\n                            finalValue += runtimeAnimation.currentValue * scale;\n                        }\n                    }\n                    // Add up the additive animations\n                    for (let animIndex = 0; animIndex < holder.additiveAnimations.length; animIndex++) {\n                        const runtimeAnimation = holder.additiveAnimations[animIndex];\n                        const scale = runtimeAnimation.weight;\n                        if (!scale) {\n                            continue;\n                        }\n                        else if (runtimeAnimation.currentValue.scaleAndAddToRef) {\n                            runtimeAnimation.currentValue.scaleAndAddToRef(scale, finalValue);\n                        }\n                        else {\n                            finalValue += runtimeAnimation.currentValue * scale;\n                        }\n                    }\n                }\n            }\n            target[path] = finalValue;\n        }\n        target._lateAnimationHolders = {};\n    }\n    scene._registeredForLateAnimationBindings.reset();\n}\n/** @internal */\nexport function RegisterTargetForLateAnimationBinding(scene, runtimeAnimation, originalValue) {\n    const target = runtimeAnimation.target;\n    scene._registeredForLateAnimationBindings.pushNoDuplicate(target);\n    if (!target._lateAnimationHolders) {\n        target._lateAnimationHolders = {};\n    }\n    if (!target._lateAnimationHolders[runtimeAnimation.targetPath]) {\n        target._lateAnimationHolders[runtimeAnimation.targetPath] = {\n            totalWeight: 0,\n            totalAdditiveWeight: 0,\n            animations: [],\n            additiveAnimations: [],\n            originalValue: originalValue,\n        };\n    }\n    if (runtimeAnimation.isAdditive) {\n        target._lateAnimationHolders[runtimeAnimation.targetPath].additiveAnimations.push(runtimeAnimation);\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalAdditiveWeight += runtimeAnimation.weight;\n    }\n    else {\n        target._lateAnimationHolders[runtimeAnimation.targetPath].animations.push(runtimeAnimation);\n        target._lateAnimationHolders[runtimeAnimation.targetPath].totalWeight += runtimeAnimation.weight;\n    }\n}\n/**\n * Initialize all the inter dependecies between the animations and Scene and Bone\n * @param sceneClass defines the scene prototype to use\n * @param boneClass defines the bone prototype to use\n */\nexport function AddAnimationExtensions(sceneClass, boneClass) {\n    if (boneClass) {\n        boneClass.prototype.copyAnimationRange = function (source, rangeName, frameOffset, rescaleAsRequired = false, skelDimensionsRatio = null) {\n            // all animation may be coming from a library skeleton, so may need to create animation\n            if (this.animations.length === 0) {\n                this.animations.push(new Animation(this.name, \"_matrix\", source.animations[0].framePerSecond, Animation.ANIMATIONTYPE_MATRIX, 0));\n                this.animations[0].setKeys([]);\n            }\n            // get animation info / verify there is such a range from the source bone\n            const sourceRange = source.animations[0].getRange(rangeName);\n            if (!sourceRange) {\n                return false;\n            }\n            const from = sourceRange.from;\n            const to = sourceRange.to;\n            const sourceKeys = source.animations[0].getKeys();\n            // rescaling prep\n            const sourceBoneLength = source.length;\n            const sourceParent = source.getParent();\n            const parent = this.getParent();\n            const parentScalingReqd = rescaleAsRequired && sourceParent && sourceBoneLength && this.length && sourceBoneLength !== this.length;\n            const parentRatio = parentScalingReqd && parent && sourceParent ? parent.length / sourceParent.length : 1;\n            const dimensionsScalingReqd = rescaleAsRequired && !parent && skelDimensionsRatio && (skelDimensionsRatio.x !== 1 || skelDimensionsRatio.y !== 1 || skelDimensionsRatio.z !== 1);\n            const destKeys = this.animations[0].getKeys();\n            // loop vars declaration\n            let orig;\n            let origTranslation;\n            let mat;\n            for (let key = 0, nKeys = sourceKeys.length; key < nKeys; key++) {\n                orig = sourceKeys[key];\n                if (orig.frame >= from && orig.frame <= to) {\n                    if (rescaleAsRequired) {\n                        mat = orig.value.clone();\n                        // scale based on parent ratio, when bone has parent\n                        if (parentScalingReqd) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.scaleInPlace(parentRatio));\n                            // scale based on skeleton dimension ratio when root bone, and value is passed\n                        }\n                        else if (dimensionsScalingReqd && skelDimensionsRatio) {\n                            origTranslation = mat.getTranslation();\n                            mat.setTranslation(origTranslation.multiplyInPlace(skelDimensionsRatio));\n                            // use original when root bone, and no data for skelDimensionsRatio\n                        }\n                        else {\n                            mat = orig.value;\n                        }\n                    }\n                    else {\n                        mat = orig.value;\n                    }\n                    destKeys.push({ frame: orig.frame + frameOffset, value: mat });\n                }\n            }\n            this.animations[0].createRange(rangeName, from + frameOffset, to + frameOffset);\n            return true;\n        };\n    }\n    if (!sceneClass) {\n        return;\n    }\n    sceneClass.prototype._animate = function (customDeltaTime) {\n        if (!this.animationsEnabled) {\n            return;\n        }\n        // Getting time\n        const now = PrecisionDate.Now;\n        if (!this._animationTimeLast) {\n            if (this._pendingData.length > 0) {\n                return;\n            }\n            this._animationTimeLast = now;\n        }\n        this.deltaTime = customDeltaTime !== undefined ? customDeltaTime : this.useConstantAnimationDeltaTime ? 16.0 : (now - this._animationTimeLast) * this.animationTimeScale;\n        this._animationTimeLast = now;\n        const animatables = this._activeAnimatables;\n        if (animatables.length === 0) {\n            return;\n        }\n        this._animationTime += this.deltaTime;\n        const animationTime = this._animationTime;\n        for (let index = 0; index < animatables.length; index++) {\n            const animatable = animatables[index];\n            if (!animatable._animate(animationTime) && animatable.disposeOnEnd) {\n                index--; // Array was updated\n            }\n        }\n        // Late animation bindings\n        ProcessLateAnimationBindings(this);\n    };\n    sceneClass.prototype.sortActiveAnimatables = function () {\n        this._activeAnimatables.sort((a, b) => {\n            return a.playOrder - b.playOrder;\n        });\n    };\n    sceneClass.prototype.beginWeightedAnimation = function (target, from, to, weight = 1.0, loop, speedRatio = 1.0, onAnimationEnd, animatable, targetMask, onAnimationLoop, isAdditive = false) {\n        const returnedAnimatable = this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, false, targetMask, onAnimationLoop, isAdditive);\n        returnedAnimatable.weight = weight;\n        return returnedAnimatable;\n    };\n    sceneClass.prototype.beginAnimation = function (target, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n        // get speed speedRatio, to and from, based on the sign and value(s)\n        if (speedRatio < 0) {\n            const tmp = from;\n            from = to;\n            to = tmp;\n            speedRatio = -speedRatio;\n        }\n        // if from > to switch speed ratio\n        if (from > to) {\n            speedRatio = -speedRatio;\n        }\n        if (stopCurrent) {\n            this.stopAnimation(target, undefined, targetMask);\n        }\n        if (!animatable) {\n            animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, undefined, onAnimationLoop, isAdditive);\n        }\n        const shouldRunTargetAnimations = targetMask ? targetMask(target) : true;\n        // Local animations\n        if (target.animations && shouldRunTargetAnimations) {\n            animatable.appendAnimations(target, target.animations);\n        }\n        // Children animations\n        if (target.getAnimatables) {\n            const animatables = target.getAnimatables();\n            for (let index = 0; index < animatables.length; index++) {\n                this.beginAnimation(animatables[index], from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, onAnimationLoop);\n            }\n        }\n        animatable.reset();\n        return animatable;\n    };\n    sceneClass.prototype.beginHierarchyAnimation = function (target, directDescendantsOnly, from, to, loop, speedRatio = 1.0, onAnimationEnd, animatable, stopCurrent = true, targetMask, onAnimationLoop, isAdditive = false) {\n        const children = target.getDescendants(directDescendantsOnly);\n        const result = [];\n        result.push(this.beginAnimation(target, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n        for (const child of children) {\n            result.push(this.beginAnimation(child, from, to, loop, speedRatio, onAnimationEnd, animatable, stopCurrent, targetMask, undefined, isAdditive));\n        }\n        return result;\n    };\n    sceneClass.prototype.beginDirectAnimation = function (target, animations, from, to, loop, speedRatio = 1.0, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n        // get speed speedRatio, to and from, based on the sign and value(s)\n        if (speedRatio < 0) {\n            const tmp = from;\n            from = to;\n            to = tmp;\n            speedRatio = -speedRatio;\n        }\n        // if from > to switch speed ratio\n        if (from > to) {\n            speedRatio = -speedRatio;\n        }\n        const animatable = new Animatable(this, target, from, to, loop, speedRatio, onAnimationEnd, animations, onAnimationLoop, isAdditive);\n        return animatable;\n    };\n    sceneClass.prototype.beginDirectHierarchyAnimation = function (target, directDescendantsOnly, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive = false) {\n        const children = target.getDescendants(directDescendantsOnly);\n        const result = [];\n        result.push(this.beginDirectAnimation(target, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n        for (const child of children) {\n            result.push(this.beginDirectAnimation(child, animations, from, to, loop, speedRatio, onAnimationEnd, onAnimationLoop, isAdditive));\n        }\n        return result;\n    };\n    sceneClass.prototype.getAnimatableByTarget = function (target) {\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\n            if (this._activeAnimatables[index].target === target) {\n                return this._activeAnimatables[index];\n            }\n        }\n        return null;\n    };\n    sceneClass.prototype.getAllAnimatablesByTarget = function (target) {\n        const result = [];\n        for (let index = 0; index < this._activeAnimatables.length; index++) {\n            if (this._activeAnimatables[index].target === target) {\n                result.push(this._activeAnimatables[index]);\n            }\n        }\n        return result;\n    };\n    sceneClass.prototype.stopAnimation = function (target, animationName, targetMask) {\n        const animatables = this.getAllAnimatablesByTarget(target);\n        for (const animatable of animatables) {\n            animatable.stop(animationName, targetMask);\n        }\n    };\n    sceneClass.prototype.stopAllAnimations = function () {\n        if (this._activeAnimatables) {\n            for (let i = 0; i < this._activeAnimatables.length; i++) {\n                this._activeAnimatables[i].stop(undefined, undefined, true);\n            }\n            this._activeAnimatables.length = 0;\n        }\n        for (const group of this.animationGroups) {\n            group.stop();\n        }\n    };\n}\n//# sourceMappingURL=animatable.core.js.map","import { Bone } from \"../Bones/bone\";\nimport { AddAnimationExtensions } from \"./animatable.core\";\nimport { Scene } from \"core/scene\";\nexport * from \"./animatable.core\";\n// Connect everything!\nAddAnimationExtensions(Scene, Bone);\n//# sourceMappingURL=animatable.js.map","import { Animation } from \"./animation\";\nimport { Observable } from \"../Misc/observable\";\nimport { EngineStore } from \"../Engines/engineStore\";\nimport { Tags } from \"../Misc/tags\";\nimport \"./animatable\";\nimport { UniqueIdGenerator } from \"core/Misc/uniqueIdGenerator\";\n/**\n * This class defines the direct association between an animation and a target\n */\nexport class TargetedAnimation {\n    /**\n     * Returns the string \"TargetedAnimation\"\n     * @returns \"TargetedAnimation\"\n     */\n    getClassName() {\n        return \"TargetedAnimation\";\n    }\n    /**\n     * Creates a new targeted animation\n     * @param parent The animation group to which the animation belongs\n     */\n    constructor(parent) {\n        this.parent = parent;\n        /**\n         * Gets or sets the unique id of the targeted animation\n         */\n        this.uniqueId = UniqueIdGenerator.UniqueId;\n    }\n    /**\n     * Serialize the object\n     * @returns the JSON object representing the current entity\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.animation = this.animation.serialize();\n        serializationObject.targetId = this.target.id;\n        serializationObject.targetUniqueId = this.target.uniqueId;\n        return serializationObject;\n    }\n}\n/**\n * Use this class to create coordinated animations on multiple targets\n */\nexport class AnimationGroup {\n    /**\n     * Gets or sets the mask associated with this animation group. This mask is used to filter which objects should be animated.\n     */\n    get mask() {\n        return this._mask;\n    }\n    set mask(value) {\n        if (this._mask === value) {\n            return;\n        }\n        this._mask = value;\n        this.syncWithMask(true);\n    }\n    /**\n     * Makes sure that the animations are either played or stopped according to the animation group mask.\n     * Note however that the call won't have any effect if the animation group has not been started yet.\n     * @param forceUpdate If true, forces to loop over the animatables even if no mask is defined (used internally, you shouldn't need to use it). Default: false.\n     */\n    syncWithMask(forceUpdate = false) {\n        if (!this.mask && !forceUpdate) {\n            this._numActiveAnimatables = this._targetedAnimations.length;\n            return;\n        }\n        this._numActiveAnimatables = 0;\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask || this.mask.disabled || this.mask.retainsTarget(animatable.target.name)) {\n                this._numActiveAnimatables++;\n                if (animatable.paused) {\n                    animatable.restart();\n                }\n            }\n            else {\n                if (!animatable.paused) {\n                    animatable.pause();\n                }\n            }\n        }\n    }\n    /**\n     * Removes all animations for the targets not retained by the animation group mask.\n     * Use this function if you know you won't need those animations anymore and if you want to free memory.\n     */\n    removeUnmaskedAnimations() {\n        if (!this.mask || this.mask.disabled) {\n            return;\n        }\n        // Removes all animatables (in case the animation group has already been started)\n        for (let i = 0; i < this._animatables.length; ++i) {\n            const animatable = this._animatables[i];\n            if (!this.mask.retainsTarget(animatable.target.name)) {\n                animatable.stop();\n                this._animatables.splice(i, 1);\n                --i;\n            }\n        }\n        // Removes the targeted animations\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (!this.mask.retainsTarget(targetedAnimation.target.name)) {\n                this._targetedAnimations.splice(index, 1);\n                --index;\n            }\n        }\n    }\n    /**\n     * Gets or sets the first frame\n     */\n    get from() {\n        return this._from;\n    }\n    set from(value) {\n        if (this._from === value) {\n            return;\n        }\n        this._from = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.fromFrame = this._from;\n        }\n    }\n    /**\n     * Gets or sets the last frame\n     */\n    get to() {\n        return this._to;\n    }\n    set to(value) {\n        if (this._to === value) {\n            return;\n        }\n        this._to = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.toFrame = this._to;\n        }\n    }\n    /**\n     * Define if the animations are started\n     */\n    get isStarted() {\n        return this._isStarted;\n    }\n    /**\n     * Gets a value indicating that the current group is playing\n     */\n    get isPlaying() {\n        return this._isStarted && !this._isPaused;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    get speedRatio() {\n        return this._speedRatio;\n    }\n    /**\n     * Gets or sets the speed ratio to use for all animations\n     */\n    set speedRatio(value) {\n        if (this._speedRatio === value) {\n            return;\n        }\n        this._speedRatio = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.speedRatio = this._speedRatio;\n        }\n    }\n    /**\n     * Gets or sets if all animations should loop or not\n     */\n    get loopAnimation() {\n        return this._loopAnimation;\n    }\n    set loopAnimation(value) {\n        if (this._loopAnimation === value) {\n            return;\n        }\n        this._loopAnimation = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.loopAnimation = this._loopAnimation;\n        }\n    }\n    /**\n     * Gets or sets if all animations should be evaluated additively\n     */\n    get isAdditive() {\n        return this._isAdditive;\n    }\n    set isAdditive(value) {\n        if (this._isAdditive === value) {\n            return;\n        }\n        this._isAdditive = value;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.isAdditive = this._isAdditive;\n        }\n    }\n    /**\n     * Gets or sets the weight to apply to all animations of the group\n     */\n    get weight() {\n        return this._weight;\n    }\n    set weight(value) {\n        if (this._weight === value) {\n            return;\n        }\n        this._weight = value;\n        this.setWeightForAllAnimatables(this._weight);\n    }\n    /**\n     * Gets the targeted animations for this animation group\n     */\n    get targetedAnimations() {\n        return this._targetedAnimations;\n    }\n    /**\n     * returning the list of animatables controlled by this animation group.\n     */\n    get animatables() {\n        return this._animatables;\n    }\n    /**\n     * Gets the list of target animations\n     */\n    get children() {\n        return this._targetedAnimations;\n    }\n    /**\n     * Gets or sets the order of play of the animation group (default: 0)\n     */\n    get playOrder() {\n        return this._playOrder;\n    }\n    set playOrder(value) {\n        if (this._playOrder === value) {\n            return;\n        }\n        this._playOrder = value;\n        if (this._animatables.length > 0) {\n            for (let i = 0; i < this._animatables.length; i++) {\n                this._animatables[i].playOrder = this._playOrder;\n            }\n            this._scene.sortActiveAnimatables();\n        }\n    }\n    /**\n     * Allows the animations of the animation group to blend with current running animations\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.enableBlending)\n     */\n    get enableBlending() {\n        return this._enableBlending;\n    }\n    set enableBlending(value) {\n        if (this._enableBlending === value) {\n            return;\n        }\n        this._enableBlending = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.enableBlending = value;\n            }\n        }\n    }\n    /**\n     * Gets or sets the animation blending speed\n     * Note that a null value means that each animation will use their own existing blending configuration (Animation.blendingSpeed)\n     */\n    get blendingSpeed() {\n        return this._blendingSpeed;\n    }\n    set blendingSpeed(value) {\n        if (this._blendingSpeed === value) {\n            return;\n        }\n        this._blendingSpeed = value;\n        if (value !== null) {\n            for (let i = 0; i < this._targetedAnimations.length; ++i) {\n                this._targetedAnimations[i].animation.blendingSpeed = value;\n            }\n        }\n    }\n    /**\n     * Gets the length (in seconds) of the animation group\n     * This function assumes that all animations are played at the same framePerSecond speed!\n     * Note: you can only call this method after you've added at least one targeted animation!\n     * @param from Starting frame range (default is AnimationGroup.from)\n     * @param to Ending frame range (default is AnimationGroup.to)\n     * @returns The length in seconds\n     */\n    getLength(from, to) {\n        from = from ?? this._from;\n        to = to ?? this._to;\n        const fps = this.targetedAnimations[0].animation.framePerSecond * this._speedRatio;\n        return (to - from) / fps;\n    }\n    /**\n     * Merge the array of animation groups into a new animation group\n     * @param animationGroups List of animation groups to merge\n     * @param disposeSource If true, animation groups will be disposed after being merged (default: true)\n     * @param normalize If true, animation groups will be normalized before being merged, so that all animations have the same \"from\" and \"to\" frame (default: false)\n     * @param weight Weight for the new animation group. If not provided, it will inherit the weight from the first animation group of the array\n     * @returns The new animation group or null if no animation groups were passed\n     */\n    static MergeAnimationGroups(animationGroups, disposeSource = true, normalize = false, weight) {\n        if (animationGroups.length === 0) {\n            return null;\n        }\n        weight = weight ?? animationGroups[0].weight;\n        let beginFrame = Number.MAX_VALUE;\n        let endFrame = -Number.MAX_VALUE;\n        if (normalize) {\n            for (const animationGroup of animationGroups) {\n                if (animationGroup.from < beginFrame) {\n                    beginFrame = animationGroup.from;\n                }\n                if (animationGroup.to > endFrame) {\n                    endFrame = animationGroup.to;\n                }\n            }\n        }\n        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + \"_merged\", animationGroups[0]._scene, weight);\n        for (const animationGroup of animationGroups) {\n            if (normalize) {\n                animationGroup.normalize(beginFrame, endFrame);\n            }\n            for (const targetedAnimation of animationGroup.targetedAnimations) {\n                mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);\n            }\n            if (disposeSource) {\n                animationGroup.dispose();\n            }\n        }\n        return mergedAnimationGroup;\n    }\n    /**\n     * Gets the scene the animation group belongs to\n     * @returns The scene the animation group belongs to\n     */\n    getScene() {\n        return this._scene;\n    }\n    /**\n     * Instantiates a new Animation Group.\n     * This helps managing several animations at once.\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/groupAnimations\n     * @param name Defines the name of the group\n     * @param scene Defines the scene the group belongs to\n     * @param weight Defines the weight to use for animations in the group (-1.0 by default, meaning \"no weight\")\n     * @param playOrder Defines the order of play of the animation group (default is 0)\n     */\n    constructor(\n    /** The name of the animation group */\n    name, scene = null, weight = -1, playOrder = 0) {\n        this.name = name;\n        this._targetedAnimations = new Array();\n        this._animatables = new Array();\n        this._from = Number.MAX_VALUE;\n        this._to = -Number.MAX_VALUE;\n        this._speedRatio = 1;\n        this._loopAnimation = false;\n        this._isAdditive = false;\n        this._weight = -1;\n        this._playOrder = 0;\n        this._enableBlending = null;\n        this._blendingSpeed = null;\n        this._numActiveAnimatables = 0;\n        this._shouldStart = true;\n        /** @internal */\n        this._parentContainer = null;\n        /**\n         * This observable will notify when one animation have ended\n         */\n        this.onAnimationEndObservable = new Observable();\n        /**\n         * Observer raised when one animation loops\n         */\n        this.onAnimationLoopObservable = new Observable();\n        /**\n         * Observer raised when all animations have looped\n         */\n        this.onAnimationGroupLoopObservable = new Observable();\n        /**\n         * This observable will notify when all animations have ended.\n         */\n        this.onAnimationGroupEndObservable = new Observable();\n        /**\n         * This observable will notify when all animations have paused.\n         */\n        this.onAnimationGroupPauseObservable = new Observable();\n        /**\n         * This observable will notify when all animations are playing.\n         */\n        this.onAnimationGroupPlayObservable = new Observable();\n        /**\n         * Gets or sets an object used to store user defined information for the node\n         */\n        this.metadata = null;\n        this._mask = null;\n        this._animationLoopFlags = [];\n        this._scene = scene || EngineStore.LastCreatedScene;\n        this._weight = weight;\n        this._playOrder = playOrder;\n        this.uniqueId = this._scene.getUniqueId();\n        this._scene.addAnimationGroup(this);\n    }\n    /**\n     * Add an animation (with its target) in the group\n     * @param animation defines the animation we want to add\n     * @param target defines the target of the animation\n     * @returns the TargetedAnimation object\n     */\n    addTargetedAnimation(animation, target) {\n        const targetedAnimation = new TargetedAnimation(this);\n        targetedAnimation.animation = animation;\n        targetedAnimation.target = target;\n        const keys = animation.getKeys();\n        if (this._from > keys[0].frame) {\n            this._from = keys[0].frame;\n        }\n        if (this._to < keys[keys.length - 1].frame) {\n            this._to = keys[keys.length - 1].frame;\n        }\n        if (this._enableBlending !== null) {\n            animation.enableBlending = this._enableBlending;\n        }\n        if (this._blendingSpeed !== null) {\n            animation.blendingSpeed = this._blendingSpeed;\n        }\n        this._targetedAnimations.push(targetedAnimation);\n        this._shouldStart = true;\n        return targetedAnimation;\n    }\n    /**\n     * Remove an animation from the group\n     * @param animation defines the animation we want to remove\n     */\n    removeTargetedAnimation(animation) {\n        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {\n            const targetedAnimation = this._targetedAnimations[index];\n            if (targetedAnimation.animation === animation) {\n                this._targetedAnimations.splice(index, 1);\n            }\n        }\n    }\n    /**\n     * This function will normalize every animation in the group to make sure they all go from beginFrame to endFrame\n     * It can add constant keys at begin or end\n     * @param beginFrame defines the new begin frame for all animations or the smallest begin frame of all animations if null (defaults to null)\n     * @param endFrame defines the new end frame for all animations or the largest end frame of all animations if null (defaults to null)\n     * @returns the animation group\n     */\n    normalize(beginFrame = null, endFrame = null) {\n        if (beginFrame == null) {\n            beginFrame = this._from;\n        }\n        if (endFrame == null) {\n            endFrame = this._to;\n        }\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const keys = targetedAnimation.animation.getKeys();\n            const startKey = keys[0];\n            const endKey = keys[keys.length - 1];\n            if (startKey.frame > beginFrame) {\n                const newKey = {\n                    frame: beginFrame,\n                    value: startKey.value,\n                    inTangent: startKey.inTangent,\n                    outTangent: startKey.outTangent,\n                    interpolation: startKey.interpolation,\n                };\n                keys.splice(0, 0, newKey);\n            }\n            if (endKey.frame < endFrame) {\n                const newKey = {\n                    frame: endFrame,\n                    value: endKey.value,\n                    inTangent: endKey.inTangent,\n                    outTangent: endKey.outTangent,\n                    interpolation: endKey.interpolation,\n                };\n                keys.push(newKey);\n            }\n        }\n        this._from = beginFrame;\n        this._to = endFrame;\n        return this;\n    }\n    _processLoop(animatable, targetedAnimation, index) {\n        animatable.onAnimationLoop = () => {\n            this.onAnimationLoopObservable.notifyObservers(targetedAnimation);\n            if (this._animationLoopFlags[index]) {\n                return;\n            }\n            this._animationLoopFlags[index] = true;\n            this._animationLoopCount++;\n            if (this._animationLoopCount === this._numActiveAnimatables) {\n                this.onAnimationGroupLoopObservable.notifyObservers(this);\n                this._animationLoopCount = 0;\n                this._animationLoopFlags.length = 0;\n            }\n        };\n    }\n    /**\n     * Start all animations on given targets\n     * @param loop defines if animations must loop\n     * @param speedRatio defines the ratio to apply to animation speed (1 by default)\n     * @param from defines the from key (optional)\n     * @param to defines the to key (optional)\n     * @param isAdditive defines the additive state for the resulting animatables (optional)\n     * @returns the current animation group\n     */\n    start(loop = false, speedRatio = 1, from, to, isAdditive) {\n        if (this._isStarted || this._targetedAnimations.length === 0) {\n            return this;\n        }\n        this._loopAnimation = loop;\n        this._shouldStart = false;\n        this._animationLoopCount = 0;\n        this._animationLoopFlags.length = 0;\n        for (let index = 0; index < this._targetedAnimations.length; index++) {\n            const targetedAnimation = this._targetedAnimations[index];\n            const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== undefined ? from : this._from, to !== undefined ? to : this._to, loop, speedRatio, undefined, undefined, isAdditive !== undefined ? isAdditive : this._isAdditive);\n            animatable.weight = this._weight;\n            animatable.playOrder = this._playOrder;\n            animatable.onAnimationEnd = () => {\n                this.onAnimationEndObservable.notifyObservers(targetedAnimation);\n                this._checkAnimationGroupEnded(animatable);\n            };\n            this._processLoop(animatable, targetedAnimation, index);\n            this._animatables.push(animatable);\n        }\n        this.syncWithMask();\n        this._scene.sortActiveAnimatables();\n        this._speedRatio = speedRatio;\n        this._isStarted = true;\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Pause all animations\n     * @returns the animation group\n     */\n    pause() {\n        if (!this._isStarted) {\n            return this;\n        }\n        this._isPaused = true;\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.pause();\n        }\n        this.onAnimationGroupPauseObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Play all animations to initial state\n     * This function will start() the animations if they were not started or will restart() them if they were paused\n     * @param loop defines if animations must loop\n     * @returns the animation group\n     */\n    play(loop) {\n        // only if there are animatable available\n        if (this.isStarted && this._animatables.length && !this._shouldStart) {\n            if (loop !== undefined) {\n                this.loopAnimation = loop;\n            }\n            this.restart();\n        }\n        else {\n            this.stop();\n            this.start(loop, this._speedRatio);\n        }\n        return this;\n    }\n    /**\n     * Reset all animations to initial state\n     * @returns the animation group\n     */\n    reset() {\n        if (!this._isStarted) {\n            this.play();\n            this.goToFrame(0);\n            this.stop(true);\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.reset();\n        }\n        return this;\n    }\n    /**\n     * Restart animations from after pausing it\n     * @returns the animation group\n     */\n    restart() {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.restart();\n        }\n        this.syncWithMask();\n        this._isPaused = false;\n        this.onAnimationGroupPlayObservable.notifyObservers(this);\n        return this;\n    }\n    /**\n     * Stop all animations\n     * @param skipOnAnimationEnd defines if the system should not raise onAnimationEnd. Default is false\n     * @returns the animation group\n     */\n    stop(skipOnAnimationEnd = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        const list = this._animatables.slice();\n        for (let index = 0; index < list.length; index++) {\n            list[index].stop(undefined, undefined, true, skipOnAnimationEnd);\n        }\n        // We will take care of removing all stopped animatables\n        let curIndex = 0;\n        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {\n            const animatable = this._scene._activeAnimatables[index];\n            if (animatable._runtimeAnimations.length > 0) {\n                this._scene._activeAnimatables[curIndex++] = animatable;\n            }\n            else if (skipOnAnimationEnd) {\n                // We normally rely on the onAnimationEnd callback (assigned in the start function) to be notified when an animatable\n                // ends and should be removed from the active animatables array. However, if the animatable is stopped with the skipOnAnimationEnd\n                // flag set to true, then we need to explicitly remove it from the active animatables array.\n                this._checkAnimationGroupEnded(animatable, skipOnAnimationEnd);\n            }\n        }\n        this._scene._activeAnimatables.length = curIndex;\n        this._isStarted = false;\n        return this;\n    }\n    /**\n     * Set animation weight for all animatables\n     *\n     * @since 6.12.4\n     *  You can pass the weight to the AnimationGroup constructor, or use the weight property to set it after the group has been created,\n     *  making it easier to define the overall animation weight than calling setWeightForAllAnimatables() after the animation group has been started\n     * @param weight defines the weight to use\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    setWeightForAllAnimatables(weight) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.weight = weight;\n        }\n        return this;\n    }\n    /**\n     * Synchronize and normalize all animatables with a source animatable\n     * @param root defines the root animatable to synchronize with (null to stop synchronizing)\n     * @returns the animationGroup\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/animation/advanced_animations#animation-weights\n     */\n    syncAllAnimationsWith(root) {\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.syncWith(root);\n        }\n        return this;\n    }\n    /**\n     * Goes to a specific frame in this animation group. Note that the animation group must be in playing or paused status\n     * @param frame the frame number to go to\n     * @param useWeight defines whether the animation weight should be applied to the image to be jumped to (false by default)\n     * @returns the animationGroup\n     */\n    goToFrame(frame, useWeight = false) {\n        if (!this._isStarted) {\n            return this;\n        }\n        for (let index = 0; index < this._animatables.length; index++) {\n            const animatable = this._animatables[index];\n            animatable.goToFrame(frame, useWeight);\n        }\n        return this;\n    }\n    /**\n     * Helper to get the current frame. This will return 0 if the AnimationGroup is not running, and it might return wrong results if multiple animations are running in different frames.\n     * @returns current animation frame.\n     */\n    getCurrentFrame() {\n        return this.animatables[0]?.masterFrame || 0;\n    }\n    /**\n     * Dispose all associated resources\n     */\n    dispose() {\n        if (this.isStarted) {\n            this.stop();\n        }\n        this._targetedAnimations.length = 0;\n        this._animatables.length = 0;\n        // Remove from scene\n        this._scene.removeAnimationGroup(this);\n        if (this._parentContainer) {\n            const index = this._parentContainer.animationGroups.indexOf(this);\n            if (index > -1) {\n                this._parentContainer.animationGroups.splice(index, 1);\n            }\n            this._parentContainer = null;\n        }\n        this.onAnimationEndObservable.clear();\n        this.onAnimationGroupEndObservable.clear();\n        this.onAnimationGroupPauseObservable.clear();\n        this.onAnimationGroupPlayObservable.clear();\n        this.onAnimationLoopObservable.clear();\n        this.onAnimationGroupLoopObservable.clear();\n    }\n    _checkAnimationGroupEnded(animatable, skipOnAnimationEnd = false) {\n        // animatable should be taken out of the array\n        const idx = this._animatables.indexOf(animatable);\n        if (idx > -1) {\n            this._animatables.splice(idx, 1);\n        }\n        // all animatables were removed? animation group ended!\n        if (this._animatables.length === this._targetedAnimations.length - this._numActiveAnimatables) {\n            this._isStarted = false;\n            if (!skipOnAnimationEnd) {\n                this.onAnimationGroupEndObservable.notifyObservers(this);\n            }\n            this._animatables.length = 0;\n        }\n    }\n    /**\n     * Clone the current animation group and returns a copy\n     * @param newName defines the name of the new group\n     * @param targetConverter defines an optional function used to convert current animation targets to new ones\n     * @param cloneAnimations defines if the animations should be cloned or referenced\n     * @param cloneAnimationKeys defines if the animation keys should be cloned when cloning animations (false by default). No effect if cloneAnimations is false\n     * @returns the new animation group\n     */\n    clone(newName, targetConverter, cloneAnimations = false, cloneAnimationKeys = false) {\n        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);\n        newGroup._from = this.from;\n        newGroup._to = this.to;\n        newGroup._speedRatio = this.speedRatio;\n        newGroup._loopAnimation = this.loopAnimation;\n        newGroup._isAdditive = this.isAdditive;\n        newGroup._enableBlending = this.enableBlending;\n        newGroup._blendingSpeed = this.blendingSpeed;\n        newGroup.metadata = this.metadata;\n        newGroup.mask = this.mask;\n        for (const targetAnimation of this._targetedAnimations) {\n            newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone(cloneAnimationKeys) : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);\n        }\n        return newGroup;\n    }\n    /**\n     * Serializes the animationGroup to an object\n     * @returns Serialized object\n     */\n    serialize() {\n        const serializationObject = {};\n        serializationObject.name = this.name;\n        serializationObject.from = this.from;\n        serializationObject.to = this.to;\n        serializationObject.speedRatio = this.speedRatio;\n        serializationObject.loopAnimation = this.loopAnimation;\n        serializationObject.isAdditive = this.isAdditive;\n        serializationObject.weight = this.weight;\n        serializationObject.playOrder = this.playOrder;\n        serializationObject.enableBlending = this.enableBlending;\n        serializationObject.blendingSpeed = this.blendingSpeed;\n        serializationObject.targetedAnimations = [];\n        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {\n            const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];\n            serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();\n        }\n        if (Tags && Tags.HasTags(this)) {\n            serializationObject.tags = Tags.GetTags(this);\n        }\n        // Metadata\n        if (this.metadata) {\n            serializationObject.metadata = this.metadata;\n        }\n        return serializationObject;\n    }\n    // Statics\n    /**\n     * Returns a new AnimationGroup object parsed from the source provided.\n     * @param parsedAnimationGroup defines the source\n     * @param scene defines the scene that will receive the animationGroup\n     * @param targetLookup a callback that will be used instead of the default lookup\n     * @returns a new AnimationGroup\n     */\n    static Parse(parsedAnimationGroup, scene, targetLookup) {\n        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);\n        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {\n            const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];\n            const animation = Animation.Parse(targetedAnimation.animation);\n            const target = targetLookup\n                ? targetLookup(targetedAnimation)\n                : targetedAnimation.animation.property === \"influence\"\n                    ? scene.getMorphTargetById(targetedAnimation.targetId)\n                    : scene.getNodeById(targetedAnimation.targetId);\n            if (target) {\n                animationGroup.addTargetedAnimation(animation, target);\n            }\n        }\n        if (Tags) {\n            Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);\n        }\n        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {\n            animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);\n        }\n        if (parsedAnimationGroup.speedRatio !== undefined) {\n            animationGroup._speedRatio = parsedAnimationGroup.speedRatio;\n        }\n        if (parsedAnimationGroup.loopAnimation !== undefined) {\n            animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;\n        }\n        if (parsedAnimationGroup.isAdditive !== undefined) {\n            animationGroup._isAdditive = parsedAnimationGroup.isAdditive;\n        }\n        if (parsedAnimationGroup.weight !== undefined) {\n            animationGroup._weight = parsedAnimationGroup.weight;\n        }\n        if (parsedAnimationGroup.playOrder !== undefined) {\n            animationGroup._playOrder = parsedAnimationGroup.playOrder;\n        }\n        if (parsedAnimationGroup.enableBlending !== undefined) {\n            animationGroup._enableBlending = parsedAnimationGroup.enableBlending;\n        }\n        if (parsedAnimationGroup.blendingSpeed !== undefined) {\n            animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;\n        }\n        if (parsedAnimationGroup.metadata !== undefined) {\n            animationGroup.metadata = parsedAnimationGroup.metadata;\n        }\n        return animationGroup;\n    }\n    /** @internal */\n    static MakeAnimationAdditive(sourceAnimationGroup, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {\n        let options;\n        if (typeof referenceFrameOrOptions === \"object\") {\n            options = referenceFrameOrOptions;\n        }\n        else {\n            options = {\n                referenceFrame: referenceFrameOrOptions,\n                range: range,\n                cloneOriginalAnimationGroup: cloneOriginal,\n                clonedAnimationName: clonedName,\n            };\n        }\n        let animationGroup = sourceAnimationGroup;\n        if (options.cloneOriginalAnimationGroup) {\n            animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);\n        }\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);\n        }\n        animationGroup.isAdditive = true;\n        if (options.clipKeys) {\n            // We need to recalculate the from/to frames for the animation group because some keys may have been removed\n            let from = Number.MAX_VALUE;\n            let to = -Number.MAX_VALUE;\n            const targetedAnimations = animationGroup.targetedAnimations;\n            for (let index = 0; index < targetedAnimations.length; index++) {\n                const targetedAnimation = targetedAnimations[index];\n                const animation = targetedAnimation.animation;\n                const keys = animation.getKeys();\n                if (from > keys[0].frame) {\n                    from = keys[0].frame;\n                }\n                if (to < keys[keys.length - 1].frame) {\n                    to = keys[keys.length - 1].frame;\n                }\n            }\n            animationGroup._from = from;\n            animationGroup._to = to;\n        }\n        return animationGroup;\n    }\n    /**\n     * Creates a new animation, keeping only the keys that are inside a given key range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the keys outside the given range\n     */\n    static ClipKeys(sourceAnimationGroup, fromKey, toKey, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromKey defines the lower bound of the range\n     * @param toKey defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);\n    }\n    /**\n     * Creates a new animation, keeping only the frames that are inside a given frame range\n     * @param sourceAnimationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param name defines the name of the new animation group. If not provided, use the same name as animationGroup\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns a new animation group stripped from all the frames outside the given range\n     */\n    static ClipFrames(sourceAnimationGroup, fromFrame, toFrame, name, dontCloneAnimations) {\n        const animationGroup = sourceAnimationGroup.clone(name || sourceAnimationGroup.name);\n        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);\n    }\n    /**\n     * Updates an existing animation, keeping only the frames that are inside a given frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param fromFrame defines the lower bound of the range\n     * @param toFrame defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the frames. Default is false, so animations will be cloned\n     * @returns the animationGroup stripped from all the frames outside the given range\n     */\n    static ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations) {\n        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);\n    }\n    /**\n     * Updates an existing animation, keeping only the keys that are inside a given key or frame range\n     * @param animationGroup defines the animation group on which to operate\n     * @param start defines the lower bound of the range\n     * @param end defines the upper bound of the range\n     * @param dontCloneAnimations defines whether or not the animations should be cloned before clipping the keys. Default is false, so animations will be cloned\n     * @param useFrame defines if the range is defined by frame numbers or key indices (default is false which means use key indices)\n     * @returns the animationGroup stripped from all the keys outside the given range\n     */\n    static ClipInPlace(animationGroup, start, end, dontCloneAnimations, useFrame = false) {\n        let from = Number.MAX_VALUE;\n        let to = -Number.MAX_VALUE;\n        const targetedAnimations = animationGroup.targetedAnimations;\n        for (let index = 0; index < targetedAnimations.length; index++) {\n            const targetedAnimation = targetedAnimations[index];\n            const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();\n            if (useFrame) {\n                // Make sure we have keys corresponding to the bounds of the frame range\n                animation.createKeyForFrame(start);\n                animation.createKeyForFrame(end);\n            }\n            const keys = animation.getKeys();\n            const newKeys = [];\n            let startFrame = Number.MAX_VALUE;\n            for (let k = 0; k < keys.length; k++) {\n                const key = keys[k];\n                if ((!useFrame && k >= start && k <= end) || (useFrame && key.frame >= start && key.frame <= end)) {\n                    const newKey = {\n                        frame: key.frame,\n                        value: key.value.clone ? key.value.clone() : key.value,\n                        inTangent: key.inTangent,\n                        outTangent: key.outTangent,\n                        interpolation: key.interpolation,\n                        lockedTangent: key.lockedTangent,\n                    };\n                    if (startFrame === Number.MAX_VALUE) {\n                        startFrame = newKey.frame;\n                    }\n                    newKey.frame -= startFrame;\n                    newKeys.push(newKey);\n                }\n            }\n            if (newKeys.length === 0) {\n                targetedAnimations.splice(index, 1);\n                index--;\n                continue;\n            }\n            if (from > newKeys[0].frame) {\n                from = newKeys[0].frame;\n            }\n            if (to < newKeys[newKeys.length - 1].frame) {\n                to = newKeys[newKeys.length - 1].frame;\n            }\n            animation.setKeys(newKeys, true);\n            targetedAnimation.animation = animation; // in case the animation has been cloned\n        }\n        animationGroup._from = from;\n        animationGroup._to = to;\n        return animationGroup;\n    }\n    /**\n     * Returns the string \"AnimationGroup\"\n     * @returns \"AnimationGroup\"\n     */\n    getClassName() {\n        return \"AnimationGroup\";\n    }\n    /**\n     * Creates a detailed string about the object\n     * @param fullDetails defines if the output string will support multiple levels of logging within scene loading\n     * @returns a string representing the object\n     */\n    toString(fullDetails) {\n        let ret = \"Name: \" + this.name;\n        ret += \", type: \" + this.getClassName();\n        if (fullDetails) {\n            ret += \", from: \" + this._from;\n            ret += \", to: \" + this._to;\n            ret += \", isStarted: \" + this._isStarted;\n            ret += \", speedRatio: \" + this._speedRatio;\n            ret += \", targetedAnimations length: \" + this._targetedAnimations.length;\n            ret += \", animatables length: \" + this._animatables;\n        }\n        return ret;\n    }\n}\n//# sourceMappingURL=animationGroup.js.map"],"names":["RuntimeAnimation","currentFrame","this","_currentFrame","weight","_weight","currentValue","_currentValue","targetPath","_targetPath","target","_currentActiveTarget","isAdditive","_host","constructor","animation","scene","host","_events","Array","_originalValue","_originalBlendValue","_offsetsCache","_highLimitsCache","_stopped","_blendingFactor","_directTarget","_absoluteFrameOffset","_previousElapsedTime","_yoyoDirection","_previousAbsoluteFrame","_targetIsArray","_coreRuntimeAnimation","_animation","_target","_scene","_activeTargets","_runtimeAnimations","push","_animationState","key","repeatCount","loopMode","_getCorrectLoopMode","dataType","Animation","ANIMATIONTYPE_MATRIX","workValue","Matrix","Zero","_keys","getKeys","_minFrame","frame","_maxFrame","length","newKey","value","splice","index","_preparePath","_getOriginalValues","events","getEvents","e","_clone","_enableBlending","animationPropertiesOverride","enableBlending","targetIndex","targetPropertyPath","property","name","undefined","Error","join","reset","restoreOriginal","_setValue","isDone","isStopped","dispose","runtimeAnimations","indexOf","setValue","originalValue","getLocalMatrix","clone","_registerTargetForLateAnimationBinding","runtimeAnimation","_registeredForLateAnimationBindings","pushNoDuplicate","_lateAnimationHolders","totalWeight","totalAdditiveWeight","animations","additiveAnimations","destination","m","AllowMatrixDecomposeForInterpolation","DecomposeLerpToRef","DecomposeLerp","LerpToRef","Lerp","_UniversalLerp","blendingSpeed","copyFrom","ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT","addToRef","markAsDirty","targetProperty","goToFrame","keys","onlyOnce","_interpolate","_prepareForSpeedRatioChange","newSpeedRatio","newAbsoluteFrame","framePerSecond","animate","elapsedTimeSinceAnimationStart","from","to","loop","speedRatio","returnValue","frameRange","highLimitValue","offsetValue","absoluteFrame","yoyoLoop","yoyoMode","ANIMATIONLOOPMODE_YOYO","position","sin","Math","PI","abs","direction","evaluate","ANIMATIONLOOPMODE_CYCLE","keyOffset","toString","fromValue","toValue","ANIMATIONTYPE_FLOAT","ANIMATIONTYPE_QUATERNION","ANIMATIONTYPE_VECTOR3","ANIMATIONTYPE_VECTOR2","ANIMATIONTYPE_SIZE","ANIMATIONTYPE_COLOR3","subtract","_StaticOffsetValueQuaternion","_StaticOffsetValueVector3","_StaticOffsetValueVector2","_StaticOffsetValueSize","_StaticOffsetValueColor3","ANIMATIONTYPE_COLOR4","_StaticOffsetValueColor4","syncRoot","masterFrame","fromFrame","toFrame","_onLoop","event","action","Animatable","_syncRoot","min","max","_speedRatio","_goToFrame","elapsedTime","_localDelayOffset","_animationTime","loopAnimation","onAnimationEnd","onAnimationLoop","playOrder","_pausedDelay","_manualJumpDelay","_paused","_previousWeight","_frameToSyncFromJump","disposeOnEnd","animationStarted","onAnimationEndObservable","Observable","onAnimationLoopObservable","appendAnimations","_activeAnimatables","syncWith","root","getAnimations","newRuntimeAnimation","notifyObservers","getAnimationByTargetProperty","getRuntimeAnimationByTargetProperty","disableBlending","useWeight","fps","delay","paused","pause","restart","_raiseOnAnimationEnd","stop","animationName","targetMask","useGlobalSplice","skipOnAnimationEnd","idx","waitAsync","Promise","resolve","add","_animate","ProcessPausedAnimatables","running","isRunning","clear","ProcessLateAnimationBindingsForMatrices","holder","normalizer","finalPosition","TmpVectors","Vector3","finalScaling","finalQuaternion","Quaternion","startIndex","originalAnimation","scale","skipOverride","decompose","scaleInPlace","animIndex","currentPosition","currentScaling","currentQuaternion","scaleAndAddToRef","Dot","normalize","multiplyToRef","SlerpToRef","ComposeToRef","ProcessLateAnimationBindingsForQuaternions","refQuaternion","cumulativeQuaternion","quaternions","weights","cumulativeAmount","sceneClass","boneClass","Scene","Bone","prototype","copyAnimationRange","source","rangeName","frameOffset","rescaleAsRequired","skelDimensionsRatio","setKeys","sourceRange","getRange","sourceKeys","sourceBoneLength","sourceParent","getParent","parent","parentScalingReqd","parentRatio","dimensionsScalingReqd","x","y","z","destKeys","orig","origTranslation","mat","nKeys","getTranslation","setTranslation","multiplyInPlace","createRange","customDeltaTime","animationsEnabled","now","PrecisionDate","Now","_animationTimeLast","_pendingData","deltaTime","useConstantAnimationDeltaTime","animationTimeScale","animatables","animationTime","animatable","data","path","matrixDecomposeMode","finalValue","w","Identity","originalAnimationIsLoopRelativeFromCurrent","ProcessLateAnimationBindings","sortActiveAnimatables","sort","a","b","beginWeightedAnimation","returnedAnimatable","beginAnimation","stopCurrent","tmp","stopAnimation","shouldRunTargetAnimations","getAnimatables","beginHierarchyAnimation","directDescendantsOnly","children","getDescendants","result","child","beginDirectAnimation","beginDirectHierarchyAnimation","getAnimatableByTarget","getAllAnimatablesByTarget","stopAllAnimations","i","group","animationGroups","TargetedAnimation","getClassName","uniqueId","UniqueIdGenerator","UniqueId","serialize","serializationObject","targetId","id","targetUniqueId","AnimationGroup","mask","_mask","syncWithMask","forceUpdate","_numActiveAnimatables","_animatables","disabled","retainsTarget","_targetedAnimations","removeUnmaskedAnimations","targetedAnimation","_from","_to","isStarted","_isStarted","isPlaying","_isPaused","_loopAnimation","_isAdditive","setWeightForAllAnimatables","targetedAnimations","_playOrder","_blendingSpeed","getLength","MergeAnimationGroups","disposeSource","beginFrame","Number","MAX_VALUE","endFrame","animationGroup","mergedAnimationGroup","addTargetedAnimation","getScene","_shouldStart","_parentContainer","onAnimationGroupLoopObservable","onAnimationGroupEndObservable","onAnimationGroupPauseObservable","onAnimationGroupPlayObservable","metadata","_animationLoopFlags","EngineStore","LastCreatedScene","getUniqueId","addAnimationGroup","removeTargetedAnimation","startKey","endKey","inTangent","outTangent","interpolation","_processLoop","_animationLoopCount","start","_checkAnimationGroupEnded","play","list","slice","curIndex","syncAllAnimationsWith","getCurrentFrame","removeAnimationGroup","newName","targetConverter","cloneAnimations","cloneAnimationKeys","newGroup","targetAnimation","targetedAnimationIndex","Tags","HasTags","tags","GetTags","Parse","parsedAnimationGroup","targetLookup","getMorphTargetById","getNodeById","AddTagsTo","MakeAnimationAdditive","sourceAnimationGroup","referenceFrameOrOptions","range","cloneOriginal","clonedName","options","referenceFrame","cloneOriginalAnimationGroup","clonedAnimationName","clonedAnimationGroupName","clipKeys","ClipKeys","fromKey","toKey","dontCloneAnimations","ClipKeysInPlace","ClipInPlace","ClipFrames","ClipFramesInPlace","end","useFrame","createKeyForFrame","newKeys","startFrame","k","lockedTangent","fullDetails","ret"],"mappings":"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"}